/*! modernizr 3.6.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-canvas-inputtypes-touchevents-urlparser-mq !*/
!function(e,t,n){function o(e,t){return typeof e===t}function i(){var e,t,n,i,a,r,s;for(var u in l)if(l.hasOwnProperty(u)){if(e=[],t=l[u],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(i=o(t.fn,"function")?t.fn():t.fn,a=0;a<e.length;a++)r=e[a],s=r.split("."),1===s.length?Modernizr[s[0]]=i:(!Modernizr[s[0]]||Modernizr[s[0]]instanceof Boolean||(Modernizr[s[0]]=new Boolean(Modernizr[s[0]])),Modernizr[s[0]][s[1]]=i),d.push((i?"":"no-")+s.join("-"))}}function a(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):p?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}function r(){var e=t.body;return e||(e=a(p?"svg":"body"),e.fake=!0),e}function s(e,n,o,i){var s,l,u,d,f="modernizr",p=a("div"),h=r();if(parseInt(o,10))for(;o--;)u=a("div"),u.id=i?i[o]:f+(o+1),p.appendChild(u);return s=a("style"),s.type="text/css",s.id="s"+f,(h.fake?h:p).appendChild(s),h.appendChild(p),s.styleSheet?s.styleSheet.cssText=e:s.appendChild(t.createTextNode(e)),p.id=f,h.fake&&(h.style.background="",h.style.overflow="hidden",d=c.style.overflow,c.style.overflow="hidden",c.appendChild(h)),l=n(p,e),h.fake?(h.parentNode.removeChild(h),c.style.overflow=d,c.offsetHeight):p.parentNode.removeChild(p),!!l}var l=[],u={_version:"3.6.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){l.push({name:e,fn:t,options:n})},addAsyncTest:function(e){l.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=u,Modernizr=new Modernizr,Modernizr.addTest("urlparser",function(){var e;try{return e=new URL("http://modernizr.com/"),"http://modernizr.com/"===e.href}catch(t){return!1}});var d=[],c=t.documentElement,f=u._config.usePrefixes?" -webkit- -moz- -o- -ms- ".split(" "):["",""];u._prefixes=f;var p="svg"===c.nodeName.toLowerCase(),h=a("input"),m="search tel url email datetime date month week time datetime-local number range color".split(" "),v={};Modernizr.inputtypes=function(e){for(var o,i,a,r=e.length,s="1)",l=0;r>l;l++)h.setAttribute("type",o=e[l]),a="text"!==h.type&&"style"in h,a&&(h.value=s,h.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(o)&&h.style.WebkitAppearance!==n?(c.appendChild(h),i=t.defaultView,a=i.getComputedStyle&&"textfield"!==i.getComputedStyle(h,null).WebkitAppearance&&0!==h.offsetHeight,c.removeChild(h)):/^(search|tel)$/.test(o)||(a=/^(url|email)$/.test(o)?h.checkValidity&&h.checkValidity()===!1:h.value!=s)),v[e[l]]=!!a;return v}(m);var y=function(){var t=e.matchMedia||e.msMatchMedia;return t?function(e){var n=t(e);return n&&n.matches||!1}:function(t){var n=!1;return s("@media "+t+" { #modernizr { position: absolute; } }",function(t){n="absolute"==(e.getComputedStyle?e.getComputedStyle(t,null):t.currentStyle).position}),n}}();u.mq=y;var g=u.testStyles=s;Modernizr.addTest("touchevents",function(){var n;if("ontouchstart"in e||e.DocumentTouch&&t instanceof DocumentTouch)n=!0;else{var o=["@media (",f.join("touch-enabled),("),"heartz",")","{#modernizr{top:9px;position:absolute}}"].join("");g(o,function(e){n=9===e.offsetTop})}return n}),Modernizr.addTest("canvas",function(){var e=a("canvas");return!(!e.getContext||!e.getContext("2d"))}),i(),delete u.addTest,delete u.addAsyncTest;for(var w=0;w<Modernizr._q.length;w++)Modernizr._q[w]();e.Modernizr=Modernizr}(window,document);
﻿!function(n,t){"function"==typeof define&&define.amd&&define.amd.dust===!0?define("dust.core",[],t):"object"==typeof exports?module.exports=t():n.dust=t()}(this,function(){function c(t,i){if(t)return"function"==typeof t&&t.template?t.template:n.isTemplateFn(t)?t:i!==!1?n.cache[t]:void 0}function o(t,r,u){if(!t)return r.setError(new Error("No template or template name provided to render"));var f=c(t,n.config.cache);return f?f(r,i.wrap(u,f.templateName)):n.onLoad?r.map(function(r){function e(t,e){var o;if(t)return r.setError(t);if(o=c(e,!1)||c(f,n.config.cache),!o){if(!n.compile)return r.setError(new Error("Dust compiler not available"));o=n.loadSource(n.compile(e,f))}o(r,i.wrap(u,o.templateName)).end()}var f=t;3===n.onLoad.length?n.onLoad(f,u.options,e):n.onLoad(f,e)}):r.setError(new Error("Template Not Found: "+t))}function i(n,t,i,r,u){void 0===n||n instanceof l||(n=new l(n));this.stack=n;this.global=t;this.options=i;this.blocks=r;this.templateName=u}function k(n,t,i){return function(r){return n.push(r)._get(t,i)}}function l(n,t,i,r){this.tail=t;this.isObject=n&&"object"==typeof n;this.head=n;this.index=i;this.of=r}function a(n){this.head=new t(this);this.callback=n;this.out=""}function e(){this.head=new t(this)}function t(n,t,i){this.root=n;this.next=t;this.data=[];this.flushable=!1;this.taps=i}function s(n,t){this.head=n;this.tail=t}var n={version:"2.7.1"},d="NONE",r="ERROR",u="WARN",v="INFO",f="DEBUG",y=function(){},h;n.config={whitespace:!1,amd:!1,cjs:!1,cache:!0};n._aliases={write:"w",end:"e",map:"m",render:"r",reference:"f",section:"s",exists:"x",notexists:"nx",block:"b",partial:"p",helper:"h"},function(){var t,i,r={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};"undefined"!=typeof console&&console.log?(t=console.log,i="function"==typeof t?function(){t.apply(console,arguments)}:function(){t(Array.prototype.slice.apply(arguments).join(" "))}):i=y;n.log=function(t,u){u=u||v;r[u]>=r[n.debugLevel]&&i("[DUST:"+u+"]",t)};n.debugLevel=d;"undefined"!=typeof process&&process.env&&/\bdust\b/.test(process.env.DEBUG)&&(n.debugLevel=f)}();n.helpers={};n.cache={};n.register=function(t,i){t&&(i.templateName=t,n.config.cache!==!1&&(n.cache[t]=i))};n.render=function(n,t,i){var r=new a(i).head;try{o(n,r,t).end()}catch(u){r.setError(u)}};n.stream=function(t,i){var r=new e,u=r.head;return n.nextTick(function(){try{o(t,u,i).end()}catch(n){u.setError(n)}}),r};n.loadSource=function(source){return eval(source)};n.isArray=Array.isArray?Array.isArray:function(n){return"[object Array]"===Object.prototype.toString.call(n)};n.nextTick=function(){return function(n){setTimeout(n,0)}}();n.isEmpty=function(t){return 0===t?!1:n.isArray(t)&&!t.length?!0:!t};n.isEmptyObject=function(n){var t;if(null===n||void 0===n||n.length>0)return!1;for(t in n)if(Object.prototype.hasOwnProperty.call(n,t))return!1;return!0};n.isTemplateFn=function(n){return"function"==typeof n&&n.__dustBody};n.isThenable=function(n){return n&&"object"==typeof n&&"function"==typeof n.then};n.isStreamable=function(n){return n&&"function"==typeof n.on};n.filter=function(t,i,r){var e,o,f;if(r)for(e=0,o=r.length;o>e;e++)f=r[e],"s"===f?i=null:"function"==typeof n.filters[f]?t=n.filters[f](t):n.log("Invalid filter `"+f+"`",u);return i&&(t=n.filters[i](t)),t};n.filters={h:function(t){return n.escapeHtml(t)},j:function(t){return n.escapeJs(t)},u:encodeURI,uc:encodeURIComponent,js:function(t){return n.escapeJSON(t)},jp:function(t){return JSON?JSON.parse(t):(n.log("JSON is undefined; could not parse `"+t+"`",u),t)}};n.makeBase=n.context=function(n,t){return new i(void 0,n,t)};i.wrap=function(n,t){return n instanceof i?n:new i(n,{},{},null,t)};i.prototype.get=function(n,t){return"string"==typeof n&&("."===n[0]&&(t=!0,n=n.substr(1)),n=n.split(".")),this._get(t,n)};i.prototype._get=function(t,i){var f,e,h,o,c,u=this.stack||{},s=1;if(e=i[0],h=i.length,t&&0===h)o=u,u=u.head;else{if(t)u&&(u=u.head?u.head[e]:void 0);else{for(;u&&(!u.isObject||(o=u.head,f=u.head[e],void 0===f));)u=u.tail;u=void 0!==f?f:this.global&&this.global[e]}for(;u&&h>s;){if(n.isThenable(u))return u.then(k(this,t,i.slice(s)));o=u;u=u[i[s]];s++}}return"function"==typeof u?(c=function(){try{return u.apply(o,arguments)}catch(t){throw n.log(t,r),t;}},c.__dustBody=!!u.__dustBody,c):(void 0===u&&n.log("Cannot find reference `{"+i.join(".")+"}` in template `"+this.getTemplateName()+"`",v),u)};i.prototype.getPath=function(n,t){return this._get(n,t)};i.prototype.push=function(t,i,r){return void 0===t?(n.log("Not pushing an undefined variable onto the context",v),this):this.rebase(new l(t,this.stack,i,r))};i.prototype.pop=function(){var n=this.current();return this.stack=this.stack&&this.stack.tail,n};i.prototype.rebase=function(n){return new i(n,this.global,this.options,this.blocks,this.getTemplateName())};i.prototype.clone=function(){var n=this.rebase();return n.stack=this.stack,n};i.prototype.current=function(){return this.stack&&this.stack.head};i.prototype.getBlock=function(i){var r,u,e;if("function"==typeof i&&(i=i(new t,this).data.join("")),r=this.blocks,!r)return n.log("No blocks for context `"+i+"` in template `"+this.getTemplateName()+"`",f),!1;for(u=r.length;u--;)if(e=r[u][i])return e;return n.log("Malformed template `"+this.getTemplateName()+"` was missing one or more blocks."),!1};i.prototype.shiftBlocks=function(n){var t,r=this.blocks;return n?(t=r?r.concat([n]):[n],new i(this.stack,this.global,this.options,t,this.getTemplateName())):this};i.prototype.resolve=function(n){var i;return"function"!=typeof n?n:(i=(new t).render(n,this),i instanceof t?i.data.join(""):i)};i.prototype.getTemplateName=function(){return this.templateName};a.prototype.flush=function(){for(var t=this.head;t;){if(!t.flushable)return t.error?(this.callback(t.error),n.log("Rendering failed with error `"+t.error+"`",r),void(this.flush=y)):void 0;this.out+=t.data.join("");t=t.next;this.head=t}this.callback(null,this.out)};e.prototype.flush=function(){for(var t=this.head;t;){if(!t.flushable)return t.error?(this.emit("error",t.error),this.emit("end"),n.log("Streaming failed with error `"+t.error+"`",r),void(this.flush=y)):void 0;this.emit("data",t.data.join(""));t=t.next;this.head=t}this.emit("end")};e.prototype.emit=function(t,i){var u,e,o=this.events||{},r=o[t]||[];if(!r.length)return n.log("Stream broadcasting, but no listeners for `"+t+"`",f),!1;for(r=r.slice(0),u=0,e=r.length;e>u;u++)r[u](i);return!0};e.prototype.on=function(t,i){var r=this.events=this.events||{},f=r[t]=r[t]||[];return"function"!=typeof i?n.log("No callback function provided for `"+t+"` event listener",u):f.push(i),this};e.prototype.pipe=function(t){if("function"!=typeof t.write||"function"!=typeof t.end)return n.log("Incompatible stream passed to `pipe`",u),this;var i=!1;return"function"==typeof t.emit&&t.emit("pipe",this),"function"==typeof t.on&&t.on("error",function(){i=!0}),this.on("data",function(u){if(!i)try{t.write(u,"utf8")}catch(f){n.log(f,r)}}).on("end",function(){if(!i)try{t.end();i=!0}catch(u){n.log(u,r)}})};t.prototype.write=function(n){var t=this.taps;return t&&(n=t.go(n)),this.data.push(n),this};t.prototype.end=function(n){return n&&this.write(n),this.flushable=!0,this.root.flush(),this};t.prototype.map=function(i){var f=new t(this.root,this.next,this.taps),u=new t(this.root,f,this.taps);this.next=u;this.flushable=!0;try{i(u)}catch(e){n.log(e,r);u.setError(e)}return f};t.prototype.tap=function(n){var t=this.taps;return this.taps=t?t.push(n):new s(n),this};t.prototype.untap=function(){return this.taps=this.taps.tail,this};t.prototype.render=function(n,t){return n(this,t)};t.prototype.reference=function(i,r,u,f){return"function"==typeof i?(i=i.apply(r.current(),[this,r,null,{auto:u,filters:f}]),i instanceof t?i:this.reference(i,r,u,f)):n.isThenable(i)?this.await(i,r,null,u,f):n.isStreamable(i)?this.stream(i,r,null,u,f):n.isEmpty(i)?this:this.write(n.filter(i,u,f))};t.prototype.section=function(i,u,e,o){var s,c,l,h=e.block,a=e["else"],v=this;if("function"==typeof i&&!n.isTemplateFn(i)){try{i=i.apply(u.current(),[this,u,e,o])}catch(y){return n.log(y,r),this.setError(y)}if(i instanceof t)return i}if(n.isEmptyObject(o)||(u=u.push(o)),n.isArray(i)){if(h){if(c=i.length,c>0){for(l=u.stack&&u.stack.head||{},l.$len=c,s=0;c>s;s++)l.$idx=s,v=h(v,u.push(i[s],s,c));return l.$idx=void 0,l.$len=void 0,v}if(a)return a(this,u)}}else{if(n.isThenable(i))return this.await(i,u,e);if(n.isStreamable(i))return this.stream(i,u,e);if(i===!0){if(h)return h(this,u)}else if(i||0===i){if(h)return h(this,u.push(i))}else if(a)return a(this,u)}return n.log("Section without corresponding key in template `"+u.getTemplateName()+"`",f),this};t.prototype.exists=function(t,i,r){var u=r.block,e=r["else"];if(n.isEmpty(t)){if(e)return e(this,i)}else{if(u)return u(this,i);n.log("No block for exists check in template `"+i.getTemplateName()+"`",f)}return this};t.prototype.notexists=function(t,i,r){var u=r.block,e=r["else"];if(n.isEmpty(t)){if(u)return u(this,i);n.log("No block for not-exists check in template `"+i.getTemplateName()+"`",f)}else if(e)return e(this,i);return this};t.prototype.block=function(n,t,i){var r=n||i.block;return r?r(this,t):this};t.prototype.partial=function(t,i,r,u){var f;return void 0===u&&(u=r,r=i),n.isEmptyObject(u)||(r=r.clone(),f=r.pop(),r=r.push(u).push(f)),n.isTemplateFn(t)?this.capture(t,i,function(n,t){r.templateName=n;o(n,t,r).end()}):(r.templateName=t,o(t,this,r))};t.prototype.helper=function(t,i,f,e){var o,s=this;if(!n.helpers[t])return n.log("Helper `"+t+"` does not exist",u),s;try{return o=n.helpers[t](s,i,f,e),n.isThenable(o)?this.await(o,i,f):o}catch(h){return n.log("Error in helper `"+t+"`: "+h.message,r),s.setError(h)}};t.prototype.await=function(t,i,r,u,f){var e=r&&r.block,o=r&&r.error;return this.map(function(r){t.then(function(n){e?r.render(e,i.push(n)).end():r.reference(n,i,u,f).end()},function(t){o?r.render(o,i.push(t)).end():(n.log("Unhandled promise rejection in `"+i.getTemplateName()+"`"),r.end())})})};t.prototype.stream=function(t,i,r,u,f){var e=r&&r.block,o=r&&r.error;return this.map(function(r){var s=!1;t.on("data",function(n){s||(r=e?r.map(function(t){t.render(e,i.push(n)).end()}):r.reference(n,i,u,f))}).on("error",function(t){s||(o?r.render(o,i.push(t)):n.log("Unhandled stream error in `"+i.getTemplateName()+"`"),s||(s=!0,r.end()))}).on("end",function(){s||(s=!0,r.end())})})};t.prototype.capture=function(n,t,i){return this.map(function(r){var u=new a(function(n,t){n?r.setError(n):i(t,r)});n(u.head,t).end()})};t.prototype.setError=function(n){return this.error=n,this.root.flush(),this};for(h in t.prototype)n._aliases[h]&&(t.prototype[n._aliases[h]]=t.prototype[h]);s.prototype.push=function(n){return new s(n,this)};s.prototype.go=function(n){for(var t=this;t;)n=t.head(n),t=t.tail;return n};var g=/[&<>"']/,nt=/&/g,p=/</g,tt=/>/g,it=/\"/g,rt=/\'/g;n.escapeHtml=function(n){return"string"==typeof n||n&&"function"==typeof n.toString?("string"!=typeof n&&(n=n.toString()),g.test(n)?n.replace(nt,"&amp;").replace(p,"&lt;").replace(tt,"&gt;").replace(it,"&quot;").replace(rt,"&#39;"):n):n};var ut=/\\/g,ft=/\//g,et=/\r/g,w=/\u2028/g,b=/\u2029/g,ot=/\n/g,st=/\f/g,ht=/'/g,ct=/"/g,lt=/\t/g;return n.escapeJs=function(n){return"string"==typeof n?n.replace(ut,"\\\\").replace(ft,"\\/").replace(ct,'\\"').replace(ht,"\\'").replace(et,"\\r").replace(w,"\\u2028").replace(b,"\\u2029").replace(ot,"\\n").replace(st,"\\f").replace(lt,"\\t"):n},n.escapeJSON=function(t){return JSON?JSON.stringify(t).replace(w,"\\u2028").replace(b,"\\u2029").replace(p,"\\u003c"):(n.log("JSON is undefined; could not escape `"+t+"`",u),t)},n}),function(n,t){"function"==typeof define&&define.amd&&define.amd.dust===!0?define("dust.parse",["dust.core"],function(n){return t(n).parse}):"object"==typeof exports?module.exports=t(require("./dust")):t(n.dust)}(this,function(n){var t=function(){function t(n,t){function i(){this.constructor=n}i.prototype=t.prototype;n.prototype=new i}function n(n,t,i,r,u,f){this.message=n;this.expected=t;this.found=i;this.offset=r;this.line=u;this.column=f;this.name="SyntaxError"}function i(t){function wr(){return pt(o).line}function br(){return pt(o).column}function kr(n){throw hi(n,null,o);}function pt(n){function i(n,i,r){for(var u,f=i;r>f;f++)u=t.charAt(f),"\n"===u?(n.seenCR||n.line++,n.column=1,n.seenCR=!1):"\r"===u||"\u2028"===u||"\u2029"===u?(n.line++,n.column=1,n.seenCR=!0):(n.column++,n.seenCR=!1)}return ut!==n&&(ut>n&&(ut=0,oi={line:1,column:1,seenCR:!1}),i(oi,ut,n),ut=n),oi}function e(n){yt>i||(i>yt&&(yt=i,si=[]),si.push(n))}function hi(i,r,u){function o(n){var t=1;for(n.sort(function(n,t){return n.description<t.description?-1:n.description>t.description?1:0});t<n.length;)n[t-1]===n[t]?n.splice(t,1):t++}function s(n,t){function e(n){function t(n){return n.charCodeAt(0).toString(16).toUpperCase()}return n.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g,function(n){return"\\x0"+t(n)}).replace(/[\x10-\x1F\x80-\xFF]/g,function(n){return"\\x"+t(n)}).replace(/[\u0180-\u0FFF]/g,function(n){return"\\u0"+t(n)}).replace(/[\u1080-\uFFFF]/g,function(n){return"\\u"+t(n)})}for(var u,f,r=new Array(n.length),i=0;i<n.length;i++)r[i]=n[i].description;return u=n.length>1?r.slice(0,-1).join(", ")+" or "+r[n.length-1]:r[0],f=t?'"'+e(t)+'"':"end of input","Expected "+u+" but "+f+" found."}var f=pt(u),e=u<t.length?t.charAt(u):null;return null!==r&&o(r),new n(null!==i?i:s(r,e),r,e,u,f.line,f.column)}function ci(){return ft()}function ft(){var u,n,t;for(u=i,n=[],t=li();t!==r;)n.push(t),t=li();return n!==r&&(o=u,n=cu(n)),u=n}function li(){var n;return n=dt(),n===r&&(n=gt(),n===r&&(n=dr(),n===r&&(n=tu(),n===r&&(n=pi(),n===r&&(n=wt(),n===r&&(n=eu())))))),n}function dr(){var n,l,v,c,y,w,p,b;if(u++,n=i,l=ai(),l!==r){for(v=[],c=s();c!==r;)v.push(c),c=s();v!==r?(c=a(),c!==r?(y=ft(),y!==r?(w=nu(),w!==r?(p=gr(),p===r&&(p=rt),p!==r?(o=i,b=au(l,y,w,p),b=b?h:f,b!==r?(o=n,l=vu(l,y,w,p),n=l):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;if(n===r)if(n=i,l=ai(),l!==r){for(v=[],c=s();c!==r;)v.push(c),c=s();v!==r?(47===t.charCodeAt(i)?(c=ni,i++):(c=r,0===u&&e(ti)),c!==r?(y=a(),y!==r?(o=n,l=yu(l),n=l):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;return u--,n===r&&(l=r,0===u&&e(lu)),n}function ai(){var n,c,l,a,h,y,w;if(n=i,c=v(),c!==r)if(pu.test(t.charAt(i))?(l=t.charAt(i),i++):(l=r,0===u&&e(wu)),l!==r){for(a=[],h=s();h!==r;)a.push(h),h=s();a!==r?(h=p(),h!==r?(y=vi(),y!==r?(w=yi(),w!==r?(o=n,c=bu(l,h,y,w),n=c):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;else i=n,n=f;return n}function gr(){var n,l,y,w,h,b,c;if(u++,n=i,l=v(),l!==r)if(47===t.charCodeAt(i)?(y=ni,i++):(y=r,0===u&&e(ti)),y!==r){for(w=[],h=s();h!==r;)w.push(h),h=s();if(w!==r)if(h=p(),h!==r){for(b=[],c=s();c!==r;)b.push(c),c=s();b!==r?(c=a(),c!==r?(o=n,l=du(h),n=l):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;else i=n,n=f}else i=n,n=f;else i=n,n=f;return u--,n===r&&(l=r,0===u&&e(ku)),n}function vi(){var h,n,s,c;return h=i,n=i,58===t.charCodeAt(i)?(s=ii,i++):(s=r,0===u&&e(ri)),s!==r?(c=p(),c!==r?(o=n,s=ui(c),n=s):(i=n,n=f)):(i=n,n=f),n===r&&(n=rt),n!==r&&(o=h,n=gu(n)),h=n}function yi(){var w,v,n,a,h,y,c;if(u++,w=i,v=[],n=i,a=[],h=s(),h!==r)for(;h!==r;)a.push(h),h=s();else a=f;for(a!==r?(h=l(),h!==r?(61===t.charCodeAt(i)?(y=ir,i++):(y=r,0===u&&e(rr)),y!==r?(c=wi(),c===r&&(c=p(),c===r&&(c=kt())),c!==r?(o=n,a=ht(h,c),n=a):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f);n!==r;){if(v.push(n),n=i,a=[],h=s(),h!==r)for(;h!==r;)a.push(h),h=s();else a=f;a!==r?(h=l(),h!==r?(61===t.charCodeAt(i)?(y=ir,i++):(y=r,0===u&&e(rr)),y!==r?(c=wi(),c===r&&(c=p(),c===r&&(c=kt())),c!==r?(o=n,a=ht(h,c),n=a):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)}return v!==r&&(o=w,v=tf(v)),w=v,u--,w===r&&(v=r,0===u&&e(nf)),w}function nu(){var w,h,n,s,c,y,b,p;for(u++,w=i,h=[],n=i,s=v(),s!==r?(58===t.charCodeAt(i)?(c=ii,i++):(c=r,0===u&&e(ri)),c!==r?(y=l(),y!==r?(b=a(),b!==r?(p=ft(),p!==r?(o=n,s=ht(y,p),n=s):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f);n!==r;)h.push(n),n=i,s=v(),s!==r?(58===t.charCodeAt(i)?(c=ii,i++):(c=r,0===u&&e(ri)),c!==r?(y=l(),y!==r?(b=a(),b!==r?(p=ft(),p!==r?(o=n,s=ht(y,p),n=s):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f);return h!==r&&(o=w,h=uf(h)),w=h,u--,w===r&&(h=r,0===u&&e(rf)),w}function wt(){var n,t,s,h,c;return u++,n=i,t=v(),t!==r?(s=p(),s!==r?(h=iu(),h!==r?(c=a(),c!==r?(o=n,t=ef(s,h),n=t):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),u--,n===r&&(t=r,0===u&&e(ff)),n}function tu(){var n,w,y,b,h,c,k,d,p,g;if(u++,n=i,w=v(),w!==r)if(62===t.charCodeAt(i)?(y=sf,i++):(y=r,0===u&&e(hf)),y===r&&(43===t.charCodeAt(i)?(y=cf,i++):(y=r,0===u&&e(lf))),y!==r){for(b=[],h=s();h!==r;)b.push(h),h=s();if(b!==r)if(h=i,c=l(),c!==r&&(o=h,c=af(c)),h=c,h===r&&(h=kt()),h!==r)if(c=vi(),c!==r)if(k=yi(),k!==r){for(d=[],p=s();p!==r;)d.push(p),p=s();d!==r?(47===t.charCodeAt(i)?(p=ni,i++):(p=r,0===u&&e(ti)),p!==r?(g=a(),g!==r?(o=n,w=vf(y,h,c,k),n=w):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;else i=n,n=f;else i=n,n=f;else i=n,n=f}else i=n,n=f;else i=n,n=f;return u--,n===r&&(w=r,0===u&&e(of)),n}function iu(){var a,h,n,s,c;for(u++,a=i,h=[],n=i,124===t.charCodeAt(i)?(s=ur,i++):(s=r,0===u&&e(fr)),s!==r?(c=l(),c!==r?(o=n,s=ui(c),n=s):(i=n,n=f)):(i=n,n=f);n!==r;)h.push(n),n=i,124===t.charCodeAt(i)?(s=ur,i++):(s=r,0===u&&e(fr)),s!==r?(c=l(),c!==r?(o=n,s=ui(c),n=s):(i=n,n=f)):(i=n,n=f);return h!==r&&(o=a,h=pf(h)),a=h,u--,a===r&&(h=r,0===u&&e(yf)),a}function pi(){var n,s,h,c,y;return u++,n=i,s=v(),s!==r?(126===t.charCodeAt(i)?(h=bf,i++):(h=r,0===u&&e(kf)),h!==r?(c=l(),c!==r?(y=a(),y!==r?(o=n,s=df(c),n=s):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),u--,n===r&&(s=r,0===u&&e(wf)),n}function p(){var t,n;return u++,t=i,n=fu(),n!==r&&(o=t,n=ne(n)),t=n,t===r&&(t=i,n=l(),n!==r&&(o=t,n=te(n)),t=n),u--,t===r&&(n=r,0===u&&e(gf)),t}function wi(){var t,n;return u++,t=i,n=ru(),n===r&&(n=bi()),n!==r&&(o=t,n=re(n)),t=n,u--,t===r&&(n=r,0===u&&e(ie)),t}function ru(){var n,s,h,c;return u++,n=i,s=bi(),s!==r?(46===t.charCodeAt(i)?(h=ct,i++):(h=r,0===u&&e(lt)),h!==r?(c=bt(),c!==r?(o=n,s=fe(s,c),n=s):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),u--,n===r&&(s=r,0===u&&e(ue)),n}function bt(){var h,n,s;if(u++,h=i,n=[],at.test(t.charAt(i))?(s=t.charAt(i),i++):(s=r,0===u&&e(vt)),s!==r)for(;s!==r;)n.push(s),at.test(t.charAt(i))?(s=t.charAt(i),i++):(s=r,0===u&&e(vt));else n=f;return n!==r&&(o=h,n=oe(n)),h=n,u--,h===r&&(n=r,0===u&&e(ee)),h}function uu(){var n,s,h;return u++,n=i,45===t.charCodeAt(i)?(s=he,i++):(s=r,0===u&&e(ce)),s!==r?(h=bt(),h!==r?(o=n,s=le(s,h),n=s):(i=n,n=f)):(i=n,n=f),u--,n===r&&(s=r,0===u&&e(se)),n}function bi(){var n,t;return u++,n=uu(),n===r&&(n=bt()),u--,n===r&&(t=r,0===u&&e(ae)),n}function fu(){var n,h,c,s;if(u++,n=i,h=l(),h===r&&(h=rt),h!==r){if(c=[],s=it(),s===r&&(s=tt()),s!==r)for(;s!==r;)c.push(s),s=it(),s===r&&(s=tt());else c=f;c!==r?(o=n,h=ye(h,c),n=h):(i=n,n=f)}else i=n,n=f;if(n===r)if(n=i,46===t.charCodeAt(i)?(h=ct,i++):(h=r,0===u&&e(lt)),h!==r){for(c=[],s=it(),s===r&&(s=tt());s!==r;)c.push(s),s=it(),s===r&&(s=tt());c!==r?(o=n,h=pe(c),n=h):(i=n,n=f)}else i=n,n=f;return u--,n===r&&(h=r,0===u&&e(ve)),n}function l(){var n,s,c,h;if(u++,n=i,be.test(t.charAt(i))?(s=t.charAt(i),i++):(s=r,0===u&&e(ke)),s!==r){for(c=[],er.test(t.charAt(i))?(h=t.charAt(i),i++):(h=r,0===u&&e(or));h!==r;)c.push(h),er.test(t.charAt(i))?(h=t.charAt(i),i++):(h=r,0===u&&e(or));c!==r?(o=n,s=de(s,c),n=s):(i=n,n=f)}else i=n,n=f;return u--,n===r&&(s=r,0===u&&e(we)),n}function tt(){var s,n,h,l,c,a;if(u++,s=i,n=i,h=ou(),h!==r){if(l=i,c=[],at.test(t.charAt(i))?(a=t.charAt(i),i++):(a=r,0===u&&e(vt)),a!==r)for(;a!==r;)c.push(a),at.test(t.charAt(i))?(a=t.charAt(i),i++):(a=r,0===u&&e(vt));else c=f;c!==r&&(o=l,c=no(c));l=c;l===r&&(l=p());l!==r?(c=su(),c!==r?(o=n,h=to(l),n=h):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;return n!==r?(h=it(),h===r&&(h=rt),h!==r?(o=s,n=io(n,h),s=n):(i=s,s=f)):(i=s,s=f),u--,s===r&&(n=r,0===u&&e(ge)),s}function it(){var h,c,n,s,a;if(u++,h=i,c=[],n=i,46===t.charCodeAt(i)?(s=ct,i++):(s=r,0===u&&e(lt)),s!==r?(a=l(),a!==r?(o=n,s=sr(a),n=s):(i=n,n=f)):(i=n,n=f),n!==r)for(;n!==r;)c.push(n),n=i,46===t.charCodeAt(i)?(s=ct,i++):(s=r,0===u&&e(lt)),s!==r?(a=l(),a!==r?(o=n,s=sr(a),n=s):(i=n,n=f)):(i=n,n=f);else c=f;return c!==r?(n=tt(),n===r&&(n=rt),n!==r?(o=h,c=uo(c,n),h=c):(i=h,h=f)):(i=h,h=f),u--,h===r&&(c=r,0===u&&e(ro)),h}function kt(){var n,s,h,c;if(u++,n=i,34===t.charCodeAt(i)?(s=b,i++):(s=r,0===u&&e(k)),s!==r?(34===t.charCodeAt(i)?(h=b,i++):(h=r,0===u&&e(k)),h!==r?(o=n,s=eo(),n=s):(i=n,n=f)):(i=n,n=f),n===r&&(n=i,34===t.charCodeAt(i)?(s=b,i++):(s=r,0===u&&e(k)),s!==r?(h=di(),h!==r?(34===t.charCodeAt(i)?(c=b,i++):(c=r,0===u&&e(k)),c!==r?(o=n,s=oo(h),n=s):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),n===r))if(n=i,34===t.charCodeAt(i)?(s=b,i++):(s=r,0===u&&e(k)),s!==r){if(h=[],c=ki(),c!==r)for(;c!==r;)h.push(c),c=ki();else h=f;h!==r?(34===t.charCodeAt(i)?(c=b,i++):(c=r,0===u&&e(k)),c!==r?(o=n,s=so(h),n=s):(i=n,n=f)):(i=n,n=f)}else i=n,n=f;return u--,n===r&&(s=r,0===u&&e(fo)),n}function ki(){var n,t;return n=pi(),n===r&&(n=wt(),n===r&&(n=i,t=di(),t!==r&&(o=n,t=ho(t)),n=t)),n}function eu(){var p,b,n,c,l,a,v,k;if(u++,p=i,b=w(),b!==r){for(n=[],c=s();c!==r;)n.push(c),c=s();n!==r?(o=p,b=lo(b,n),p=b):(i=p,p=f)}else i=p,p=f;if(p===r){if(p=i,b=[],n=i,c=i,u++,l=et(),u--,l===r?c=h:(i=c,c=f),c!==r?(l=i,u++,a=dt(),u--,a===r?l=h:(i=l,l=f),l!==r?(a=i,u++,v=gt(),u--,v===r?a=h:(i=a,a=f),a!==r?(v=i,u++,k=w(),u--,k===r?v=h:(i=v,v=f),v!==r?(t.length>i?(k=t.charAt(i),i++):(k=r,0===u&&e(y)),k!==r?(o=n,c=d(k),n=c):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),n!==r)for(;n!==r;)b.push(n),n=i,c=i,u++,l=et(),u--,l===r?c=h:(i=c,c=f),c!==r?(l=i,u++,a=dt(),u--,a===r?l=h:(i=l,l=f),l!==r?(a=i,u++,v=gt(),u--,v===r?a=h:(i=a,a=f),a!==r?(v=i,u++,k=w(),u--,k===r?v=h:(i=v,v=f),v!==r?(t.length>i?(k=t.charAt(i),i++):(k=r,0===u&&e(y)),k!==r?(o=n,c=d(k),n=c):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f)):(i=n,n=f);else b=f;b!==r&&(o=p,b=ao(b));p=b}return u--,p===r&&(b=r,0===u&&e(co)),p}function di(){var a,l,n,c,s;if(u++,a=i,l=[],n=i,c=i,u++,s=et(),u--,s===r?c=h:(i=c,c=f),c!==r?(s=gi(),s===r&&(hr.test(t.charAt(i))?(s=t.charAt(i),i++):(s=r,0===u&&e(cr))),s!==r?(o=n,c=d(s),n=c):(i=n,n=f)):(i=n,n=f),n!==r)for(;n!==r;)l.push(n),n=i,c=i,u++,s=et(),u--,s===r?c=h:(i=c,c=f),c!==r?(s=gi(),s===r&&(hr.test(t.charAt(i))?(s=t.charAt(i),i++):(s=r,0===u&&e(cr))),s!==r?(o=n,c=d(s),n=c):(i=n,n=f)):(i=n,n=f);else l=f;return l!==r&&(o=a,l=yo(l)),a=l,u--,a===r&&(l=r,0===u&&e(vo)),a}function gi(){var f,n;return f=i,t.substr(i,2)===lr?(n=lr,i+=2):(n=r,0===u&&e(po)),n!==r&&(o=f,n=wo()),f=n}function dt(){var l,a,v,n,s,c;if(u++,l=i,t.substr(i,2)===ar?(a=ar,i+=2):(a=r,0===u&&e(ko)),a!==r){for(v=[],n=i,s=i,u++,t.substr(i,2)===g?(c=g,i+=2):(c=r,0===u&&e(fi)),u--,c===r?s=h:(i=s,s=f),s!==r?(t.length>i?(c=t.charAt(i),i++):(c=r,0===u&&e(y)),c!==r?(o=n,s=vr(c),n=s):(i=n,n=f)):(i=n,n=f);n!==r;)v.push(n),n=i,s=i,u++,t.substr(i,2)===g?(c=g,i+=2):(c=r,0===u&&e(fi)),u--,c===r?s=h:(i=s,s=f),s!==r?(t.length>i?(c=t.charAt(i),i++):(c=r,0===u&&e(y)),c!==r?(o=n,s=vr(c),n=s):(i=n,n=f)):(i=n,n=f);v!==r?(t.substr(i,2)===g?(n=g,i+=2):(n=r,0===u&&e(fi)),n!==r?(o=l,a=go(v),l=a):(i=l,l=f)):(i=l,l=f)}else i=l,l=f;return u--,l===r&&(a=r,0===u&&e(bo)),l}function gt(){var l,a,v,n,s,c;if(u++,l=i,t.substr(i,2)===yr?(a=yr,i+=2):(a=r,0===u&&e(ts)),a!==r){for(v=[],n=i,s=i,u++,t.substr(i,2)===nt?(c=nt,i+=2):(c=r,0===u&&e(ei)),u--,c===r?s=h:(i=s,s=f),s!==r?(t.length>i?(c=t.charAt(i),i++):(c=r,0===u&&e(y)),c!==r?(o=n,s=d(c),n=s):(i=n,n=f)):(i=n,n=f);n!==r;)v.push(n),n=i,s=i,u++,t.substr(i,2)===nt?(c=nt,i+=2):(c=r,0===u&&e(ei)),u--,c===r?s=h:(i=s,s=f),s!==r?(t.length>i?(c=t.charAt(i),i++):(c=r,0===u&&e(y)),c!==r?(o=n,s=d(c),n=s):(i=n,n=f)):(i=n,n=f);v!==r?(t.substr(i,2)===nt?(n=nt,i+=2):(n=r,0===u&&e(ei)),n!==r?(o=l,a=is(v),l=a):(i=l,l=f)):(i=l,l=f)}else i=l,l=f;return u--,l===r&&(a=r,0===u&&e(ns)),l}function et(){var c,d,g,k,nt,b,n,o,l,p;if(c=i,d=v(),d!==r){for(g=[],k=s();k!==r;)g.push(k),k=s();if(g!==r)if(rs.test(t.charAt(i))?(k=t.charAt(i),i++):(k=r,0===u&&e(us)),k!==r){for(nt=[],b=s();b!==r;)nt.push(b),b=s();if(nt!==r){if(b=[],n=i,o=i,u++,l=a(),u--,l===r?o=h:(i=o,o=f),o!==r?(l=i,u++,p=w(),u--,p===r?l=h:(i=l,l=f),l!==r?(t.length>i?(p=t.charAt(i),i++):(p=r,0===u&&e(y)),p!==r?(o=[o,l,p],n=o):(i=n,n=f)):(i=n,n=f)):(i=n,n=f),n!==r)for(;n!==r;)b.push(n),n=i,o=i,u++,l=a(),u--,l===r?o=h:(i=o,o=f),o!==r?(l=i,u++,p=w(),u--,p===r?l=h:(i=l,l=f),l!==r?(t.length>i?(p=t.charAt(i),i++):(p=r,0===u&&e(y)),p!==r?(o=[o,l,p],n=o):(i=n,n=f)):(i=n,n=f)):(i=n,n=f);else b=f;if(b!==r){for(n=[],o=s();o!==r;)n.push(o),o=s();n!==r?(o=a(),o!==r?(d=[d,g,k,nt,b,n,o],c=d):(i=c,c=f)):(i=c,c=f)}else i=c,c=f}else i=c,c=f}else i=c,c=f;else i=c,c=f}else i=c,c=f;return c===r&&(c=wt()),c}function v(){var n;return 123===t.charCodeAt(i)?(n=fs,i++):(n=r,0===u&&e(es)),n}function a(){var n;return 125===t.charCodeAt(i)?(n=os,i++):(n=r,0===u&&e(ss)),n}function ou(){var n;return 91===t.charCodeAt(i)?(n=hs,i++):(n=r,0===u&&e(cs)),n}function su(){var n;return 93===t.charCodeAt(i)?(n=ls,i++):(n=r,0===u&&e(as)),n}function w(){var n;return 10===t.charCodeAt(i)?(n=vs,i++):(n=r,0===u&&e(ys)),n===r&&(t.substr(i,2)===pr?(n=pr,i+=2):(n=r,0===u&&e(ps)),n===r&&(13===t.charCodeAt(i)?(n=ws,i++):(n=r,0===u&&e(bs)),n===r&&(8232===t.charCodeAt(i)?(n=ks,i++):(n=r,0===u&&e(ds)),n===r&&(8233===t.charCodeAt(i)?(n=gs,i++):(n=r,0===u&&e(nh)))))),n}function s(){var n;return th.test(t.charAt(i))?(n=t.charAt(i),i++):(n=r,0===u&&e(ih)),n===r&&(n=w()),n}function hu(n){return parseInt(n.join(""),10)}function c(n){return n.concat([["line",wr()],["col",br()]])}var ot,st=arguments.length>1?arguments[1]:{},r={},nr={start:ci},tr=ci,cu=function(n){var t=["body"].concat(n);return c(t)},lu={type:"other",description:"section"},f=r,rt=null,au=function(n,t,i,r){return r&&n[1].text===r.text||kr("Expected end tag for "+n[1].text+" but it was not found."),!0},h=void 0,vu=function(n,t,i){return i.push(["param",["literal","block"],t]),n.push(i),c(n)},ni="/",ti={type:"literal",value:"/",description:'"/"'},yu=function(n){return n.push(["bodies"]),c(n)},pu=/^[#?\^<+@%]/,wu={type:"class",value:"[#?\\^<+@%]",description:"[#?\\^<+@%]"},bu=function(n,t,i,r){return[n,t,i,r]},ku={type:"other",description:"end tag"},du=function(n){return n},ii=":",ri={type:"literal",value:":",description:'":"'},ui=function(n){return n},gu=function(n){return n?["context",n]:["context"]},nf={type:"other",description:"params"},ir="=",rr={type:"literal",value:"=",description:'"="'},ht=function(n,t){return["param",["literal",n],t]},tf=function(n){return["params"].concat(n)},rf={type:"other",description:"bodies"},uf=function(n){return["bodies"].concat(n)},ff={type:"other",description:"reference"},ef=function(n,t){return c(["reference",n,t])},of={type:"other",description:"partial"},sf=">",hf={type:"literal",value:">",description:'">"'},cf="+",lf={type:"literal",value:"+",description:'"+"'},af=function(n){return["literal",n]},vf=function(n,t,i,r){var u=">"===n?"partial":n;return c([u,t,i,r])},yf={type:"other",description:"filters"},ur="|",fr={type:"literal",value:"|",description:'"|"'},pf=function(n){return["filters"].concat(n)},wf={type:"other",description:"special"},bf="~",kf={type:"literal",value:"~",description:'"~"'},df=function(n){return c(["special",n])},gf={type:"other",description:"identifier"},ne=function(n){var t=["path"].concat(n);return t.text=n[1].join(".").replace(/,line,\d+,col,\d+/g,""),t},te=function(n){var t=["key",n];return t.text=n,t},ie={type:"other",description:"number"},re=function(n){return["literal",n]},ue={type:"other",description:"float"},ct=".",lt={type:"literal",value:".",description:'"."'},fe=function(n,t){return parseFloat(n+"."+t)},ee={type:"other",description:"unsigned_integer"},at=/^[0-9]/,vt={type:"class",value:"[0-9]",description:"[0-9]"},oe=function(n){return hu(n)},se={type:"other",description:"signed_integer"},he="-",ce={type:"literal",value:"-",description:'"-"'},le=function(n,t){return-1*t},ae={type:"other",description:"integer"},ve={type:"other",description:"path"},ye=function(n,t){return t=t[0],n&&t?(t.unshift(n),c([!1,t])):c([!0,t])},pe=function(n){return c(n.length>0?[!0,n[0]]:[!0,[]])},we={type:"other",description:"key"},be=/^[a-zA-Z_$]/,ke={type:"class",value:"[a-zA-Z_$]",description:"[a-zA-Z_$]"},er=/^[0-9a-zA-Z_$\-]/,or={type:"class",value:"[0-9a-zA-Z_$\\-]",description:"[0-9a-zA-Z_$\\-]"},de=function(n,t){return n+t.join("")},ge={type:"other",description:"array"},no=function(n){return n.join("")},to=function(n){return n},io=function(n,t){return t?t.unshift(n):t=[n],t},ro={type:"other",description:"array_part"},sr=function(n){return n},uo=function(n,t){return t?n.concat(t):n},fo={type:"other",description:"inline"},b='"',k={type:"literal",value:'"',description:'"\\""'},eo=function(){return c(["literal",""])},oo=function(n){return c(["literal",n])},so=function(n){return c(["body"].concat(n))},ho=function(n){return["buffer",n]},co={type:"other",description:"buffer"},lo=function(n,t){return c(["format",n,t.join("")])},y={type:"any",description:"any character"},d=function(n){return n},ao=function(n){return c(["buffer",n.join("")])},vo={type:"other",description:"literal"},hr=/^[^"]/,cr={type:"class",value:'[^"]',description:'[^"]'},yo=function(n){return n.join("")},lr='\\"',po={type:"literal",value:'\\"',description:'"\\\\\\""'},wo=function(){return'"'},bo={type:"other",description:"raw"},ar="{`",ko={type:"literal",value:"{`",description:'"{`"'},g="`}",fi={type:"literal",value:"`}",description:'"`}"'},vr=function(n){return n},go=function(n){return c(["raw",n.join("")])},ns={type:"other",description:"comment"},yr="{!",ts={type:"literal",value:"{!",description:'"{!"'},nt="!}",ei={type:"literal",value:"!}",description:'"!}"'},is=function(n){return c(["comment",n.join("")])},rs=/^[#?\^><+%:@\/~%]/,us={type:"class",value:"[#?\\^><+%:@\\/~%]",description:"[#?\\^><+%:@\\/~%]"},fs="{",es={type:"literal",value:"{",description:'"{"'},os="}",ss={type:"literal",value:"}",description:'"}"'},hs="[",cs={type:"literal",value:"[",description:'"["'},ls="]",as={type:"literal",value:"]",description:'"]"'},vs="\n",ys={type:"literal",value:"\n",description:'"\\n"'},pr="\r\n",ps={type:"literal",value:"\r\n",description:'"\\r\\n"'},ws="\r",bs={type:"literal",value:"\r",description:'"\\r"'},ks="\u2028",ds={type:"literal",value:"\u2028",description:'"\\u2028"'},gs="\u2029",nh={type:"literal",value:"\u2029",description:'"\\u2029"'},th=/^[\t\x0B\f \xA0\uFEFF]/,ih={type:"class",value:"[\\t\\x0B\\f \\xA0\\uFEFF]",description:"[\\t\\x0B\\f \\xA0\\uFEFF]"},i=0,o=0,ut=0,oi={line:1,column:1,seenCR:!1},yt=0,si=[],u=0;if("startRule"in st){if(!(st.startRule in nr))throw new Error("Can't start parsing from rule \""+st.startRule+'".');tr=nr[st.startRule]}if(ot=tr(),ot!==r&&i===t.length)return ot;throw ot!==r&&i<t.length&&e({type:"end",description:"end of input"}),hi(null,si,yt);}return t(n,Error),{SyntaxError:n,parse:i}}();return n.parse=t.parse,t}),function(n,t){"function"==typeof define&&define.amd&&define.amd.dust===!0?define("dust.compile",["dust.core","dust.parse"],function(n,i){return t(i,n).compile}):"object"==typeof exports?module.exports=t(require("./parser").parse,require("./dust")):t(n.dust.parse,n.dust)}(this,function(n,t){function l(n){return i.filterNode({},n)}function r(n,t){for(var u,e=[t[0]],r=1,f=t.length;f>r;r++)u=i.filterNode(n,t[r]),u&&e.push(u);return e}function a(n,t){for(var u,r,e=[t[0]],f=1,o=t.length;o>f;f++)r=i.filterNode(n,t[f]),r&&("buffer"===r[0]||"format"===r[0]?u?(u[0]="buffer"===r[0]?"buffer":u[0],u[1]+=r.slice(1,-2).join("")):(u=r,e.push(r)):(u=null,e.push(r)));return e}function v(n,t){return["buffer",c[t[1]],t[2],t[3]]}function u(n,t){return t}function e(){}function y(n,i){return t.config.whitespace?(i.splice(1,2,i.slice(1,-2).join("")),i):null}function p(n,r){var f,e={name:r,bodies:[],blocks:{},index:0,auto:"h"},o=t.escapeJs(r),c=r?'"'+o+'",':"",u="function(dust){",h=i.compileNode(e,n);return r&&(u+='dust.register("'+o+'",'+h+");"),u+=w(e)+b(e)+"return "+h+"}",f="("+u+"(dust));",t.config.amd?"define("+c+'["dust.core"],'+u+");":t.config.cjs?"module.exports=function(dust){var tmpl="+f+"var f="+s().toString()+";f.template=tmpl;return f}":f}function w(n){var t,i=[],r=n.blocks;for(t in r)i.push('"'+t+'":'+r[t]);return i.length?(n.blocks="ctx=ctx.shiftBlocks(blocks);","var blocks={"+i.join(",")+"};"):(n.blocks="",n.blocks)}function b(n){for(var r=[],u=n.bodies,f=n.blocks,t=0,i=u.length;i>t;t++)r[t]="function body_"+t+"(chk,ctx){"+f+"return chk"+u[t]+";}body_"+t+".__dustBody=!0;";return r.join("")}function h(n,t){for(var f="",r=1,u=t.length;u>r;r++)f+=i.compileNode(n,t[r]);return f}function o(n,r,u){return"."+(t._aliases[u]||u)+"("+i.compileNode(n,r[1])+","+i.compileNode(n,r[2])+","+i.compileNode(n,r[4])+","+i.compileNode(n,r[3])+")"}function k(n){return n.replace(tt,"\\\\").replace(it,'\\"').replace(rt,"\\f").replace(ut,"\\n").replace(ft,"\\r").replace(et,"\\t")}function d(n,i,r){var u=t.loadSource(t.compile(n));return s(u)(i,r)}function g(n,i){var r=t.loadSource(t.compile(n,i));return s(r)}function s(n){return function(i,r){var u=r?"render":"stream";return t[u](n,i,r)}}var i={},nt=t.isArray,c;i.compile=function(t,i){try{var u=l(n(t));return p(u,i)}catch(r){if(!r.line||!r.column)throw r;throw new SyntaxError(r.message+" At line : "+r.line+", column : "+r.column);}};i.filterNode=function(n,t){return i.optimizers[t[0]](n,t)};i.optimizers={body:a,buffer:u,special:v,format:y,reference:r,"#":r,"?":r,"^":r,"<":r,"+":r,"@":r,"%":r,partial:r,context:r,params:r,bodies:r,param:r,filters:u,key:u,path:u,literal:u,raw:u,comment:e,line:e,col:e};i.pragmas={esc:function(n,t,i){var r,u=n.auto;return t||(t="h"),n.auto="s"===t?"":t,r=h(n,i.block),n.auto=u,r}};c={s:" ",n:"\n",r:"\r",lb:"{",rb:"}"};i.compileNode=function(n,t){return i.nodes[t[0]](n,t)};i.nodes={body:function(n,t){var i=n.index++,r="body_"+i;return n.bodies[i]=h(n,t),r},buffer:function(n,t){return".w("+f(t[1])+")"},format:function(n,t){return".w("+f(t[1])+")"},reference:function(n,t){return".f("+i.compileNode(n,t[1])+",ctx,"+i.compileNode(n,t[2])+")"},"#":function(n,t){return o(n,t,"section")},"?":function(n,t){return o(n,t,"exists")},"^":function(n,t){return o(n,t,"notexists")},"<":function(n,t){for(var u,e,f=t[4],r=1,o=f.length;o>r;r++)if(u=f[r],e=u[1][1],"block"===e)return n.blocks[t[1].text]=i.compileNode(n,u[2]),"";return""},"+":function(n,t){return"undefined"==typeof t[1].text&&"undefined"==typeof t[4]?".b(ctx.getBlock("+i.compileNode(n,t[1])+",chk, ctx),"+i.compileNode(n,t[2])+", {},"+i.compileNode(n,t[3])+")":".b(ctx.getBlock("+f(t[1].text)+"),"+i.compileNode(n,t[2])+","+i.compileNode(n,t[4])+","+i.compileNode(n,t[3])+")"},"@":function(n,t){return".h("+f(t[1].text)+","+i.compileNode(n,t[2])+","+i.compileNode(n,t[4])+","+i.compileNode(n,t[3])+")"},"%":function(n,t){var f,e,o,s,l,h,c,r,u,a=t[1][1];if(!i.pragmas[a])return"";for(f=t[4],e={},r=1,u=f.length;u>r;r++)h=f[r],e[h[1][1]]=h[2];for(o=t[3],s={},r=1,u=o.length;u>r;r++)c=o[r],s[c[1][1]]=c[2][1];return l=t[2][1]?t[2][1].text:null,i.pragmas[a](n,l,e,s)},partial:function(n,t){return".p("+i.compileNode(n,t[1])+",ctx,"+i.compileNode(n,t[2])+","+i.compileNode(n,t[3])+")"},context:function(n,t){return t[1]?"ctx.rebase("+i.compileNode(n,t[1])+")":"ctx"},params:function(n,t){for(var r=[],u=1,f=t.length;f>u;u++)r.push(i.compileNode(n,t[u]));return r.length?"{"+r.join(",")+"}":"{}"},bodies:function(n,t){for(var u=[],r=1,f=t.length;f>r;r++)u.push(i.compileNode(n,t[r]));return"{"+u.join(",")+"}"},param:function(n,t){return i.compileNode(n,t[1])+":"+i.compileNode(n,t[2])},filters:function(n,t){for(var u,i=[],r=1,f=t.length;f>r;r++)u=t[r],i.push('"'+u+'"');return'"'+n.auto+'"'+(i.length?",["+i.join(",")+"]":"")},key:function(n,t){return'ctx.get(["'+t[1]+'"], false)'},path:function(n,t){for(var e=t[1],u=t[2],f=[],r=0,o=u.length;o>r;r++)f.push(nt(u[r])?i.compileNode(n,u[r]):'"'+u[r]+'"');return"ctx.getPath("+e+", ["+f.join(",")+"])"},literal:function(n,t){return f(t[1])},raw:function(n,t){return".w("+f(t[1])+")"}};var tt=/\\/g,it=/"/g,rt=/\f/g,ut=/\n/g,ft=/\r/g,et=/\t/g,f="undefined"==typeof JSON?function(n){return'"'+k(n)+'"'}:JSON.stringify;return t.compiler=i,t.compile=t.compiler.compile,t.renderSource=d,t.compileFn=g,t.filterNode=i.filterNode,t.optimizers=i.optimizers,t.pragmas=i.pragmas,t.compileNode=i.compileNode,t.nodes=i.nodes,i});"function"==typeof define&&define.amd&&define.amd.dust===!0&&define(["require","dust.core","dust.compile"],function(n,t){return t.onLoad=function(t,i){n([t],function(){i()})},t});(function(n,t){typeof define=="function"&&define.amd&&define.amd.dust===!0?define(["dust.core"],t):typeof exports=="object"?module.exports=t(require("dustjs-linkedin")):t(n.dust)})(this,function(n){function t(t,i,r){r=r||"INFO";t=t?"{@"+t+"}: ":"";n.log(t+i,r)}function c(n){u[n]||(t(n,"Deprecation warning: "+n+" is deprecated and will be removed in a future version of dustjs-helpers","WARN"),t(null,"For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#"+n.replace(/\W+/g,""),"WARN"),u[n]=!0)}function l(n){return n.stack.tail&&n.stack.tail.head&&typeof n.stack.tail.head.__select__!="undefined"}function r(n){return l(n)&&n.get("__select__")}function f(n,t){var f=n.stack.head,u=n.rebase(),i,r;n.stack&&n.stack.tail&&(u.stack=n.stack.tail);r={isPending:!1,isResolved:!1,isDeferredComplete:!1,deferreds:[]};for(i in t)r[i]=t[i];return u.push({__select__:r}).push(f,n.stack.index,n.stack.of)}function e(n){var t,i;if(n.isDeferredPending=!0,n.deferreds.length)for(n.isDeferredComplete=!0,t=0,i=n.deferreds.length;t<i;t++)n.deferreds[t]();n.isDeferredPending=!1}function a(n,t){return typeof t=="function"?t.toString().replace(/(^\s+|\s+$)/mg,"").replace(/\n/mg,"").replace(/,\s*/mg,", ").replace(/\)\{/mg,") {"):t}function i(n,t){return function(i,r,u,f){return v(i,r,u,f,n,t)}}function v(n,i,u,f,e,s){var a=u.block,v=u["else"],h=r(i)||{},y,c,p,l;if(h.isResolved&&!h.isDeferredPending)return n;if(f.hasOwnProperty("key"))c=f.key;else if(h.hasOwnProperty("key"))c=h.key;else return t(e,"No key specified","WARN"),n;return l=f.type||h.type,c=o(i.resolve(c),l),p=o(i.resolve(f.value),l),s(c,p)?(h.isPending||(y=!0,h.isPending=!0),a&&(n=n.render(a,i)),y&&(h.isResolved=!0)):v&&(n=n.render(v,i)),n}function o(n,t){t&&(t=t.toLowerCase());switch(t){case"number":return+n;case"string":return String(n);case"boolean":return n=n==="false"?!1:n,Boolean(n);case"date":return new Date(n)}return n}var u={},s={tap:function(n,t,i){return c("tap"),i.resolve(n)},sep:function(n,t,i){var r=i.block;return t.stack.index===t.stack.of-1?n:r?r(n,t):n},first:function(n,t,i){return t.stack.index===0?i.block(n,t):n},last:function(n,t,i){return t.stack.index===t.stack.of-1?i.block(n,t):n},contextDump:function(n,i,r,u){var o=i.resolve(u.to),s=i.resolve(u.key),e,f;switch(s){case"full":e=i.stack;break;default:e=i.stack.head}f=JSON.stringify(e,a,2);switch(o){case"console":t("contextDump",f);break;default:f=f.replace(/</g,"\\u003c");n=n.write(f)}return n},math:function(n,i,u,o){var h=o.key,l=o.method,c=o.operand,a=o.round,s;if(!o.hasOwnProperty("key")||!o.method)return t("math","`key` or `method` was not provided","ERROR"),n;h=parseFloat(i.resolve(h));c=parseFloat(i.resolve(c));switch(l){case"mod":c===0&&t("math","Division by 0","ERROR");s=h%c;break;case"add":s=h+c;break;case"subtract":s=h-c;break;case"multiply":s=h*c;break;case"divide":c===0&&t("math","Division by 0","ERROR");s=h/c;break;case"ceil":case"floor":case"round":case"abs":s=Math[l](h);break;case"toint":s=parseInt(h,10);break;default:t("math","Method `"+l+"` is not supported","ERROR")}return typeof s!="undefined"&&(a&&(s=Math.round(s)),u&&u.block?(i=f(i,{key:s}),n=n.render(u.block,i),e(r(i))):n=n.write(s)),n},select:function(n,i,u,o){var h=u.block,s={};return o.hasOwnProperty("key")&&(s.key=i.resolve(o.key)),o.hasOwnProperty("type")&&(s.type=o.type),h?(i=f(i,s),n=n.render(h,i),e(r(i))):t("select","Missing body block","WARN"),n},eq:i("eq",function(n,t){return n===t}),ne:i("ne",function(n,t){return n!==t}),lt:i("lt",function(n,t){return n<t}),lte:i("lte",function(n,t){return n<=t}),gt:i("gt",function(n,t){return n>t}),gte:i("gte",function(n,t){return n>=t}),any:function(n,i,u){var f=r(i);return f?f.isDeferredComplete?t("any","Must not be nested inside {@any} or {@none} block","ERROR"):n=n.map(function(n){f.deferreds.push(function(){f.isResolved&&(n=n.render(u.block,i));n.end()})}):t("any","Must be used inside a {@select} block","ERROR"),n},none:function(n,i,u){var f=r(i);return f?f.isDeferredComplete?t("none","Must not be nested inside {@any} or {@none} block","ERROR"):n=n.map(function(n){f.deferreds.push(function(){f.isResolved||(n=n.render(u.block,i));n.end()})}):t("none","Must be used inside a {@select} block","ERROR"),n},size:function(t,i,r,u){var f=u.key,e,o;if(f=i.resolve(u.key),f&&f!==!0)if(n.isArray(f))e=f.length;else if(!isNaN(parseFloat(f))&&isFinite(f))e=f;else if(typeof f=="object"){e=0;for(o in f)f.hasOwnProperty(o)&&e++}else e=(f+"").length;else e=0;return t.write(e)}};for(var h in s)n.helpers[h]=s[h];return n});
﻿/*! dustjs-i18n - v0.0.2 - 2015-03-31
* https://bitbucket.org/manolakis/dustjs-i18n
* Copyright (c) 2015 Manuel Martin; Licensed MIT */
!function(a,b){"function"==typeof define&&define.amd?define(["dustjs-linkedin"],function(c){return b(c,a)}):"object"==typeof module&&module.exports?module.exports=b(require("dustjs-linkedin"),this):a.dust=b(a.dust,a)}(this,function(a,b,c){"use strict";var d=Object.prototype.toString,e=typeof console!==c?console:{log:function(){}},f={isArray:Array.isArray||function(a){return"[object Array]"===d.call(a)},isAvailable:function(a){return h[a]!==c},log:e.log},g={selected:c,languages:{},filters:{}},h=g.languages;return typeof String.prototype.trim===c&&(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")}),a.i18n={resetContext:function(){g.selected=c,Object.keys(h).forEach(function(a){delete h[a]})},setLanguage:function(a){if(!f.isAvailable(a))throw new Error("language '"+a+"' not available!");g.selected=a},setLanguages:function(a){f.isArray(a)&&a.forEach(function(a){f.isAvailable(a)||(h[a]={}),g.selected===c&&(g.selected=a)})},add:function(a,b){if(f.isAvailable(a)){var c=h[a];Object.keys(b).forEach(function(a){c[a]=b[a]})}},addFilter:function(a,b){a in g.filters||(g.filters[a]=b)}},a.helpers.i18n=function(b,d,e,i){if(i&&i.$key!==c){var j,k,l,m,n,o=g.selected,p=h[o],q=/\{(\s*[\w]+\s*)\}/g;m=a.helpers.tap(i.$key,b,d).split("|");var r=a.helpers.tap(m.shift(),b,d);for(n=p!==c&&p[r]!==c?p[r]:null;null!==(j=q.exec(n));)l=j[1].trim(),"$key"===l?(k="",f.log("$key can't be used as a parameter")):k=a.helpers.tap(i[j[1].trim()],b,d),n=n.replace(j[0],k);m.forEach(function(a){a in g.filters&&(n=g.filters[a](n))}),b.write(n)}else f.log("No key given in the i18n helper");return b},a});
﻿(function () {
    dust.helpers.iterate = function (chunk, context, bodies, params) {
        params = params || {};
        var obj = params['on'] || context.current();
        var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;

        for (var k in obj) {
            if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                chunk = chunk.render(bodies.block, context.push({ key: k, value: obj[k] }));
            }
        }
        return chunk;
    }
    dust.helpers.startsWith = function (chunk, context, bodies, params) {
        var body = bodies.block, skip = bodies['else'], key = params["key"], value = params["value"];
        if (typeof (key) === "string" && key.toLowerCase().indexOf(value.toLowerCase())===0) {
            chunk = chunk.render(body, context);
        }
        else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    };
})();

﻿var __extends=this.__extends||function(b,d){function n(){this.constructor=b}for(var f in d)d.hasOwnProperty(f)&&(b[f]=d[f]);n.prototype=d.prototype;b.prototype=new n};
function JL(b){if(!b)return JL.__;Array.prototype.reduce||(Array.prototype.reduce=function(b,d){for(var l=d,g=0;g<this.length;g++)l=b(l,this[g],g,this);return l});var d="";return("."+b).split(".").reduce(function(b,f,l,g){d=d?d+("."+f):f;f=b["__"+d];void 0===f&&(JL.Logger.prototype=b,f=new JL.Logger(d),b["__"+d]=f);return f},JL.__)}
(function(b){function d(a,c,h){void 0!==c[a]&&(null===c[a]?delete h[a]:h[a]=c[a])}function n(a){if(null!=b.enabled&&!b.enabled||null!=b.maxMessages&&1>b.maxMessages)return!1;try{if(a.userAgentRegex&&!RegExp(a.userAgentRegex).test(navigator.userAgent))return!1}catch(c){}try{if(a.ipRegex&&b.clientIP&&!RegExp(a.ipRegex).test(b.clientIP))return!1}catch(h){}return!0}function f(a,c){try{if(a.disallow&&RegExp(a.disallow).test(c))return!1}catch(h){}return!0}function l(a){return"function"==typeof a?a instanceof
RegExp?a.toString():a():a}function g(a){a=l(a);switch(typeof a){case "string":return new m(a,null,a);case "number":return a=a.toString(),new m(a,null,a);case "boolean":return a=a.toString(),new m(a,null,a);case "undefined":return new m("undefined",null,"undefined");case "object":return a instanceof RegExp||a instanceof String||a instanceof Number||a instanceof Boolean?(a=a.toString(),new m(a,null,a)):new m(null,a,JSON.stringify(a));default:return new m("unknown",null,"unknown")}}b.enabled;b.maxMessages;
b.defaultAjaxUrl;b.clientIP;b.defaultBeforeSend;b.requestId="";var m=function(){return function(a,c,h){this.msg=a;this.meta=c;this.finalString=h}}();b.setOptions=function(a){d("enabled",a,this);d("maxMessages",a,this);d("defaultAjaxUrl",a,this);d("clientIP",a,this);d("requestId",a,this);d("defaultBeforeSend",a,this);return this};b.getAllLevel=function(){return-2147483648};b.getTraceLevel=function(){return 1E3};b.getDebugLevel=function(){return 2E3};b.getInfoLevel=function(){return 3E3};b.getWarnLevel=
function(){return 4E3};b.getErrorLevel=function(){return 5E3};b.getFatalLevel=function(){return 6E3};b.getOffLevel=function(){return 2147483647};var e=function(){return function(a,c){this.inner=c;this.name="JL.Exception";this.message=g(a).finalString}}();b.Exception=e;e.prototype=Error();var r=function(){return function(a,c,h,b){this.l=a;this.m=c;this.n=h;this.t=b}}();b.LogItem=r;e=function(){function a(c,a){this.appenderName=c;this.sendLogItems=a;this.level=b.getTraceLevel();this.sendWithBufferLevel=
2147483647;this.storeInBufferLevel=-2147483648;this.bufferSize=0;this.batchSize=1;this.buffer=[];this.batchBuffer=[]}a.prototype.setOptions=function(c){d("level",c,this);d("ipRegex",c,this);d("userAgentRegex",c,this);d("disallow",c,this);d("sendWithBufferLevel",c,this);d("storeInBufferLevel",c,this);d("bufferSize",c,this);d("batchSize",c,this);this.bufferSize<this.buffer.length&&(this.buffer.length=this.bufferSize);return this};a.prototype.log=function(c,a,b,d,k,e,g){!n(this)||!f(this,e)||k<this.storeInBufferLevel||
(c=new r(k,e,g,(new Date).getTime()),k<this.level?0<this.bufferSize&&(this.buffer.push(c),this.buffer.length>this.bufferSize&&this.buffer.shift()):(k<this.sendWithBufferLevel||!this.buffer.length||(this.batchBuffer=this.batchBuffer.concat(this.buffer),this.buffer.length=0),this.batchBuffer.push(c),this.batchBuffer.length>=this.batchSize&&this.sendBatch()))};a.prototype.sendBatch=function(){0==this.batchBuffer.length||null!=b.maxMessages&&1>b.maxMessages||(null!=b.maxMessages&&(b.maxMessages-=this.batchBuffer.length),
this.sendLogItems(this.batchBuffer),this.batchBuffer.length=0)};return a}();b.Appender=e;var p=function(a){function c(b){a.call(this,b,c.prototype.sendLogItemsAjax)}__extends(c,a);c.prototype.setOptions=function(c){d("url",c,this);d("beforeSend",c,this);a.prototype.setOptions.call(this,c);return this};c.prototype.sendLogItemsAjax=function(c){try{var a="/jsnlog.logger";null!=b.defaultAjaxUrl&&(a=b.defaultAjaxUrl);this.url&&(a=this.url);var d=JSON.stringify({r:b.requestId,lg:c}),k=this.getXhr(a);"function"===
typeof this.beforeSend?this.beforeSend.call(this,k):"function"===typeof b.defaultBeforeSend&&b.defaultBeforeSend.call(this,k);k.send(d)}catch(f){}};c.prototype.getXhr=function(c){var a=new XMLHttpRequest;if(!("withCredentials"in a)&&"undefined"!=typeof XDomainRequest)return a=new XDomainRequest,a.open("POST",c),a;a.open("POST",c);a.setRequestHeader("Content-Type","application/json");a.setRequestHeader("JSNLog-RequestId",b.requestId);return a};return c}(e);b.AjaxAppender=p;var q=function(a){function c(b){a.call(this,
b,c.prototype.sendLogItemsConsole)}__extends(c,a);c.prototype.clog=function(a){console.log(a)};c.prototype.cerror=function(a){console.error?console.error(a):this.clog(a)};c.prototype.cwarn=function(a){console.warn?console.warn(a):this.clog(a)};c.prototype.cinfo=function(a){console.info?console.info(a):this.clog(a)};c.prototype.cdebug=function(a){console.debug?console.debug(a):this.cinfo(a)};c.prototype.sendLogItemsConsole=function(a){try{if(console){var c;for(c=0;c<a.length;++c){var d=a[c],f=d.n+
": "+d.m;"undefined"===typeof window&&(f=new Date(d.t)+" | "+f);d.l<=b.getDebugLevel()?this.cdebug(f):d.l<=b.getInfoLevel()?this.cinfo(f):d.l<=b.getWarnLevel()?this.cwarn(f):this.cerror(f)}}}catch(e){}};return c}(e);b.ConsoleAppender=q;e=function(){function a(a){this.loggerName=a;this.seenRegexes=[]}a.prototype.setOptions=function(a){d("level",a,this);d("userAgentRegex",a,this);d("disallow",a,this);d("ipRegex",a,this);d("appenders",a,this);d("onceOnly",a,this);this.seenRegexes=[];return this};a.prototype.buildExceptionObject=
function(a){var b={};a.stack?b.stack=a.stack:b.e=a;a.message&&(b.message=a.message);a.name&&(b.name=a.name);a.data&&(b.data=a.data);a.inner&&(b.inner=this.buildExceptionObject(a.inner));return b};a.prototype.log=function(a,b,d){var e=0;if(!this.appenders)return this;if(a>=this.level&&n(this)&&(d?(e=this.buildExceptionObject(d),e.logData=l(b)):e=b,b=g(e),f(this,b.finalString))){if(this.onceOnly)for(e=this.onceOnly.length-1;0<=e;){if(RegExp(this.onceOnly[e]).test(b.finalString)){if(this.seenRegexes[e])return this;
this.seenRegexes[e]=!0}e--}b.meta=b.meta||{};b.meta.loggerName=this.loggerName;for(e=this.appenders.length-1;0<=e;)this.appenders[e].log(1E3>=a?"trace":2E3>=a?"debug":3E3>=a?"info":4E3>=a?"warn":5E3>=a?"error":"fatal",b.msg,b.meta,function(){},a,b.finalString,this.loggerName),e--}return this};a.prototype.trace=function(a){return this.log(1E3,a)};a.prototype.debug=function(a){return this.log(2E3,a)};a.prototype.info=function(a){return this.log(3E3,a)};a.prototype.warn=function(a){return this.log(4E3,
a)};a.prototype.error=function(a){return this.log(5E3,a)};a.prototype.fatal=function(a){return this.log(6E3,a)};a.prototype.fatalException=function(a,b){return this.log(6E3,a,b)};return a}();b.Logger=e;b.createAjaxAppender=function(a){return new p(a)};b.createConsoleAppender=function(a){return new q(a)};e=new p("");"undefined"===typeof window&&(e=new q(""));b.__=new b.Logger("");b.__.setOptions({level:b.getDebugLevel(),appenders:[e]})})(JL||(JL={}));var exports;
"undefined"!==typeof exports&&(exports.JL=JL);var define;"function"==typeof define&&define.amd&&define("jsnlog",[],function(){return JL});"function"==typeof __jsnlog_configure&&__jsnlog_configure(JL);

﻿// OpenLayers. See https://openlayers.org/
// License: https://raw.githubusercontent.com/openlayers/openlayers/master/LICENSE.md
var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};$jscomp.polyfill("Math.cosh",function(a){if(a)return a;var b=Math.exp;return function(a){a=Number(a);return(b(a)+b(-a))/2}},"es6","es3");$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.Symbol=function(){var a=0;return function(b){return $jscomp.SYMBOL_PREFIX+(b||"")+a++}}();
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var a=$jscomp.global.Symbol.iterator;a||(a=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&$jscomp.defineProperty(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}});$jscomp.initSymbolIterator=function(){}};$jscomp.arrayIterator=function(a){var b=0;return $jscomp.iteratorPrototype(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})};
$jscomp.iteratorPrototype=function(a){$jscomp.initSymbolIterator();a={next:a};a[$jscomp.global.Symbol.iterator]=function(){return this};return a};$jscomp.iteratorFromArray=function(a,b){$jscomp.initSymbolIterator();a instanceof String&&(a+="");var c=0,d={next:function(){if(c<a.length){var e=c++;return{value:b(e,a[e]),done:!1}}d.next=function(){return{done:!0,value:void 0}};return d.next()}};d[Symbol.iterator]=function(){return d};return d};
$jscomp.polyfill("Array.prototype.keys",function(a){return a?a:function(){return $jscomp.iteratorFromArray(this,function(a){return a})}},"es6","es3");$jscomp.polyfill("Array.prototype.values",function(a){return a?a:function(){return $jscomp.iteratorFromArray(this,function(a,c){return c})}},"es8","es3");
$jscomp.polyfill("Array.prototype.fill",function(a){return a?a:function(a,c,d){var b=this.length||0;0>c&&(c=Math.max(0,b+c));if(null==d||d>b)d=b;d=Number(d);0>d&&(d=Math.max(0,b+d));for(c=Number(c||0);c<d;c++)this[c]=a;return this}},"es6","es3");$jscomp.polyfill("Number.EPSILON",function(a){return Math.pow(2,-52)},"es6","es3");$jscomp.polyfill("Object.is",function(a){return a?a:function(a,c){return a===c?0!==a||1/a===1/c:a!==a&&c!==c}},"es6","es3");
$jscomp.polyfill("Array.prototype.includes",function(a){return a?a:function(a,c){var b=this;b instanceof String&&(b=String(b));var e=b.length;for(c=c||0;c<e;c++)if(b[c]==a||Object.is(b[c],a))return!0;return!1}},"es7","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};$jscomp.polyfill("String.prototype.includes",function(a){return a?a:function(a,c){return-1!==$jscomp.checkStringArgs(this,a,"includes").indexOf(a,c||0)}},"es6","es3");
$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return{i:e,v:f}}return{i:-1,v:void 0}};$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");var COMPILED=!0,goog=goog||{};goog.global=this;
goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return"string"==typeof a};goog.isBoolean=function(a){return"boolean"==typeof a};goog.isNumber=function(a){return"number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={}};
goog.define=function(a,b){COMPILED||(goog.global.CLOSURE_UNCOMPILED_DEFINES&&void 0===goog.global.CLOSURE_UNCOMPILED_DEFINES.nodeType&&Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES,a)?b=goog.global.CLOSURE_UNCOMPILED_DEFINES[a]:goog.global.CLOSURE_DEFINES&&void 0===goog.global.CLOSURE_DEFINES.nodeType&&Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES,a)&&(b=goog.global.CLOSURE_DEFINES[a]));goog.exportPath_(a,b)};goog.DEBUG=!1;goog.LOCALE="en";
goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=COMPILED&&!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide can not be used within a goog.module.");if(!COMPILED&&goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');goog.constructNamespace_(a)};
goog.constructNamespace_=function(a,b){if(!COMPILED){delete goog.implicitNamespaces_[a];for(var c=a;(c=c.substring(0,c.lastIndexOf(".")))&&!goog.getObjectByName(c);)goog.implicitNamespaces_[c]=!0}goog.exportPath_(a,b)};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");
goog.moduleLoaderState_.moduleName=a;if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');delete goog.implicitNamespaces_[a]}};goog.module.get=function(a){return goog.module.getInternal_(a)};goog.module.getInternal_=function(a){if(!COMPILED){if(a in goog.loadedModules_)return goog.loadedModules_[a];if(!goog.implicitNamespaces_[a])return a=goog.getObjectByName(a),null!=a?a:null}return null};goog.moduleLoaderState_=null;
goog.isInModuleLoader_=function(){return null!=goog.moduleLoaderState_};goog.module.declareLegacyNamespace=function(){if(!COMPILED&&!goog.isInModuleLoader_())throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");if(!COMPILED&&!goog.moduleLoaderState_.moduleName)throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");goog.moduleLoaderState_.declareLegacyNamespace=!0};
goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};COMPILED||(goog.isProvided_=function(a){return a in goog.loadedModules_||!goog.implicitNamespaces_[a]&&goog.isDefAndNotNull(goog.getObjectByName(a))},goog.implicitNamespaces_={"goog.module":!0});
goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c]};
goog.addDependency=function(a,b,c,d){if(goog.DEPENDENCIES_ENABLED){var e;a=a.replace(/\\/g,"/");var f=goog.dependencies_;d&&"boolean"!==typeof d||(d=d?{module:"goog"}:{});for(var g=0;e=b[g];g++)f.nameToPath[e]=a,f.loadFlags[a]=d;for(d=0;b=c[d];d++)a in f.requires||(f.requires[a]={}),f.requires[a][b]=!0}};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a)};
goog.require=function(a){if(!COMPILED){goog.ENABLE_DEBUG_LOADER&&goog.IS_OLD_IE_&&goog.maybeProcessDeferredDep_(a);if(goog.isProvided_(a)){if(goog.isInModuleLoader_())return goog.module.getInternal_(a)}else if(goog.ENABLE_DEBUG_LOADER){var b=goog.getPathFromDeps_(a);if(b)goog.writeScripts_(b);else throw a="goog.require could not find: "+a,goog.logToConsole_(a),Error(a);}return null}};goog.basePath="";goog.nullFunction=function(){};
goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a}};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED&&goog.ENABLE_DEBUG_LOADER;goog.TRANSPILE="detect";
goog.TRANSPILER="transpile.js";
goog.DEPENDENCIES_ENABLED&&(goog.dependencies_={loadFlags:{},nameToPath:{},requires:{},visited:{},written:{},deferred:{}},goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH)&&goog.isString(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_()){var a=goog.global.document,b=a.currentScript;a=b?[b]:a.getElementsByTagName("SCRIPT");for(b=a.length-
1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?");d=-1==d?c.length:d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}}},goog.importScript_=function(a,b){(goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_)(a,b)&&(goog.dependencies_.written[a]=!0)},goog.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.oldIeWaiting_=!1,goog.importProcessedScript_=function(a,b,c){goog.importScript_("",'goog.retrieveAndExec_("'+a+'", '+b+", "+c+");")},goog.queuedModules_=
[],goog.wrapModule_=function(a,b){return goog.LOAD_MODULE_USING_EVAL&&goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(b+"\n//# sourceURL="+a+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+b+"\n;return exports});\n//# sourceURL="+a+"\n"},goog.loadQueuedModules_=function(){var a=goog.queuedModules_.length;if(0<a){var b=goog.queuedModules_;goog.queuedModules_=[];for(var c=0;c<a;c++)goog.maybeProcessDeferredPath_(b[c])}goog.oldIeWaiting_=!1},goog.maybeProcessDeferredDep_=
function(a){goog.isDeferredModule_(a)&&goog.allDepsAreAvailable_(a)&&(a=goog.getPathFromDeps_(a),goog.maybeProcessDeferredPath_(goog.basePath+a))},goog.isDeferredModule_=function(a){var b=(a=goog.getPathFromDeps_(a))&&goog.dependencies_.loadFlags[a]||{},c=b.lang||"es3";return a&&("goog"==b.module||goog.needsTranspile_(c))?goog.basePath+a in goog.dependencies_.deferred:!1},goog.allDepsAreAvailable_=function(a){if((a=goog.getPathFromDeps_(a))&&a in goog.dependencies_.requires)for(var b in goog.dependencies_.requires[a])if(!goog.isProvided_(b)&&
!goog.isDeferredModule_(b))return!1;return!0},goog.maybeProcessDeferredPath_=function(a){if(a in goog.dependencies_.deferred){var b=goog.dependencies_.deferred[a];delete goog.dependencies_.deferred[a];goog.globalEval(b)}},goog.loadModuleFromUrl=function(a){goog.retrieveAndExec_(a,!0,!1)},goog.writeScriptSrcNode_=function(a){goog.global.document.write('<script type="text/javascript" src="'+a+'">\x3c/script>')},goog.appendScriptSrcNode_=function(a){var b=goog.global.document,c=b.createElement("script");
c.type="text/javascript";c.src=a;c.defer=!1;c.async=!1;b.head.appendChild(c)},goog.writeScriptTag_=function(a,b){if(goog.inHtmlDocument_()){var c=goog.global.document;if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&"complete"==c.readyState){if(/\bdeps.js$/.test(a))return!1;throw Error('Cannot write "'+a+'" after document load');}void 0===b?goog.IS_OLD_IE_?(goog.oldIeWaiting_=!0,b=" onreadystatechange='goog.onScriptLoad_(this, "+ ++goog.lastNonModuleScriptIndex_+")' ",c.write('<script type="text/javascript" src="'+
a+'"'+b+">\x3c/script>")):goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING?goog.appendScriptSrcNode_(a):goog.writeScriptSrcNode_(a):c.write('<script type="text/javascript">'+goog.protectScriptTag_(b)+"\x3c/script>");return!0}return!1},goog.protectScriptTag_=function(a){return a.replace(/<\/(SCRIPT)/ig,"\\x3c/$1")},goog.needsTranspile_=function(a){if("always"==goog.TRANSPILE)return!0;if("never"==goog.TRANSPILE)return!1;goog.requiresTranspilation_||(goog.requiresTranspilation_=goog.createRequiresTranspilation_());
if(a in goog.requiresTranspilation_)return goog.requiresTranspilation_[a];throw Error("Unknown language mode: "+a);},goog.requiresTranspilation_=null,goog.lastNonModuleScriptIndex_=0,goog.onScriptLoad_=function(a,b){"complete"==a.readyState&&goog.lastNonModuleScriptIndex_==b&&goog.loadQueuedModules_();return!0},goog.writeScripts_=function(a){function b(a){if(!(a in e.written||a in e.visited)){e.visited[a]=!0;if(a in e.requires)for(var f in e.requires[a])if(!goog.isProvided_(f))if(f in e.nameToPath)b(e.nameToPath[f]);
else throw Error("Undefined nameToPath for "+f);a in d||(d[a]=!0,c.push(a))}}var c=[],d={},e=goog.dependencies_;b(a);for(a=0;a<c.length;a++){var f=c[a];goog.dependencies_.written[f]=!0}var g=goog.moduleLoaderState_;goog.moduleLoaderState_=null;for(a=0;a<c.length;a++)if(f=c[a]){var h=e.loadFlags[f]||{},k=goog.needsTranspile_(h.lang||"es3");"goog"==h.module||k?goog.importProcessedScript_(goog.basePath+f,"goog"==h.module,k):goog.importScript_(goog.basePath+f)}else throw goog.moduleLoaderState_=g,Error("Undefined script input");
goog.moduleLoaderState_=g},goog.getPathFromDeps_=function(a){return a in goog.dependencies_.nameToPath?goog.dependencies_.nameToPath[a]:null},goog.findBasePath_(),goog.global.CLOSURE_NO_DEPS||goog.importScript_(goog.basePath+"deps.js"));goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";')}catch(b){a=!1}goog.hasBadLetScoping=a}return goog.hasBadLetScoping};
goog.workaroundSafari10EvalBug=function(a){return"(function(){"+a+"\n;})();\n"};
goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:void 0,declareLegacyNamespace:!1};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(!goog.isString(d)||!d)throw Error('Invalid module name "'+d+'"');goog.moduleLoaderState_.declareLegacyNamespace?
goog.constructNamespace_(d,c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c);goog.loadedModules_[d]=c}finally{goog.moduleLoaderState_=b}};goog.loadModuleFromSource_=function(a){eval(a);return{}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
goog.retrieveAndExec_=function(a,b,c){if(!COMPILED){var d=a;a=goog.normalizePath_(a);var e=goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_,f=goog.loadFileSync_(a);if(null==f)throw Error('Load of "'+a+'" failed');c&&(f=goog.transpile_.call(goog.global,f,a));f=b?goog.wrapModule_(a,f):f+("\n//# sourceURL="+a);goog.IS_OLD_IE_&&goog.oldIeWaiting_?(goog.dependencies_.deferred[d]=f,goog.queuedModules_.push(d)):e(a,f)}};
goog.transpile_=function(a,b){var c=goog.global.$jscomp;c||(goog.global.$jscomp=c={});var d=c.transpile;if(!d){var e=goog.basePath+goog.TRANSPILER,f=goog.loadFileSync_(e);if(f){eval(f+"\n//# sourceURL="+e);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=goog.global.$gwtExport.$jscomp.transpile;
c=goog.global.$jscomp;d=c.transpile}}d||(d=c.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return d(a,b)};
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return"array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return"array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return"function"==goog.typeOf(a)};
goog.isObject=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return!!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return+new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_)if(goog.global.eval("var _evalTest_ = 1;"),"undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_}catch(d){}goog.evalWorksForGlobals_=!0}else goog.evalWorksForGlobals_=!1;if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=!1;c.appendChild(b.createTextNode(a));
b.body.appendChild(c);b.body.removeChild(c)}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b){b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,d){return null!=b&&d in b?b[d]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};goog.exportProperty=function(a,b,c){a[b]=c};
goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if(d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor;g;g=
g.superClass_&&g.superClass_.constructor)if(g.prototype[b]===d)f=!0;else if(f)return g.prototype[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a goog.module.");a.call(goog.global)};COMPILED||(goog.global.COMPILED=COMPILED);
goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;
goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};goog.tagUnsealableClass=function(a){!COMPILED&&goog.defineClass.SEAL_CLASS_INSTANCES&&(a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]=!0)};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
goog.createRequiresTranspilation_=function(){function a(a,b){d?c[a]=!0:b()?c[a]=!1:d=c[a]=!0}function b(a){try{return!!eval(a)}catch(g){return!1}}var c={es3:!1},d=!1,e=goog.global.navigator&&goog.global.navigator.userAgent?goog.global.navigator.userAgent:"";a("es5",function(){return b("[1,].length==1")});a("es6",function(){var a=e.match(/Edge\/(\d+)(\.\d)*/i);return a&&15>Number(a[1])?!1:b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')});
a("es6-impl",function(){return!0});a("es7",function(){return b("2 ** 2 == 4")});a("es8",function(){return b("async () => 1, true")});return c};var ol={ASSUME_TOUCH:!1,DEFAULT_MAX_ZOOM:42,DEFAULT_MIN_ZOOM:0,DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD:.5,DEFAULT_TILE_SIZE:256,DEFAULT_WMS_VERSION:"1.3.0",ENABLE_CANVAS:!0,ENABLE_PROJ4JS:!0,ENABLE_RASTER_REPROJECTION:!0,ENABLE_WEBGL:!0,DEBUG_WEBGL:!0,INITIAL_ATLAS_SIZE:256,MAX_ATLAS_SIZE:-1,MOUSEWHEELZOOM_MAXDELTA:1,OVERVIEWMAP_MAX_RATIO:.75,OVERVIEWMAP_MIN_RATIO:.1,RASTER_REPROJECTION_MAX_SOURCE_TILES:100,RASTER_REPROJECTION_MAX_SUBDIVISION:10,RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH:.25,SIMPLIFY_TOLERANCE:.5,
WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK:1024,VERSION:"4.6.5",inherits:function(a,b){a.prototype=Object.create(b.prototype);a.prototype.constructor=a},nullFunction:function(){},getUid:function(a){return a.ol_uid||(a.ol_uid=++ol.uidCounter_)},uidCounter_:0};ol.AssertionError=function(a){this.message="Assertion failed. See https://openlayers.org/en/"+(ol.VERSION?ol.VERSION.split("-")[0]:"latest")+"/doc/errors/#"+a+" for details.";this.code=a;this.name="AssertionError"};ol.inherits(ol.AssertionError,Error);ol.TileRange=function(a,b,c,d){this.minX=a;this.maxX=b;this.minY=c;this.maxY=d};ol.TileRange.createOrUpdate=function(a,b,c,d,e){return void 0!==e?(e.minX=a,e.maxX=b,e.minY=c,e.maxY=d,e):new ol.TileRange(a,b,c,d)};ol.TileRange.prototype.contains=function(a){return this.containsXY(a[1],a[2])};ol.TileRange.prototype.containsTileRange=function(a){return this.minX<=a.minX&&a.maxX<=this.maxX&&this.minY<=a.minY&&a.maxY<=this.maxY};
ol.TileRange.prototype.containsXY=function(a,b){return this.minX<=a&&a<=this.maxX&&this.minY<=b&&b<=this.maxY};ol.TileRange.prototype.equals=function(a){return this.minX==a.minX&&this.minY==a.minY&&this.maxX==a.maxX&&this.maxY==a.maxY};ol.TileRange.prototype.extend=function(a){a.minX<this.minX&&(this.minX=a.minX);a.maxX>this.maxX&&(this.maxX=a.maxX);a.minY<this.minY&&(this.minY=a.minY);a.maxY>this.maxY&&(this.maxY=a.maxY)};ol.TileRange.prototype.getHeight=function(){return this.maxY-this.minY+1};
ol.TileRange.prototype.getSize=function(){return[this.getWidth(),this.getHeight()]};ol.TileRange.prototype.getWidth=function(){return this.maxX-this.minX+1};ol.TileRange.prototype.intersects=function(a){return this.minX<=a.maxX&&this.maxX>=a.minX&&this.minY<=a.maxY&&this.maxY>=a.minY};ol.asserts={};ol.asserts.assert=function(a,b){if(!a)throw new ol.AssertionError(b);};ol.math={};ol.math.clamp=function(a,b,c){return Math.min(Math.max(a,b),c)};ol.math.cosh=function(){return"cosh"in Math?Math.cosh:function(a){a=Math.exp(a);return(a+1/a)/2}}();ol.math.roundUpToPowerOfTwo=function(a){ol.asserts.assert(0<a,29);return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))};ol.math.squaredSegmentDistance=function(a,b,c,d,e,f){var g=e-c,h=f-d;if(0!==g||0!==h){var k=((a-c)*g+(b-d)*h)/(g*g+h*h);1<k?(c=e,d=f):0<k&&(c+=g*k,d+=h*k)}return ol.math.squaredDistance(a,b,c,d)};
ol.math.squaredDistance=function(a,b,c,d){a=c-a;b=d-b;return a*a+b*b};ol.math.solveLinearSystem=function(a){for(var b=a.length,c=0;c<b;c++){for(var d=c,e=Math.abs(a[c][c]),f=c+1;f<b;f++){var g=Math.abs(a[f][c]);g>e&&(e=g,d=f)}if(0===e)return null;e=a[d];a[d]=a[c];a[c]=e;for(d=c+1;d<b;d++)for(e=-a[d][c]/a[c][c],f=c;f<b+1;f++)a[d][f]=c==f?0:a[d][f]+e*a[c][f]}c=Array(b);for(d=b-1;0<=d;d--)for(c[d]=a[d][b]/a[d][d],e=d-1;0<=e;e--)a[e][b]-=a[e][d]*c[d];return c};
ol.math.toDegrees=function(a){return 180*a/Math.PI};ol.math.toRadians=function(a){return a*Math.PI/180};ol.math.modulo=function(a,b){a%=b;return 0>a*b?a+b:a};ol.math.lerp=function(a,b,c){return a+c*(b-a)};ol.size={};ol.size.buffer=function(a,b,c){void 0===c&&(c=[0,0]);c[0]=a[0]+2*b;c[1]=a[1]+2*b;return c};ol.size.hasArea=function(a){return 0<a[0]&&0<a[1]};ol.size.scale=function(a,b,c){void 0===c&&(c=[0,0]);c[0]=a[0]*b+.5|0;c[1]=a[1]*b+.5|0;return c};ol.size.toSize=function(a,b){if(Array.isArray(a))return a;void 0===b?b=[a,a]:b[0]=b[1]=a;return b};ol.extent={};ol.extent.Corner={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"};ol.extent.Relationship={UNKNOWN:0,INTERSECTING:1,ABOVE:2,RIGHT:4,BELOW:8,LEFT:16};ol.extent.boundingExtent=function(a){for(var b=ol.extent.createEmpty(),c=0,d=a.length;c<d;++c)ol.extent.extendCoordinate(b,a[c]);return b};ol.extent.boundingExtentXYs_=function(a,b,c){var d=Math.min.apply(null,a),e=Math.min.apply(null,b);a=Math.max.apply(null,a);b=Math.max.apply(null,b);return ol.extent.createOrUpdate(d,e,a,b,c)};ol.extent.buffer=function(a,b,c){return c?(c[0]=a[0]-b,c[1]=a[1]-b,c[2]=a[2]+b,c[3]=a[3]+b,c):[a[0]-b,a[1]-b,a[2]+b,a[3]+b]};
ol.extent.clone=function(a,b){return b?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b):a.slice()};ol.extent.closestSquaredDistanceXY=function(a,b,c){b=b<a[0]?a[0]-b:a[2]<b?b-a[2]:0;a=c<a[1]?a[1]-c:a[3]<c?c-a[3]:0;return b*b+a*a};ol.extent.containsCoordinate=function(a,b){return ol.extent.containsXY(a,b[0],b[1])};ol.extent.containsExtent=function(a,b){return a[0]<=b[0]&&b[2]<=a[2]&&a[1]<=b[1]&&b[3]<=a[3]};ol.extent.containsXY=function(a,b,c){return a[0]<=b&&b<=a[2]&&a[1]<=c&&c<=a[3]};
ol.extent.coordinateRelationship=function(a,b){var c=a[1],d=a[2],e=a[3],f=b[0];b=b[1];var g=ol.extent.Relationship.UNKNOWN;f<a[0]?g|=ol.extent.Relationship.LEFT:f>d&&(g|=ol.extent.Relationship.RIGHT);b<c?g|=ol.extent.Relationship.BELOW:b>e&&(g|=ol.extent.Relationship.ABOVE);g===ol.extent.Relationship.UNKNOWN&&(g=ol.extent.Relationship.INTERSECTING);return g};ol.extent.createEmpty=function(){return[Infinity,Infinity,-Infinity,-Infinity]};
ol.extent.createOrUpdate=function(a,b,c,d,e){return e?(e[0]=a,e[1]=b,e[2]=c,e[3]=d,e):[a,b,c,d]};ol.extent.createOrUpdateEmpty=function(a){return ol.extent.createOrUpdate(Infinity,Infinity,-Infinity,-Infinity,a)};ol.extent.createOrUpdateFromCoordinate=function(a,b){var c=a[0];a=a[1];return ol.extent.createOrUpdate(c,a,c,a,b)};ol.extent.createOrUpdateFromCoordinates=function(a,b){b=ol.extent.createOrUpdateEmpty(b);return ol.extent.extendCoordinates(b,a)};
ol.extent.createOrUpdateFromFlatCoordinates=function(a,b,c,d,e){e=ol.extent.createOrUpdateEmpty(e);return ol.extent.extendFlatCoordinates(e,a,b,c,d)};ol.extent.createOrUpdateFromRings=function(a,b){b=ol.extent.createOrUpdateEmpty(b);return ol.extent.extendRings(b,a)};ol.extent.equals=function(a,b){return a[0]==b[0]&&a[2]==b[2]&&a[1]==b[1]&&a[3]==b[3]};ol.extent.extend=function(a,b){b[0]<a[0]&&(a[0]=b[0]);b[2]>a[2]&&(a[2]=b[2]);b[1]<a[1]&&(a[1]=b[1]);b[3]>a[3]&&(a[3]=b[3]);return a};
ol.extent.extendCoordinate=function(a,b){b[0]<a[0]&&(a[0]=b[0]);b[0]>a[2]&&(a[2]=b[0]);b[1]<a[1]&&(a[1]=b[1]);b[1]>a[3]&&(a[3]=b[1])};ol.extent.extendCoordinates=function(a,b){var c;var d=0;for(c=b.length;d<c;++d)ol.extent.extendCoordinate(a,b[d]);return a};ol.extent.extendFlatCoordinates=function(a,b,c,d,e){for(;c<d;c+=e)ol.extent.extendXY(a,b[c],b[c+1]);return a};ol.extent.extendRings=function(a,b){var c;var d=0;for(c=b.length;d<c;++d)ol.extent.extendCoordinates(a,b[d]);return a};
ol.extent.extendXY=function(a,b,c){a[0]=Math.min(a[0],b);a[1]=Math.min(a[1],c);a[2]=Math.max(a[2],b);a[3]=Math.max(a[3],c)};ol.extent.forEachCorner=function(a,b,c){var d;return(d=b.call(c,ol.extent.getBottomLeft(a)))||(d=b.call(c,ol.extent.getBottomRight(a)))||(d=b.call(c,ol.extent.getTopRight(a)))?d:(d=b.call(c,ol.extent.getTopLeft(a)))?d:!1};ol.extent.getArea=function(a){var b=0;ol.extent.isEmpty(a)||(b=ol.extent.getWidth(a)*ol.extent.getHeight(a));return b};
ol.extent.getBottomLeft=function(a){return[a[0],a[1]]};ol.extent.getBottomRight=function(a){return[a[2],a[1]]};ol.extent.getCenter=function(a){return[(a[0]+a[2])/2,(a[1]+a[3])/2]};ol.extent.getCorner=function(a,b){var c;b===ol.extent.Corner.BOTTOM_LEFT?c=ol.extent.getBottomLeft(a):b===ol.extent.Corner.BOTTOM_RIGHT?c=ol.extent.getBottomRight(a):b===ol.extent.Corner.TOP_LEFT?c=ol.extent.getTopLeft(a):b===ol.extent.Corner.TOP_RIGHT?c=ol.extent.getTopRight(a):ol.asserts.assert(!1,13);return c};
ol.extent.getEnlargedArea=function(a,b){return(Math.max(a[2],b[2])-Math.min(a[0],b[0]))*(Math.max(a[3],b[3])-Math.min(a[1],b[1]))};ol.extent.getForViewAndSize=function(a,b,c,d,e){var f=b*d[0]/2;d=b*d[1]/2;b=Math.cos(c);var g=Math.sin(c);c=f*b;f*=g;b*=d;var h=d*g,k=a[0],l=a[1];a=k-c+h;d=k-c-h;g=k+c-h;c=k+c+h;h=l-f-b;k=l-f+b;var m=l+f+b;f=l+f-b;return ol.extent.createOrUpdate(Math.min(a,d,g,c),Math.min(h,k,m,f),Math.max(a,d,g,c),Math.max(h,k,m,f),e)};ol.extent.getHeight=function(a){return a[3]-a[1]};
ol.extent.getIntersectionArea=function(a,b){a=ol.extent.getIntersection(a,b);return ol.extent.getArea(a)};ol.extent.getIntersection=function(a,b,c){c=c?c:ol.extent.createEmpty();ol.extent.intersects(a,b)&&(c[0]=a[0]>b[0]?a[0]:b[0],c[1]=a[1]>b[1]?a[1]:b[1],c[2]=a[2]<b[2]?a[2]:b[2],c[3]=a[3]<b[3]?a[3]:b[3]);return c};ol.extent.getMargin=function(a){return ol.extent.getWidth(a)+ol.extent.getHeight(a)};ol.extent.getSize=function(a){return[a[2]-a[0],a[3]-a[1]]};
ol.extent.getTopLeft=function(a){return[a[0],a[3]]};ol.extent.getTopRight=function(a){return[a[2],a[3]]};ol.extent.getWidth=function(a){return a[2]-a[0]};ol.extent.intersects=function(a,b){return a[0]<=b[2]&&a[2]>=b[0]&&a[1]<=b[3]&&a[3]>=b[1]};ol.extent.isEmpty=function(a){return a[2]<a[0]||a[3]<a[1]};ol.extent.returnOrUpdate=function(a,b){return b?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b):a};
ol.extent.scaleFromCenter=function(a,b){var c=(a[2]-a[0])/2*(b-1);b=(a[3]-a[1])/2*(b-1);a[0]-=c;a[2]+=c;a[1]-=b;a[3]+=b};
ol.extent.intersectsSegment=function(a,b,c){var d=!1,e=ol.extent.coordinateRelationship(a,b),f=ol.extent.coordinateRelationship(a,c);if(e===ol.extent.Relationship.INTERSECTING||f===ol.extent.Relationship.INTERSECTING)d=!0;else{var g=a[0],h=a[1],k=a[2];a=a[3];var l=c[0];c=c[1];b=(c-b[1])/(l-b[0]);f&ol.extent.Relationship.ABOVE&&!(e&ol.extent.Relationship.ABOVE)&&(d=l-(c-a)/b,d=d>=g&&d<=k);d||!(f&ol.extent.Relationship.RIGHT)||e&ol.extent.Relationship.RIGHT||(d=c-(l-k)*b,d=d>=h&&d<=a);d||!(f&ol.extent.Relationship.BELOW)||
e&ol.extent.Relationship.BELOW||(d=l-(c-h)/b,d=d>=g&&d<=k);d||!(f&ol.extent.Relationship.LEFT)||e&ol.extent.Relationship.LEFT||(d=c-(l-g)*b,d=d>=h&&d<=a)}return d};ol.extent.applyTransform=function(a,b,c){a=[a[0],a[1],a[0],a[3],a[2],a[1],a[2],a[3]];b(a,a,2);return ol.extent.boundingExtentXYs_([a[0],a[2],a[4],a[6]],[a[1],a[3],a[5],a[7]],c)};ol.obj={};ol.obj.assign="function"===typeof Object.assign?Object.assign:function(a,b){if(void 0===a||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var c=Object(a),d=1,e=arguments.length;d<e;++d){var f=arguments[d];if(void 0!==f&&null!==f)for(var g in f)f.hasOwnProperty(g)&&(c[g]=f[g])}return c};ol.obj.clear=function(a){for(var b in a)delete a[b]};ol.obj.getValues=function(a){var b=[],c;for(c in a)b.push(a[c]);return b};
ol.obj.isEmpty=function(a){for(var b in a)return!1;return!b};ol.geom={};ol.geom.GeometryType={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"};/*

 Latitude/longitude spherical geodesy formulae taken from
 http://www.movable-type.co.uk/scripts/latlong.html
 Licensed under CC-BY-3.0.
*/
ol.Sphere=function(a){this.radius=a};ol.Sphere.prototype.geodesicArea=function(a){return ol.Sphere.getArea_(a,this.radius)};ol.Sphere.prototype.haversineDistance=function(a,b){return ol.Sphere.getDistance_(a,b,this.radius)};
ol.Sphere.prototype.offset=function(a,b,c){var d=ol.math.toRadians(a[1]);a=ol.math.toRadians(a[0]);b/=this.radius;var e=Math.asin(Math.sin(d)*Math.cos(b)+Math.cos(d)*Math.sin(b)*Math.cos(c));return[ol.math.toDegrees(a+Math.atan2(Math.sin(c)*Math.sin(b)*Math.cos(d),Math.cos(b)-Math.sin(d)*Math.sin(e))),ol.math.toDegrees(e)]};ol.Sphere.DEFAULT_RADIUS=6371008.8;
ol.Sphere.getLength=function(a,b){var c=b||{},d=c.radius||ol.Sphere.DEFAULT_RADIUS;c=c.projection||"EPSG:3857";a=a.clone().transform(c,"EPSG:4326");var e=a.getType();c=0;var f;switch(e){case ol.geom.GeometryType.POINT:case ol.geom.GeometryType.MULTI_POINT:break;case ol.geom.GeometryType.LINE_STRING:case ol.geom.GeometryType.LINEAR_RING:b=a.getCoordinates();c=ol.Sphere.getLength_(b,d);break;case ol.geom.GeometryType.MULTI_LINE_STRING:case ol.geom.GeometryType.POLYGON:b=a.getCoordinates();a=0;for(e=
b.length;a<e;++a)c+=ol.Sphere.getLength_(b[a],d);break;case ol.geom.GeometryType.MULTI_POLYGON:b=a.getCoordinates();a=0;for(e=b.length;a<e;++a){var g=b[a];var h=0;for(f=g.length;h<f;++h)c+=ol.Sphere.getLength_(g[h],d)}break;case ol.geom.GeometryType.GEOMETRY_COLLECTION:d=a.getGeometries();a=0;for(e=d.length;a<e;++a)c+=ol.Sphere.getLength(d[a],b);break;default:throw Error("Unsupported geometry type: "+e);}return c};
ol.Sphere.getLength_=function(a,b){for(var c=0,d=0,e=a.length;d<e-1;++d)c+=ol.Sphere.getDistance_(a[d],a[d+1],b);return c};ol.Sphere.getDistance_=function(a,b,c){var d=ol.math.toRadians(a[1]),e=ol.math.toRadians(b[1]),f=(e-d)/2;a=ol.math.toRadians(b[0]-a[0])/2;d=Math.sin(f)*Math.sin(f)+Math.sin(a)*Math.sin(a)*Math.cos(d)*Math.cos(e);return 2*c*Math.atan2(Math.sqrt(d),Math.sqrt(1-d))};
ol.Sphere.getArea=function(a,b){var c=b||{},d=c.radius||ol.Sphere.DEFAULT_RADIUS;c=c.projection||"EPSG:3857";a=a.clone().transform(c,"EPSG:4326");var e=a.getType();c=0;var f;switch(e){case ol.geom.GeometryType.POINT:case ol.geom.GeometryType.MULTI_POINT:case ol.geom.GeometryType.LINE_STRING:case ol.geom.GeometryType.MULTI_LINE_STRING:case ol.geom.GeometryType.LINEAR_RING:break;case ol.geom.GeometryType.POLYGON:b=a.getCoordinates();c=Math.abs(ol.Sphere.getArea_(b[0],d));a=1;for(e=b.length;a<e;++a)c-=
Math.abs(ol.Sphere.getArea_(b[a],d));break;case ol.geom.GeometryType.MULTI_POLYGON:b=a.getCoordinates();a=0;for(e=b.length;a<e;++a){var g=b[a];c+=Math.abs(ol.Sphere.getArea_(g[0],d));var h=1;for(f=g.length;h<f;++h)c-=Math.abs(ol.Sphere.getArea_(g[h],d))}break;case ol.geom.GeometryType.GEOMETRY_COLLECTION:d=a.getGeometries();a=0;for(e=d.length;a<e;++a)c+=ol.Sphere.getArea(d[a],b);break;default:throw Error("Unsupported geometry type: "+e);}return c};
ol.Sphere.getArea_=function(a,b){for(var c=0,d=a.length,e=a[d-1][0],f=a[d-1][1],g=0;g<d;g++){var h=a[g][0],k=a[g][1];c+=ol.math.toRadians(h-e)*(2+Math.sin(ol.math.toRadians(f))+Math.sin(ol.math.toRadians(k)));e=h;f=k}return c*b*b/2};ol.proj={};ol.proj.Units={DEGREES:"degrees",FEET:"ft",METERS:"m",PIXELS:"pixels",TILE_PIXELS:"tile-pixels",USFEET:"us-ft"};ol.proj.Units.METERS_PER_UNIT={};ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.DEGREES]=12741994*Math.PI/360;ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.FEET]=.3048;ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.METERS]=1;ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.USFEET]=1200/3937;ol.proj.proj4={};ol.proj.proj4.cache_=null;ol.proj.proj4.set=function(a){ol.proj.proj4.cache_=a};ol.proj.proj4.get=function(){return ol.proj.proj4.cache_||window.proj4};ol.proj.Projection=function(a){this.code_=a.code;this.units_=a.units;this.extent_=void 0!==a.extent?a.extent:null;this.worldExtent_=void 0!==a.worldExtent?a.worldExtent:null;this.axisOrientation_=void 0!==a.axisOrientation?a.axisOrientation:"enu";this.global_=void 0!==a.global?a.global:!1;this.canWrapX_=!(!this.global_||!this.extent_);this.getPointResolutionFunc_=a.getPointResolution;this.defaultTileGrid_=null;this.metersPerUnit_=a.metersPerUnit;var b=a.code;if(ol.ENABLE_PROJ4JS){var c=ol.proj.proj4.get();
"function"==typeof c&&(b=c.defs(b),void 0!==b&&(void 0!==b.axis&&void 0===a.axisOrientation&&(this.axisOrientation_=b.axis),void 0===a.metersPerUnit&&(this.metersPerUnit_=b.to_meter),void 0===a.units&&(this.units_=b.units)))}};ol.proj.Projection.prototype.canWrapX=function(){return this.canWrapX_};ol.proj.Projection.prototype.getCode=function(){return this.code_};ol.proj.Projection.prototype.getExtent=function(){return this.extent_};ol.proj.Projection.prototype.getUnits=function(){return this.units_};
ol.proj.Projection.prototype.getMetersPerUnit=function(){return this.metersPerUnit_||ol.proj.Units.METERS_PER_UNIT[this.units_]};ol.proj.Projection.prototype.getWorldExtent=function(){return this.worldExtent_};ol.proj.Projection.prototype.getAxisOrientation=function(){return this.axisOrientation_};ol.proj.Projection.prototype.isGlobal=function(){return this.global_};ol.proj.Projection.prototype.setGlobal=function(a){this.global_=a;this.canWrapX_=!(!a||!this.extent_)};
ol.proj.Projection.prototype.getDefaultTileGrid=function(){return this.defaultTileGrid_};ol.proj.Projection.prototype.setDefaultTileGrid=function(a){this.defaultTileGrid_=a};ol.proj.Projection.prototype.setExtent=function(a){this.extent_=a;this.canWrapX_=!(!this.global_||!a)};ol.proj.Projection.prototype.setWorldExtent=function(a){this.worldExtent_=a};ol.proj.Projection.prototype.setGetPointResolution=function(a){this.getPointResolutionFunc_=a};
ol.proj.Projection.prototype.getPointResolutionFunc=function(){return this.getPointResolutionFunc_};ol.proj.EPSG3857={};ol.proj.EPSG3857.Projection_=function(a){ol.proj.Projection.call(this,{code:a,units:ol.proj.Units.METERS,extent:ol.proj.EPSG3857.EXTENT,global:!0,worldExtent:ol.proj.EPSG3857.WORLD_EXTENT,getPointResolution:function(a,c){return a/ol.math.cosh(c[1]/ol.proj.EPSG3857.RADIUS)}})};ol.inherits(ol.proj.EPSG3857.Projection_,ol.proj.Projection);ol.proj.EPSG3857.RADIUS=6378137;ol.proj.EPSG3857.HALF_SIZE=Math.PI*ol.proj.EPSG3857.RADIUS;
ol.proj.EPSG3857.EXTENT=[-ol.proj.EPSG3857.HALF_SIZE,-ol.proj.EPSG3857.HALF_SIZE,ol.proj.EPSG3857.HALF_SIZE,ol.proj.EPSG3857.HALF_SIZE];ol.proj.EPSG3857.WORLD_EXTENT=[-180,-85,180,85];
ol.proj.EPSG3857.PROJECTIONS=[new ol.proj.EPSG3857.Projection_("EPSG:3857"),new ol.proj.EPSG3857.Projection_("EPSG:102100"),new ol.proj.EPSG3857.Projection_("EPSG:102113"),new ol.proj.EPSG3857.Projection_("EPSG:900913"),new ol.proj.EPSG3857.Projection_("urn:ogc:def:crs:EPSG:6.18:3:3857"),new ol.proj.EPSG3857.Projection_("urn:ogc:def:crs:EPSG::3857"),new ol.proj.EPSG3857.Projection_("http://www.opengis.net/gml/srs/epsg.xml#3857")];
ol.proj.EPSG3857.fromEPSG4326=function(a,b,c){var d=a.length;c=1<c?c:2;void 0===b&&(b=2<c?a.slice():Array(d));for(var e=ol.proj.EPSG3857.HALF_SIZE,f=0;f<d;f+=c){b[f]=e*a[f]/180;var g=ol.proj.EPSG3857.RADIUS*Math.log(Math.tan(Math.PI*(a[f+1]+90)/360));g>e?g=e:g<-e&&(g=-e);b[f+1]=g}return b};
ol.proj.EPSG3857.toEPSG4326=function(a,b,c){var d=a.length;c=1<c?c:2;void 0===b&&(b=2<c?a.slice():Array(d));for(var e=0;e<d;e+=c)b[e]=180*a[e]/ol.proj.EPSG3857.HALF_SIZE,b[e+1]=360*Math.atan(Math.exp(a[e+1]/ol.proj.EPSG3857.RADIUS))/Math.PI-90;return b};ol.proj.EPSG4326={};ol.proj.EPSG4326.Projection_=function(a,b){ol.proj.Projection.call(this,{code:a,units:ol.proj.Units.DEGREES,extent:ol.proj.EPSG4326.EXTENT,axisOrientation:b,global:!0,metersPerUnit:ol.proj.EPSG4326.METERS_PER_UNIT,worldExtent:ol.proj.EPSG4326.EXTENT})};ol.inherits(ol.proj.EPSG4326.Projection_,ol.proj.Projection);ol.proj.EPSG4326.RADIUS=6378137;ol.proj.EPSG4326.EXTENT=[-180,-90,180,90];ol.proj.EPSG4326.METERS_PER_UNIT=Math.PI*ol.proj.EPSG4326.RADIUS/180;
ol.proj.EPSG4326.PROJECTIONS=[new ol.proj.EPSG4326.Projection_("CRS:84"),new ol.proj.EPSG4326.Projection_("EPSG:4326","neu"),new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:EPSG::4326","neu"),new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:EPSG:6.6:4326","neu"),new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:OGC:1.3:CRS84"),new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:OGC:2:84"),new ol.proj.EPSG4326.Projection_("http://www.opengis.net/gml/srs/epsg.xml#4326","neu"),new ol.proj.EPSG4326.Projection_("urn:x-ogc:def:crs:EPSG:4326",
"neu")];ol.proj.projections={};ol.proj.projections.cache_={};ol.proj.projections.clear=function(){ol.proj.projections.cache_={}};ol.proj.projections.get=function(a){return ol.proj.projections.cache_[a]||null};ol.proj.projections.add=function(a,b){ol.proj.projections.cache_[a]=b};ol.proj.transforms={};ol.proj.transforms.cache_={};ol.proj.transforms.clear=function(){ol.proj.transforms.cache_={}};ol.proj.transforms.add=function(a,b,c){a=a.getCode();b=b.getCode();var d=ol.proj.transforms.cache_;a in d||(d[a]={});d[a][b]=c};ol.proj.transforms.remove=function(a,b){a=a.getCode();b=b.getCode();var c=ol.proj.transforms.cache_,d=c[a][b];delete c[a][b];ol.obj.isEmpty(c[a])&&delete c[a];return d};
ol.proj.transforms.get=function(a,b){var c,d=ol.proj.transforms.cache_;a in d&&b in d[a]&&(c=d[a][b]);return c};ol.proj.METERS_PER_UNIT=ol.proj.Units.METERS_PER_UNIT;ol.proj.SPHERE_=new ol.Sphere(ol.Sphere.DEFAULT_RADIUS);ol.ENABLE_PROJ4JS&&(ol.proj.setProj4=function(a){ol.proj.proj4.set(a)});
ol.proj.getPointResolution=function(a,b,c,d){a=ol.proj.get(a);var e=a.getPointResolutionFunc();e?b=e(b,c):a.getUnits()==ol.proj.Units.DEGREES&&!d||d==ol.proj.Units.DEGREES||(e=ol.proj.getTransformFromProjections(a,ol.proj.get("EPSG:4326")),b=[c[0]-b/2,c[1],c[0]+b/2,c[1],c[0],c[1]-b/2,c[0],c[1]+b/2],b=e(b,b,2),c=ol.proj.SPHERE_.haversineDistance(b.slice(0,2),b.slice(2,4)),b=ol.proj.SPHERE_.haversineDistance(b.slice(4,6),b.slice(6,8)),b=(c+b)/2,a=d?ol.proj.Units.METERS_PER_UNIT[d]:a.getMetersPerUnit(),
void 0!==a&&(b/=a));return b};ol.proj.addEquivalentProjections=function(a){ol.proj.addProjections(a);a.forEach(function(b){a.forEach(function(a){b!==a&&ol.proj.transforms.add(b,a,ol.proj.cloneTransform)})})};ol.proj.addEquivalentTransforms=function(a,b,c,d){a.forEach(function(a){b.forEach(function(b){ol.proj.transforms.add(a,b,c);ol.proj.transforms.add(b,a,d)})})};ol.proj.addProjection=function(a){ol.proj.projections.add(a.getCode(),a);ol.proj.transforms.add(a,a,ol.proj.cloneTransform)};
ol.proj.addProjections=function(a){a.forEach(ol.proj.addProjection)};ol.proj.clearAllProjections=function(){ol.proj.projections.clear();ol.proj.transforms.clear()};ol.proj.createProjection=function(a,b){return a?"string"===typeof a?ol.proj.get(a):a:ol.proj.get(b)};ol.proj.addCoordinateTransforms=function(a,b,c,d){a=ol.proj.get(a);b=ol.proj.get(b);ol.proj.transforms.add(a,b,ol.proj.createTransformFromCoordinateTransform(c));ol.proj.transforms.add(b,a,ol.proj.createTransformFromCoordinateTransform(d))};
ol.proj.createTransformFromCoordinateTransform=function(a){return function(b,c,d){var e=b.length;d=void 0!==d?d:2;c=void 0!==c?c:Array(e);var f;for(f=0;f<e;f+=d){var g=a([b[f],b[f+1]]);c[f]=g[0];c[f+1]=g[1];for(g=d-1;2<=g;--g)c[f+g]=b[f+g]}return c}};ol.proj.fromLonLat=function(a,b){return ol.proj.transform(a,"EPSG:4326",void 0!==b?b:"EPSG:3857")};ol.proj.toLonLat=function(a,b){a=ol.proj.transform(a,void 0!==b?b:"EPSG:3857","EPSG:4326");b=a[0];if(-180>b||180<b)a[0]=ol.math.modulo(b+180,360)-180;return a};
ol.proj.get=function(a){var b=null;if(a instanceof ol.proj.Projection)b=a;else if("string"===typeof a&&(b=ol.proj.projections.get(a),ol.ENABLE_PROJ4JS&&!b)){var c=ol.proj.proj4.get();"function"==typeof c&&void 0!==c.defs(a)&&(b=new ol.proj.Projection({code:a}),ol.proj.addProjection(b))}return b};ol.proj.equivalent=function(a,b){if(a===b)return!0;var c=a.getUnits()===b.getUnits();return a.getCode()===b.getCode()?c:ol.proj.getTransformFromProjections(a,b)===ol.proj.cloneTransform&&c};
ol.proj.getTransform=function(a,b){a=ol.proj.get(a);b=ol.proj.get(b);return ol.proj.getTransformFromProjections(a,b)};
ol.proj.getTransformFromProjections=function(a,b){var c=a.getCode(),d=b.getCode(),e=ol.proj.transforms.get(c,d);if(ol.ENABLE_PROJ4JS&&!e){var f=ol.proj.proj4.get();if("function"==typeof f){var g=f.defs(c),h=f.defs(d);void 0!==g&&void 0!==h&&(g===h?ol.proj.addEquivalentProjections([b,a]):(e=f(d,c),ol.proj.addCoordinateTransforms(b,a,e.forward,e.inverse)),e=ol.proj.transforms.get(c,d))}}e||(e=ol.proj.identityTransform);return e};
ol.proj.identityTransform=function(a,b,c){if(void 0!==b&&a!==b){c=0;for(var d=a.length;c<d;++c)b[c]=a[c];a=b}return a};ol.proj.cloneTransform=function(a,b,c){if(void 0!==b){c=0;for(var d=a.length;c<d;++c)b[c]=a[c];a=b}else a=a.slice();return a};ol.proj.transform=function(a,b,c){return ol.proj.getTransform(b,c)(a,void 0,a.length)};ol.proj.transformExtent=function(a,b,c){b=ol.proj.getTransform(b,c);return ol.extent.applyTransform(a,b)};
ol.proj.transformWithProjections=function(a,b,c){return ol.proj.getTransformFromProjections(b,c)(a)};ol.proj.addCommon=function(){ol.proj.addEquivalentProjections(ol.proj.EPSG3857.PROJECTIONS);ol.proj.addEquivalentProjections(ol.proj.EPSG4326.PROJECTIONS);ol.proj.addEquivalentTransforms(ol.proj.EPSG4326.PROJECTIONS,ol.proj.EPSG3857.PROJECTIONS,ol.proj.EPSG3857.fromEPSG4326,ol.proj.EPSG3857.toEPSG4326)};ol.proj.addCommon();ol.array={};ol.array.binarySearch=function(a,b,c){for(var d,e=c||ol.array.numberSafeCompareFunction,f=0,g=a.length,h=!1;f<g;)c=f+(g-f>>1),d=+e(a[c],b),0>d?f=c+1:(g=c,h=!d);return h?f:~f};ol.array.numberSafeCompareFunction=function(a,b){return a>b?1:a<b?-1:0};ol.array.includes=function(a,b){return 0<=a.indexOf(b)};
ol.array.linearFindNearest=function(a,b,c){var d=a.length;if(a[0]<=b)return 0;if(!(b<=a[d-1]))if(0<c)for(c=1;c<d;++c){if(a[c]<b)return c-1}else if(0>c)for(c=1;c<d;++c){if(a[c]<=b)return c}else for(c=1;c<d;++c){if(a[c]==b)return c;if(a[c]<b)return a[c-1]-b<b-a[c]?c-1:c}return d-1};ol.array.reverseSubArray=function(a,b,c){for(;b<c;){var d=a[b];a[b]=a[c];a[c]=d;++b;--c}};ol.array.extend=function(a,b){var c=Array.isArray(b)?b:[b],d=c.length;for(b=0;b<d;b++)a[a.length]=c[b]};
ol.array.remove=function(a,b){b=a.indexOf(b);var c=-1<b;c&&a.splice(b,1);return c};ol.array.find=function(a,b){for(var c=a.length>>>0,d,e=0;e<c;e++)if(d=a[e],b(d,e,a))return d;return null};ol.array.equals=function(a,b){var c=a.length;if(c!==b.length)return!1;for(var d=0;d<c;d++)if(a[d]!==b[d])return!1;return!0};
ol.array.stableSort=function(a,b){var c=a.length,d=Array(a.length),e;for(e=0;e<c;e++)d[e]={index:e,value:a[e]};d.sort(function(a,c){return b(a.value,c.value)||a.index-c.index});for(e=0;e<a.length;e++)a[e]=d[e].value};ol.array.findIndex=function(a,b){var c;return a.every(function(d,e){c=e;return!b(d,e,a)})?-1:c};ol.array.isSorted=function(a,b,c){var d=b||ol.array.numberSafeCompareFunction;return a.every(function(b,f){if(0===f)return!0;b=d(a[f-1],b);return!(0<b||c&&0===b)})};ol.tilecoord={};ol.tilecoord.createOrUpdate=function(a,b,c,d){return void 0!==d?(d[0]=a,d[1]=b,d[2]=c,d):[a,b,c]};ol.tilecoord.getKeyZXY=function(a,b,c){return a+"/"+b+"/"+c};ol.tilecoord.getKey=function(a){return ol.tilecoord.getKeyZXY(a[0],a[1],a[2])};ol.tilecoord.fromKey=function(a){return a.split("/").map(Number)};ol.tilecoord.hash=function(a){return(a[1]<<a[0])+a[2]};
ol.tilecoord.quadKey=function(a){var b=a[0],c=Array(b),d=1<<b-1,e;for(e=0;e<b;++e){var f=48;a[1]&d&&(f+=1);a[2]&d&&(f+=2);c[e]=String.fromCharCode(f);d>>=1}return c.join("")};ol.tilecoord.withinExtentAndZ=function(a,b){var c=a[0],d=a[1];a=a[2];if(b.getMinZoom()>c||c>b.getMaxZoom())return!1;var e=b.getExtent();return(b=e?b.getTileRangeForExtentAndZ(e,c):b.getFullTileRange(c))?b.containsXY(d,a):!0};ol.tilegrid={};
ol.tilegrid.TileGrid=function(a){this.minZoom=void 0!==a.minZoom?a.minZoom:0;this.resolutions_=a.resolutions;ol.asserts.assert(ol.array.isSorted(this.resolutions_,function(a,b){return b-a},!0),17);if(!a.origins)for(var b=0,c=this.resolutions_.length-1;b<c;++b)if(!d)var d=this.resolutions_[b]/this.resolutions_[b+1];else if(this.resolutions_[b]/this.resolutions_[b+1]!==d){d=void 0;break}this.zoomFactor_=d;this.maxZoom=this.resolutions_.length-1;this.origin_=void 0!==a.origin?a.origin:null;this.origins_=
null;void 0!==a.origins&&(this.origins_=a.origins,ol.asserts.assert(this.origins_.length==this.resolutions_.length,20));d=a.extent;void 0===d||this.origin_||this.origins_||(this.origin_=ol.extent.getTopLeft(d));ol.asserts.assert(!this.origin_&&this.origins_||this.origin_&&!this.origins_,18);this.tileSizes_=null;void 0!==a.tileSizes&&(this.tileSizes_=a.tileSizes,ol.asserts.assert(this.tileSizes_.length==this.resolutions_.length,19));this.tileSize_=void 0!==a.tileSize?a.tileSize:this.tileSizes_?null:
ol.DEFAULT_TILE_SIZE;ol.asserts.assert(!this.tileSize_&&this.tileSizes_||this.tileSize_&&!this.tileSizes_,22);this.extent_=void 0!==d?d:null;this.fullTileRanges_=null;this.tmpSize_=[0,0];void 0!==a.sizes?this.fullTileRanges_=a.sizes.map(function(a,b){return new ol.TileRange(Math.min(0,a[0]),Math.max(a[0]-1,-1),Math.min(0,a[1]),Math.max(a[1]-1,-1))},this):d&&this.calculateTileRanges_(d)};ol.tilegrid.TileGrid.tmpTileCoord_=[0,0,0];
ol.tilegrid.TileGrid.prototype.forEachTileCoord=function(a,b,c){a=this.getTileRangeForExtentAndZ(a,b);for(var d=a.minX,e=a.maxX;d<=e;++d)for(var f=a.minY,g=a.maxY;f<=g;++f)c([b,d,f])};
ol.tilegrid.TileGrid.prototype.forEachTileCoordParentTileRange=function(a,b,c,d,e){var f=null,g=a[0]-1;if(2===this.zoomFactor_){var h=a[1];var k=a[2]}else f=this.getTileCoordExtent(a,e);for(;g>=this.minZoom;){2===this.zoomFactor_?(h=Math.floor(h/2),k=Math.floor(k/2),a=ol.TileRange.createOrUpdate(h,h,k,k,d)):a=this.getTileRangeForExtentAndZ(f,g,d);if(b.call(c,g,a))return!0;--g}return!1};ol.tilegrid.TileGrid.prototype.getExtent=function(){return this.extent_};
ol.tilegrid.TileGrid.prototype.getMaxZoom=function(){return this.maxZoom};ol.tilegrid.TileGrid.prototype.getMinZoom=function(){return this.minZoom};ol.tilegrid.TileGrid.prototype.getOrigin=function(a){return this.origin_?this.origin_:this.origins_[a]};ol.tilegrid.TileGrid.prototype.getResolution=function(a){return this.resolutions_[a]};ol.tilegrid.TileGrid.prototype.getResolutions=function(){return this.resolutions_};
ol.tilegrid.TileGrid.prototype.getTileCoordChildTileRange=function(a,b,c){if(a[0]<this.maxZoom){if(2===this.zoomFactor_)return c=2*a[1],a=2*a[2],ol.TileRange.createOrUpdate(c,c+1,a,a+1,b);c=this.getTileCoordExtent(a,c);return this.getTileRangeForExtentAndZ(c,a[0]+1,b)}return null};
ol.tilegrid.TileGrid.prototype.getTileRangeExtent=function(a,b,c){var d=this.getOrigin(a),e=this.getResolution(a);a=ol.size.toSize(this.getTileSize(a),this.tmpSize_);return ol.extent.createOrUpdate(d[0]+b.minX*a[0]*e,d[1]+b.minY*a[1]*e,d[0]+(b.maxX+1)*a[0]*e,d[1]+(b.maxY+1)*a[1]*e,c)};
ol.tilegrid.TileGrid.prototype.getTileRangeForExtentAndZ=function(a,b,c){var d=ol.tilegrid.TileGrid.tmpTileCoord_;this.getTileCoordForXYAndZ_(a[0],a[1],b,!1,d);var e=d[1],f=d[2];this.getTileCoordForXYAndZ_(a[2],a[3],b,!0,d);return ol.TileRange.createOrUpdate(e,d[1],f,d[2],c)};ol.tilegrid.TileGrid.prototype.getTileCoordCenter=function(a){var b=this.getOrigin(a[0]),c=this.getResolution(a[0]),d=ol.size.toSize(this.getTileSize(a[0]),this.tmpSize_);return[b[0]+(a[1]+.5)*d[0]*c,b[1]+(a[2]+.5)*d[1]*c]};
ol.tilegrid.TileGrid.prototype.getTileCoordExtent=function(a,b){var c=this.getOrigin(a[0]),d=this.getResolution(a[0]),e=ol.size.toSize(this.getTileSize(a[0]),this.tmpSize_),f=c[0]+a[1]*e[0]*d;a=c[1]+a[2]*e[1]*d;return ol.extent.createOrUpdate(f,a,f+e[0]*d,a+e[1]*d,b)};ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution=function(a,b,c){return this.getTileCoordForXYAndResolution_(a[0],a[1],b,!1,c)};
ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndResolution_=function(a,b,c,d,e){var f=this.getZForResolution(c),g=c/this.getResolution(f),h=this.getOrigin(f),k=ol.size.toSize(this.getTileSize(f),this.tmpSize_);a=g*Math.floor((a-h[0])/c+(d?.5:0))/k[0];b=g*Math.floor((b-h[1])/c+(d?0:.5))/k[1];d?(a=Math.ceil(a)-1,b=Math.ceil(b)-1):(a=Math.floor(a),b=Math.floor(b));return ol.tilecoord.createOrUpdate(f,a,b,e)};
ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndZ_=function(a,b,c,d,e){var f=this.getOrigin(c),g=this.getResolution(c),h=ol.size.toSize(this.getTileSize(c),this.tmpSize_);a=Math.floor((a-f[0])/g+(d?.5:0))/h[0];b=Math.floor((b-f[1])/g+(d?0:.5))/h[1];d?(a=Math.ceil(a)-1,b=Math.ceil(b)-1):(a=Math.floor(a),b=Math.floor(b));return ol.tilecoord.createOrUpdate(c,a,b,e)};ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ=function(a,b,c){return this.getTileCoordForXYAndZ_(a[0],a[1],b,!1,c)};
ol.tilegrid.TileGrid.prototype.getTileCoordResolution=function(a){return this.resolutions_[a[0]]};ol.tilegrid.TileGrid.prototype.getTileSize=function(a){return this.tileSize_?this.tileSize_:this.tileSizes_[a]};ol.tilegrid.TileGrid.prototype.getFullTileRange=function(a){return this.fullTileRanges_?this.fullTileRanges_[a]:null};ol.tilegrid.TileGrid.prototype.getZForResolution=function(a,b){a=ol.array.linearFindNearest(this.resolutions_,a,b||0);return ol.math.clamp(a,this.minZoom,this.maxZoom)};
ol.tilegrid.TileGrid.prototype.calculateTileRanges_=function(a){for(var b=this.resolutions_.length,c=Array(b),d=this.minZoom;d<b;++d)c[d]=this.getTileRangeForExtentAndZ(a,d);this.fullTileRanges_=c};ol.tilegrid.getForProjection=function(a){var b=a.getDefaultTileGrid();b||(b=ol.tilegrid.createForProjection(a),a.setDefaultTileGrid(b));return b};ol.tilegrid.wrapX=function(a,b,c){var d=b[0],e=a.getTileCoordCenter(b);c=ol.tilegrid.extentFromProjection(c);if(ol.extent.containsCoordinate(c,e))return b;b=ol.extent.getWidth(c);e[0]+=b*Math.ceil((c[0]-e[0])/b);return a.getTileCoordForCoordAndZ(e,d)};
ol.tilegrid.createForExtent=function(a,b,c,d){d=void 0!==d?d:ol.extent.Corner.TOP_LEFT;b=ol.tilegrid.resolutionsFromExtent(a,b,c);return new ol.tilegrid.TileGrid({extent:a,origin:ol.extent.getCorner(a,d),resolutions:b,tileSize:c})};ol.tilegrid.createXYZ=function(a){var b={};ol.obj.assign(b,void 0!==a?a:{});void 0===b.extent&&(b.extent=ol.proj.get("EPSG:3857").getExtent());b.resolutions=ol.tilegrid.resolutionsFromExtent(b.extent,b.maxZoom,b.tileSize);delete b.maxZoom;return new ol.tilegrid.TileGrid(b)};
ol.tilegrid.resolutionsFromExtent=function(a,b,c){b=void 0!==b?b:ol.DEFAULT_MAX_ZOOM;var d=ol.extent.getHeight(a);a=ol.extent.getWidth(a);c=ol.size.toSize(void 0!==c?c:ol.DEFAULT_TILE_SIZE);c=Math.max(a/c[0],d/c[1]);b+=1;d=Array(b);for(a=0;a<b;++a)d[a]=c/Math.pow(2,a);return d};ol.tilegrid.createForProjection=function(a,b,c,d){a=ol.tilegrid.extentFromProjection(a);return ol.tilegrid.createForExtent(a,b,c,d)};
ol.tilegrid.extentFromProjection=function(a){a=ol.proj.get(a);var b=a.getExtent();b||(a=180*ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES]/a.getMetersPerUnit(),b=ol.extent.createOrUpdate(-a,-a,a,a));return b};ol.Attribution=function(a){this.html_=a.html;this.tileRanges_=a.tileRanges?a.tileRanges:null};ol.Attribution.prototype.getHTML=function(){return this.html_};
ol.Attribution.prototype.intersectsAnyTileRange=function(a,b,c){if(!this.tileRanges_)return!0;var d,e;for(e in a)if(e in this.tileRanges_){var f=a[e];var g=0;for(d=this.tileRanges_[e].length;g<d;++g){var h=this.tileRanges_[e][g];if(h.intersects(f))return!0;var k=b.getTileRangeForExtentAndZ(ol.tilegrid.extentFromProjection(c),parseInt(e,10)),l=k.getWidth();if(f.minX<k.minX||f.maxX>k.maxX)if(h.intersects(new ol.TileRange(ol.math.modulo(f.minX,l),ol.math.modulo(f.maxX,l),f.minY,f.maxY))||f.getWidth()>
l&&h.intersects(k))return!0}}return!1};ol.CollectionEventType={ADD:"add",REMOVE:"remove"};ol.ObjectEventType={PROPERTYCHANGE:"propertychange"};ol.events={};ol.events.bindListener_=function(a){var b=function(b){var c=a.listener,e=a.bindTo||a.target;a.callOnce&&ol.events.unlistenByKey(a);return c.call(e,b)};return a.boundListener=b};ol.events.findListener_=function(a,b,c,d){for(var e,f=0,g=a.length;f<g;++f)if(e=a[f],e.listener===b&&e.bindTo===c)return d&&(e.deleteIndex=f),e};ol.events.getListeners=function(a,b){return(a=a.ol_lm)?a[b]:void 0};ol.events.getListenerMap_=function(a){var b=a.ol_lm;b||(b=a.ol_lm={});return b};
ol.events.removeListeners_=function(a,b){var c=ol.events.getListeners(a,b);if(c){for(var d=0,e=c.length;d<e;++d)a.removeEventListener(b,c[d].boundListener),ol.obj.clear(c[d]);c.length=0;if(c=a.ol_lm)delete c[b],0===Object.keys(c).length&&delete a.ol_lm}};
ol.events.listen=function(a,b,c,d,e){var f=ol.events.getListenerMap_(a),g=f[b];g||(g=f[b]=[]);(f=ol.events.findListener_(g,c,d,!1))?e||(f.callOnce=!1):(f={bindTo:d,callOnce:!!e,listener:c,target:a,type:b},a.addEventListener(b,ol.events.bindListener_(f)),g.push(f));return f};ol.events.listenOnce=function(a,b,c,d){return ol.events.listen(a,b,c,d,!0)};ol.events.unlisten=function(a,b,c,d){(a=ol.events.getListeners(a,b))&&(c=ol.events.findListener_(a,c,d,!0))&&ol.events.unlistenByKey(c)};
ol.events.unlistenByKey=function(a){if(a&&a.target){a.target.removeEventListener(a.type,a.boundListener);var b=ol.events.getListeners(a.target,a.type);if(b){var c="deleteIndex"in a?a.deleteIndex:b.indexOf(a);-1!==c&&b.splice(c,1);0===b.length&&ol.events.removeListeners_(a.target,a.type)}ol.obj.clear(a)}};ol.events.unlistenAll=function(a){var b=ol.events.getListenerMap_(a),c;for(c in b)ol.events.removeListeners_(a,c)};ol.Disposable=function(){};ol.Disposable.prototype.disposed_=!1;ol.Disposable.prototype.dispose=function(){this.disposed_||(this.disposed_=!0,this.disposeInternal())};ol.Disposable.prototype.disposeInternal=ol.nullFunction;ol.events.Event=function(a){this.type=a;this.target=null};ol.events.Event.prototype.preventDefault=ol.events.Event.prototype.stopPropagation=function(){this.propagationStopped=!0};ol.events.Event.stopPropagation=function(a){a.stopPropagation()};ol.events.Event.preventDefault=function(a){a.preventDefault()};ol.events.EventTarget=function(){ol.Disposable.call(this);this.pendingRemovals_={};this.dispatching_={};this.listeners_={}};ol.inherits(ol.events.EventTarget,ol.Disposable);ol.events.EventTarget.prototype.addEventListener=function(a,b){var c=this.listeners_[a];c||(c=this.listeners_[a]=[]);-1===c.indexOf(b)&&c.push(b)};
ol.events.EventTarget.prototype.dispatchEvent=function(a){var b="string"===typeof a?new ol.events.Event(a):a;a=b.type;b.target=this;var c=this.listeners_[a];if(c){a in this.dispatching_||(this.dispatching_[a]=0,this.pendingRemovals_[a]=0);++this.dispatching_[a];for(var d=0,e=c.length;d<e;++d)if(!1===c[d].call(this,b)||b.propagationStopped){var f=!1;break}--this.dispatching_[a];if(0===this.dispatching_[a]){b=this.pendingRemovals_[a];for(delete this.pendingRemovals_[a];b--;)this.removeEventListener(a,
ol.nullFunction);delete this.dispatching_[a]}return f}};ol.events.EventTarget.prototype.disposeInternal=function(){ol.events.unlistenAll(this)};ol.events.EventTarget.prototype.getListeners=function(a){return this.listeners_[a]};ol.events.EventTarget.prototype.hasListener=function(a){return a?a in this.listeners_:0<Object.keys(this.listeners_).length};
ol.events.EventTarget.prototype.removeEventListener=function(a,b){var c=this.listeners_[a];c&&(b=c.indexOf(b),a in this.pendingRemovals_?(c[b]=ol.nullFunction,++this.pendingRemovals_[a]):(c.splice(b,1),0===c.length&&delete this.listeners_[a]))};ol.events.EventType={CHANGE:"change",CLEAR:"clear",CLICK:"click",DBLCLICK:"dblclick",DRAGENTER:"dragenter",DRAGOVER:"dragover",DROP:"drop",ERROR:"error",KEYDOWN:"keydown",KEYPRESS:"keypress",LOAD:"load",MOUSEDOWN:"mousedown",MOUSEMOVE:"mousemove",MOUSEOUT:"mouseout",MOUSEUP:"mouseup",MOUSEWHEEL:"mousewheel",MSPOINTERDOWN:"MSPointerDown",RESIZE:"resize",TOUCHSTART:"touchstart",TOUCHMOVE:"touchmove",TOUCHEND:"touchend",WHEEL:"wheel"};ol.Observable=function(){ol.events.EventTarget.call(this);this.revision_=0};ol.inherits(ol.Observable,ol.events.EventTarget);ol.Observable.unByKey=function(a){if(Array.isArray(a))for(var b=0,c=a.length;b<c;++b)ol.events.unlistenByKey(a[b]);else ol.events.unlistenByKey(a)};ol.Observable.prototype.changed=function(){++this.revision_;this.dispatchEvent(ol.events.EventType.CHANGE)};ol.Observable.prototype.getRevision=function(){return this.revision_};
ol.Observable.prototype.on=function(a,b,c){if(Array.isArray(a)){for(var d=a.length,e=Array(d),f=0;f<d;++f)e[f]=ol.events.listen(this,a[f],b,c);return e}return ol.events.listen(this,a,b,c)};ol.Observable.prototype.once=function(a,b,c){if(Array.isArray(a)){for(var d=a.length,e=Array(d),f=0;f<d;++f)e[f]=ol.events.listenOnce(this,a[f],b,c);return e}return ol.events.listenOnce(this,a,b,c)};
ol.Observable.prototype.un=function(a,b,c){if(Array.isArray(a))for(var d=0,e=a.length;d<e;++d)ol.events.unlisten(this,a[d],b,c);else ol.events.unlisten(this,a,b,c)};ol.Object=function(a){ol.Observable.call(this);ol.getUid(this);this.values_={};void 0!==a&&this.setProperties(a)};ol.inherits(ol.Object,ol.Observable);ol.Object.changeEventTypeCache_={};ol.Object.getChangeEventType=function(a){return ol.Object.changeEventTypeCache_.hasOwnProperty(a)?ol.Object.changeEventTypeCache_[a]:ol.Object.changeEventTypeCache_[a]="change:"+a};ol.Object.prototype.get=function(a){var b;this.values_.hasOwnProperty(a)&&(b=this.values_[a]);return b};ol.Object.prototype.getKeys=function(){return Object.keys(this.values_)};
ol.Object.prototype.getProperties=function(){return ol.obj.assign({},this.values_)};ol.Object.prototype.notify=function(a,b){var c=ol.Object.getChangeEventType(a);this.dispatchEvent(new ol.Object.Event(c,a,b));c=ol.ObjectEventType.PROPERTYCHANGE;this.dispatchEvent(new ol.Object.Event(c,a,b))};ol.Object.prototype.set=function(a,b,c){c?this.values_[a]=b:(c=this.values_[a],this.values_[a]=b,c!==b&&this.notify(a,c))};ol.Object.prototype.setProperties=function(a,b){for(var c in a)this.set(c,a[c],b)};
ol.Object.prototype.unset=function(a,b){if(a in this.values_){var c=this.values_[a];delete this.values_[a];b||this.notify(a,c)}};ol.Object.Event=function(a,b,c){ol.events.Event.call(this,a);this.key=b;this.oldValue=c};ol.inherits(ol.Object.Event,ol.events.Event);ol.Collection=function(a,b){ol.Object.call(this);this.unique_=!!(b||{}).unique;this.array_=a?a:[];if(this.unique_)for(a=0,b=this.array_.length;a<b;++a)this.assertUnique_(this.array_[a],a);this.updateLength_()};ol.inherits(ol.Collection,ol.Object);ol.Collection.prototype.clear=function(){for(;0<this.getLength();)this.pop()};ol.Collection.prototype.extend=function(a){var b;var c=0;for(b=a.length;c<b;++c)this.push(a[c]);return this};
ol.Collection.prototype.forEach=function(a,b){a=b?a.bind(b):a;b=this.array_;for(var c=0,d=b.length;c<d;++c)a(b[c],c,b)};ol.Collection.prototype.getArray=function(){return this.array_};ol.Collection.prototype.item=function(a){return this.array_[a]};ol.Collection.prototype.getLength=function(){return this.get(ol.Collection.Property_.LENGTH)};
ol.Collection.prototype.insertAt=function(a,b){this.unique_&&this.assertUnique_(b);this.array_.splice(a,0,b);this.updateLength_();this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.ADD,b))};ol.Collection.prototype.pop=function(){return this.removeAt(this.getLength()-1)};ol.Collection.prototype.push=function(a){this.unique_&&this.assertUnique_(a);var b=this.getLength();this.insertAt(b,a);return this.getLength()};
ol.Collection.prototype.remove=function(a){var b=this.array_,c;var d=0;for(c=b.length;d<c;++d)if(b[d]===a)return this.removeAt(d)};ol.Collection.prototype.removeAt=function(a){var b=this.array_[a];this.array_.splice(a,1);this.updateLength_();this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.REMOVE,b));return b};
ol.Collection.prototype.setAt=function(a,b){var c=this.getLength();if(a<c)this.unique_&&this.assertUnique_(b,a),c=this.array_[a],this.array_[a]=b,this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.REMOVE,c)),this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.ADD,b));else{for(;c<a;++c)this.insertAt(c,void 0);this.insertAt(a,b)}};ol.Collection.prototype.updateLength_=function(){this.set(ol.Collection.Property_.LENGTH,this.array_.length)};
ol.Collection.prototype.assertUnique_=function(a,b){for(var c=0,d=this.array_.length;c<d;++c)if(this.array_[c]===a&&c!==b)throw new ol.AssertionError(58);};ol.Collection.Property_={LENGTH:"length"};ol.Collection.Event=function(a,b){ol.events.Event.call(this,a);this.element=b};ol.inherits(ol.Collection.Event,ol.events.Event);ol.MapEvent=function(a,b,c){ol.events.Event.call(this,a);this.map=b;this.frameState=void 0!==c?c:null};ol.inherits(ol.MapEvent,ol.events.Event);ol.MapBrowserEvent=function(a,b,c,d,e){ol.MapEvent.call(this,a,b,e);this.originalEvent=c;this.pixel=b.getEventPixel(c);this.coordinate=b.getCoordinateFromPixel(this.pixel);this.dragging=void 0!==d?d:!1};ol.inherits(ol.MapBrowserEvent,ol.MapEvent);ol.MapBrowserEvent.prototype.preventDefault=function(){ol.MapEvent.prototype.preventDefault.call(this);this.originalEvent.preventDefault()};ol.MapBrowserEvent.prototype.stopPropagation=function(){ol.MapEvent.prototype.stopPropagation.call(this);this.originalEvent.stopPropagation()};ol.webgl={};ol.webgl.ONE=1;ol.webgl.SRC_ALPHA=770;ol.webgl.COLOR_ATTACHMENT0=36064;ol.webgl.COLOR_BUFFER_BIT=16384;ol.webgl.TRIANGLES=4;ol.webgl.TRIANGLE_STRIP=5;ol.webgl.ONE_MINUS_SRC_ALPHA=771;ol.webgl.ARRAY_BUFFER=34962;ol.webgl.ELEMENT_ARRAY_BUFFER=34963;ol.webgl.STREAM_DRAW=35040;ol.webgl.STATIC_DRAW=35044;ol.webgl.DYNAMIC_DRAW=35048;ol.webgl.CULL_FACE=2884;ol.webgl.BLEND=3042;ol.webgl.STENCIL_TEST=2960;ol.webgl.DEPTH_TEST=2929;ol.webgl.SCISSOR_TEST=3089;ol.webgl.UNSIGNED_BYTE=5121;
ol.webgl.UNSIGNED_SHORT=5123;ol.webgl.UNSIGNED_INT=5125;ol.webgl.FLOAT=5126;ol.webgl.RGBA=6408;ol.webgl.FRAGMENT_SHADER=35632;ol.webgl.VERTEX_SHADER=35633;ol.webgl.LINK_STATUS=35714;ol.webgl.LINEAR=9729;ol.webgl.TEXTURE_MAG_FILTER=10240;ol.webgl.TEXTURE_MIN_FILTER=10241;ol.webgl.TEXTURE_WRAP_S=10242;ol.webgl.TEXTURE_WRAP_T=10243;ol.webgl.TEXTURE_2D=3553;ol.webgl.TEXTURE0=33984;ol.webgl.CLAMP_TO_EDGE=33071;ol.webgl.COMPILE_STATUS=35713;ol.webgl.FRAMEBUFFER=36160;
ol.webgl.CONTEXT_IDS_=["experimental-webgl","webgl","webkit-3d","moz-webgl"];ol.webgl.getContext=function(a,b){var c,d,e=ol.webgl.CONTEXT_IDS_.length;for(d=0;d<e;++d)try{if(c=a.getContext(ol.webgl.CONTEXT_IDS_[d],b))return c}catch(f){}return null};ol.has={};var ua="undefined"!==typeof navigator?navigator.userAgent.toLowerCase():"";ol.has.FIREFOX=-1!==ua.indexOf("firefox");ol.has.SAFARI=-1!==ua.indexOf("safari")&&-1==ua.indexOf("chrom");ol.has.WEBKIT=-1!==ua.indexOf("webkit")&&-1==ua.indexOf("edge");ol.has.MAC=-1!==ua.indexOf("macintosh");ol.has.DEVICE_PIXEL_RATIO=window.devicePixelRatio||1;ol.has.CANVAS_LINE_DASH=!1;
ol.has.CANVAS=ol.ENABLE_CANVAS&&function(){if(!("HTMLCanvasElement"in window))return!1;try{var a=document.createElement("CANVAS").getContext("2d");return a?(void 0!==a.setLineDash&&(ol.has.CANVAS_LINE_DASH=!0),!0):!1}catch(b){return!1}}();ol.has.DEVICE_ORIENTATION="DeviceOrientationEvent"in window;ol.has.GEOLOCATION="geolocation"in navigator;ol.has.TOUCH=ol.ASSUME_TOUCH||"ontouchstart"in window;ol.has.POINTER="PointerEvent"in window;ol.has.MSPOINTER=!!navigator.msPointerEnabled;
(function(){if(ol.ENABLE_WEBGL){var a=!1,b=[];if("WebGLRenderingContext"in window)try{var c=document.createElement("CANVAS"),d=ol.webgl.getContext(c,{failIfMajorPerformanceCaveat:!0});if(d){a=!0;var e=d.getParameter(d.MAX_TEXTURE_SIZE);b=d.getSupportedExtensions()}}catch(f){}ol.has.WEBGL=a;ol.WEBGL_EXTENSIONS=b;ol.WEBGL_MAX_TEXTURE_SIZE=e}})();ol.MapBrowserEventType={SINGLECLICK:"singleclick",CLICK:ol.events.EventType.CLICK,DBLCLICK:ol.events.EventType.DBLCLICK,POINTERDRAG:"pointerdrag",POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"};ol.MapBrowserPointerEvent=function(a,b,c,d,e){ol.MapBrowserEvent.call(this,a,b,c.originalEvent,d,e);this.pointerEvent=c};ol.inherits(ol.MapBrowserPointerEvent,ol.MapBrowserEvent);ol.pointer={};ol.pointer.EventType={POINTERMOVE:"pointermove",POINTERDOWN:"pointerdown",POINTERUP:"pointerup",POINTEROVER:"pointerover",POINTEROUT:"pointerout",POINTERENTER:"pointerenter",POINTERLEAVE:"pointerleave",POINTERCANCEL:"pointercancel"};ol.pointer.EventSource=function(a,b){this.dispatcher=a;this.mapping_=b};ol.pointer.EventSource.prototype.getEvents=function(){return Object.keys(this.mapping_)};ol.pointer.EventSource.prototype.getHandlerForEvent=function(a){return this.mapping_[a]};ol.pointer.MouseSource=function(a){ol.pointer.EventSource.call(this,a,{mousedown:this.mousedown,mousemove:this.mousemove,mouseup:this.mouseup,mouseover:this.mouseover,mouseout:this.mouseout});this.pointerMap=a.pointerMap;this.lastTouches=[]};ol.inherits(ol.pointer.MouseSource,ol.pointer.EventSource);ol.pointer.MouseSource.POINTER_ID=1;ol.pointer.MouseSource.POINTER_TYPE="mouse";ol.pointer.MouseSource.DEDUP_DIST=25;
ol.pointer.MouseSource.prototype.isEventSimulatedFromTouch_=function(a){var b=this.lastTouches,c=a.clientX;a=a.clientY;for(var d=0,e=b.length,f;d<e&&(f=b[d]);d++){var g=Math.abs(a-f[1]);if(Math.abs(c-f[0])<=ol.pointer.MouseSource.DEDUP_DIST&&g<=ol.pointer.MouseSource.DEDUP_DIST)return!0}return!1};
ol.pointer.MouseSource.prepareEvent=function(a,b){b=b.cloneEvent(a,a);var c=b.preventDefault;b.preventDefault=function(){a.preventDefault();c()};b.pointerId=ol.pointer.MouseSource.POINTER_ID;b.isPrimary=!0;b.pointerType=ol.pointer.MouseSource.POINTER_TYPE;return b};
ol.pointer.MouseSource.prototype.mousedown=function(a){if(!this.isEventSimulatedFromTouch_(a)){ol.pointer.MouseSource.POINTER_ID.toString()in this.pointerMap&&this.cancel(a);var b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher);this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()]=a;this.dispatcher.down(b,a)}};
ol.pointer.MouseSource.prototype.mousemove=function(a){if(!this.isEventSimulatedFromTouch_(a)){var b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher);this.dispatcher.move(b,a)}};ol.pointer.MouseSource.prototype.mouseup=function(a){if(!this.isEventSimulatedFromTouch_(a)){var b=this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()];b&&b.button===a.button&&(b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher),this.dispatcher.up(b,a),this.cleanupMouse())}};
ol.pointer.MouseSource.prototype.mouseover=function(a){if(!this.isEventSimulatedFromTouch_(a)){var b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher);this.dispatcher.enterOver(b,a)}};ol.pointer.MouseSource.prototype.mouseout=function(a){if(!this.isEventSimulatedFromTouch_(a)){var b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher);this.dispatcher.leaveOut(b,a)}};
ol.pointer.MouseSource.prototype.cancel=function(a){var b=ol.pointer.MouseSource.prepareEvent(a,this.dispatcher);this.dispatcher.cancel(b,a);this.cleanupMouse()};ol.pointer.MouseSource.prototype.cleanupMouse=function(){delete this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()]};ol.pointer.MsSource=function(a){ol.pointer.EventSource.call(this,a,{MSPointerDown:this.msPointerDown,MSPointerMove:this.msPointerMove,MSPointerUp:this.msPointerUp,MSPointerOut:this.msPointerOut,MSPointerOver:this.msPointerOver,MSPointerCancel:this.msPointerCancel,MSGotPointerCapture:this.msGotPointerCapture,MSLostPointerCapture:this.msLostPointerCapture});this.pointerMap=a.pointerMap;this.POINTER_TYPES=["","unavailable","touch","pen","mouse"]};ol.inherits(ol.pointer.MsSource,ol.pointer.EventSource);
ol.pointer.MsSource.prototype.prepareEvent_=function(a){var b=a;"number"===typeof a.pointerType&&(b=this.dispatcher.cloneEvent(a,a),b.pointerType=this.POINTER_TYPES[a.pointerType]);return b};ol.pointer.MsSource.prototype.cleanup=function(a){delete this.pointerMap[a.toString()]};ol.pointer.MsSource.prototype.msPointerDown=function(a){this.pointerMap[a.pointerId.toString()]=a;var b=this.prepareEvent_(a);this.dispatcher.down(b,a)};
ol.pointer.MsSource.prototype.msPointerMove=function(a){var b=this.prepareEvent_(a);this.dispatcher.move(b,a)};ol.pointer.MsSource.prototype.msPointerUp=function(a){var b=this.prepareEvent_(a);this.dispatcher.up(b,a);this.cleanup(a.pointerId)};ol.pointer.MsSource.prototype.msPointerOut=function(a){var b=this.prepareEvent_(a);this.dispatcher.leaveOut(b,a)};ol.pointer.MsSource.prototype.msPointerOver=function(a){var b=this.prepareEvent_(a);this.dispatcher.enterOver(b,a)};
ol.pointer.MsSource.prototype.msPointerCancel=function(a){var b=this.prepareEvent_(a);this.dispatcher.cancel(b,a);this.cleanup(a.pointerId)};ol.pointer.MsSource.prototype.msLostPointerCapture=function(a){a=this.dispatcher.makeEvent("lostpointercapture",a,a);this.dispatcher.dispatchEvent(a)};ol.pointer.MsSource.prototype.msGotPointerCapture=function(a){a=this.dispatcher.makeEvent("gotpointercapture",a,a);this.dispatcher.dispatchEvent(a)};ol.pointer.NativeSource=function(a){ol.pointer.EventSource.call(this,a,{pointerdown:this.pointerDown,pointermove:this.pointerMove,pointerup:this.pointerUp,pointerout:this.pointerOut,pointerover:this.pointerOver,pointercancel:this.pointerCancel,gotpointercapture:this.gotPointerCapture,lostpointercapture:this.lostPointerCapture})};ol.inherits(ol.pointer.NativeSource,ol.pointer.EventSource);ol.pointer.NativeSource.prototype.pointerDown=function(a){this.dispatcher.fireNativeEvent(a)};
ol.pointer.NativeSource.prototype.pointerMove=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.NativeSource.prototype.pointerUp=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.NativeSource.prototype.pointerOut=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.NativeSource.prototype.pointerOver=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.NativeSource.prototype.pointerCancel=function(a){this.dispatcher.fireNativeEvent(a)};
ol.pointer.NativeSource.prototype.lostPointerCapture=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.NativeSource.prototype.gotPointerCapture=function(a){this.dispatcher.fireNativeEvent(a)};ol.pointer.PointerEvent=function(a,b,c){ol.events.Event.call(this,a);this.originalEvent=b;a=c?c:{};this.buttons=this.getButtons_(a);this.pressure=this.getPressure_(a,this.buttons);this.bubbles="bubbles"in a?a.bubbles:!1;this.cancelable="cancelable"in a?a.cancelable:!1;this.view="view"in a?a.view:null;this.detail="detail"in a?a.detail:null;this.screenX="screenX"in a?a.screenX:0;this.screenY="screenY"in a?a.screenY:0;this.clientX="clientX"in a?a.clientX:0;this.clientY="clientY"in a?a.clientY:0;this.ctrlKey=
"ctrlKey"in a?a.ctrlKey:!1;this.altKey="altKey"in a?a.altKey:!1;this.shiftKey="shiftKey"in a?a.shiftKey:!1;this.metaKey="metaKey"in a?a.metaKey:!1;this.button="button"in a?a.button:0;this.relatedTarget="relatedTarget"in a?a.relatedTarget:null;this.pointerId="pointerId"in a?a.pointerId:0;this.width="width"in a?a.width:0;this.height="height"in a?a.height:0;this.tiltX="tiltX"in a?a.tiltX:0;this.tiltY="tiltY"in a?a.tiltY:0;this.pointerType="pointerType"in a?a.pointerType:"";this.hwTimestamp="hwTimestamp"in
a?a.hwTimestamp:0;this.isPrimary="isPrimary"in a?a.isPrimary:!1;b.preventDefault&&(this.preventDefault=function(){b.preventDefault()})};ol.inherits(ol.pointer.PointerEvent,ol.events.Event);ol.pointer.PointerEvent.prototype.getButtons_=function(a){if(a.buttons||ol.pointer.PointerEvent.HAS_BUTTONS)a=a.buttons;else switch(a.which){case 1:a=1;break;case 2:a=4;break;case 3:a=2;break;default:a=0}return a};ol.pointer.PointerEvent.prototype.getPressure_=function(a,b){return a.pressure?a.pressure:b?.5:0};
ol.pointer.PointerEvent.HAS_BUTTONS=!1;(function(){try{var a=new MouseEvent("click",{buttons:1});ol.pointer.PointerEvent.HAS_BUTTONS=1===a.buttons}catch(b){}})();ol.pointer.TouchSource=function(a,b){ol.pointer.EventSource.call(this,a,{touchstart:this.touchstart,touchmove:this.touchmove,touchend:this.touchend,touchcancel:this.touchcancel});this.pointerMap=a.pointerMap;this.mouseSource=b;this.firstTouchId_=void 0;this.clickCount_=0;this.resetId_=void 0};ol.inherits(ol.pointer.TouchSource,ol.pointer.EventSource);ol.pointer.TouchSource.DEDUP_TIMEOUT=2500;ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT=200;ol.pointer.TouchSource.POINTER_TYPE="touch";
ol.pointer.TouchSource.prototype.isPrimaryTouch_=function(a){return this.firstTouchId_===a.identifier};ol.pointer.TouchSource.prototype.setPrimaryTouch_=function(a){var b=Object.keys(this.pointerMap).length;if(0===b||1===b&&ol.pointer.MouseSource.POINTER_ID.toString()in this.pointerMap)this.firstTouchId_=a.identifier,this.cancelResetClickCount_()};ol.pointer.TouchSource.prototype.removePrimaryPointer_=function(a){a.isPrimary&&(this.firstTouchId_=void 0,this.resetClickCount_())};
ol.pointer.TouchSource.prototype.resetClickCount_=function(){this.resetId_=setTimeout(this.resetClickCountHandler_.bind(this),ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT)};ol.pointer.TouchSource.prototype.resetClickCountHandler_=function(){this.clickCount_=0;this.resetId_=void 0};ol.pointer.TouchSource.prototype.cancelResetClickCount_=function(){void 0!==this.resetId_&&clearTimeout(this.resetId_)};
ol.pointer.TouchSource.prototype.touchToPointer_=function(a,b){a=this.dispatcher.cloneEvent(a,b);a.pointerId=b.identifier+2;a.bubbles=!0;a.cancelable=!0;a.detail=this.clickCount_;a.button=0;a.buttons=1;a.width=b.webkitRadiusX||b.radiusX||0;a.height=b.webkitRadiusY||b.radiusY||0;a.pressure=b.webkitForce||b.force||.5;a.isPrimary=this.isPrimaryTouch_(b);a.pointerType=ol.pointer.TouchSource.POINTER_TYPE;a.clientX=b.clientX;a.clientY=b.clientY;a.screenX=b.screenX;a.screenY=b.screenY;return a};
ol.pointer.TouchSource.prototype.processTouches_=function(a,b){function c(){a.preventDefault()}var d=Array.prototype.slice.call(a.changedTouches),e=d.length,f;for(f=0;f<e;++f){var g=this.touchToPointer_(a,d[f]);g.preventDefault=c;b.call(this,a,g)}};ol.pointer.TouchSource.prototype.findTouch_=function(a,b){for(var c=a.length,d,e=0;e<c;e++)if(d=a[e],d.identifier===b)return!0;return!1};
ol.pointer.TouchSource.prototype.vacuumTouches_=function(a){var b=a.touches,c=Object.keys(this.pointerMap),d=c.length;if(d>=b.length){var e=[],f;for(f=0;f<d;++f){var g=c[f];var h=this.pointerMap[g];g==ol.pointer.MouseSource.POINTER_ID||this.findTouch_(b,g-2)||e.push(h.out)}for(f=0;f<e.length;++f)this.cancelOut_(a,e[f])}};
ol.pointer.TouchSource.prototype.touchstart=function(a){this.vacuumTouches_(a);this.setPrimaryTouch_(a.changedTouches[0]);this.dedupSynthMouse_(a);this.clickCount_++;this.processTouches_(a,this.overDown_)};ol.pointer.TouchSource.prototype.overDown_=function(a,b){this.pointerMap[b.pointerId]={target:b.target,out:b,outTarget:b.target};this.dispatcher.over(b,a);this.dispatcher.enter(b,a);this.dispatcher.down(b,a)};
ol.pointer.TouchSource.prototype.touchmove=function(a){a.preventDefault();this.processTouches_(a,this.moveOverOut_)};ol.pointer.TouchSource.prototype.moveOverOut_=function(a,b){var c=this.pointerMap[b.pointerId];if(c){var d=c.out,e=c.outTarget;this.dispatcher.move(b,a);d&&e!==b.target&&(d.relatedTarget=b.target,b.relatedTarget=e,d.target=e,b.target?(this.dispatcher.leaveOut(d,a),this.dispatcher.enterOver(b,a)):(b.target=e,b.relatedTarget=null,this.cancelOut_(a,b)));c.out=b;c.outTarget=b.target}};
ol.pointer.TouchSource.prototype.touchend=function(a){this.dedupSynthMouse_(a);this.processTouches_(a,this.upOut_)};ol.pointer.TouchSource.prototype.upOut_=function(a,b){this.dispatcher.up(b,a);this.dispatcher.out(b,a);this.dispatcher.leave(b,a);this.cleanUpPointer_(b)};ol.pointer.TouchSource.prototype.touchcancel=function(a){this.processTouches_(a,this.cancelOut_)};
ol.pointer.TouchSource.prototype.cancelOut_=function(a,b){this.dispatcher.cancel(b,a);this.dispatcher.out(b,a);this.dispatcher.leave(b,a);this.cleanUpPointer_(b)};ol.pointer.TouchSource.prototype.cleanUpPointer_=function(a){delete this.pointerMap[a.pointerId];this.removePrimaryPointer_(a)};
ol.pointer.TouchSource.prototype.dedupSynthMouse_=function(a){var b=this.mouseSource.lastTouches;a=a.changedTouches[0];if(this.isPrimaryTouch_(a)){var c=[a.clientX,a.clientY];b.push(c);setTimeout(function(){ol.array.remove(b,c)},ol.pointer.TouchSource.DEDUP_TIMEOUT)}};ol.pointer.PointerEventHandler=function(a){ol.events.EventTarget.call(this);this.element_=a;this.pointerMap={};this.eventMap_={};this.eventSourceList_=[];this.registerSources()};ol.inherits(ol.pointer.PointerEventHandler,ol.events.EventTarget);
ol.pointer.PointerEventHandler.prototype.registerSources=function(){if(ol.has.POINTER)this.registerSource("native",new ol.pointer.NativeSource(this));else if(ol.has.MSPOINTER)this.registerSource("ms",new ol.pointer.MsSource(this));else{var a=new ol.pointer.MouseSource(this);this.registerSource("mouse",a);ol.has.TOUCH&&this.registerSource("touch",new ol.pointer.TouchSource(this,a))}this.register_()};
ol.pointer.PointerEventHandler.prototype.registerSource=function(a,b){if(a=b.getEvents())a.forEach(function(a){var c=b.getHandlerForEvent(a);c&&(this.eventMap_[a]=c.bind(b))},this),this.eventSourceList_.push(b)};ol.pointer.PointerEventHandler.prototype.register_=function(){for(var a=this.eventSourceList_.length,b,c=0;c<a;c++)b=this.eventSourceList_[c],this.addEvents_(b.getEvents())};
ol.pointer.PointerEventHandler.prototype.unregister_=function(){for(var a=this.eventSourceList_.length,b,c=0;c<a;c++)b=this.eventSourceList_[c],this.removeEvents_(b.getEvents())};ol.pointer.PointerEventHandler.prototype.eventHandler_=function(a){var b=this.eventMap_[a.type];b&&b(a)};ol.pointer.PointerEventHandler.prototype.addEvents_=function(a){a.forEach(function(a){ol.events.listen(this.element_,a,this.eventHandler_,this)},this)};
ol.pointer.PointerEventHandler.prototype.removeEvents_=function(a){a.forEach(function(a){ol.events.unlisten(this.element_,a,this.eventHandler_,this)},this)};ol.pointer.PointerEventHandler.prototype.cloneEvent=function(a,b){for(var c={},d,e=0,f=ol.pointer.PointerEventHandler.CLONE_PROPS.length;e<f;e++)d=ol.pointer.PointerEventHandler.CLONE_PROPS[e][0],c[d]=a[d]||b[d]||ol.pointer.PointerEventHandler.CLONE_PROPS[e][1];return c};
ol.pointer.PointerEventHandler.prototype.down=function(a,b){this.fireEvent(ol.pointer.EventType.POINTERDOWN,a,b)};ol.pointer.PointerEventHandler.prototype.move=function(a,b){this.fireEvent(ol.pointer.EventType.POINTERMOVE,a,b)};ol.pointer.PointerEventHandler.prototype.up=function(a,b){this.fireEvent(ol.pointer.EventType.POINTERUP,a,b)};ol.pointer.PointerEventHandler.prototype.enter=function(a,b){a.bubbles=!1;this.fireEvent(ol.pointer.EventType.POINTERENTER,a,b)};
ol.pointer.PointerEventHandler.prototype.leave=function(a,b){a.bubbles=!1;this.fireEvent(ol.pointer.EventType.POINTERLEAVE,a,b)};ol.pointer.PointerEventHandler.prototype.over=function(a,b){a.bubbles=!0;this.fireEvent(ol.pointer.EventType.POINTEROVER,a,b)};ol.pointer.PointerEventHandler.prototype.out=function(a,b){a.bubbles=!0;this.fireEvent(ol.pointer.EventType.POINTEROUT,a,b)};ol.pointer.PointerEventHandler.prototype.cancel=function(a,b){this.fireEvent(ol.pointer.EventType.POINTERCANCEL,a,b)};
ol.pointer.PointerEventHandler.prototype.leaveOut=function(a,b){this.out(a,b);this.contains_(a.target,a.relatedTarget)||this.leave(a,b)};ol.pointer.PointerEventHandler.prototype.enterOver=function(a,b){this.over(a,b);this.contains_(a.target,a.relatedTarget)||this.enter(a,b)};ol.pointer.PointerEventHandler.prototype.contains_=function(a,b){return a&&b?a.contains(b):!1};ol.pointer.PointerEventHandler.prototype.makeEvent=function(a,b,c){return new ol.pointer.PointerEvent(a,c,b)};
ol.pointer.PointerEventHandler.prototype.fireEvent=function(a,b,c){a=this.makeEvent(a,b,c);this.dispatchEvent(a)};ol.pointer.PointerEventHandler.prototype.fireNativeEvent=function(a){a=this.makeEvent(a.type,a,a);this.dispatchEvent(a)};ol.pointer.PointerEventHandler.prototype.wrapMouseEvent=function(a,b){return this.makeEvent(a,ol.pointer.MouseSource.prepareEvent(b,this),b)};ol.pointer.PointerEventHandler.prototype.disposeInternal=function(){this.unregister_();ol.events.EventTarget.prototype.disposeInternal.call(this)};
ol.pointer.PointerEventHandler.CLONE_PROPS=[["bubbles",!1],["cancelable",!1],["view",null],["detail",null],["screenX",0],["screenY",0],["clientX",0],["clientY",0],["ctrlKey",!1],["altKey",!1],["shiftKey",!1],["metaKey",!1],["button",0],["relatedTarget",null],["buttons",0],["pointerId",0],["width",0],["height",0],["pressure",0],["tiltX",0],["tiltY",0],["pointerType",""],["hwTimestamp",0],["isPrimary",!1],["type",""],["target",null],["currentTarget",null],["which",0]];ol.MapBrowserEventHandler=function(a,b){ol.events.EventTarget.call(this);this.map_=a;this.clickTimeoutId_=0;this.dragging_=!1;this.dragListenerKeys_=[];this.moveTolerance_=b?b*ol.has.DEVICE_PIXEL_RATIO:ol.has.DEVICE_PIXEL_RATIO;this.down_=null;a=this.map_.getViewport();this.activePointers_=0;this.trackedTouches_={};this.pointerEventHandler_=new ol.pointer.PointerEventHandler(a);this.documentPointerEventHandler_=null;this.pointerdownListenerKey_=ol.events.listen(this.pointerEventHandler_,ol.pointer.EventType.POINTERDOWN,
this.handlePointerDown_,this);this.relayedListenerKey_=ol.events.listen(this.pointerEventHandler_,ol.pointer.EventType.POINTERMOVE,this.relayEvent_,this)};ol.inherits(ol.MapBrowserEventHandler,ol.events.EventTarget);
ol.MapBrowserEventHandler.prototype.emulateClick_=function(a){var b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.CLICK,this.map_,a);this.dispatchEvent(b);0!==this.clickTimeoutId_?(clearTimeout(this.clickTimeoutId_),this.clickTimeoutId_=0,b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.DBLCLICK,this.map_,a),this.dispatchEvent(b)):this.clickTimeoutId_=setTimeout(function(){this.clickTimeoutId_=0;var b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.SINGLECLICK,this.map_,a);this.dispatchEvent(b)}.bind(this),
250)};ol.MapBrowserEventHandler.prototype.updateActivePointers_=function(a){a.type==ol.MapBrowserEventType.POINTERUP||a.type==ol.MapBrowserEventType.POINTERCANCEL?delete this.trackedTouches_[a.pointerId]:a.type==ol.MapBrowserEventType.POINTERDOWN&&(this.trackedTouches_[a.pointerId]=!0);this.activePointers_=Object.keys(this.trackedTouches_).length};
ol.MapBrowserEventHandler.prototype.handlePointerUp_=function(a){this.updateActivePointers_(a);var b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERUP,this.map_,a);this.dispatchEvent(b);b.propagationStopped||this.dragging_||!this.isMouseActionButton_(a)||this.emulateClick_(this.down_);0===this.activePointers_&&(this.dragListenerKeys_.forEach(ol.events.unlistenByKey),this.dragListenerKeys_.length=0,this.dragging_=!1,this.down_=null,this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=
null)};ol.MapBrowserEventHandler.prototype.isMouseActionButton_=function(a){return 0===a.button};
ol.MapBrowserEventHandler.prototype.handlePointerDown_=function(a){this.updateActivePointers_(a);var b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERDOWN,this.map_,a);this.dispatchEvent(b);this.down_=a;0===this.dragListenerKeys_.length&&(this.documentPointerEventHandler_=new ol.pointer.PointerEventHandler(document),this.dragListenerKeys_.push(ol.events.listen(this.documentPointerEventHandler_,ol.MapBrowserEventType.POINTERMOVE,this.handlePointerMove_,this),ol.events.listen(this.documentPointerEventHandler_,
ol.MapBrowserEventType.POINTERUP,this.handlePointerUp_,this),ol.events.listen(this.pointerEventHandler_,ol.MapBrowserEventType.POINTERCANCEL,this.handlePointerUp_,this)))};ol.MapBrowserEventHandler.prototype.handlePointerMove_=function(a){if(this.isMoving_(a)){this.dragging_=!0;var b=new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERDRAG,this.map_,a,this.dragging_);this.dispatchEvent(b)}a.preventDefault()};
ol.MapBrowserEventHandler.prototype.relayEvent_=function(a){var b=!(!this.down_||!this.isMoving_(a));this.dispatchEvent(new ol.MapBrowserPointerEvent(a.type,this.map_,a,b))};ol.MapBrowserEventHandler.prototype.isMoving_=function(a){return Math.abs(a.clientX-this.down_.clientX)>this.moveTolerance_||Math.abs(a.clientY-this.down_.clientY)>this.moveTolerance_};
ol.MapBrowserEventHandler.prototype.disposeInternal=function(){this.relayedListenerKey_&&(ol.events.unlistenByKey(this.relayedListenerKey_),this.relayedListenerKey_=null);this.pointerdownListenerKey_&&(ol.events.unlistenByKey(this.pointerdownListenerKey_),this.pointerdownListenerKey_=null);this.dragListenerKeys_.forEach(ol.events.unlistenByKey);this.dragListenerKeys_.length=0;this.documentPointerEventHandler_&&(this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null);this.pointerEventHandler_&&
(this.pointerEventHandler_.dispose(),this.pointerEventHandler_=null);ol.events.EventTarget.prototype.disposeInternal.call(this)};ol.MapEventType={POSTRENDER:"postrender",MOVESTART:"movestart",MOVEEND:"moveend"};ol.MapProperty={LAYERGROUP:"layergroup",SIZE:"size",TARGET:"target",VIEW:"view"};ol.TileState={IDLE:0,LOADING:1,LOADED:2,ERROR:3,EMPTY:4,ABORT:5};ol.structs={};ol.structs.PriorityQueue=function(a,b){this.priorityFunction_=a;this.keyFunction_=b;this.elements_=[];this.priorities_=[];this.queuedElements_={}};ol.structs.PriorityQueue.DROP=Infinity;ol.structs.PriorityQueue.prototype.clear=function(){this.elements_.length=0;this.priorities_.length=0;ol.obj.clear(this.queuedElements_)};
ol.structs.PriorityQueue.prototype.dequeue=function(){var a=this.elements_,b=this.priorities_,c=a[0];1==a.length?(a.length=0,b.length=0):(a[0]=a.pop(),b[0]=b.pop(),this.siftUp_(0));a=this.keyFunction_(c);delete this.queuedElements_[a];return c};
ol.structs.PriorityQueue.prototype.enqueue=function(a){ol.asserts.assert(!(this.keyFunction_(a)in this.queuedElements_),31);var b=this.priorityFunction_(a);return b!=ol.structs.PriorityQueue.DROP?(this.elements_.push(a),this.priorities_.push(b),this.queuedElements_[this.keyFunction_(a)]=!0,this.siftDown_(0,this.elements_.length-1),!0):!1};ol.structs.PriorityQueue.prototype.getCount=function(){return this.elements_.length};
ol.structs.PriorityQueue.prototype.getLeftChildIndex_=function(a){return 2*a+1};ol.structs.PriorityQueue.prototype.getRightChildIndex_=function(a){return 2*a+2};ol.structs.PriorityQueue.prototype.getParentIndex_=function(a){return a-1>>1};ol.structs.PriorityQueue.prototype.heapify_=function(){var a;for(a=(this.elements_.length>>1)-1;0<=a;a--)this.siftUp_(a)};ol.structs.PriorityQueue.prototype.isEmpty=function(){return 0===this.elements_.length};
ol.structs.PriorityQueue.prototype.isKeyQueued=function(a){return a in this.queuedElements_};ol.structs.PriorityQueue.prototype.isQueued=function(a){return this.isKeyQueued(this.keyFunction_(a))};ol.structs.PriorityQueue.prototype.siftUp_=function(a){for(var b=this.elements_,c=this.priorities_,d=b.length,e=b[a],f=c[a],g=a;a<d>>1;){var h=this.getLeftChildIndex_(a),k=this.getRightChildIndex_(a);h=k<d&&c[k]<c[h]?k:h;b[a]=b[h];c[a]=c[h];a=h}b[a]=e;c[a]=f;this.siftDown_(g,a)};
ol.structs.PriorityQueue.prototype.siftDown_=function(a,b){for(var c=this.elements_,d=this.priorities_,e=c[b],f=d[b];b>a;){var g=this.getParentIndex_(b);if(d[g]>f)c[b]=c[g],d[b]=d[g],b=g;else break}c[b]=e;d[b]=f};
ol.structs.PriorityQueue.prototype.reprioritize=function(){var a=this.priorityFunction_,b=this.elements_,c=this.priorities_,d=0,e=b.length,f;for(f=0;f<e;++f){var g=b[f];var h=a(g);h==ol.structs.PriorityQueue.DROP?delete this.queuedElements_[this.keyFunction_(g)]:(c[d]=h,b[d++]=g)}b.length=d;c.length=d;this.heapify_()};ol.TileQueue=function(a,b){ol.structs.PriorityQueue.call(this,function(b){return a.apply(null,b)},function(a){return a[0].getKey()});this.tileChangeCallback_=b;this.tilesLoading_=0;this.tilesLoadingKeys_={}};ol.inherits(ol.TileQueue,ol.structs.PriorityQueue);ol.TileQueue.prototype.enqueue=function(a){var b=ol.structs.PriorityQueue.prototype.enqueue.call(this,a);b&&ol.events.listen(a[0],ol.events.EventType.CHANGE,this.handleTileChange,this);return b};ol.TileQueue.prototype.getTilesLoading=function(){return this.tilesLoading_};
ol.TileQueue.prototype.handleTileChange=function(a){a=a.target;var b=a.getState();if(b===ol.TileState.LOADED||b===ol.TileState.ERROR||b===ol.TileState.EMPTY||b===ol.TileState.ABORT)ol.events.unlisten(a,ol.events.EventType.CHANGE,this.handleTileChange,this),a=a.getKey(),a in this.tilesLoadingKeys_&&(delete this.tilesLoadingKeys_[a],--this.tilesLoading_),this.tileChangeCallback_()};
ol.TileQueue.prototype.loadMoreTiles=function(a,b){for(var c=0,d=!1,e,f,g;this.tilesLoading_<a&&c<b&&0<this.getCount();)f=this.dequeue()[0],g=f.getKey(),e=f.getState(),e===ol.TileState.ABORT?d=!0:e!==ol.TileState.IDLE||g in this.tilesLoadingKeys_||(this.tilesLoadingKeys_[g]=!0,++this.tilesLoading_,++c,f.load());0===c&&d&&this.tileChangeCallback_()};ol.CenterConstraint={};ol.CenterConstraint.createExtent=function(a){return function(b){if(b)return[ol.math.clamp(b[0],a[0],a[2]),ol.math.clamp(b[1],a[1],a[3])]}};ol.CenterConstraint.none=function(a){return a};ol.ResolutionConstraint={};ol.ResolutionConstraint.createSnapToResolutions=function(a){return function(b,c,d){if(void 0!==b)return b=ol.array.linearFindNearest(a,b,d),b=ol.math.clamp(b+c,0,a.length-1),c=Math.floor(b),b!=c&&c<a.length-1?a[c]/Math.pow(a[c]/a[c+1],b-c):a[c]}};ol.ResolutionConstraint.createSnapToPower=function(a,b,c){return function(d,e,f){if(void 0!==d)return d=Math.max(Math.floor(Math.log(b/d)/Math.log(a)+(-f/2+.5))+e,0),void 0!==c&&(d=Math.min(d,c)),b/Math.pow(a,d)}};ol.RotationConstraint={};ol.RotationConstraint.disable=function(a,b){if(void 0!==a)return 0};ol.RotationConstraint.none=function(a,b){if(void 0!==a)return a+b};ol.RotationConstraint.createSnapToN=function(a){var b=2*Math.PI/a;return function(a,d){if(void 0!==a)return a=Math.floor((a+d)/b+.5)*b}};ol.RotationConstraint.createSnapToZero=function(a){var b=a||ol.math.toRadians(5);return function(a,d){if(void 0!==a)return Math.abs(a+d)<=b?0:a+d}};ol.ViewHint={ANIMATING:0,INTERACTING:1};ol.ViewProperty={CENTER:"center",RESOLUTION:"resolution",ROTATION:"rotation"};ol.string={};ol.string.padNumber=function(a,b,c){a=void 0!==c?a.toFixed(c):""+a;c=a.indexOf(".");c=-1===c?a.length:c;return c>b?a:Array(1+b-c).join("0")+a};ol.string.compareVersions=function(a,b){a=(""+a).split(".");b=(""+b).split(".");for(var c=0;c<Math.max(a.length,b.length);c++){var d=parseInt(a[c]||"0",10),e=parseInt(b[c]||"0",10);if(d>e)return 1;if(e>d)return-1}return 0};ol.coordinate={};ol.coordinate.add=function(a,b){a[0]+=b[0];a[1]+=b[1];return a};ol.coordinate.closestOnCircle=function(a,b){var c=b.getRadius(),d=b.getCenter();b=d[0];d=d[1];var e=a[0]-b;a=a[1]-d;0===e&&0===a&&(e=1);var f=Math.sqrt(e*e+a*a);return[b+c*e/f,d+c*a/f]};
ol.coordinate.closestOnSegment=function(a,b){var c=a[0];a=a[1];var d=b[0],e=b[1];b=d[0];d=d[1];var f=e[0];e=e[1];var g=f-b,h=e-d;c=0===g&&0===h?0:(g*(c-b)+h*(a-d))/(g*g+h*h||0);0>=c?(a=b,c=d):1<=c?(a=f,c=e):(a=b+c*g,c=d+c*h);return[a,c]};ol.coordinate.createStringXY=function(a){return function(b){return ol.coordinate.toStringXY(b,a)}};
ol.coordinate.degreesToStringHDMS=function(a,b,c){b=ol.math.modulo(b+180,360)-180;var d=Math.abs(3600*b);c=c||0;var e=Math.pow(10,c),f=Math.floor(d/3600),g=Math.floor((d-3600*f)/60);d=Math.ceil((d-3600*f-60*g)*e)/e;60<=d&&(d=0,g+=1);60<=g&&(g=0,f+=1);return f+"\u00b0 "+ol.string.padNumber(g,2)+"\u2032 "+ol.string.padNumber(d,2,c)+"\u2033"+(0==b?"":" "+a.charAt(0>b?1:0))};ol.coordinate.format=function(a,b,c){return a?b.replace("{x}",a[0].toFixed(c)).replace("{y}",a[1].toFixed(c)):""};
ol.coordinate.equals=function(a,b){for(var c=!0,d=a.length-1;0<=d;--d)if(a[d]!=b[d]){c=!1;break}return c};ol.coordinate.rotate=function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=a[1]*c+a[0]*b;a[0]=a[0]*c-a[1]*b;a[1]=d;return a};ol.coordinate.scale=function(a,b){a[0]*=b;a[1]*=b;return a};ol.coordinate.sub=function(a,b){a[0]-=b[0];a[1]-=b[1];return a};ol.coordinate.squaredDistance=function(a,b){var c=a[0]-b[0];a=a[1]-b[1];return c*c+a*a};
ol.coordinate.distance=function(a,b){return Math.sqrt(ol.coordinate.squaredDistance(a,b))};ol.coordinate.squaredDistanceToSegment=function(a,b){return ol.coordinate.squaredDistance(a,ol.coordinate.closestOnSegment(a,b))};ol.coordinate.toStringHDMS=function(a,b){return a?ol.coordinate.degreesToStringHDMS("NS",a[1],b)+" "+ol.coordinate.degreesToStringHDMS("EW",a[0],b):""};ol.coordinate.toStringXY=function(a,b){return ol.coordinate.format(a,"{x}, {y}",b)};ol.easing={};ol.easing.easeIn=function(a){return Math.pow(a,3)};ol.easing.easeOut=function(a){return 1-ol.easing.easeIn(1-a)};ol.easing.inAndOut=function(a){return 3*a*a-2*a*a*a};ol.easing.linear=function(a){return a};ol.easing.upAndDown=function(a){return.5>a?ol.easing.inAndOut(2*a):1-ol.easing.inAndOut(2*(a-.5))};ol.geom.GeometryLayout={XY:"XY",XYZ:"XYZ",XYM:"XYM",XYZM:"XYZM"};ol.functions={};ol.functions.TRUE=function(){return!0};ol.functions.FALSE=function(){return!1};ol.geom.flat={};ol.geom.flat.transform={};ol.geom.flat.transform.transform2D=function(a,b,c,d,e,f){for(var g=f?f:[],h=0;b<c;b+=d){var k=a[b],l=a[b+1];g[h++]=e[0]*k+e[2]*l+e[4];g[h++]=e[1]*k+e[3]*l+e[5]}f&&g.length!=h&&(g.length=h);return g};ol.geom.flat.transform.rotate=function(a,b,c,d,e,f,g){var h=g?g:[],k=Math.cos(e);e=Math.sin(e);var l=f[0];f=f[1];for(var m=0;b<c;b+=d){var n=a[b]-l,p=a[b+1]-f;h[m++]=l+n*k-p*e;h[m++]=f+n*e+p*k;for(n=b+2;n<b+d;++n)h[m++]=a[n]}g&&h.length!=m&&(h.length=m);return h};
ol.geom.flat.transform.scale=function(a,b,c,d,e,f,g,h){var k=h?h:[],l=g[0];g=g[1];for(var m=0;b<c;b+=d){var n=a[b]-l,p=a[b+1]-g;k[m++]=l+e*n;k[m++]=g+f*p;for(n=b+2;n<b+d;++n)k[m++]=a[n]}h&&k.length!=m&&(k.length=m);return k};ol.geom.flat.transform.translate=function(a,b,c,d,e,f,g){for(var h=g?g:[],k=0,l;b<c;b+=d)for(h[k++]=a[b]+e,h[k++]=a[b+1]+f,l=b+2;l<b+d;++l)h[k++]=a[l];g&&h.length!=k&&(h.length=k);return h};ol.transform={};ol.transform.tmp_=Array(6);ol.transform.create=function(){return[1,0,0,1,0,0]};ol.transform.reset=function(a){return ol.transform.set(a,1,0,0,1,0,0)};ol.transform.multiply=function(a,b){var c=a[0],d=a[1],e=a[2],f=a[3],g=a[4],h=a[5],k=b[0],l=b[1],m=b[2],n=b[3],p=b[4];b=b[5];a[0]=c*k+e*l;a[1]=d*k+f*l;a[2]=c*m+e*n;a[3]=d*m+f*n;a[4]=c*p+e*b+g;a[5]=d*p+f*b+h;return a};ol.transform.set=function(a,b,c,d,e,f,g){a[0]=b;a[1]=c;a[2]=d;a[3]=e;a[4]=f;a[5]=g;return a};
ol.transform.setFromArray=function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];return a};ol.transform.apply=function(a,b){var c=b[0],d=b[1];b[0]=a[0]*c+a[2]*d+a[4];b[1]=a[1]*c+a[3]*d+a[5];return b};ol.transform.rotate=function(a,b){var c=Math.cos(b);b=Math.sin(b);return ol.transform.multiply(a,ol.transform.set(ol.transform.tmp_,c,b,-b,c,0,0))};ol.transform.scale=function(a,b,c){return ol.transform.multiply(a,ol.transform.set(ol.transform.tmp_,b,0,0,c,0,0))};
ol.transform.translate=function(a,b,c){return ol.transform.multiply(a,ol.transform.set(ol.transform.tmp_,1,0,0,1,b,c))};ol.transform.compose=function(a,b,c,d,e,f,g,h){var k=Math.sin(f);f=Math.cos(f);a[0]=d*f;a[1]=e*k;a[2]=-d*k;a[3]=e*f;a[4]=g*d*f-h*d*k+b;a[5]=g*e*k+h*e*f+c;return a};ol.transform.invert=function(a){var b=ol.transform.determinant(a);ol.asserts.assert(0!==b,32);var c=a[0],d=a[1],e=a[2],f=a[3],g=a[4],h=a[5];a[0]=f/b;a[1]=-d/b;a[2]=-e/b;a[3]=c/b;a[4]=(e*h-f*g)/b;a[5]=-(c*h-d*g)/b;return a};
ol.transform.determinant=function(a){return a[0]*a[3]-a[1]*a[2]};ol.geom.Geometry=function(){ol.Object.call(this);this.extent_=ol.extent.createEmpty();this.extentRevision_=-1;this.simplifiedGeometryCache={};this.simplifiedGeometryRevision=this.simplifiedGeometryMaxMinSquaredTolerance=0;this.tmpTransform_=ol.transform.create()};ol.inherits(ol.geom.Geometry,ol.Object);ol.geom.Geometry.prototype.clone=function(){};ol.geom.Geometry.prototype.closestPointXY=function(a,b,c,d){};
ol.geom.Geometry.prototype.getClosestPoint=function(a,b){b=b?b:[NaN,NaN];this.closestPointXY(a[0],a[1],b,Infinity);return b};ol.geom.Geometry.prototype.intersectsCoordinate=function(a){return this.containsXY(a[0],a[1])};ol.geom.Geometry.prototype.computeExtent=function(a){};ol.geom.Geometry.prototype.containsXY=ol.functions.FALSE;
ol.geom.Geometry.prototype.getExtent=function(a){this.extentRevision_!=this.getRevision()&&(this.extent_=this.computeExtent(this.extent_),this.extentRevision_=this.getRevision());return ol.extent.returnOrUpdate(this.extent_,a)};ol.geom.Geometry.prototype.rotate=function(a,b){};ol.geom.Geometry.prototype.scale=function(a,b,c){};ol.geom.Geometry.prototype.simplify=function(a){return this.getSimplifiedGeometry(a*a)};ol.geom.Geometry.prototype.getSimplifiedGeometry=function(a){};
ol.geom.Geometry.prototype.getType=function(){};ol.geom.Geometry.prototype.applyTransform=function(a){};ol.geom.Geometry.prototype.intersectsExtent=function(a){};ol.geom.Geometry.prototype.translate=function(a,b){};
ol.geom.Geometry.prototype.transform=function(a,b){var c=this.tmpTransform_;a=ol.proj.get(a);var d=a.getUnits()==ol.proj.Units.TILE_PIXELS?function(d,f,g){var e=a.getExtent(),k=a.getWorldExtent();e=ol.extent.getHeight(k)/ol.extent.getHeight(e);ol.transform.compose(c,k[0],k[3],e,-e,0,0,0);ol.geom.flat.transform.transform2D(d,0,d.length,g,c,f);return ol.proj.getTransform(a,b)(d,f,g)}:ol.proj.getTransform(a,b);this.applyTransform(d);return this};ol.geom.SimpleGeometry=function(){ol.geom.Geometry.call(this);this.layout=ol.geom.GeometryLayout.XY;this.stride=2;this.flatCoordinates=null};ol.inherits(ol.geom.SimpleGeometry,ol.geom.Geometry);ol.geom.SimpleGeometry.getLayoutForStride_=function(a){if(2==a)var b=ol.geom.GeometryLayout.XY;else 3==a?b=ol.geom.GeometryLayout.XYZ:4==a&&(b=ol.geom.GeometryLayout.XYZM);return b};
ol.geom.SimpleGeometry.getStrideForLayout=function(a){var b;a==ol.geom.GeometryLayout.XY?b=2:a==ol.geom.GeometryLayout.XYZ||a==ol.geom.GeometryLayout.XYM?b=3:a==ol.geom.GeometryLayout.XYZM&&(b=4);return b};ol.geom.SimpleGeometry.prototype.containsXY=ol.functions.FALSE;ol.geom.SimpleGeometry.prototype.computeExtent=function(a){return ol.extent.createOrUpdateFromFlatCoordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a)};ol.geom.SimpleGeometry.prototype.getCoordinates=function(){};
ol.geom.SimpleGeometry.prototype.getFirstCoordinate=function(){return this.flatCoordinates.slice(0,this.stride)};ol.geom.SimpleGeometry.prototype.getFlatCoordinates=function(){return this.flatCoordinates};ol.geom.SimpleGeometry.prototype.getLastCoordinate=function(){return this.flatCoordinates.slice(this.flatCoordinates.length-this.stride)};ol.geom.SimpleGeometry.prototype.getLayout=function(){return this.layout};
ol.geom.SimpleGeometry.prototype.getSimplifiedGeometry=function(a){this.simplifiedGeometryRevision!=this.getRevision()&&(ol.obj.clear(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision());if(0>a||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&a<=this.simplifiedGeometryMaxMinSquaredTolerance)return this;var b=a.toString();if(this.simplifiedGeometryCache.hasOwnProperty(b))return this.simplifiedGeometryCache[b];var c=this.getSimplifiedGeometryInternal(a);
if(c.getFlatCoordinates().length<this.flatCoordinates.length)return this.simplifiedGeometryCache[b]=c;this.simplifiedGeometryMaxMinSquaredTolerance=a;return this};ol.geom.SimpleGeometry.prototype.getSimplifiedGeometryInternal=function(a){return this};ol.geom.SimpleGeometry.prototype.getStride=function(){return this.stride};ol.geom.SimpleGeometry.prototype.setFlatCoordinatesInternal=function(a,b){this.stride=ol.geom.SimpleGeometry.getStrideForLayout(a);this.layout=a;this.flatCoordinates=b};
ol.geom.SimpleGeometry.prototype.setCoordinates=function(a,b){};ol.geom.SimpleGeometry.prototype.setLayout=function(a,b,c){if(a)b=ol.geom.SimpleGeometry.getStrideForLayout(a);else{for(a=0;a<c;++a){if(0===b.length){this.layout=ol.geom.GeometryLayout.XY;this.stride=2;return}b=b[0]}b=b.length;a=ol.geom.SimpleGeometry.getLayoutForStride_(b)}this.layout=a;this.stride=b};
ol.geom.SimpleGeometry.prototype.applyTransform=function(a){this.flatCoordinates&&(a(this.flatCoordinates,this.flatCoordinates,this.stride),this.changed())};ol.geom.SimpleGeometry.prototype.rotate=function(a,b){var c=this.getFlatCoordinates();if(c){var d=this.getStride();ol.geom.flat.transform.rotate(c,0,c.length,d,a,b,c);this.changed()}};
ol.geom.SimpleGeometry.prototype.scale=function(a,b,c){void 0===b&&(b=a);c||(c=ol.extent.getCenter(this.getExtent()));var d=this.getFlatCoordinates();if(d){var e=this.getStride();ol.geom.flat.transform.scale(d,0,d.length,e,a,b,c,d);this.changed()}};ol.geom.SimpleGeometry.prototype.translate=function(a,b){var c=this.getFlatCoordinates();if(c){var d=this.getStride();ol.geom.flat.transform.translate(c,0,c.length,d,a,b,c);this.changed()}};
ol.geom.SimpleGeometry.transform2D=function(a,b,c){var d=a.getFlatCoordinates();return d?(a=a.getStride(),ol.geom.flat.transform.transform2D(d,0,d.length,a,b,c)):null};ol.geom.flat.area={};ol.geom.flat.area.linearRing=function(a,b,c,d){for(var e=0,f=a[c-d],g=a[c-d+1];b<c;b+=d){var h=a[b],k=a[b+1];e+=g*h-f*k;f=h;g=k}return e/2};ol.geom.flat.area.linearRings=function(a,b,c,d){var e=0,f;var g=0;for(f=c.length;g<f;++g){var h=c[g];e+=ol.geom.flat.area.linearRing(a,b,h,d);b=h}return e};ol.geom.flat.area.linearRingss=function(a,b,c,d){var e=0,f;var g=0;for(f=c.length;g<f;++g){var h=c[g];e+=ol.geom.flat.area.linearRings(a,b,h,d);b=h[h.length-1]}return e};ol.geom.flat.closest={};ol.geom.flat.closest.point=function(a,b,c,d,e,f,g){var h=a[b],k=a[b+1],l=a[c]-h,m=a[c+1]-k;if(0!==l||0!==m)if(f=((e-h)*l+(f-k)*m)/(l*l+m*m),1<f)b=c;else if(0<f){for(e=0;e<d;++e)g[e]=ol.math.lerp(a[b+e],a[c+e],f);g.length=d;return}for(e=0;e<d;++e)g[e]=a[b+e];g.length=d};ol.geom.flat.closest.getMaxSquaredDelta=function(a,b,c,d,e){var f=a[b],g=a[b+1];for(b+=d;b<c;b+=d){var h=a[b],k=a[b+1];f=ol.math.squaredDistance(f,g,h,k);f>e&&(e=f);f=h;g=k}return e};
ol.geom.flat.closest.getsMaxSquaredDelta=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g){var h=c[g];e=ol.geom.flat.closest.getMaxSquaredDelta(a,b,h,d,e);b=h}return e};ol.geom.flat.closest.getssMaxSquaredDelta=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g){var h=c[g];e=ol.geom.flat.closest.getsMaxSquaredDelta(a,b,h,d,e);b=h[h.length-1]}return e};
ol.geom.flat.closest.getClosestPoint=function(a,b,c,d,e,f,g,h,k,l,m){if(b==c)return l;if(0===e){var n=ol.math.squaredDistance(g,h,a[b],a[b+1]);if(n<l){for(m=0;m<d;++m)k[m]=a[b+m];k.length=d;return n}return l}for(var p=m?m:[NaN,NaN],q=b+d;q<c;)if(ol.geom.flat.closest.point(a,q-d,q,d,g,h,p),n=ol.math.squaredDistance(g,h,p[0],p[1]),n<l){l=n;for(m=0;m<d;++m)k[m]=p[m];k.length=d;q+=d}else q+=d*Math.max((Math.sqrt(n)-Math.sqrt(l))/e|0,1);if(f&&(ol.geom.flat.closest.point(a,c-d,b,d,g,h,p),n=ol.math.squaredDistance(g,
h,p[0],p[1]),n<l)){l=n;for(m=0;m<d;++m)k[m]=p[m];k.length=d}return l};ol.geom.flat.closest.getsClosestPoint=function(a,b,c,d,e,f,g,h,k,l,m){m=m?m:[NaN,NaN];var n;var p=0;for(n=c.length;p<n;++p){var q=c[p];l=ol.geom.flat.closest.getClosestPoint(a,b,q,d,e,f,g,h,k,l,m);b=q}return l};ol.geom.flat.closest.getssClosestPoint=function(a,b,c,d,e,f,g,h,k,l,m){m=m?m:[NaN,NaN];var n;var p=0;for(n=c.length;p<n;++p){var q=c[p];l=ol.geom.flat.closest.getsClosestPoint(a,b,q,d,e,f,g,h,k,l,m);b=q[q.length-1]}return l};ol.geom.flat.deflate={};ol.geom.flat.deflate.coordinate=function(a,b,c,d){var e;d=0;for(e=c.length;d<e;++d)a[b++]=c[d];return b};ol.geom.flat.deflate.coordinates=function(a,b,c,d){var e;var f=0;for(e=c.length;f<e;++f){var g=c[f],h;for(h=0;h<d;++h)a[b++]=g[h]}return b};ol.geom.flat.deflate.coordinatess=function(a,b,c,d,e){e=e?e:[];var f=0,g;var h=0;for(g=c.length;h<g;++h)b=ol.geom.flat.deflate.coordinates(a,b,c[h],d),e[f++]=b;e.length=f;return e};
ol.geom.flat.deflate.coordinatesss=function(a,b,c,d,e){e=e?e:[];var f=0,g;var h=0;for(g=c.length;h<g;++h)b=ol.geom.flat.deflate.coordinatess(a,b,c[h],d,e[f]),e[f++]=b,b=b[b.length-1];e.length=f;return e};ol.geom.flat.inflate={};ol.geom.flat.inflate.coordinates=function(a,b,c,d,e){e=void 0!==e?e:[];for(var f=0;b<c;b+=d)e[f++]=a.slice(b,b+d);e.length=f;return e};ol.geom.flat.inflate.coordinatess=function(a,b,c,d,e){e=void 0!==e?e:[];var f=0,g;var h=0;for(g=c.length;h<g;++h){var k=c[h];e[f++]=ol.geom.flat.inflate.coordinates(a,b,k,d,e[f]);b=k}e.length=f;return e};
ol.geom.flat.inflate.coordinatesss=function(a,b,c,d,e){e=void 0!==e?e:[];var f=0,g;var h=0;for(g=c.length;h<g;++h){var k=c[h];e[f++]=ol.geom.flat.inflate.coordinatess(a,b,k,d,e[f]);b=k[k.length-1]}e.length=f;return e};ol.geom.flat.simplify={};ol.geom.flat.simplify.lineString=function(a,b,c,d,e,f,g){g=void 0!==g?g:[];f||(c=ol.geom.flat.simplify.radialDistance(a,b,c,d,e,g,0),a=g,b=0,d=2);g.length=ol.geom.flat.simplify.douglasPeucker(a,b,c,d,e,g,0);return g};
ol.geom.flat.simplify.douglasPeucker=function(a,b,c,d,e,f,g){var h=(c-b)/d;if(3>h){for(;b<c;b+=d)f[g++]=a[b],f[g++]=a[b+1];return g}var k=Array(h);k[0]=1;k[h-1]=1;c=[b,c-d];for(var l=0,m;0<c.length;){var n=c.pop(),p=c.pop(),q=0,r=a[p],u=a[p+1],t=a[n],v=a[n+1];for(m=p+d;m<n;m+=d){var w=ol.math.squaredSegmentDistance(a[m],a[m+1],r,u,t,v);w>q&&(l=m,q=w)}q>e&&(k[(l-b)/d]=1,p+d<l&&c.push(p,l),l+d<n&&c.push(l,n))}for(m=0;m<h;++m)k[m]&&(f[g++]=a[b+m*d],f[g++]=a[b+m*d+1]);return g};
ol.geom.flat.simplify.douglasPeuckers=function(a,b,c,d,e,f,g,h){var k;var l=0;for(k=c.length;l<k;++l){var m=c[l];g=ol.geom.flat.simplify.douglasPeucker(a,b,m,d,e,f,g);h.push(g);b=m}return g};ol.geom.flat.simplify.douglasPeuckerss=function(a,b,c,d,e,f,g,h){var k;var l=0;for(k=c.length;l<k;++l){var m=c[l],n=[];g=ol.geom.flat.simplify.douglasPeuckers(a,b,m,d,e,f,g,n);h.push(n);b=m[m.length-1]}return g};
ol.geom.flat.simplify.radialDistance=function(a,b,c,d,e,f,g){if(c<=b+d){for(;b<c;b+=d)f[g++]=a[b],f[g++]=a[b+1];return g}var h=a[b],k=a[b+1];f[g++]=h;f[g++]=k;var l=h,m=k;for(b+=d;b<c;b+=d)l=a[b],m=a[b+1],ol.math.squaredDistance(h,k,l,m)>e&&(f[g++]=l,f[g++]=m,h=l,k=m);if(l!=h||m!=k)f[g++]=l,f[g++]=m;return g};ol.geom.flat.simplify.snap=function(a,b){return b*Math.round(a/b)};
ol.geom.flat.simplify.quantize=function(a,b,c,d,e,f,g){if(b==c)return g;var h=ol.geom.flat.simplify.snap(a[b],e),k=ol.geom.flat.simplify.snap(a[b+1],e);b+=d;f[g++]=h;f[g++]=k;do{var l=ol.geom.flat.simplify.snap(a[b],e);var m=ol.geom.flat.simplify.snap(a[b+1],e);b+=d;if(b==c)return f[g++]=l,f[g++]=m,g}while(l==h&&m==k);for(;b<c;){var n=ol.geom.flat.simplify.snap(a[b],e);var p=ol.geom.flat.simplify.snap(a[b+1],e);b+=d;if(n!=l||p!=m){var q=l-h,r=m-k,u=n-h,t=p-k;q*t==r*u&&(0>q&&u<q||q==u||0<q&&u>q)&&
(0>r&&t<r||r==t||0<r&&t>r)||(f[g++]=l,f[g++]=m,h=l,k=m);l=n;m=p}}f[g++]=l;f[g++]=m;return g};ol.geom.flat.simplify.quantizes=function(a,b,c,d,e,f,g,h){var k;var l=0;for(k=c.length;l<k;++l){var m=c[l];g=ol.geom.flat.simplify.quantize(a,b,m,d,e,f,g);h.push(g);b=m}return g};ol.geom.flat.simplify.quantizess=function(a,b,c,d,e,f,g,h){var k;var l=0;for(k=c.length;l<k;++l){var m=c[l],n=[];g=ol.geom.flat.simplify.quantizes(a,b,m,d,e,f,g,n);h.push(n);b=m[m.length-1]}return g};ol.geom.LinearRing=function(a,b){ol.geom.SimpleGeometry.call(this);this.maxDeltaRevision_=this.maxDelta_=-1;this.setCoordinates(a,b)};ol.inherits(ol.geom.LinearRing,ol.geom.SimpleGeometry);ol.geom.LinearRing.prototype.clone=function(){var a=new ol.geom.LinearRing(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return a};
ol.geom.LinearRing.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision());return ol.geom.flat.closest.getClosestPoint(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!0,a,b,c,d)};
ol.geom.LinearRing.prototype.getArea=function(){return ol.geom.flat.area.linearRing(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)};ol.geom.LinearRing.prototype.getCoordinates=function(){return ol.geom.flat.inflate.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)};
ol.geom.LinearRing.prototype.getSimplifiedGeometryInternal=function(a){var b=[];b.length=ol.geom.flat.simplify.douglasPeucker(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a,b,0);a=new ol.geom.LinearRing(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,b);return a};ol.geom.LinearRing.prototype.getType=function(){return ol.geom.GeometryType.LINEAR_RING};ol.geom.LinearRing.prototype.intersectsExtent=function(a){};
ol.geom.LinearRing.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ol.geom.flat.deflate.coordinates(this.flatCoordinates,0,a,this.stride),this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null)};ol.geom.LinearRing.prototype.setFlatCoordinates=function(a,b){this.setFlatCoordinatesInternal(a,b);this.changed()};ol.geom.Point=function(a,b){ol.geom.SimpleGeometry.call(this);this.setCoordinates(a,b)};ol.inherits(ol.geom.Point,ol.geom.SimpleGeometry);ol.geom.Point.prototype.clone=function(){var a=new ol.geom.Point(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return a};ol.geom.Point.prototype.closestPointXY=function(a,b,c,d){var e=this.flatCoordinates;a=ol.math.squaredDistance(a,b,e[0],e[1]);if(a<d){d=this.stride;for(b=0;b<d;++b)c[b]=e[b];c.length=d;return a}return d};
ol.geom.Point.prototype.getCoordinates=function(){return this.flatCoordinates?this.flatCoordinates.slice():[]};ol.geom.Point.prototype.computeExtent=function(a){return ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates,a)};ol.geom.Point.prototype.getType=function(){return ol.geom.GeometryType.POINT};ol.geom.Point.prototype.intersectsExtent=function(a){return ol.extent.containsXY(a,this.flatCoordinates[0],this.flatCoordinates[1])};
ol.geom.Point.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,0),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ol.geom.flat.deflate.coordinate(this.flatCoordinates,0,a,this.stride),this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null)};ol.geom.Point.prototype.setFlatCoordinates=function(a,b){this.setFlatCoordinatesInternal(a,b);this.changed()};ol.geom.flat.contains={};ol.geom.flat.contains.linearRingContainsExtent=function(a,b,c,d,e){return!ol.extent.forEachCorner(e,function(e){return!ol.geom.flat.contains.linearRingContainsXY(a,b,c,d,e[0],e[1])})};ol.geom.flat.contains.linearRingContainsXY=function(a,b,c,d,e,f){for(var g=0,h=a[c-d],k=a[c-d+1];b<c;b+=d){var l=a[b],m=a[b+1];k<=f?m>f&&0<(l-h)*(f-k)-(e-h)*(m-k)&&g++:m<=f&&0>(l-h)*(f-k)-(e-h)*(m-k)&&g--;h=l;k=m}return 0!==g};
ol.geom.flat.contains.linearRingsContainsXY=function(a,b,c,d,e,f){if(0===c.length||!ol.geom.flat.contains.linearRingContainsXY(a,b,c[0],d,e,f))return!1;var g;b=1;for(g=c.length;b<g;++b)if(ol.geom.flat.contains.linearRingContainsXY(a,c[b-1],c[b],d,e,f))return!1;return!0};ol.geom.flat.contains.linearRingssContainsXY=function(a,b,c,d,e,f){if(0===c.length)return!1;var g;var h=0;for(g=c.length;h<g;++h){var k=c[h];if(ol.geom.flat.contains.linearRingsContainsXY(a,b,k,d,e,f))return!0;b=k[k.length-1]}return!1};ol.geom.flat.interiorpoint={};
ol.geom.flat.interiorpoint.linearRings=function(a,b,c,d,e,f,g){for(var h,k,l,m,n,p=e[f+1],q=[],r=0,u=c.length;r<u;++r){var t=c[r];l=a[t-d];n=a[t-d+1];for(h=b;h<t;h+=d){m=a[h];k=a[h+1];if(p<=n&&k<=p||n<=p&&p<=k)l=(p-n)/(k-n)*(m-l)+l,q.push(l);l=m;n=k}}r=NaN;u=-Infinity;q.sort(ol.array.numberSafeCompareFunction);l=q[0];h=1;for(k=q.length;h<k;++h)m=q[h],t=Math.abs(m-l),t>u&&(l=(l+m)/2,ol.geom.flat.contains.linearRingsContainsXY(a,b,c,d,l,p)&&(r=l,u=t)),l=m;isNaN(r)&&(r=e[f]);return g?(g.push(r,p,u),
g):[r,p,u]};ol.geom.flat.interiorpoint.linearRingss=function(a,b,c,d,e){var f=[],g;var h=0;for(g=c.length;h<g;++h){var k=c[h];f=ol.geom.flat.interiorpoint.linearRings(a,b,k,d,e,2*h,f);b=k[k.length-1]}return f};ol.geom.flat.segments={};ol.geom.flat.segments.forEach=function(a,b,c,d,e,f){for(var g=[a[b],a[b+1]],h=[],k;b+d<c;b+=d){h[0]=a[b+d];h[1]=a[b+d+1];if(k=e.call(f,g,h))return k;g[0]=h[0];g[1]=h[1]}return!1};ol.geom.flat.intersectsextent={};ol.geom.flat.intersectsextent.lineString=function(a,b,c,d,e){var f=ol.extent.extendFlatCoordinates(ol.extent.createEmpty(),a,b,c,d);return ol.extent.intersects(e,f)?ol.extent.containsExtent(e,f)||f[0]>=e[0]&&f[2]<=e[2]||f[1]>=e[1]&&f[3]<=e[3]?!0:ol.geom.flat.segments.forEach(a,b,c,d,function(a,b){return ol.extent.intersectsSegment(e,a,b)}):!1};
ol.geom.flat.intersectsextent.lineStrings=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g){if(ol.geom.flat.intersectsextent.lineString(a,b,c[g],d,e))return!0;b=c[g]}return!1};
ol.geom.flat.intersectsextent.linearRing=function(a,b,c,d,e){return ol.geom.flat.intersectsextent.lineString(a,b,c,d,e)||ol.geom.flat.contains.linearRingContainsXY(a,b,c,d,e[0],e[1])||ol.geom.flat.contains.linearRingContainsXY(a,b,c,d,e[0],e[3])||ol.geom.flat.contains.linearRingContainsXY(a,b,c,d,e[2],e[1])||ol.geom.flat.contains.linearRingContainsXY(a,b,c,d,e[2],e[3])?!0:!1};
ol.geom.flat.intersectsextent.linearRings=function(a,b,c,d,e){if(!ol.geom.flat.intersectsextent.linearRing(a,b,c[0],d,e))return!1;if(1===c.length)return!0;var f;b=1;for(f=c.length;b<f;++b)if(ol.geom.flat.contains.linearRingContainsExtent(a,c[b-1],c[b],d,e))return!1;return!0};ol.geom.flat.intersectsextent.linearRingss=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g){var h=c[g];if(ol.geom.flat.intersectsextent.linearRings(a,b,h,d,e))return!0;b=h[h.length-1]}return!1};ol.geom.flat.reverse={};ol.geom.flat.reverse.coordinates=function(a,b,c,d){for(;b<c-d;){var e;for(e=0;e<d;++e){var f=a[b+e];a[b+e]=a[c-d+e];a[c-d+e]=f}b+=d;c-=d}};ol.geom.flat.orient={};ol.geom.flat.orient.linearRingIsClockwise=function(a,b,c,d){for(var e=0,f=a[c-d],g=a[c-d+1];b<c;b+=d){var h=a[b],k=a[b+1];e+=(h-f)*(k+g);f=h;g=k}return 0<e};ol.geom.flat.orient.linearRingsAreOriented=function(a,b,c,d,e){e=void 0!==e?e:!1;var f;var g=0;for(f=c.length;g<f;++g){var h=c[g];b=ol.geom.flat.orient.linearRingIsClockwise(a,b,h,d);if(0===g){if(e&&b||!e&&!b)return!1}else if(e&&!b||!e&&b)return!1;b=h}return!0};
ol.geom.flat.orient.linearRingssAreOriented=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g)if(!ol.geom.flat.orient.linearRingsAreOriented(a,b,c[g],d,e))return!1;return!0};ol.geom.flat.orient.orientLinearRings=function(a,b,c,d,e){e=void 0!==e?e:!1;var f;var g=0;for(f=c.length;g<f;++g){var h=c[g],k=ol.geom.flat.orient.linearRingIsClockwise(a,b,h,d);(0===g?e&&k||!e&&!k:e&&!k||!e&&k)&&ol.geom.flat.reverse.coordinates(a,b,h,d);b=h}return b};
ol.geom.flat.orient.orientLinearRingss=function(a,b,c,d,e){var f;var g=0;for(f=c.length;g<f;++g)b=ol.geom.flat.orient.orientLinearRings(a,b,c[g],d,e);return b};ol.geom.Polygon=function(a,b){ol.geom.SimpleGeometry.call(this);this.ends_=[];this.flatInteriorPointRevision_=-1;this.flatInteriorPoint_=null;this.orientedRevision_=this.maxDeltaRevision_=this.maxDelta_=-1;this.orientedFlatCoordinates_=null;this.setCoordinates(a,b)};ol.inherits(ol.geom.Polygon,ol.geom.SimpleGeometry);
ol.geom.Polygon.prototype.appendLinearRing=function(a){this.flatCoordinates?ol.array.extend(this.flatCoordinates,a.getFlatCoordinates()):this.flatCoordinates=a.getFlatCoordinates().slice();this.ends_.push(this.flatCoordinates.length);this.changed()};ol.geom.Polygon.prototype.clone=function(){var a=new ol.geom.Polygon(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice());return a};
ol.geom.Polygon.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision());return ol.geom.flat.closest.getsClosestPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,a,b,c,d)};
ol.geom.Polygon.prototype.containsXY=function(a,b){return ol.geom.flat.contains.linearRingsContainsXY(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,a,b)};ol.geom.Polygon.prototype.getArea=function(){return ol.geom.flat.area.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)};
ol.geom.Polygon.prototype.getCoordinates=function(a){if(void 0!==a){var b=this.getOrientedFlatCoordinates().slice();ol.geom.flat.orient.orientLinearRings(b,0,this.ends_,this.stride,a)}else b=this.flatCoordinates;return ol.geom.flat.inflate.coordinatess(b,0,this.ends_,this.stride)};ol.geom.Polygon.prototype.getEnds=function(){return this.ends_};
ol.geom.Polygon.prototype.getFlatInteriorPoint=function(){if(this.flatInteriorPointRevision_!=this.getRevision()){var a=ol.extent.getCenter(this.getExtent());this.flatInteriorPoint_=ol.geom.flat.interiorpoint.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,a,0);this.flatInteriorPointRevision_=this.getRevision()}return this.flatInteriorPoint_};ol.geom.Polygon.prototype.getInteriorPoint=function(){return new ol.geom.Point(this.getFlatInteriorPoint(),ol.geom.GeometryLayout.XYM)};
ol.geom.Polygon.prototype.getLinearRingCount=function(){return this.ends_.length};ol.geom.Polygon.prototype.getLinearRing=function(a){if(0>a||this.ends_.length<=a)return null;var b=new ol.geom.LinearRing(null);b.setFlatCoordinates(this.layout,this.flatCoordinates.slice(0===a?0:this.ends_[a-1],this.ends_[a]));return b};
ol.geom.Polygon.prototype.getLinearRings=function(){var a=this.layout,b=this.flatCoordinates,c=this.ends_,d=[],e=0,f;var g=0;for(f=c.length;g<f;++g){var h=c[g],k=new ol.geom.LinearRing(null);k.setFlatCoordinates(a,b.slice(e,h));d.push(k);e=h}return d};
ol.geom.Polygon.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var a=this.flatCoordinates;ol.geom.flat.orient.linearRingsAreOriented(a,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=a:(this.orientedFlatCoordinates_=a.slice(),this.orientedFlatCoordinates_.length=ol.geom.flat.orient.orientLinearRings(this.orientedFlatCoordinates_,0,this.ends_,this.stride));this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_};
ol.geom.Polygon.prototype.getSimplifiedGeometryInternal=function(a){var b=[],c=[];b.length=ol.geom.flat.simplify.quantizes(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(a),b,0,c);a=new ol.geom.Polygon(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,b,c);return a};ol.geom.Polygon.prototype.getType=function(){return ol.geom.GeometryType.POLYGON};
ol.geom.Polygon.prototype.intersectsExtent=function(a){return ol.geom.flat.intersectsextent.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,a)};
ol.geom.Polygon.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,2),this.flatCoordinates||(this.flatCoordinates=[]),a=ol.geom.flat.deflate.coordinatess(this.flatCoordinates,0,a,this.stride,this.ends_),this.flatCoordinates.length=0===a.length?0:a[a.length-1],this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null,this.ends_)};ol.geom.Polygon.prototype.setFlatCoordinates=function(a,b,c){this.setFlatCoordinatesInternal(a,b);this.ends_=c;this.changed()};
ol.geom.Polygon.circular=function(a,b,c,d){var e=d?d:32;d=[];var f;for(f=0;f<e;++f)ol.array.extend(d,a.offset(b,c,2*Math.PI*f/e));d.push(d[0],d[1]);a=new ol.geom.Polygon(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,d,[d.length]);return a};ol.geom.Polygon.fromExtent=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];b=[b,c,b,a,d,a,d,c,b,c];c=new ol.geom.Polygon(null);c.setFlatCoordinates(ol.geom.GeometryLayout.XY,b,[b.length]);return c};
ol.geom.Polygon.fromCircle=function(a,b,c){var d=b?b:32,e=a.getStride();b=a.getLayout();var f=new ol.geom.Polygon(null,b);d=e*(d+1);e=Array(d);for(var g=0;g<d;g++)e[g]=0;f.setFlatCoordinates(b,e,[e.length]);ol.geom.Polygon.makeRegular(f,a.getCenter(),a.getRadius(),c);return f};
ol.geom.Polygon.makeRegular=function(a,b,c,d){var e=a.getFlatCoordinates(),f=a.getLayout(),g=a.getStride(),h=a.getEnds(),k=e.length/g-1;d=d?d:0;for(var l,m,n=0;n<=k;++n)m=n*g,l=d+2*ol.math.modulo(n,k)*Math.PI/k,e[m]=b[0]+c*Math.cos(l),e[m+1]=b[1]+c*Math.sin(l);a.setFlatCoordinates(f,e,h)};ol.View=function(a){ol.Object.call(this);a=ol.obj.assign({},a);this.hints_=[0,0];this.animations_=[];this.updateAnimations_=this.updateAnimations_.bind(this);this.projection_=ol.proj.createProjection(a.projection,"EPSG:3857");this.applyOptions_(a)};ol.inherits(ol.View,ol.Object);
ol.View.prototype.applyOptions_=function(a){var b={};b[ol.ViewProperty.CENTER]=void 0!==a.center?a.center:null;var c=ol.View.createResolutionConstraint_(a);this.maxResolution_=c.maxResolution;this.minResolution_=c.minResolution;this.zoomFactor_=c.zoomFactor;this.resolutions_=a.resolutions;this.minZoom_=c.minZoom;var d=ol.View.createCenterConstraint_(a);c=c.constraint;var e=ol.View.createRotationConstraint_(a);this.constraints_={center:d,resolution:c,rotation:e};void 0!==a.resolution?b[ol.ViewProperty.RESOLUTION]=
a.resolution:void 0!==a.zoom&&(b[ol.ViewProperty.RESOLUTION]=this.constrainResolution(this.maxResolution_,a.zoom-this.minZoom_),this.resolutions_&&(b[ol.ViewProperty.RESOLUTION]=ol.math.clamp(Number(this.getResolution()||b[ol.ViewProperty.RESOLUTION]),this.minResolution_,this.maxResolution_)));b[ol.ViewProperty.ROTATION]=void 0!==a.rotation?a.rotation:0;this.setProperties(b);this.options_=a};
ol.View.prototype.getUpdatedOptions_=function(a){var b=ol.obj.assign({},this.options_);void 0!==b.resolution?b.resolution=this.getResolution():b.zoom=this.getZoom();b.center=this.getCenter();b.rotation=this.getRotation();return ol.obj.assign({},b,a)};
ol.View.prototype.animate=function(a){var b=arguments.length;if(1<b&&"function"===typeof arguments[b-1]){var c=arguments[b-1];--b}if(this.isDef()){for(var d=Date.now(),e=this.getCenter().slice(),f=this.getResolution(),g=this.getRotation(),h=[],k=0;k<b;++k){var l=arguments[k],m={start:d,complete:!1,anchor:l.anchor,duration:void 0!==l.duration?l.duration:1E3,easing:l.easing||ol.easing.inAndOut};l.center&&(m.sourceCenter=e,m.targetCenter=l.center,e=m.targetCenter);void 0!==l.zoom?(m.sourceResolution=
f,m.targetResolution=this.constrainResolution(this.maxResolution_,l.zoom-this.minZoom_,0),f=m.targetResolution):l.resolution&&(m.sourceResolution=f,m.targetResolution=l.resolution,f=m.targetResolution);void 0!==l.rotation&&(m.sourceRotation=g,l=ol.math.modulo(l.rotation-g+Math.PI,2*Math.PI)-Math.PI,m.targetRotation=g+l,g=m.targetRotation);m.callback=c;ol.View.isNoopAnimation(m)?m.complete=!0:d+=m.duration;h.push(m)}this.animations_.push(h);this.setHint(ol.ViewHint.ANIMATING,1);this.updateAnimations_()}else b=
arguments[b-1],b.center&&this.setCenter(b.center),void 0!==b.zoom&&this.setZoom(b.zoom),void 0!==b.rotation&&this.setRotation(b.rotation),c&&c(!0)};ol.View.prototype.getAnimating=function(){return 0<this.hints_[ol.ViewHint.ANIMATING]};ol.View.prototype.getInteracting=function(){return 0<this.hints_[ol.ViewHint.INTERACTING]};
ol.View.prototype.cancelAnimations=function(){this.setHint(ol.ViewHint.ANIMATING,-this.hints_[ol.ViewHint.ANIMATING]);for(var a=0,b=this.animations_.length;a<b;++a){var c=this.animations_[a];c[0].callback&&c[0].callback(!1)}this.animations_.length=0};
ol.View.prototype.updateAnimations_=function(){void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0);if(this.getAnimating()){for(var a=Date.now(),b=!1,c=this.animations_.length-1;0<=c;--c){for(var d=this.animations_[c],e=!0,f=0,g=d.length;f<g;++f){var h=d[f];if(!h.complete){b=a-h.start;b=0<h.duration?b/h.duration:1;1<=b?(h.complete=!0,b=1):e=!1;b=h.easing(b);if(h.sourceCenter){var k=h.sourceCenter[0],l=h.sourceCenter[1];this.set(ol.ViewProperty.CENTER,
[k+b*(h.targetCenter[0]-k),l+b*(h.targetCenter[1]-l)])}h.sourceResolution&&h.targetResolution&&(k=1===b?h.targetResolution:h.sourceResolution+b*(h.targetResolution-h.sourceResolution),h.anchor&&this.set(ol.ViewProperty.CENTER,this.calculateCenterZoom(k,h.anchor)),this.set(ol.ViewProperty.RESOLUTION,k));void 0!==h.sourceRotation&&void 0!==h.targetRotation&&(b=1===b?ol.math.modulo(h.targetRotation+Math.PI,2*Math.PI)-Math.PI:h.sourceRotation+b*(h.targetRotation-h.sourceRotation),h.anchor&&this.set(ol.ViewProperty.CENTER,
this.calculateCenterRotate(b,h.anchor)),this.set(ol.ViewProperty.ROTATION,b));b=!0;if(!h.complete)break}}e&&(this.animations_[c]=null,this.setHint(ol.ViewHint.ANIMATING,-1),(d=d[0].callback)&&d(!0))}this.animations_=this.animations_.filter(Boolean);b&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_))}};
ol.View.prototype.calculateCenterRotate=function(a,b){var c=this.getCenter();if(void 0!==c){var d=[c[0]-b[0],c[1]-b[1]];ol.coordinate.rotate(d,a-this.getRotation());ol.coordinate.add(d,b)}return d};ol.View.prototype.calculateCenterZoom=function(a,b){var c,d=this.getCenter(),e=this.getResolution();void 0!==d&&void 0!==e&&(c=[b[0]-a*(b[0]-d[0])/e,b[1]-a*(b[1]-d[1])/e]);return c};
ol.View.prototype.getSizeFromViewport_=function(){var a=[100,100],b='.ol-viewport[data-view="'+ol.getUid(this)+'"]';if(b=document.querySelector(b))b=getComputedStyle(b),a[0]=parseInt(b.width,10),a[1]=parseInt(b.height,10);return a};ol.View.prototype.constrainCenter=function(a){return this.constraints_.center(a)};ol.View.prototype.constrainResolution=function(a,b,c){return this.constraints_.resolution(a,b||0,c||0)};
ol.View.prototype.constrainRotation=function(a,b){return this.constraints_.rotation(a,b||0)};ol.View.prototype.getCenter=function(){return this.get(ol.ViewProperty.CENTER)};ol.View.prototype.getConstraints=function(){return this.constraints_};ol.View.prototype.getHints=function(a){return void 0!==a?(a[0]=this.hints_[0],a[1]=this.hints_[1],a):this.hints_.slice()};
ol.View.prototype.calculateExtent=function(a){a=a||this.getSizeFromViewport_();var b=this.getCenter();ol.asserts.assert(b,1);var c=this.getResolution();ol.asserts.assert(void 0!==c,2);var d=this.getRotation();ol.asserts.assert(void 0!==d,3);return ol.extent.getForViewAndSize(b,c,d,a)};ol.View.prototype.getMaxResolution=function(){return this.maxResolution_};ol.View.prototype.getMinResolution=function(){return this.minResolution_};ol.View.prototype.getMaxZoom=function(){return this.getZoomForResolution(this.minResolution_)};
ol.View.prototype.setMaxZoom=function(a){this.applyOptions_(this.getUpdatedOptions_({maxZoom:a}))};ol.View.prototype.getMinZoom=function(){return this.getZoomForResolution(this.maxResolution_)};ol.View.prototype.setMinZoom=function(a){this.applyOptions_(this.getUpdatedOptions_({minZoom:a}))};ol.View.prototype.getProjection=function(){return this.projection_};ol.View.prototype.getResolution=function(){return this.get(ol.ViewProperty.RESOLUTION)};ol.View.prototype.getResolutions=function(){return this.resolutions_};
ol.View.prototype.getResolutionForExtent=function(a,b){var c=b||this.getSizeFromViewport_();b=ol.extent.getWidth(a)/c[0];a=ol.extent.getHeight(a)/c[1];return Math.max(b,a)};ol.View.prototype.getResolutionForValueFunction=function(a){var b=a||2,c=this.maxResolution_,d=Math.log(c/this.minResolution_)/Math.log(b);return function(a){return c/Math.pow(b,a*d)}};ol.View.prototype.getRotation=function(){return this.get(ol.ViewProperty.ROTATION)};
ol.View.prototype.getValueForResolutionFunction=function(a){var b=a||2,c=this.maxResolution_,d=Math.log(c/this.minResolution_)/Math.log(b);return function(a){return Math.log(c/a)/Math.log(b)/d}};ol.View.prototype.getState=function(){var a=this.getCenter(),b=this.getProjection(),c=this.getResolution(),d=this.getRotation();return{center:a.slice(),projection:void 0!==b?b:null,resolution:c,rotation:d,zoom:this.getZoom()}};
ol.View.prototype.getZoom=function(){var a,b=this.getResolution();void 0!==b&&(a=this.getZoomForResolution(b));return a};ol.View.prototype.getZoomForResolution=function(a){var b=this.minZoom_||0,c;if(this.resolutions_){b=c=ol.array.linearFindNearest(this.resolutions_,a,1);var d=this.resolutions_[c];c=c==this.resolutions_.length-1?2:d/this.resolutions_[c+1]}else d=this.maxResolution_,c=this.zoomFactor_;return b+Math.log(d/a)/Math.log(c)};
ol.View.prototype.getResolutionForZoom=function(a){return this.constrainResolution(this.maxResolution_,a-this.minZoom_,0)};
ol.View.prototype.fit=function(a,b){b=b||{};var c=b.size;c||(c=this.getSizeFromViewport_());if(a instanceof ol.geom.SimpleGeometry)if(a.getType()===ol.geom.GeometryType.CIRCLE){a=a.getExtent();var d=ol.geom.Polygon.fromExtent(a);d.rotate(this.getRotation(),ol.extent.getCenter(a))}else d=a;else ol.asserts.assert(Array.isArray(a),24),ol.asserts.assert(!ol.extent.isEmpty(a),25),d=ol.geom.Polygon.fromExtent(a);var e=void 0!==b.padding?b.padding:[0,0,0,0],f=void 0!==b.constrainResolution?b.constrainResolution:
!0,g=void 0!==b.nearest?b.nearest:!1;var h=void 0!==b.minResolution?b.minResolution:void 0!==b.maxZoom?this.constrainResolution(this.maxResolution_,b.maxZoom-this.minZoom_,0):0;var k=d.getFlatCoordinates(),l=this.getRotation();a=Math.cos(-l);l=Math.sin(-l);var m=Infinity,n=Infinity,p=-Infinity,q=-Infinity;d=d.getStride();for(var r=0,u=k.length;r<u;r+=d){var t=k[r]*a-k[r+1]*l,v=k[r]*l+k[r+1]*a;m=Math.min(m,t);n=Math.min(n,v);p=Math.max(p,t);q=Math.max(q,v)}c=this.getResolutionForExtent([m,n,p,q],[c[0]-
e[1]-e[3],c[1]-e[0]-e[2]]);c=isNaN(c)?h:Math.max(c,h);f&&(f=this.constrainResolution(c,0,0),!g&&f<c&&(f=this.constrainResolution(f,-1,0)),c=f);l=-l;g=(m+p)/2+(e[1]-e[3])/2*c;e=(n+q)/2+(e[0]-e[2])/2*c;a=[g*a-e*l,e*a+g*l];e=b.callback?b.callback:ol.nullFunction;void 0!==b.duration?this.animate({resolution:c,center:a,duration:b.duration,easing:b.easing},e):(this.setResolution(c),this.setCenter(a),setTimeout(e.bind(void 0,!0),0))};
ol.View.prototype.centerOn=function(a,b,c){var d=this.getRotation(),e=Math.cos(-d);d=Math.sin(-d);var f=a[0]*e-a[1]*d;a=a[1]*e+a[0]*d;var g=this.getResolution();f+=(b[0]/2-c[0])*g;a+=(c[1]-b[1]/2)*g;d=-d;this.setCenter([f*e-a*d,a*e+f*d])};ol.View.prototype.isDef=function(){return!!this.getCenter()&&void 0!==this.getResolution()};ol.View.prototype.rotate=function(a,b){void 0!==b&&(b=this.calculateCenterRotate(a,b),this.setCenter(b));this.setRotation(a)};
ol.View.prototype.setCenter=function(a){this.set(ol.ViewProperty.CENTER,a);this.getAnimating()&&this.cancelAnimations()};ol.View.prototype.setHint=function(a,b){this.hints_[a]+=b;this.changed();return this.hints_[a]};ol.View.prototype.setResolution=function(a){this.set(ol.ViewProperty.RESOLUTION,a);this.getAnimating()&&this.cancelAnimations()};ol.View.prototype.setRotation=function(a){this.set(ol.ViewProperty.ROTATION,a);this.getAnimating()&&this.cancelAnimations()};ol.View.prototype.setZoom=function(a){this.setResolution(this.getResolutionForZoom(a))};
ol.View.createCenterConstraint_=function(a){return void 0!==a.extent?ol.CenterConstraint.createExtent(a.extent):ol.CenterConstraint.none};
ol.View.createResolutionConstraint_=function(a){var b=void 0!==a.minZoom?a.minZoom:ol.DEFAULT_MIN_ZOOM;var c=void 0!==a.maxZoom?a.maxZoom:28;var d=void 0!==a.zoomFactor?a.zoomFactor:2;if(void 0!==a.resolutions){a=a.resolutions;var e=a[b];var f=void 0!==a[c]?a[c]:a[a.length-1];c=ol.ResolutionConstraint.createSnapToResolutions(a)}else{e=ol.proj.createProjection(a.projection,"EPSG:3857");f=e.getExtent();var g=(f?Math.max(ol.extent.getWidth(f),ol.extent.getHeight(f)):360*ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES]/
e.getMetersPerUnit())/ol.DEFAULT_TILE_SIZE/Math.pow(2,ol.DEFAULT_MIN_ZOOM),h=g/Math.pow(2,28-ol.DEFAULT_MIN_ZOOM);e=a.maxResolution;void 0!==e?b=0:e=g/Math.pow(d,b);f=a.minResolution;void 0===f&&(f=void 0!==a.maxZoom?void 0!==a.maxResolution?e/Math.pow(d,c):g/Math.pow(d,c):h);c=b+Math.floor(Math.log(e/f)/Math.log(d));f=e/Math.pow(d,c-b);c=ol.ResolutionConstraint.createSnapToPower(d,e,c-b)}return{constraint:c,maxResolution:e,minResolution:f,minZoom:b,zoomFactor:d}};
ol.View.createRotationConstraint_=function(a){return(void 0!==a.enableRotation?a.enableRotation:1)?(a=a.constrainRotation,void 0===a||!0===a?ol.RotationConstraint.createSnapToZero():!1===a?ol.RotationConstraint.none:"number"===typeof a?ol.RotationConstraint.createSnapToN(a):ol.RotationConstraint.none):ol.RotationConstraint.disable};
ol.View.isNoopAnimation=function(a){return a.sourceCenter&&a.targetCenter&&!ol.coordinate.equals(a.sourceCenter,a.targetCenter)||a.sourceResolution!==a.targetResolution||a.sourceRotation!==a.targetRotation?!1:!0};ol.dom={};ol.dom.createCanvasContext2D=function(a,b){var c=document.createElement("CANVAS");a&&(c.width=a);b&&(c.height=b);return c.getContext("2d")};ol.dom.outerWidth=function(a){var b=a.offsetWidth;a=getComputedStyle(a);return b+=parseInt(a.marginLeft,10)+parseInt(a.marginRight,10)};ol.dom.outerHeight=function(a){var b=a.offsetHeight;a=getComputedStyle(a);return b+=parseInt(a.marginTop,10)+parseInt(a.marginBottom,10)};ol.dom.replaceNode=function(a,b){var c=b.parentNode;c&&c.replaceChild(a,b)};
ol.dom.removeNode=function(a){return a&&a.parentNode?a.parentNode.removeChild(a):null};ol.dom.removeChildren=function(a){for(;a.lastChild;)a.removeChild(a.lastChild)};ol.layer={};ol.layer.Property={OPACITY:"opacity",VISIBLE:"visible",EXTENT:"extent",Z_INDEX:"zIndex",MAX_RESOLUTION:"maxResolution",MIN_RESOLUTION:"minResolution",SOURCE:"source"};ol.layer.Base=function(a){ol.Object.call(this);var b=ol.obj.assign({},a);b[ol.layer.Property.OPACITY]=void 0!==a.opacity?a.opacity:1;b[ol.layer.Property.VISIBLE]=void 0!==a.visible?a.visible:!0;b[ol.layer.Property.Z_INDEX]=void 0!==a.zIndex?a.zIndex:0;b[ol.layer.Property.MAX_RESOLUTION]=void 0!==a.maxResolution?a.maxResolution:Infinity;b[ol.layer.Property.MIN_RESOLUTION]=void 0!==a.minResolution?a.minResolution:0;this.setProperties(b);this.state_={layer:this,managed:!0}};
ol.inherits(ol.layer.Base,ol.Object);ol.layer.Base.prototype.getType=function(){return this.type};ol.layer.Base.prototype.getLayerState=function(){this.state_.opacity=ol.math.clamp(this.getOpacity(),0,1);this.state_.sourceState=this.getSourceState();this.state_.visible=this.getVisible();this.state_.extent=this.getExtent();this.state_.zIndex=this.getZIndex();this.state_.maxResolution=this.getMaxResolution();this.state_.minResolution=Math.max(this.getMinResolution(),0);return this.state_};
ol.layer.Base.prototype.getLayersArray=function(a){};ol.layer.Base.prototype.getLayerStatesArray=function(a){};ol.layer.Base.prototype.getExtent=function(){return this.get(ol.layer.Property.EXTENT)};ol.layer.Base.prototype.getMaxResolution=function(){return this.get(ol.layer.Property.MAX_RESOLUTION)};ol.layer.Base.prototype.getMinResolution=function(){return this.get(ol.layer.Property.MIN_RESOLUTION)};ol.layer.Base.prototype.getOpacity=function(){return this.get(ol.layer.Property.OPACITY)};
ol.layer.Base.prototype.getSourceState=function(){};ol.layer.Base.prototype.getVisible=function(){return this.get(ol.layer.Property.VISIBLE)};ol.layer.Base.prototype.getZIndex=function(){return this.get(ol.layer.Property.Z_INDEX)};ol.layer.Base.prototype.setExtent=function(a){this.set(ol.layer.Property.EXTENT,a)};ol.layer.Base.prototype.setMaxResolution=function(a){this.set(ol.layer.Property.MAX_RESOLUTION,a)};
ol.layer.Base.prototype.setMinResolution=function(a){this.set(ol.layer.Property.MIN_RESOLUTION,a)};ol.layer.Base.prototype.setOpacity=function(a){this.set(ol.layer.Property.OPACITY,a)};ol.layer.Base.prototype.setVisible=function(a){this.set(ol.layer.Property.VISIBLE,a)};ol.layer.Base.prototype.setZIndex=function(a){this.set(ol.layer.Property.Z_INDEX,a)};ol.source={};ol.source.State={UNDEFINED:"undefined",LOADING:"loading",READY:"ready",ERROR:"error"};ol.layer.Group=function(a){var b=a||{};a=ol.obj.assign({},b);delete a.layers;b=b.layers;ol.layer.Base.call(this,a);this.layersListenerKeys_=[];this.listenerKeys_={};ol.events.listen(this,ol.Object.getChangeEventType(ol.layer.Group.Property_.LAYERS),this.handleLayersChanged_,this);b?Array.isArray(b)?b=new ol.Collection(b.slice(),{unique:!0}):ol.asserts.assert(b instanceof ol.Collection,43):b=new ol.Collection(void 0,{unique:!0});this.setLayers(b)};ol.inherits(ol.layer.Group,ol.layer.Base);
ol.layer.Group.prototype.handleLayerChange_=function(){this.changed()};
ol.layer.Group.prototype.handleLayersChanged_=function(a){this.layersListenerKeys_.forEach(ol.events.unlistenByKey);this.layersListenerKeys_.length=0;a=this.getLayers();this.layersListenerKeys_.push(ol.events.listen(a,ol.CollectionEventType.ADD,this.handleLayersAdd_,this),ol.events.listen(a,ol.CollectionEventType.REMOVE,this.handleLayersRemove_,this));for(var b in this.listenerKeys_)this.listenerKeys_[b].forEach(ol.events.unlistenByKey);ol.obj.clear(this.listenerKeys_);b=a.getArray();var c;a=0;for(c=
b.length;a<c;a++){var d=b[a];this.listenerKeys_[ol.getUid(d).toString()]=[ol.events.listen(d,ol.ObjectEventType.PROPERTYCHANGE,this.handleLayerChange_,this),ol.events.listen(d,ol.events.EventType.CHANGE,this.handleLayerChange_,this)]}this.changed()};
ol.layer.Group.prototype.handleLayersAdd_=function(a){a=a.element;var b=ol.getUid(a).toString();this.listenerKeys_[b]=[ol.events.listen(a,ol.ObjectEventType.PROPERTYCHANGE,this.handleLayerChange_,this),ol.events.listen(a,ol.events.EventType.CHANGE,this.handleLayerChange_,this)];this.changed()};ol.layer.Group.prototype.handleLayersRemove_=function(a){a=ol.getUid(a.element).toString();this.listenerKeys_[a].forEach(ol.events.unlistenByKey);delete this.listenerKeys_[a];this.changed()};
ol.layer.Group.prototype.getLayers=function(){return this.get(ol.layer.Group.Property_.LAYERS)};ol.layer.Group.prototype.setLayers=function(a){this.set(ol.layer.Group.Property_.LAYERS,a)};ol.layer.Group.prototype.getLayersArray=function(a){var b=void 0!==a?a:[];this.getLayers().forEach(function(a){a.getLayersArray(b)});return b};
ol.layer.Group.prototype.getLayerStatesArray=function(a){var b=void 0!==a?a:[],c=b.length;this.getLayers().forEach(function(a){a.getLayerStatesArray(b)});a=this.getLayerState();var d;for(d=b.length;c<d;c++){var e=b[c];e.opacity*=a.opacity;e.visible=e.visible&&a.visible;e.maxResolution=Math.min(e.maxResolution,a.maxResolution);e.minResolution=Math.max(e.minResolution,a.minResolution);void 0!==a.extent&&(e.extent=void 0!==e.extent?ol.extent.getIntersection(e.extent,a.extent):a.extent)}return b};
ol.layer.Group.prototype.getSourceState=function(){return ol.source.State.READY};ol.layer.Group.Property_={LAYERS:"layers"};ol.PluginType={MAP_RENDERER:"MAP_RENDERER",LAYER_RENDERER:"LAYER_RENDERER"};ol.plugins={};ol.plugins.mapRendererPlugins_=[];ol.plugins.getMapRendererPlugins=function(){return ol.plugins.mapRendererPlugins_};ol.plugins.layerRendererPlugins_=[];ol.plugins.getLayerRendererPlugins=function(){return ol.plugins.layerRendererPlugins_};
ol.plugins.register=function(a,b){switch(a){case ol.PluginType.MAP_RENDERER:a=ol.plugins.mapRendererPlugins_;a.push(b);break;case ol.PluginType.LAYER_RENDERER:a=ol.plugins.layerRendererPlugins_;a.push(b);break;default:throw Error("Unsupported plugin type: "+a);}};ol.plugins.registerMultiple=function(a,b){for(var c=0,d=b.length;c<d;++c)ol.plugins.register(a,b[c])};ol.renderer={};ol.renderer.Type={CANVAS:"canvas",WEBGL:"webgl"};ol.PluggableMap=function(a){ol.Object.call(this);var b=ol.PluggableMap.createOptionsInternal(a);this.loadTilesWhileAnimating_=void 0!==a.loadTilesWhileAnimating?a.loadTilesWhileAnimating:!1;this.loadTilesWhileInteracting_=void 0!==a.loadTilesWhileInteracting?a.loadTilesWhileInteracting:!1;this.pixelRatio_=void 0!==a.pixelRatio?a.pixelRatio:ol.has.DEVICE_PIXEL_RATIO;this.logos_=b.logos;this.animationDelay_=function(){this.animationDelayKey_=void 0;this.renderFrame_.call(this,Date.now())}.bind(this);
this.coordinateToPixelTransform_=ol.transform.create();this.pixelToCoordinateTransform_=ol.transform.create();this.frameIndex_=0;this.layerGroupPropertyListenerKeys_=this.viewChangeListenerKey_=this.viewPropertyListenerKey_=this.previousExtent_=this.frameState_=null;this.viewport_=document.createElement("DIV");this.viewport_.className="ol-viewport"+(ol.has.TOUCH?" ol-touch":"");this.viewport_.style.position="relative";this.viewport_.style.overflow="hidden";this.viewport_.style.width="100%";this.viewport_.style.height=
"100%";this.viewport_.style.msTouchAction="none";this.viewport_.style.touchAction="none";this.overlayContainer_=document.createElement("DIV");this.overlayContainer_.className="ol-overlaycontainer";this.viewport_.appendChild(this.overlayContainer_);this.overlayContainerStopEvent_=document.createElement("DIV");this.overlayContainerStopEvent_.className="ol-overlaycontainer-stopevent";for(var c=[ol.events.EventType.CLICK,ol.events.EventType.DBLCLICK,ol.events.EventType.MOUSEDOWN,ol.events.EventType.TOUCHSTART,
ol.events.EventType.MSPOINTERDOWN,ol.MapBrowserEventType.POINTERDOWN,ol.events.EventType.MOUSEWHEEL,ol.events.EventType.WHEEL],d=0,e=c.length;d<e;++d)ol.events.listen(this.overlayContainerStopEvent_,c[d],ol.events.Event.stopPropagation);this.viewport_.appendChild(this.overlayContainerStopEvent_);this.mapBrowserEventHandler_=new ol.MapBrowserEventHandler(this,a.moveTolerance);for(var f in ol.MapBrowserEventType)ol.events.listen(this.mapBrowserEventHandler_,ol.MapBrowserEventType[f],this.handleMapBrowserEvent,
this);this.keyboardEventTarget_=b.keyboardEventTarget;this.keyHandlerKeys_=null;ol.events.listen(this.viewport_,ol.events.EventType.WHEEL,this.handleBrowserEvent,this);ol.events.listen(this.viewport_,ol.events.EventType.MOUSEWHEEL,this.handleBrowserEvent,this);this.controls=b.controls||new ol.Collection;this.interactions=b.interactions||new ol.Collection;this.overlays_=b.overlays;this.overlayIdIndex_={};this.renderer_=b.mapRendererPlugin.create(this.viewport_,this);this.focus_=null;this.postRenderFunctions_=
[];this.tileQueue_=new ol.TileQueue(this.getTilePriority.bind(this),this.handleTileChange_.bind(this));this.skippedFeatureUids_={};ol.events.listen(this,ol.Object.getChangeEventType(ol.MapProperty.LAYERGROUP),this.handleLayerGroupChanged_,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.MapProperty.VIEW),this.handleViewChanged_,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.MapProperty.SIZE),this.handleSizeChanged_,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.MapProperty.TARGET),
this.handleTargetChanged_,this);this.setProperties(b.values);this.controls.forEach(function(a){a.setMap(this)},this);ol.events.listen(this.controls,ol.CollectionEventType.ADD,function(a){a.element.setMap(this)},this);ol.events.listen(this.controls,ol.CollectionEventType.REMOVE,function(a){a.element.setMap(null)},this);this.interactions.forEach(function(a){a.setMap(this)},this);ol.events.listen(this.interactions,ol.CollectionEventType.ADD,function(a){a.element.setMap(this)},this);ol.events.listen(this.interactions,
ol.CollectionEventType.REMOVE,function(a){a.element.setMap(null)},this);this.overlays_.forEach(this.addOverlayInternal_,this);ol.events.listen(this.overlays_,ol.CollectionEventType.ADD,function(a){this.addOverlayInternal_(a.element)},this);ol.events.listen(this.overlays_,ol.CollectionEventType.REMOVE,function(a){var b=a.element.getId();void 0!==b&&delete this.overlayIdIndex_[b.toString()];a.element.setMap(null)},this)};ol.inherits(ol.PluggableMap,ol.Object);ol.PluggableMap.prototype.addControl=function(a){this.getControls().push(a)};
ol.PluggableMap.prototype.addInteraction=function(a){this.getInteractions().push(a)};ol.PluggableMap.prototype.addLayer=function(a){this.getLayerGroup().getLayers().push(a)};ol.PluggableMap.prototype.addOverlay=function(a){this.getOverlays().push(a)};ol.PluggableMap.prototype.addOverlayInternal_=function(a){var b=a.getId();void 0!==b&&(this.overlayIdIndex_[b.toString()]=a);a.setMap(this)};
ol.PluggableMap.prototype.disposeInternal=function(){this.mapBrowserEventHandler_.dispose();ol.events.unlisten(this.viewport_,ol.events.EventType.WHEEL,this.handleBrowserEvent,this);ol.events.unlisten(this.viewport_,ol.events.EventType.MOUSEWHEEL,this.handleBrowserEvent,this);void 0!==this.handleResize_&&(window.removeEventListener(ol.events.EventType.RESIZE,this.handleResize_,!1),this.handleResize_=void 0);this.animationDelayKey_&&(cancelAnimationFrame(this.animationDelayKey_),this.animationDelayKey_=
void 0);this.setTarget(null);ol.Object.prototype.disposeInternal.call(this)};ol.PluggableMap.prototype.forEachFeatureAtPixel=function(a,b,c){if(this.frameState_)return a=this.getCoordinateFromPixel(a),c=void 0!==c?c:{},this.renderer_.forEachFeatureAtCoordinate(a,this.frameState_,void 0!==c.hitTolerance?c.hitTolerance*this.frameState_.pixelRatio:0,b,null,void 0!==c.layerFilter?c.layerFilter:ol.functions.TRUE,null)};
ol.PluggableMap.prototype.getFeaturesAtPixel=function(a,b){var c=null;this.forEachFeatureAtPixel(a,function(a){c||(c=[]);c.push(a)},b);return c};ol.PluggableMap.prototype.forEachLayerAtPixel=function(a,b,c,d,e){if(this.frameState_)return this.renderer_.forEachLayerAtPixel(a,this.frameState_,b,void 0!==c?c:null,void 0!==d?d:ol.functions.TRUE,void 0!==e?e:null)};
ol.PluggableMap.prototype.hasFeatureAtPixel=function(a,b){if(!this.frameState_)return!1;a=this.getCoordinateFromPixel(a);b=void 0!==b?b:{};return this.renderer_.hasFeatureAtCoordinate(a,this.frameState_,void 0!==b.hitTolerance?b.hitTolerance*this.frameState_.pixelRatio:0,void 0!==b.layerFilter?b.layerFilter:ol.functions.TRUE,null)};ol.PluggableMap.prototype.getEventCoordinate=function(a){return this.getCoordinateFromPixel(this.getEventPixel(a))};
ol.PluggableMap.prototype.getEventPixel=function(a){var b=this.viewport_.getBoundingClientRect();a=a.changedTouches?a.changedTouches[0]:a;return[a.clientX-b.left,a.clientY-b.top]};ol.PluggableMap.prototype.getTarget=function(){return this.get(ol.MapProperty.TARGET)};ol.PluggableMap.prototype.getTargetElement=function(){var a=this.getTarget();return void 0!==a?"string"===typeof a?document.getElementById(a):a:null};
ol.PluggableMap.prototype.getCoordinateFromPixel=function(a){var b=this.frameState_;return b?ol.transform.apply(b.pixelToCoordinateTransform,a.slice()):null};ol.PluggableMap.prototype.getControls=function(){return this.controls};ol.PluggableMap.prototype.getOverlays=function(){return this.overlays_};ol.PluggableMap.prototype.getOverlayById=function(a){a=this.overlayIdIndex_[a.toString()];return void 0!==a?a:null};ol.PluggableMap.prototype.getInteractions=function(){return this.interactions};
ol.PluggableMap.prototype.getLayerGroup=function(){return this.get(ol.MapProperty.LAYERGROUP)};ol.PluggableMap.prototype.getLayers=function(){return this.getLayerGroup().getLayers()};ol.PluggableMap.prototype.getPixelFromCoordinate=function(a){var b=this.frameState_;return b?ol.transform.apply(b.coordinateToPixelTransform,a.slice(0,2)):null};ol.PluggableMap.prototype.getRenderer=function(){return this.renderer_};ol.PluggableMap.prototype.getSize=function(){return this.get(ol.MapProperty.SIZE)};
ol.PluggableMap.prototype.getView=function(){return this.get(ol.MapProperty.VIEW)};ol.PluggableMap.prototype.getViewport=function(){return this.viewport_};ol.PluggableMap.prototype.getOverlayContainer=function(){return this.overlayContainer_};ol.PluggableMap.prototype.getOverlayContainerStopEvent=function(){return this.overlayContainerStopEvent_};
ol.PluggableMap.prototype.getTilePriority=function(a,b,c,d){var e=this.frameState_;if(!(e&&b in e.wantedTiles&&e.wantedTiles[b][a.getKey()]))return ol.structs.PriorityQueue.DROP;a=c[0]-e.focus[0];c=c[1]-e.focus[1];return 65536*Math.log(d)+Math.sqrt(a*a+c*c)/d};ol.PluggableMap.prototype.handleBrowserEvent=function(a,b){a=new ol.MapBrowserEvent(b||a.type,this,a);this.handleMapBrowserEvent(a)};
ol.PluggableMap.prototype.handleMapBrowserEvent=function(a){if(this.frameState_){this.focus_=a.coordinate;a.frameState=this.frameState_;var b=this.getInteractions().getArray(),c;if(!1!==this.dispatchEvent(a))for(c=b.length-1;0<=c;c--){var d=b[c];if(d.getActive()&&!d.handleEvent(a))break}}};
ol.PluggableMap.prototype.handlePostRender=function(){var a=this.frameState_,b=this.tileQueue_;if(!b.isEmpty()){var c=16,d=c;if(a){var e=a.viewHints;e[ol.ViewHint.ANIMATING]&&(c=this.loadTilesWhileAnimating_?8:0,d=2);e[ol.ViewHint.INTERACTING]&&(c=this.loadTilesWhileInteracting_?8:0,d=2)}b.getTilesLoading()<c&&(b.reprioritize(),b.loadMoreTiles(c,d))}b=this.postRenderFunctions_;c=0;for(d=b.length;c<d;++c)b[c](this,a);b.length=0};ol.PluggableMap.prototype.handleSizeChanged_=function(){this.render()};
ol.PluggableMap.prototype.handleTargetChanged_=function(){var a;this.getTarget()&&(a=this.getTargetElement());if(this.keyHandlerKeys_){for(var b=0,c=this.keyHandlerKeys_.length;b<c;++b)ol.events.unlistenByKey(this.keyHandlerKeys_[b]);this.keyHandlerKeys_=null}a?(a.appendChild(this.viewport_),a=this.keyboardEventTarget_?this.keyboardEventTarget_:a,this.keyHandlerKeys_=[ol.events.listen(a,ol.events.EventType.KEYDOWN,this.handleBrowserEvent,this),ol.events.listen(a,ol.events.EventType.KEYPRESS,this.handleBrowserEvent,
this)],this.handleResize_||(this.handleResize_=this.updateSize.bind(this),window.addEventListener(ol.events.EventType.RESIZE,this.handleResize_,!1))):(this.renderer_.removeLayerRenderers(),ol.dom.removeNode(this.viewport_),void 0!==this.handleResize_&&(window.removeEventListener(ol.events.EventType.RESIZE,this.handleResize_,!1),this.handleResize_=void 0));this.updateSize()};ol.PluggableMap.prototype.handleTileChange_=function(){this.render()};ol.PluggableMap.prototype.handleViewPropertyChanged_=function(){this.render()};
ol.PluggableMap.prototype.handleViewChanged_=function(){this.viewPropertyListenerKey_&&(ol.events.unlistenByKey(this.viewPropertyListenerKey_),this.viewPropertyListenerKey_=null);this.viewChangeListenerKey_&&(ol.events.unlistenByKey(this.viewChangeListenerKey_),this.viewChangeListenerKey_=null);var a=this.getView();a&&(this.viewport_.setAttribute("data-view",ol.getUid(a)),this.viewPropertyListenerKey_=ol.events.listen(a,ol.ObjectEventType.PROPERTYCHANGE,this.handleViewPropertyChanged_,this),this.viewChangeListenerKey_=
ol.events.listen(a,ol.events.EventType.CHANGE,this.handleViewPropertyChanged_,this));this.render()};
ol.PluggableMap.prototype.handleLayerGroupChanged_=function(){this.layerGroupPropertyListenerKeys_&&(this.layerGroupPropertyListenerKeys_.forEach(ol.events.unlistenByKey),this.layerGroupPropertyListenerKeys_=null);var a=this.getLayerGroup();a&&(this.layerGroupPropertyListenerKeys_=[ol.events.listen(a,ol.ObjectEventType.PROPERTYCHANGE,this.render,this),ol.events.listen(a,ol.events.EventType.CHANGE,this.render,this)]);this.render()};ol.PluggableMap.prototype.isRendered=function(){return!!this.frameState_};
ol.PluggableMap.prototype.renderSync=function(){this.animationDelayKey_&&cancelAnimationFrame(this.animationDelayKey_);this.animationDelay_()};ol.PluggableMap.prototype.render=function(){void 0===this.animationDelayKey_&&(this.animationDelayKey_=requestAnimationFrame(this.animationDelay_))};ol.PluggableMap.prototype.removeControl=function(a){return this.getControls().remove(a)};ol.PluggableMap.prototype.removeInteraction=function(a){return this.getInteractions().remove(a)};
ol.PluggableMap.prototype.removeLayer=function(a){return this.getLayerGroup().getLayers().remove(a)};ol.PluggableMap.prototype.removeOverlay=function(a){return this.getOverlays().remove(a)};
ol.PluggableMap.prototype.renderFrame_=function(a){var b,c=this.getSize(),d=this.getView(),e=ol.extent.createEmpty(),f=this.frameState_,g=null;if(void 0!==c&&ol.size.hasArea(c)&&d&&d.isDef()){g=d.getHints(this.frameState_?this.frameState_.viewHints:void 0);var h=this.getLayerGroup().getLayerStatesArray(),k={};var l=0;for(b=h.length;l<b;++l)k[ol.getUid(h[l].layer)]=h[l];l=d.getState();d=l.center;b=l.resolution/this.pixelRatio_;d[0]=Math.round(d[0]/b)*b;d[1]=Math.round(d[1]/b)*b;g={animate:!1,coordinateToPixelTransform:this.coordinateToPixelTransform_,
extent:e,focus:this.focus_?this.focus_:d,index:this.frameIndex_++,layerStates:k,layerStatesArray:h,logos:ol.obj.assign({},this.logos_),pixelRatio:this.pixelRatio_,pixelToCoordinateTransform:this.pixelToCoordinateTransform_,postRenderFunctions:[],size:c,skippedFeatureUids:this.skippedFeatureUids_,tileQueue:this.tileQueue_,time:a,usedTiles:{},viewState:l,viewHints:g,wantedTiles:{}}}g&&(g.extent=ol.extent.getForViewAndSize(l.center,l.resolution,l.rotation,g.size,e));this.frameState_=g;this.renderer_.renderFrame(g);
g&&(g.animate&&this.render(),Array.prototype.push.apply(this.postRenderFunctions_,g.postRenderFunctions),!f||this.previousExtent_&&(ol.extent.isEmpty(this.previousExtent_)||ol.extent.equals(g.extent,this.previousExtent_))||(this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVESTART,this,f)),this.previousExtent_=ol.extent.createOrUpdateEmpty(this.previousExtent_)),!this.previousExtent_||g.viewHints[ol.ViewHint.ANIMATING]||g.viewHints[ol.ViewHint.INTERACTING]||ol.extent.equals(g.extent,this.previousExtent_)||
(this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVEEND,this,g)),ol.extent.clone(g.extent,this.previousExtent_)));this.dispatchEvent(new ol.MapEvent(ol.MapEventType.POSTRENDER,this,g));setTimeout(this.handlePostRender.bind(this),0)};ol.PluggableMap.prototype.setLayerGroup=function(a){this.set(ol.MapProperty.LAYERGROUP,a)};ol.PluggableMap.prototype.setSize=function(a){this.set(ol.MapProperty.SIZE,a)};ol.PluggableMap.prototype.setTarget=function(a){this.set(ol.MapProperty.TARGET,a)};
ol.PluggableMap.prototype.setView=function(a){this.set(ol.MapProperty.VIEW,a)};ol.PluggableMap.prototype.skipFeature=function(a){a=ol.getUid(a).toString();this.skippedFeatureUids_[a]=!0;this.render()};
ol.PluggableMap.prototype.updateSize=function(){var a=this.getTargetElement();if(a){var b=getComputedStyle(a);this.setSize([a.offsetWidth-parseFloat(b.borderLeftWidth)-parseFloat(b.paddingLeft)-parseFloat(b.paddingRight)-parseFloat(b.borderRightWidth),a.offsetHeight-parseFloat(b.borderTopWidth)-parseFloat(b.paddingTop)-parseFloat(b.paddingBottom)-parseFloat(b.borderBottomWidth)])}else this.setSize(void 0)};
ol.PluggableMap.prototype.unskipFeature=function(a){a=ol.getUid(a).toString();delete this.skippedFeatureUids_[a];this.render()};ol.PluggableMap.DEFAULT_RENDERER_TYPES=[ol.renderer.Type.CANVAS,ol.renderer.Type.WEBGL];ol.PluggableMap.LOGO_URL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszWWMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvYasvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvXH1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1VkbMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLPVcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqTacrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaarldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+HizeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDnBAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSFhYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJREFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxCBrb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7ahgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCnB3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDgq82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC";
ol.PluggableMap.createOptionsInternal=function(a){var b=null;void 0!==a.keyboardEventTarget&&(b="string"===typeof a.keyboardEventTarget?document.getElementById(a.keyboardEventTarget):a.keyboardEventTarget);var c={},d={};if(void 0===a.logo||"boolean"===typeof a.logo&&a.logo)d[ol.PluggableMap.LOGO_URL]="https://openlayers.org/";else{var e=a.logo;"string"===typeof e?d[e]="":e instanceof HTMLElement?d[ol.getUid(e).toString()]=e:e&&(ol.asserts.assert("string"==typeof e.href,44),ol.asserts.assert("string"==
typeof e.src,45),d[e.src]=e.href)}e=a.layers instanceof ol.layer.Group?a.layers:new ol.layer.Group({layers:a.layers});c[ol.MapProperty.LAYERGROUP]=e;c[ol.MapProperty.TARGET]=a.target;c[ol.MapProperty.VIEW]=void 0!==a.view?a.view:new ol.View;var f;void 0!==a.renderer?(Array.isArray(a.renderer)?f=a.renderer:"string"===typeof a.renderer?f=[a.renderer]:ol.asserts.assert(!1,46),0<=f.indexOf("dom")&&(f=f.concat(ol.PluggableMap.DEFAULT_RENDERER_TYPES))):f=ol.PluggableMap.DEFAULT_RENDERER_TYPES;e=ol.plugins.getMapRendererPlugins();
var g=0,h=f.length;a:for(;g<h;++g)for(var k=f[g],l=0,m=e.length;l<m;++l){var n=e[l];if(n.handles(k)){var p=n;break a}}if(!p)throw Error("Unable to create a map renderer for types: "+f.join(", "));if(void 0!==a.controls)if(Array.isArray(a.controls))var q=new ol.Collection(a.controls.slice());else ol.asserts.assert(a.controls instanceof ol.Collection,47),q=a.controls;if(void 0!==a.interactions)if(Array.isArray(a.interactions))var r=new ol.Collection(a.interactions.slice());else ol.asserts.assert(a.interactions instanceof
ol.Collection,48),r=a.interactions;void 0!==a.overlays?Array.isArray(a.overlays)?a=new ol.Collection(a.overlays.slice()):(ol.asserts.assert(a.overlays instanceof ol.Collection,49),a=a.overlays):a=new ol.Collection;return{controls:q,interactions:r,keyboardEventTarget:b,logos:d,overlays:a,mapRendererPlugin:p,values:c}};ol.control={};ol.control.Control=function(a){ol.Object.call(this);this.element=a.element?a.element:null;this.map_=this.target_=null;this.listenerKeys=[];this.render=a.render?a.render:ol.nullFunction;a.target&&this.setTarget(a.target)};ol.inherits(ol.control.Control,ol.Object);ol.control.Control.prototype.disposeInternal=function(){ol.dom.removeNode(this.element);ol.Object.prototype.disposeInternal.call(this)};ol.control.Control.prototype.getMap=function(){return this.map_};
ol.control.Control.prototype.setMap=function(a){this.map_&&ol.dom.removeNode(this.element);for(var b=0,c=this.listenerKeys.length;b<c;++b)ol.events.unlistenByKey(this.listenerKeys[b]);this.listenerKeys.length=0;if(this.map_=a)(this.target_?this.target_:a.getOverlayContainerStopEvent()).appendChild(this.element),this.render!==ol.nullFunction&&this.listenerKeys.push(ol.events.listen(a,ol.MapEventType.POSTRENDER,this.render,this)),a.render()};
ol.control.Control.prototype.setTarget=function(a){this.target_="string"===typeof a?document.getElementById(a):a};ol.css={};ol.css.CLASS_HIDDEN="ol-hidden";ol.css.CLASS_SELECTABLE="ol-selectable";ol.css.CLASS_UNSELECTABLE="ol-unselectable";ol.css.CLASS_UNSUPPORTED="ol-unsupported";ol.css.CLASS_CONTROL="ol-control";ol.css.getFontFamilies=function(){var a,b={};return function(c){a||(a=document.createElement("div").style);if(!(c in b)){a.font=c;var d=a.fontFamily;a.font="";if(!d)return null;b[c]=d.split(/,\s?/)}return b[c]}}();ol.render={};ol.render.EventType={POSTCOMPOSE:"postcompose",PRECOMPOSE:"precompose",RENDER:"render"};ol.layer.Layer=function(a){var b=ol.obj.assign({},a);delete b.source;ol.layer.Base.call(this,b);this.sourceChangeKey_=this.mapRenderKey_=this.mapPrecomposeKey_=null;a.map&&this.setMap(a.map);ol.events.listen(this,ol.Object.getChangeEventType(ol.layer.Property.SOURCE),this.handleSourcePropertyChange_,this);this.setSource(a.source?a.source:null)};ol.inherits(ol.layer.Layer,ol.layer.Base);ol.layer.Layer.visibleAtResolution=function(a,b){return a.visible&&b>=a.minResolution&&b<a.maxResolution};
ol.layer.Layer.prototype.getLayersArray=function(a){a=a?a:[];a.push(this);return a};ol.layer.Layer.prototype.getLayerStatesArray=function(a){a=a?a:[];a.push(this.getLayerState());return a};ol.layer.Layer.prototype.getSource=function(){return this.get(ol.layer.Property.SOURCE)||null};ol.layer.Layer.prototype.getSourceState=function(){var a=this.getSource();return a?a.getState():ol.source.State.UNDEFINED};ol.layer.Layer.prototype.handleSourceChange_=function(){this.changed()};
ol.layer.Layer.prototype.handleSourcePropertyChange_=function(){this.sourceChangeKey_&&(ol.events.unlistenByKey(this.sourceChangeKey_),this.sourceChangeKey_=null);var a=this.getSource();a&&(this.sourceChangeKey_=ol.events.listen(a,ol.events.EventType.CHANGE,this.handleSourceChange_,this));this.changed()};
ol.layer.Layer.prototype.setMap=function(a){this.mapPrecomposeKey_&&(ol.events.unlistenByKey(this.mapPrecomposeKey_),this.mapPrecomposeKey_=null);a||this.changed();this.mapRenderKey_&&(ol.events.unlistenByKey(this.mapRenderKey_),this.mapRenderKey_=null);a&&(this.mapPrecomposeKey_=ol.events.listen(a,ol.render.EventType.PRECOMPOSE,function(a){var b=this.getLayerState();b.managed=!1;b.zIndex=Infinity;a.frameState.layerStatesArray.push(b);a.frameState.layerStates[ol.getUid(this)]=b},this),this.mapRenderKey_=
ol.events.listen(this,ol.events.EventType.CHANGE,a.render,a),this.changed())};ol.layer.Layer.prototype.setSource=function(a){this.set(ol.layer.Property.SOURCE,a)};ol.control.Attribution=function(a){a=a?a:{};this.ulElement_=document.createElement("UL");this.logoLi_=document.createElement("LI");this.ulElement_.appendChild(this.logoLi_);this.logoLi_.style.display="none";this.collapsed_=void 0!==a.collapsed?a.collapsed:!0;this.collapsible_=void 0!==a.collapsible?a.collapsible:!0;this.collapsible_||(this.collapsed_=!1);var b=void 0!==a.className?a.className:"ol-attribution",c=void 0!==a.tipLabel?a.tipLabel:"Attributions",d=void 0!==a.collapseLabel?a.collapseLabel:
"\u00bb";"string"===typeof d?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=d):this.collapseLabel_=d;d=void 0!==a.label?a.label:"i";"string"===typeof d?(this.label_=document.createElement("span"),this.label_.textContent=d):this.label_=d;var e=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_;d=document.createElement("button");d.setAttribute("type","button");d.title=c;d.appendChild(e);ol.events.listen(d,ol.events.EventType.CLICK,this.handleClick_,
this);b=b+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL+(this.collapsed_&&this.collapsible_?" ol-collapsed":"")+(this.collapsible_?"":" ol-uncollapsible");c=document.createElement("div");c.className=b;c.appendChild(this.ulElement_);c.appendChild(d);ol.control.Control.call(this,{element:c,render:a.render?a.render:ol.control.Attribution.render,target:a.target});this.renderedAttributions_=[];this.renderedVisible_=!0;this.logoElements_={}};ol.inherits(ol.control.Attribution,ol.control.Control);
ol.control.Attribution.prototype.getSourceAttributions_=function(a){for(var b={},c=[],d=a.layerStatesArray,e=a.viewState.resolution,f=0,g=d.length;f<g;++f){var h=d[f];if(ol.layer.Layer.visibleAtResolution(h,e)&&(h=h.layer.getSource())&&(h=h.getAttributions2())&&(h=h(a)))if(Array.isArray(h))for(var k=0,l=h.length;k<l;++k)h[k]in b||(c.push(h[k]),b[h[k]]=!0);else h in b||(c.push(h),b[h]=!0)}return c};ol.control.Attribution.render=function(a){this.updateElement_(a.frameState)};
ol.control.Attribution.prototype.updateElement_=function(a){if(a){var b=this.getSourceAttributions_(a);if(!ol.array.equals(b,this.renderedAttributions_)){for(;this.ulElement_.lastChild!==this.logoLi_;)this.ulElement_.removeChild(this.ulElement_.lastChild);for(var c=0,d=b.length;c<d;++c){var e=document.createElement("LI");e.innerHTML=b[c];this.ulElement_.appendChild(e)}0===b.length&&0<this.renderedAttributions_.length?this.element.classList.add("ol-logo-only"):0===this.renderedAttributions_.length&&
0<b.length&&this.element.classList.remove("ol-logo-only");c=0<b.length||!ol.obj.isEmpty(a.logos);this.renderedVisible_!=c&&(this.element.style.display=c?"":"none",this.renderedVisible_=c);this.renderedAttributions_=b;this.insertLogos_(a)}}else this.renderedVisible_&&(this.element.style.display="none",this.renderedVisible_=!1)};
ol.control.Attribution.prototype.insertLogos_=function(a){a=a.logos;var b=this.logoElements_;for(e in b)e in a||(ol.dom.removeNode(b[e]),delete b[e]);var c;for(c in a){var d=a[c];d instanceof HTMLElement&&(this.logoLi_.appendChild(d),b[c]=d);if(!(c in b)){var e=new Image;e.src=c;if(""===d)var f=e;else f=document.createElement("a"),f.href=d,f.appendChild(e);this.logoLi_.appendChild(f);b[c]=f}}this.logoLi_.style.display=ol.obj.isEmpty(a)?"none":""};
ol.control.Attribution.prototype.handleClick_=function(a){a.preventDefault();this.handleToggle_()};ol.control.Attribution.prototype.handleToggle_=function(){this.element.classList.toggle("ol-collapsed");this.collapsed_?ol.dom.replaceNode(this.collapseLabel_,this.label_):ol.dom.replaceNode(this.label_,this.collapseLabel_);this.collapsed_=!this.collapsed_};ol.control.Attribution.prototype.getCollapsible=function(){return this.collapsible_};
ol.control.Attribution.prototype.setCollapsible=function(a){this.collapsible_!==a&&(this.collapsible_=a,this.element.classList.toggle("ol-uncollapsible"),!a&&this.collapsed_&&this.handleToggle_())};ol.control.Attribution.prototype.setCollapsed=function(a){this.collapsible_&&this.collapsed_!==a&&this.handleToggle_()};ol.control.Attribution.prototype.getCollapsed=function(){return this.collapsed_};ol.control.Rotate=function(a){a=a?a:{};var b=void 0!==a.className?a.className:"ol-rotate",c=void 0!==a.label?a.label:"\u21e7";this.label_=null;"string"===typeof c?(this.label_=document.createElement("span"),this.label_.className="ol-compass",this.label_.textContent=c):(this.label_=c,this.label_.classList.add("ol-compass"));var d=a.tipLabel?a.tipLabel:"Reset rotation";c=document.createElement("button");c.className=b+"-reset";c.setAttribute("type","button");c.title=d;c.appendChild(this.label_);ol.events.listen(c,
ol.events.EventType.CLICK,ol.control.Rotate.prototype.handleClick_,this);d=b+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL;b=document.createElement("div");b.className=d;b.appendChild(c);c=a.render?a.render:ol.control.Rotate.render;this.callResetNorth_=a.resetNorth?a.resetNorth:void 0;ol.control.Control.call(this,{element:b,render:c,target:a.target});this.duration_=void 0!==a.duration?a.duration:250;this.autoHide_=void 0!==a.autoHide?a.autoHide:!0;this.rotation_=void 0;this.autoHide_&&this.element.classList.add(ol.css.CLASS_HIDDEN)};
ol.inherits(ol.control.Rotate,ol.control.Control);ol.control.Rotate.prototype.handleClick_=function(a){a.preventDefault();void 0!==this.callResetNorth_?this.callResetNorth_():this.resetNorth_()};ol.control.Rotate.prototype.resetNorth_=function(){var a=this.getMap().getView();a&&void 0!==a.getRotation()&&(0<this.duration_?a.animate({rotation:0,duration:this.duration_,easing:ol.easing.easeOut}):a.setRotation(0))};
ol.control.Rotate.render=function(a){if(a=a.frameState){a=a.viewState.rotation;if(a!=this.rotation_){var b="rotate("+a+"rad)";if(this.autoHide_){var c=this.element.classList.contains(ol.css.CLASS_HIDDEN);c||0!==a?c&&0!==a&&this.element.classList.remove(ol.css.CLASS_HIDDEN):this.element.classList.add(ol.css.CLASS_HIDDEN)}this.label_.style.msTransform=b;this.label_.style.webkitTransform=b;this.label_.style.transform=b}this.rotation_=a}};ol.control.Zoom=function(a){a=a?a:{};var b=void 0!==a.className?a.className:"ol-zoom",c=void 0!==a.delta?a.delta:1,d=void 0!==a.zoomInLabel?a.zoomInLabel:"+",e=void 0!==a.zoomOutLabel?a.zoomOutLabel:"\u2212",f=void 0!==a.zoomInTipLabel?a.zoomInTipLabel:"Zoom in",g=void 0!==a.zoomOutTipLabel?a.zoomOutTipLabel:"Zoom out",h=document.createElement("button");h.className=b+"-in";h.setAttribute("type","button");h.title=f;h.appendChild("string"===typeof d?document.createTextNode(d):d);ol.events.listen(h,
ol.events.EventType.CLICK,ol.control.Zoom.prototype.handleClick_.bind(this,c));d=document.createElement("button");d.className=b+"-out";d.setAttribute("type","button");d.title=g;d.appendChild("string"===typeof e?document.createTextNode(e):e);ol.events.listen(d,ol.events.EventType.CLICK,ol.control.Zoom.prototype.handleClick_.bind(this,-c));b=b+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL;c=document.createElement("div");c.className=b;c.appendChild(h);c.appendChild(d);ol.control.Control.call(this,
{element:c,target:a.target});this.duration_=void 0!==a.duration?a.duration:250};ol.inherits(ol.control.Zoom,ol.control.Control);ol.control.Zoom.prototype.handleClick_=function(a,b){b.preventDefault();this.zoomByDelta_(a)};ol.control.Zoom.prototype.zoomByDelta_=function(a){var b=this.getMap().getView();if(b){var c=b.getResolution();c&&(a=b.constrainResolution(c,a),0<this.duration_?(b.getAnimating()&&b.cancelAnimations(),b.animate({resolution:a,duration:this.duration_,easing:ol.easing.easeOut})):b.setResolution(a))}};ol.control.defaults=function(a){a=a?a:{};var b=new ol.Collection;(void 0!==a.zoom?a.zoom:1)&&b.push(new ol.control.Zoom(a.zoomOptions));(void 0!==a.rotate?a.rotate:1)&&b.push(new ol.control.Rotate(a.rotateOptions));(void 0!==a.attribution?a.attribution:1)&&b.push(new ol.control.Attribution(a.attributionOptions));return b};ol.Kinetic=function(a,b,c){this.decay_=a;this.minVelocity_=b;this.delay_=c;this.points_=[];this.initialVelocity_=this.angle_=0};ol.Kinetic.prototype.begin=function(){this.initialVelocity_=this.angle_=this.points_.length=0};ol.Kinetic.prototype.update=function(a,b){this.points_.push(a,b,Date.now())};
ol.Kinetic.prototype.end=function(){if(6>this.points_.length)return!1;var a=Date.now()-this.delay_,b=this.points_.length-3;if(this.points_[b+2]<a)return!1;for(var c=b-3;0<c&&this.points_[c+2]>a;)c-=3;a=this.points_[b+2]-this.points_[c+2];if(a<1E3/60)return!1;var d=this.points_[b]-this.points_[c];b=this.points_[b+1]-this.points_[c+1];this.angle_=Math.atan2(b,d);this.initialVelocity_=Math.sqrt(d*d+b*b)/a;return this.initialVelocity_>this.minVelocity_};
ol.Kinetic.prototype.getDistance=function(){return(this.minVelocity_-this.initialVelocity_)/this.decay_};ol.Kinetic.prototype.getAngle=function(){return this.angle_};ol.interaction={};ol.interaction.Property={ACTIVE:"active"};ol.interaction.Interaction=function(a){ol.Object.call(this);this.map_=null;this.setActive(!0);this.handleEvent=a.handleEvent};ol.inherits(ol.interaction.Interaction,ol.Object);ol.interaction.Interaction.prototype.getActive=function(){return this.get(ol.interaction.Property.ACTIVE)};ol.interaction.Interaction.prototype.getMap=function(){return this.map_};ol.interaction.Interaction.prototype.setActive=function(a){this.set(ol.interaction.Property.ACTIVE,a)};
ol.interaction.Interaction.prototype.setMap=function(a){this.map_=a};ol.interaction.Interaction.pan=function(a,b,c){var d=a.getCenter();d&&(b=a.constrainCenter([d[0]+b[0],d[1]+b[1]]),c?a.animate({duration:c,easing:ol.easing.linear,center:b}):a.setCenter(b))};ol.interaction.Interaction.rotate=function(a,b,c,d){b=a.constrainRotation(b,0);ol.interaction.Interaction.rotateWithoutConstraints(a,b,c,d)};
ol.interaction.Interaction.rotateWithoutConstraints=function(a,b,c,d){if(void 0!==b){var e=a.getRotation(),f=a.getCenter();void 0!==e&&f&&0<d?a.animate({rotation:b,anchor:c,duration:d,easing:ol.easing.easeOut}):a.rotate(b,c)}};ol.interaction.Interaction.zoom=function(a,b,c,d,e){b=a.constrainResolution(b,0,e);ol.interaction.Interaction.zoomWithoutConstraints(a,b,c,d)};
ol.interaction.Interaction.zoomByDelta=function(a,b,c,d){var e=a.getResolution();b=a.constrainResolution(e,b,0);if(void 0!==b){var f=a.getResolutions();b=ol.math.clamp(b,a.getMinResolution()||f[f.length-1],a.getMaxResolution()||f[0])}c&&void 0!==b&&b!==e&&(f=a.getCenter(),c=a.calculateCenterZoom(b,c),c=a.constrainCenter(c),c=[(b*f[0]-e*c[0])/(b-e),(b*f[1]-e*c[1])/(b-e)]);ol.interaction.Interaction.zoomWithoutConstraints(a,b,c,d)};
ol.interaction.Interaction.zoomWithoutConstraints=function(a,b,c,d){if(b){var e=a.getResolution(),f=a.getCenter();void 0!==e&&f&&b!==e&&d?a.animate({resolution:b,anchor:c,duration:d,easing:ol.easing.easeOut}):(c&&(c=a.calculateCenterZoom(b,c),a.setCenter(c)),a.setResolution(b))}};ol.interaction.DoubleClickZoom=function(a){a=a?a:{};this.delta_=a.delta?a.delta:1;ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.DoubleClickZoom.handleEvent});this.duration_=void 0!==a.duration?a.duration:250};ol.inherits(ol.interaction.DoubleClickZoom,ol.interaction.Interaction);
ol.interaction.DoubleClickZoom.handleEvent=function(a){var b=!1,c=a.originalEvent;if(a.type==ol.MapBrowserEventType.DBLCLICK){b=a.coordinate;c=c.shiftKey?-this.delta_:this.delta_;var d=a.map.getView();ol.interaction.Interaction.zoomByDelta(d,c,b,this.duration_);a.preventDefault();b=!0}return!b};ol.events.condition={};ol.events.condition.altKeyOnly=function(a){a=a.originalEvent;return a.altKey&&!(a.metaKey||a.ctrlKey)&&!a.shiftKey};ol.events.condition.altShiftKeysOnly=function(a){a=a.originalEvent;return a.altKey&&!(a.metaKey||a.ctrlKey)&&a.shiftKey};ol.events.condition.always=ol.functions.TRUE;ol.events.condition.click=function(a){return a.type==ol.MapBrowserEventType.CLICK};
ol.events.condition.mouseActionButton=function(a){a=a.originalEvent;return 0==a.button&&!(ol.has.WEBKIT&&ol.has.MAC&&a.ctrlKey)};ol.events.condition.never=ol.functions.FALSE;ol.events.condition.pointerMove=function(a){return"pointermove"==a.type};ol.events.condition.singleClick=function(a){return a.type==ol.MapBrowserEventType.SINGLECLICK};ol.events.condition.doubleClick=function(a){return a.type==ol.MapBrowserEventType.DBLCLICK};
ol.events.condition.noModifierKeys=function(a){a=a.originalEvent;return!a.altKey&&!(a.metaKey||a.ctrlKey)&&!a.shiftKey};ol.events.condition.platformModifierKeyOnly=function(a){a=a.originalEvent;return!a.altKey&&(ol.has.MAC?a.metaKey:a.ctrlKey)&&!a.shiftKey};ol.events.condition.shiftKeyOnly=function(a){a=a.originalEvent;return!a.altKey&&!(a.metaKey||a.ctrlKey)&&a.shiftKey};
ol.events.condition.targetNotEditable=function(a){a=a.originalEvent.target.tagName;return"INPUT"!==a&&"SELECT"!==a&&"TEXTAREA"!==a};ol.events.condition.mouseOnly=function(a){ol.asserts.assert(a.pointerEvent,56);return"mouse"==a.pointerEvent.pointerType};ol.events.condition.primaryAction=function(a){a=a.pointerEvent;return a.isPrimary&&0===a.button};ol.interaction.Pointer=function(a){a=a?a:{};ol.interaction.Interaction.call(this,{handleEvent:a.handleEvent?a.handleEvent:ol.interaction.Pointer.handleEvent});this.handleDownEvent_=a.handleDownEvent?a.handleDownEvent:ol.interaction.Pointer.handleDownEvent;this.handleDragEvent_=a.handleDragEvent?a.handleDragEvent:ol.interaction.Pointer.handleDragEvent;this.handleMoveEvent_=a.handleMoveEvent?a.handleMoveEvent:ol.interaction.Pointer.handleMoveEvent;this.handleUpEvent_=a.handleUpEvent?a.handleUpEvent:
ol.interaction.Pointer.handleUpEvent;this.handlingDownUpSequence=!1;this.trackedPointers_={};this.targetPointers=[]};ol.inherits(ol.interaction.Pointer,ol.interaction.Interaction);ol.interaction.Pointer.centroid=function(a){for(var b=a.length,c=0,d=0,e=0;e<b;e++)c+=a[e].clientX,d+=a[e].clientY;return[c/b,d/b]};ol.interaction.Pointer.prototype.isPointerDraggingEvent_=function(a){a=a.type;return a===ol.MapBrowserEventType.POINTERDOWN||a===ol.MapBrowserEventType.POINTERDRAG||a===ol.MapBrowserEventType.POINTERUP};
ol.interaction.Pointer.prototype.updateTrackedPointers_=function(a){if(this.isPointerDraggingEvent_(a)){var b=a.pointerEvent,c=b.pointerId.toString();a.type==ol.MapBrowserEventType.POINTERUP?delete this.trackedPointers_[c]:a.type==ol.MapBrowserEventType.POINTERDOWN?this.trackedPointers_[c]=b:c in this.trackedPointers_&&(this.trackedPointers_[c]=b);this.targetPointers=ol.obj.getValues(this.trackedPointers_)}};ol.interaction.Pointer.handleDragEvent=ol.nullFunction;
ol.interaction.Pointer.handleUpEvent=ol.functions.FALSE;ol.interaction.Pointer.handleDownEvent=ol.functions.FALSE;ol.interaction.Pointer.handleMoveEvent=ol.nullFunction;
ol.interaction.Pointer.handleEvent=function(a){if(!(a instanceof ol.MapBrowserPointerEvent))return!0;var b=!1;this.updateTrackedPointers_(a);this.handlingDownUpSequence?a.type==ol.MapBrowserEventType.POINTERDRAG?this.handleDragEvent_(a):a.type==ol.MapBrowserEventType.POINTERUP&&(this.handlingDownUpSequence=this.handleUpEvent_(a)&&0<this.targetPointers.length):a.type==ol.MapBrowserEventType.POINTERDOWN?(this.handlingDownUpSequence=a=this.handleDownEvent_(a),b=this.shouldStopEvent(a)):a.type==ol.MapBrowserEventType.POINTERMOVE&&
this.handleMoveEvent_(a);return!b};ol.interaction.Pointer.prototype.shouldStopEvent=function(a){return a};ol.interaction.DragPan=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.DragPan.handleDownEvent_,handleDragEvent:ol.interaction.DragPan.handleDragEvent_,handleUpEvent:ol.interaction.DragPan.handleUpEvent_});a=a?a:{};this.kinetic_=a.kinetic;this.lastCentroid=null;this.condition_=a.condition?a.condition:ol.events.condition.noModifierKeys;this.noKinetic_=!1};ol.inherits(ol.interaction.DragPan,ol.interaction.Pointer);
ol.interaction.DragPan.handleDragEvent_=function(a){var b=this.targetPointers,c=ol.interaction.Pointer.centroid(b);if(b.length==this.lastPointersCount_){if(this.kinetic_&&this.kinetic_.update(c[0],c[1]),this.lastCentroid){var d=this.lastCentroid[0]-c[0],e=c[1]-this.lastCentroid[1];a=a.map.getView();var f=a.getState();d=[d,e];ol.coordinate.scale(d,f.resolution);ol.coordinate.rotate(d,f.rotation);ol.coordinate.add(d,f.center);d=a.constrainCenter(d);a.setCenter(d)}}else this.kinetic_&&this.kinetic_.begin();
this.lastCentroid=c;this.lastPointersCount_=b.length};
ol.interaction.DragPan.handleUpEvent_=function(a){var b=a.map;a=b.getView();if(0===this.targetPointers.length){if(!this.noKinetic_&&this.kinetic_&&this.kinetic_.end()){var c=this.kinetic_.getDistance(),d=this.kinetic_.getAngle(),e=a.getCenter();e=b.getPixelFromCoordinate(e);b=b.getCoordinateFromPixel([e[0]-c*Math.cos(d),e[1]-c*Math.sin(d)]);a.animate({center:a.constrainCenter(b),duration:500,easing:ol.easing.easeOut})}a.setHint(ol.ViewHint.INTERACTING,-1);return!1}this.kinetic_&&this.kinetic_.begin();
this.lastCentroid=null;return!0};ol.interaction.DragPan.handleDownEvent_=function(a){if(0<this.targetPointers.length&&this.condition_(a)){var b=a.map.getView();this.lastCentroid=null;this.handlingDownUpSequence||b.setHint(ol.ViewHint.INTERACTING,1);b.getAnimating()&&b.setCenter(a.frameState.viewState.center);this.kinetic_&&this.kinetic_.begin();this.noKinetic_=1<this.targetPointers.length;return!0}return!1};ol.interaction.DragPan.prototype.shouldStopEvent=ol.functions.FALSE;ol.interaction.DragRotate=function(a){a=a?a:{};ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.DragRotate.handleDownEvent_,handleDragEvent:ol.interaction.DragRotate.handleDragEvent_,handleUpEvent:ol.interaction.DragRotate.handleUpEvent_});this.condition_=a.condition?a.condition:ol.events.condition.altShiftKeysOnly;this.lastAngle_=void 0;this.duration_=void 0!==a.duration?a.duration:250};ol.inherits(ol.interaction.DragRotate,ol.interaction.Pointer);
ol.interaction.DragRotate.handleDragEvent_=function(a){if(ol.events.condition.mouseOnly(a)){var b=a.map,c=b.getView();if(c.getConstraints().rotation!==ol.RotationConstraint.disable){b=b.getSize();a=a.pixel;a=Math.atan2(b[1]/2-a[1],a[0]-b[0]/2);if(void 0!==this.lastAngle_){b=a-this.lastAngle_;var d=c.getRotation();ol.interaction.Interaction.rotateWithoutConstraints(c,d-b)}this.lastAngle_=a}}};
ol.interaction.DragRotate.handleUpEvent_=function(a){if(!ol.events.condition.mouseOnly(a))return!0;a=a.map.getView();a.setHint(ol.ViewHint.INTERACTING,-1);var b=a.getRotation();ol.interaction.Interaction.rotate(a,b,void 0,this.duration_);return!1};ol.interaction.DragRotate.handleDownEvent_=function(a){return ol.events.condition.mouseOnly(a)&&ol.events.condition.mouseActionButton(a)&&this.condition_(a)?(a.map.getView().setHint(ol.ViewHint.INTERACTING,1),this.lastAngle_=void 0,!0):!1};
ol.interaction.DragRotate.prototype.shouldStopEvent=ol.functions.FALSE;ol.render.Box=function(a){this.geometry_=null;this.element_=document.createElement("div");this.element_.style.position="absolute";this.element_.className="ol-box "+a;this.endPixel_=this.startPixel_=this.map_=null};ol.inherits(ol.render.Box,ol.Disposable);ol.render.Box.prototype.disposeInternal=function(){this.setMap(null)};
ol.render.Box.prototype.render_=function(){var a=this.startPixel_,b=this.endPixel_,c=this.element_.style;c.left=Math.min(a[0],b[0])+"px";c.top=Math.min(a[1],b[1])+"px";c.width=Math.abs(b[0]-a[0])+"px";c.height=Math.abs(b[1]-a[1])+"px"};ol.render.Box.prototype.setMap=function(a){if(this.map_){this.map_.getOverlayContainer().removeChild(this.element_);var b=this.element_.style;b.left=b.top=b.width=b.height="inherit"}(this.map_=a)&&this.map_.getOverlayContainer().appendChild(this.element_)};
ol.render.Box.prototype.setPixels=function(a,b){this.startPixel_=a;this.endPixel_=b;this.createOrUpdateGeometry();this.render_()};ol.render.Box.prototype.createOrUpdateGeometry=function(){var a=this.startPixel_,b=this.endPixel_;a=[a,[a[0],b[1]],b,[b[0],a[1]]].map(this.map_.getCoordinateFromPixel,this.map_);a[4]=a[0].slice();this.geometry_?this.geometry_.setCoordinates([a]):this.geometry_=new ol.geom.Polygon([a])};ol.render.Box.prototype.getGeometry=function(){return this.geometry_};ol.interaction.DragBox=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.DragBox.handleDownEvent_,handleDragEvent:ol.interaction.DragBox.handleDragEvent_,handleUpEvent:ol.interaction.DragBox.handleUpEvent_});a=a?a:{};this.box_=new ol.render.Box(a.className||"ol-dragbox");this.minArea_=void 0!==a.minArea?a.minArea:64;this.startPixel_=null;this.condition_=a.condition?a.condition:ol.events.condition.always;this.boxEndCondition_=a.boxEndCondition?a.boxEndCondition:ol.interaction.DragBox.defaultBoxEndCondition};
ol.inherits(ol.interaction.DragBox,ol.interaction.Pointer);ol.interaction.DragBox.defaultBoxEndCondition=function(a,b,c){a=c[0]-b[0];b=c[1]-b[1];return a*a+b*b>=this.minArea_};ol.interaction.DragBox.handleDragEvent_=function(a){ol.events.condition.mouseOnly(a)&&(this.box_.setPixels(this.startPixel_,a.pixel),this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXDRAG,a.coordinate,a)))};ol.interaction.DragBox.prototype.getGeometry=function(){return this.box_.getGeometry()};
ol.interaction.DragBox.prototype.onBoxEnd=ol.nullFunction;ol.interaction.DragBox.handleUpEvent_=function(a){if(!ol.events.condition.mouseOnly(a))return!0;this.box_.setMap(null);this.boxEndCondition_(a,this.startPixel_,a.pixel)&&(this.onBoxEnd(a),this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXEND,a.coordinate,a)));return!1};
ol.interaction.DragBox.handleDownEvent_=function(a){return ol.events.condition.mouseOnly(a)&&ol.events.condition.mouseActionButton(a)&&this.condition_(a)?(this.startPixel_=a.pixel,this.box_.setMap(a.map),this.box_.setPixels(this.startPixel_,this.startPixel_),this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXSTART,a.coordinate,a)),!0):!1};ol.interaction.DragBox.EventType_={BOXSTART:"boxstart",BOXDRAG:"boxdrag",BOXEND:"boxend"};
ol.interaction.DragBox.Event=function(a,b,c){ol.events.Event.call(this,a);this.coordinate=b;this.mapBrowserEvent=c};ol.inherits(ol.interaction.DragBox.Event,ol.events.Event);ol.interaction.DragZoom=function(a){a=a?a:{};var b=a.condition?a.condition:ol.events.condition.shiftKeyOnly;this.duration_=void 0!==a.duration?a.duration:200;this.out_=void 0!==a.out?a.out:!1;ol.interaction.DragBox.call(this,{condition:b,className:a.className||"ol-dragzoom"})};ol.inherits(ol.interaction.DragZoom,ol.interaction.DragBox);
ol.interaction.DragZoom.prototype.onBoxEnd=function(){var a=this.getMap(),b=a.getView(),c=a.getSize(),d=this.getGeometry().getExtent();if(this.out_){var e=b.calculateExtent(c);d=ol.extent.createOrUpdateFromCoordinates([a.getPixelFromCoordinate(ol.extent.getBottomLeft(d)),a.getPixelFromCoordinate(ol.extent.getTopRight(d))]);d=b.getResolutionForExtent(d,c);ol.extent.scaleFromCenter(e,1/d);d=e}c=b.constrainResolution(b.getResolutionForExtent(d,c));e=ol.extent.getCenter(d);e=b.constrainCenter(e);b.animate({resolution:c,
center:e,duration:this.duration_,easing:ol.easing.easeOut})};ol.events.KeyCode={LEFT:37,UP:38,RIGHT:39,DOWN:40};ol.interaction.KeyboardPan=function(a){ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.KeyboardPan.handleEvent});a=a||{};this.defaultCondition_=function(a){return ol.events.condition.noModifierKeys(a)&&ol.events.condition.targetNotEditable(a)};this.condition_=void 0!==a.condition?a.condition:this.defaultCondition_;this.duration_=void 0!==a.duration?a.duration:100;this.pixelDelta_=void 0!==a.pixelDelta?a.pixelDelta:128};ol.inherits(ol.interaction.KeyboardPan,ol.interaction.Interaction);
ol.interaction.KeyboardPan.handleEvent=function(a){var b=!1;if(a.type==ol.events.EventType.KEYDOWN){var c=a.originalEvent.keyCode;if(this.condition_(a)&&(c==ol.events.KeyCode.DOWN||c==ol.events.KeyCode.LEFT||c==ol.events.KeyCode.RIGHT||c==ol.events.KeyCode.UP)){b=a.map.getView();var d=b.getResolution()*this.pixelDelta_,e=0,f=0;c==ol.events.KeyCode.DOWN?f=-d:c==ol.events.KeyCode.LEFT?e=-d:c==ol.events.KeyCode.RIGHT?e=d:f=d;c=[e,f];ol.coordinate.rotate(c,b.getRotation());ol.interaction.Interaction.pan(b,
c,this.duration_);a.preventDefault();b=!0}}return!b};ol.interaction.KeyboardZoom=function(a){ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.KeyboardZoom.handleEvent});a=a?a:{};this.condition_=a.condition?a.condition:ol.events.condition.targetNotEditable;this.delta_=a.delta?a.delta:1;this.duration_=void 0!==a.duration?a.duration:100};ol.inherits(ol.interaction.KeyboardZoom,ol.interaction.Interaction);
ol.interaction.KeyboardZoom.handleEvent=function(a){var b=!1;if(a.type==ol.events.EventType.KEYDOWN||a.type==ol.events.EventType.KEYPRESS){var c=a.originalEvent.charCode;!this.condition_(a)||43!=c&&45!=c||(b=43==c?this.delta_:-this.delta_,c=a.map.getView(),ol.interaction.Interaction.zoomByDelta(c,b,void 0,this.duration_),a.preventDefault(),b=!0)}return!b};ol.interaction.MouseWheelZoom=function(a){ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.MouseWheelZoom.handleEvent});a=a||{};this.delta_=0;this.duration_=void 0!==a.duration?a.duration:250;this.timeout_=void 0!==a.timeout?a.timeout:80;this.useAnchor_=void 0!==a.useAnchor?a.useAnchor:!0;this.constrainResolution_=a.constrainResolution||!1;this.lastAnchor_=null;this.mode_=this.timeoutId_=this.startTime_=void 0;this.trackpadEventGap_=400;this.trackpadTimeoutId_=void 0;this.trackpadDeltaPerZoom_=
300;this.trackpadZoomBuffer_=1.5};ol.inherits(ol.interaction.MouseWheelZoom,ol.interaction.Interaction);
ol.interaction.MouseWheelZoom.handleEvent=function(a){var b=a.type;if(b!==ol.events.EventType.WHEEL&&b!==ol.events.EventType.MOUSEWHEEL)return!0;a.preventDefault();b=a.map;var c=a.originalEvent;this.useAnchor_&&(this.lastAnchor_=a.coordinate);if(a.type==ol.events.EventType.WHEEL){var d=c.deltaY;ol.has.FIREFOX&&c.deltaMode===WheelEvent.DOM_DELTA_PIXEL&&(d/=ol.has.DEVICE_PIXEL_RATIO);c.deltaMode===WheelEvent.DOM_DELTA_LINE&&(d*=40)}else a.type==ol.events.EventType.MOUSEWHEEL&&(d=-c.wheelDeltaY,ol.has.SAFARI&&
(d/=3));if(0===d)return!1;a=Date.now();void 0===this.startTime_&&(this.startTime_=a);if(!this.mode_||a-this.startTime_>this.trackpadEventGap_)this.mode_=4>Math.abs(d)?ol.interaction.MouseWheelZoom.Mode_.TRACKPAD:ol.interaction.MouseWheelZoom.Mode_.WHEEL;if(this.mode_===ol.interaction.MouseWheelZoom.Mode_.TRACKPAD){b=b.getView();this.trackpadTimeoutId_?clearTimeout(this.trackpadTimeoutId_):b.setHint(ol.ViewHint.INTERACTING,1);this.trackpadTimeoutId_=setTimeout(this.decrementInteractingHint_.bind(this),
this.trackpadEventGap_);c=b.getResolution()*Math.pow(2,d/this.trackpadDeltaPerZoom_);var e=b.getMinResolution(),f=b.getMaxResolution(),g=0;c<e?(c=Math.max(c,e/this.trackpadZoomBuffer_),g=1):c>f&&(c=Math.min(c,f*this.trackpadZoomBuffer_),g=-1);if(this.lastAnchor_){var h=b.calculateCenterZoom(c,this.lastAnchor_);b.setCenter(b.constrainCenter(h))}b.setResolution(c);0===g&&this.constrainResolution_&&b.animate({resolution:b.constrainResolution(c,0<d?-1:1),easing:ol.easing.easeOut,anchor:this.lastAnchor_,
duration:this.duration_});0<g?b.animate({resolution:e,easing:ol.easing.easeOut,anchor:this.lastAnchor_,duration:500}):0>g&&b.animate({resolution:f,easing:ol.easing.easeOut,anchor:this.lastAnchor_,duration:500});this.startTime_=a;return!1}this.delta_+=d;d=Math.max(this.timeout_-(a-this.startTime_),0);clearTimeout(this.timeoutId_);this.timeoutId_=setTimeout(this.handleWheelZoom_.bind(this,b),d);return!1};
ol.interaction.MouseWheelZoom.prototype.decrementInteractingHint_=function(){this.trackpadTimeoutId_=void 0;this.getMap().getView().setHint(ol.ViewHint.INTERACTING,-1)};
ol.interaction.MouseWheelZoom.prototype.handleWheelZoom_=function(a){a=a.getView();a.getAnimating()&&a.cancelAnimations();var b=ol.MOUSEWHEELZOOM_MAXDELTA;b=ol.math.clamp(this.delta_,-b,b);ol.interaction.Interaction.zoomByDelta(a,-b,this.lastAnchor_,this.duration_);this.mode_=void 0;this.delta_=0;this.lastAnchor_=null;this.timeoutId_=this.startTime_=void 0};ol.interaction.MouseWheelZoom.prototype.setMouseAnchor=function(a){this.useAnchor_=a;a||(this.lastAnchor_=null)};
ol.interaction.MouseWheelZoom.Mode_={TRACKPAD:"trackpad",WHEEL:"wheel"};ol.interaction.PinchRotate=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.PinchRotate.handleDownEvent_,handleDragEvent:ol.interaction.PinchRotate.handleDragEvent_,handleUpEvent:ol.interaction.PinchRotate.handleUpEvent_});a=a||{};this.anchor_=null;this.lastAngle_=void 0;this.rotating_=!1;this.rotationDelta_=0;this.threshold_=void 0!==a.threshold?a.threshold:.3;this.duration_=void 0!==a.duration?a.duration:250};ol.inherits(ol.interaction.PinchRotate,ol.interaction.Pointer);
ol.interaction.PinchRotate.handleDragEvent_=function(a){var b=0,c=this.targetPointers[0],d=this.targetPointers[1];c=Math.atan2(d.clientY-c.clientY,d.clientX-c.clientX);void 0!==this.lastAngle_&&(b=c-this.lastAngle_,this.rotationDelta_+=b,!this.rotating_&&Math.abs(this.rotationDelta_)>this.threshold_&&(this.rotating_=!0));this.lastAngle_=c;a=a.map;c=a.getView();if(c.getConstraints().rotation!==ol.RotationConstraint.disable){d=a.getViewport().getBoundingClientRect();var e=ol.interaction.Pointer.centroid(this.targetPointers);
e[0]-=d.left;e[1]-=d.top;this.anchor_=a.getCoordinateFromPixel(e);this.rotating_&&(d=c.getRotation(),a.render(),ol.interaction.Interaction.rotateWithoutConstraints(c,d+b,this.anchor_))}};ol.interaction.PinchRotate.handleUpEvent_=function(a){if(2>this.targetPointers.length){a=a.map.getView();a.setHint(ol.ViewHint.INTERACTING,-1);if(this.rotating_){var b=a.getRotation();ol.interaction.Interaction.rotate(a,b,this.anchor_,this.duration_)}return!1}return!0};
ol.interaction.PinchRotate.handleDownEvent_=function(a){return 2<=this.targetPointers.length?(a=a.map,this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.handlingDownUpSequence||a.getView().setHint(ol.ViewHint.INTERACTING,1),!0):!1};ol.interaction.PinchRotate.prototype.shouldStopEvent=ol.functions.FALSE;ol.interaction.PinchZoom=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.PinchZoom.handleDownEvent_,handleDragEvent:ol.interaction.PinchZoom.handleDragEvent_,handleUpEvent:ol.interaction.PinchZoom.handleUpEvent_});a=a?a:{};this.constrainResolution_=a.constrainResolution||!1;this.anchor_=null;this.duration_=void 0!==a.duration?a.duration:400;this.lastDistance_=void 0;this.lastScaleDelta_=1};ol.inherits(ol.interaction.PinchZoom,ol.interaction.Pointer);
ol.interaction.PinchZoom.handleDragEvent_=function(a){var b=1,c=this.targetPointers[0],d=this.targetPointers[1],e=c.clientX-d.clientX;c=c.clientY-d.clientY;e=Math.sqrt(e*e+c*c);void 0!==this.lastDistance_&&(b=this.lastDistance_/e);this.lastDistance_=e;a=a.map;e=a.getView();d=e.getResolution();var f=e.getMaxResolution(),g=e.getMinResolution();c=d*b;c>f?(b=f/d,c=f):c<g&&(b=g/d,c=g);1!=b&&(this.lastScaleDelta_=b);b=a.getViewport().getBoundingClientRect();d=ol.interaction.Pointer.centroid(this.targetPointers);
d[0]-=b.left;d[1]-=b.top;this.anchor_=a.getCoordinateFromPixel(d);a.render();ol.interaction.Interaction.zoomWithoutConstraints(e,c,this.anchor_)};ol.interaction.PinchZoom.handleUpEvent_=function(a){if(2>this.targetPointers.length){a=a.map.getView();a.setHint(ol.ViewHint.INTERACTING,-1);var b=a.getResolution();(this.constrainResolution_||b<a.getMinResolution()||b>a.getMaxResolution())&&ol.interaction.Interaction.zoom(a,b,this.anchor_,this.duration_,this.lastScaleDelta_-1);return!1}return!0};
ol.interaction.PinchZoom.handleDownEvent_=function(a){return 2<=this.targetPointers.length?(a=a.map,this.anchor_=null,this.lastDistance_=void 0,this.lastScaleDelta_=1,this.handlingDownUpSequence||a.getView().setHint(ol.ViewHint.INTERACTING,1),!0):!1};ol.interaction.PinchZoom.prototype.shouldStopEvent=ol.functions.FALSE;ol.interaction.defaults=function(a){a=a?a:{};var b=new ol.Collection,c=new ol.Kinetic(-.005,.05,100);(void 0!==a.altShiftDragRotate?a.altShiftDragRotate:1)&&b.push(new ol.interaction.DragRotate);(void 0!==a.doubleClickZoom?a.doubleClickZoom:1)&&b.push(new ol.interaction.DoubleClickZoom({delta:a.zoomDelta,duration:a.zoomDuration}));(void 0!==a.dragPan?a.dragPan:1)&&b.push(new ol.interaction.DragPan({kinetic:c}));(void 0!==a.pinchRotate?a.pinchRotate:1)&&b.push(new ol.interaction.PinchRotate);(void 0!==
a.pinchZoom?a.pinchZoom:1)&&b.push(new ol.interaction.PinchZoom({constrainResolution:a.constrainResolution,duration:a.zoomDuration}));if(void 0!==a.keyboard?a.keyboard:1)b.push(new ol.interaction.KeyboardPan),b.push(new ol.interaction.KeyboardZoom({delta:a.zoomDelta,duration:a.zoomDuration}));(void 0!==a.mouseWheelZoom?a.mouseWheelZoom:1)&&b.push(new ol.interaction.MouseWheelZoom({constrainResolution:a.constrainResolution,duration:a.zoomDuration}));(void 0!==a.shiftDragZoom?a.shiftDragZoom:1)&&b.push(new ol.interaction.DragZoom({duration:a.zoomDuration}));
return b};ol.ImageBase=function(a,b,c,d){ol.events.EventTarget.call(this);this.extent=a;this.pixelRatio_=c;this.resolution=b;this.state=d};ol.inherits(ol.ImageBase,ol.events.EventTarget);ol.ImageBase.prototype.changed=function(){this.dispatchEvent(ol.events.EventType.CHANGE)};ol.ImageBase.prototype.getExtent=function(){return this.extent};ol.ImageBase.prototype.getImage=function(){};ol.ImageBase.prototype.getPixelRatio=function(){return this.pixelRatio_};ol.ImageBase.prototype.getResolution=function(){return this.resolution};
ol.ImageBase.prototype.getState=function(){return this.state};ol.ImageBase.prototype.load=function(){};ol.ImageState={IDLE:0,LOADING:1,LOADED:2,ERROR:3};ol.ImageCanvas=function(a,b,c,d,e){this.loader_=void 0!==e?e:null;ol.ImageBase.call(this,a,b,c,void 0!==e?ol.ImageState.IDLE:ol.ImageState.LOADED);this.canvas_=d;this.error_=null};ol.inherits(ol.ImageCanvas,ol.ImageBase);ol.ImageCanvas.prototype.getError=function(){return this.error_};ol.ImageCanvas.prototype.handleLoad_=function(a){a?(this.error_=a,this.state=ol.ImageState.ERROR):this.state=ol.ImageState.LOADED;this.changed()};
ol.ImageCanvas.prototype.load=function(){this.state==ol.ImageState.IDLE&&(this.state=ol.ImageState.LOADING,this.changed(),this.loader_(this.handleLoad_.bind(this)))};ol.ImageCanvas.prototype.getImage=function(){return this.canvas_};ol.LayerType={IMAGE:"IMAGE",TILE:"TILE",VECTOR_TILE:"VECTOR_TILE",VECTOR:"VECTOR"};ol.layer.VectorRenderType={IMAGE:"image",VECTOR:"vector"};ol.render.Event=function(a,b,c,d,e){ol.events.Event.call(this,a);this.vectorContext=b;this.frameState=c;this.context=d;this.glContext=e};ol.inherits(ol.render.Event,ol.events.Event);ol.structs.LRUCache=function(a){ol.events.EventTarget.call(this);this.highWaterMark=void 0!==a?a:2048;this.count_=0;this.entries_={};this.newest_=this.oldest_=null};ol.inherits(ol.structs.LRUCache,ol.events.EventTarget);ol.structs.LRUCache.prototype.canExpireCache=function(){return this.getCount()>this.highWaterMark};ol.structs.LRUCache.prototype.clear=function(){this.count_=0;this.entries_={};this.newest_=this.oldest_=null;this.dispatchEvent(ol.events.EventType.CLEAR)};
ol.structs.LRUCache.prototype.containsKey=function(a){return this.entries_.hasOwnProperty(a)};ol.structs.LRUCache.prototype.forEach=function(a,b){for(var c=this.oldest_;c;)a.call(b,c.value_,c.key_,this),c=c.newer};
ol.structs.LRUCache.prototype.get=function(a){a=this.entries_[a];ol.asserts.assert(void 0!==a,15);if(a===this.newest_)return a.value_;a===this.oldest_?(this.oldest_=this.oldest_.newer,this.oldest_.older=null):(a.newer.older=a.older,a.older.newer=a.newer);a.newer=null;a.older=this.newest_;this.newest_=this.newest_.newer=a;return a.value_};
ol.structs.LRUCache.prototype.remove=function(a){var b=this.entries_[a];ol.asserts.assert(void 0!==b,15);if(b===this.newest_){if(this.newest_=b.older)this.newest_.newer=null}else if(b===this.oldest_){if(this.oldest_=b.newer)this.oldest_.older=null}else b.newer.older=b.older,b.older.newer=b.newer;delete this.entries_[a];--this.count_;return b.value_};ol.structs.LRUCache.prototype.getCount=function(){return this.count_};
ol.structs.LRUCache.prototype.getKeys=function(){var a=Array(this.count_),b=0,c;for(c=this.newest_;c;c=c.older)a[b++]=c.key_;return a};ol.structs.LRUCache.prototype.getValues=function(){var a=Array(this.count_),b=0,c;for(c=this.newest_;c;c=c.older)a[b++]=c.value_;return a};ol.structs.LRUCache.prototype.peekLast=function(){return this.oldest_.value_};ol.structs.LRUCache.prototype.peekLastKey=function(){return this.oldest_.key_};ol.structs.LRUCache.prototype.peekFirstKey=function(){return this.newest_.key_};
ol.structs.LRUCache.prototype.pop=function(){var a=this.oldest_;delete this.entries_[a.key_];a.newer&&(a.newer.older=null);this.oldest_=a.newer;this.oldest_||(this.newest_=null);--this.count_;return a.value_};ol.structs.LRUCache.prototype.replace=function(a,b){this.get(a);this.entries_[a].value_=b};
ol.structs.LRUCache.prototype.set=function(a,b){ol.asserts.assert(!(a in this.entries_),16);b={key_:a,newer:null,older:this.newest_,value_:b};this.newest_?this.newest_.newer=b:this.oldest_=b;this.newest_=b;this.entries_[a]=b;++this.count_};ol.structs.LRUCache.prototype.prune=function(){for(;this.canExpireCache();)this.pop()};ol.render.canvas={};ol.render.canvas.defaultFont="10px sans-serif";ol.render.canvas.defaultFillStyle=[0,0,0,1];ol.render.canvas.defaultLineCap="round";ol.render.canvas.defaultLineDash=[];ol.render.canvas.defaultLineDashOffset=0;ol.render.canvas.defaultLineJoin="round";ol.render.canvas.defaultMiterLimit=10;ol.render.canvas.defaultStrokeStyle=[0,0,0,1];ol.render.canvas.defaultTextAlign="center";ol.render.canvas.defaultTextBaseline="middle";ol.render.canvas.defaultPadding=[0,0,0,0];
ol.render.canvas.defaultLineWidth=1;ol.render.canvas.labelCache=new ol.structs.LRUCache;ol.render.canvas.checkedFonts_={};ol.render.canvas.measureContext_=null;ol.render.canvas.textHeights_={};
ol.render.canvas.checkFont=function(){function a(a){var b=ol.render.canvas.getMeasureContext();b.font="32px monospace";f=b.measureText("wmytzilWMYTZIL@#/&?$%10").width;var c=!0;"monospace"!=a&&(b.font="32px "+a+",monospace",c=b.measureText("wmytzilWMYTZIL@#/&?$%10").width!=f);return c}function b(){var b=!0,f;for(f in c)60>c[f]&&(a(f)?(c[f]=60,ol.obj.clear(ol.render.canvas.textHeights_),ol.render.canvas.measureContext_=null,d.clear()):(++c[f],b=!1));b&&(window.clearInterval(e),e=void 0)}var c=ol.render.canvas.checkedFonts_,
d=ol.render.canvas.labelCache,e,f;return function(d){if(d=ol.css.getFontFamilies(d))for(var f=0,g=d.length;f<g;++f){var l=d[f];l in c||(c[l]=60,a(l)||(c[l]=0,void 0===e&&(e=window.setInterval(b,32))))}}}();ol.render.canvas.getMeasureContext=function(){var a=ol.render.canvas.measureContext_;a||(a=ol.render.canvas.measureContext_=ol.dom.createCanvasContext2D(1,1));return a};
ol.render.canvas.measureTextHeight=function(){var a,b=ol.render.canvas.textHeights_;return function(c){var d=b[c];void 0==d&&(a||(a=document.createElement("span"),a.textContent="M",a.style.margin=a.style.padding="0 !important",a.style.position="absolute !important",a.style.left="-99999px !important"),a.style.font=c,document.body.appendChild(a),d=b[c]=a.offsetHeight,document.body.removeChild(a));return d}}();
ol.render.canvas.measureTextWidth=function(a,b){var c=ol.render.canvas.getMeasureContext();a!=c.font&&(c.font=a);return c.measureText(b).width};ol.render.canvas.rotateAtOffset=function(a,b,c,d){0!==b&&(a.translate(c,d),a.rotate(b),a.translate(-c,-d))};ol.render.canvas.resetTransform_=ol.transform.create();
ol.render.canvas.drawImage=function(a,b,c,d,e,f,g,h,k,l,m){if(1!=c){var n=a.globalAlpha;a.globalAlpha=n*c}b&&a.setTransform.apply(a,b);a.drawImage(d,e,f,g,h,k,l,g*m,h*m);n&&(a.globalAlpha=n);b&&a.setTransform.apply(a,ol.render.canvas.resetTransform_)};ol.color={};ol.color.HEX_COLOR_RE_=/^#(?:[0-9a-f]{3,4}){1,2}$/i;ol.color.NAMED_COLOR_RE_=/^([a-z]*)$/i;ol.color.asArray=function(a){return Array.isArray(a)?a:ol.color.fromString(a)};ol.color.asString=function(a){return"string"===typeof a?a:ol.color.toString(a)};ol.color.fromNamed=function(a){var b=document.createElement("div");b.style.color=a;document.body.appendChild(b);a=getComputedStyle(b).color;document.body.removeChild(b);return a};
ol.color.fromString=function(){var a={},b=0;return function(c){if(a.hasOwnProperty(c))var d=a[c];else{if(1024<=b){d=0;for(var e in a)0===(d++&3)&&(delete a[e],--b)}d=ol.color.fromStringInternal_(c);a[c]=d;++b}return d}}();
ol.color.fromStringInternal_=function(a){ol.color.NAMED_COLOR_RE_.exec(a)&&(a=ol.color.fromNamed(a));if(ol.color.HEX_COLOR_RE_.exec(a)){var b=a.length-1;var c=4>=b?1:2;var d=4===b||8===b;b=parseInt(a.substr(1+0*c,c),16);var e=parseInt(a.substr(1+1*c,c),16);var f=parseInt(a.substr(1+2*c,c),16);a=d?parseInt(a.substr(1+3*c,c),16):255;1==c&&(b=(b<<4)+b,e=(e<<4)+e,f=(f<<4)+f,d&&(a=(a<<4)+a));c=[b,e,f,a/255]}else 0==a.indexOf("rgba(")?(a=a.slice(5,-1).split(",").map(Number),c=ol.color.normalize(a)):0==
a.indexOf("rgb(")?(a=a.slice(4,-1).split(",").map(Number),a.push(1),c=ol.color.normalize(a)):ol.asserts.assert(!1,14);return c};ol.color.normalize=function(a,b){b=b||[];b[0]=ol.math.clamp(a[0]+.5|0,0,255);b[1]=ol.math.clamp(a[1]+.5|0,0,255);b[2]=ol.math.clamp(a[2]+.5|0,0,255);b[3]=ol.math.clamp(a[3],0,1);return b};ol.color.toString=function(a){var b=a[0];b!=(b|0)&&(b=b+.5|0);var c=a[1];c!=(c|0)&&(c=c+.5|0);var d=a[2];d!=(d|0)&&(d=d+.5|0);return"rgba("+b+","+c+","+d+","+(void 0===a[3]?1:a[3])+")"};ol.colorlike={};ol.colorlike.asColorLike=function(a){return ol.colorlike.isColorLike(a)?a:ol.color.asString(a)};ol.colorlike.isColorLike=function(a){return"string"===typeof a||a instanceof CanvasPattern||a instanceof CanvasGradient};ol.render.VectorContext=function(){};ol.render.VectorContext.prototype.drawCustom=function(a,b,c){};ol.render.VectorContext.prototype.drawGeometry=function(a){};ol.render.VectorContext.prototype.setStyle=function(a){};ol.render.VectorContext.prototype.drawCircle=function(a,b){};ol.render.VectorContext.prototype.drawFeature=function(a,b){};ol.render.VectorContext.prototype.drawGeometryCollection=function(a,b){};ol.render.VectorContext.prototype.drawLineString=function(a,b){};
ol.render.VectorContext.prototype.drawMultiLineString=function(a,b){};ol.render.VectorContext.prototype.drawMultiPoint=function(a,b){};ol.render.VectorContext.prototype.drawMultiPolygon=function(a,b){};ol.render.VectorContext.prototype.drawPoint=function(a,b){};ol.render.VectorContext.prototype.drawPolygon=function(a,b){};ol.render.VectorContext.prototype.drawText=function(a,b){};ol.render.VectorContext.prototype.setFillStrokeStyle=function(a,b){};
ol.render.VectorContext.prototype.setImageStyle=function(a,b){};ol.render.VectorContext.prototype.setTextStyle=function(a,b){};ol.render.canvas.Immediate=function(a,b,c,d,e){ol.render.VectorContext.call(this);this.context_=a;this.pixelRatio_=b;this.extent_=c;this.transform_=d;this.viewRotation_=e;this.image_=this.strokeState_=this.fillState_=this.contextTextState_=this.contextStrokeState_=this.contextFillState_=null;this.imageOriginY_=this.imageOriginX_=this.imageOpacity_=this.imageHeight_=this.imageAnchorY_=this.imageAnchorX_=0;this.imageRotateWithView_=!1;this.imageScale_=this.imageRotation_=0;this.imageSnapToPixel_=!1;
this.imageWidth_=0;this.text_="";this.textOffsetY_=this.textOffsetX_=0;this.textRotateWithView_=!1;this.textScale_=this.textRotation_=0;this.textState_=this.textStrokeState_=this.textFillState_=null;this.pixelCoordinates_=[];this.tmpLocalTransform_=ol.transform.create()};ol.inherits(ol.render.canvas.Immediate,ol.render.VectorContext);
ol.render.canvas.Immediate.prototype.drawImages_=function(a,b,c,d){if(this.image_){a=ol.geom.flat.transform.transform2D(a,b,c,2,this.transform_,this.pixelCoordinates_);b=this.context_;c=this.tmpLocalTransform_;d=b.globalAlpha;1!=this.imageOpacity_&&(b.globalAlpha=d*this.imageOpacity_);var e=this.imageRotation_;this.imageRotateWithView_&&(e+=this.viewRotation_);var f;var g=0;for(f=a.length;g<f;g+=2){var h=a[g]-this.imageAnchorX_,k=a[g+1]-this.imageAnchorY_;this.imageSnapToPixel_&&(h=Math.round(h),
k=Math.round(k));if(0!==e||1!=this.imageScale_){var l=h+this.imageAnchorX_,m=k+this.imageAnchorY_;ol.transform.compose(c,l,m,this.imageScale_,this.imageScale_,e,-l,-m);b.setTransform.apply(b,c)}b.drawImage(this.image_,this.imageOriginX_,this.imageOriginY_,this.imageWidth_,this.imageHeight_,h,k,this.imageWidth_,this.imageHeight_)}0===e&&1==this.imageScale_||b.setTransform(1,0,0,1,0,0);1!=this.imageOpacity_&&(b.globalAlpha=d)}};
ol.render.canvas.Immediate.prototype.drawText_=function(a,b,c,d){if(this.textState_&&""!==this.text_){this.textFillState_&&this.setContextFillState_(this.textFillState_);this.textStrokeState_&&this.setContextStrokeState_(this.textStrokeState_);this.setContextTextState_(this.textState_);a=ol.geom.flat.transform.transform2D(a,b,c,d,this.transform_,this.pixelCoordinates_);var e=this.context_,f=this.textRotation_;for(this.textRotateWithView_&&(f+=this.viewRotation_);b<c;b+=d){var g=a[b]+this.textOffsetX_,
h=a[b+1]+this.textOffsetY_;if(0!==f||1!=this.textScale_){var k=ol.transform.compose(this.tmpLocalTransform_,g,h,this.textScale_,this.textScale_,f,-g,-h);e.setTransform.apply(e,k)}this.textStrokeState_&&e.strokeText(this.text_,g,h);this.textFillState_&&e.fillText(this.text_,g,h)}0===f&&1==this.textScale_||e.setTransform(1,0,0,1,0,0)}};
ol.render.canvas.Immediate.prototype.moveToLineTo_=function(a,b,c,d,e){var f=this.context_;a=ol.geom.flat.transform.transform2D(a,b,c,d,this.transform_,this.pixelCoordinates_);f.moveTo(a[0],a[1]);b=a.length;e&&(b-=2);for(d=2;d<b;d+=2)f.lineTo(a[d],a[d+1]);e&&f.closePath();return c};ol.render.canvas.Immediate.prototype.drawRings_=function(a,b,c,d){var e;var f=0;for(e=c.length;f<e;++f)b=this.moveToLineTo_(a,b,c[f],d,!0);return b};
ol.render.canvas.Immediate.prototype.drawCircle=function(a){if(ol.extent.intersects(this.extent_,a.getExtent())){if(this.fillState_||this.strokeState_){this.fillState_&&this.setContextFillState_(this.fillState_);this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var b=ol.geom.SimpleGeometry.transform2D(a,this.transform_,this.pixelCoordinates_),c=b[2]-b[0],d=b[3]-b[1];c=Math.sqrt(c*c+d*d);d=this.context_;d.beginPath();d.arc(b[0],b[1],c,0,2*Math.PI);this.fillState_&&d.fill();this.strokeState_&&
d.stroke()}""!==this.text_&&this.drawText_(a.getCenter(),0,2,2)}};ol.render.canvas.Immediate.prototype.setStyle=function(a){this.setFillStrokeStyle(a.getFill(),a.getStroke());this.setImageStyle(a.getImage());this.setTextStyle(a.getText())};
ol.render.canvas.Immediate.prototype.drawGeometry=function(a){switch(a.getType()){case ol.geom.GeometryType.POINT:this.drawPoint(a);break;case ol.geom.GeometryType.LINE_STRING:this.drawLineString(a);break;case ol.geom.GeometryType.POLYGON:this.drawPolygon(a);break;case ol.geom.GeometryType.MULTI_POINT:this.drawMultiPoint(a);break;case ol.geom.GeometryType.MULTI_LINE_STRING:this.drawMultiLineString(a);break;case ol.geom.GeometryType.MULTI_POLYGON:this.drawMultiPolygon(a);break;case ol.geom.GeometryType.GEOMETRY_COLLECTION:this.drawGeometryCollection(a);
break;case ol.geom.GeometryType.CIRCLE:this.drawCircle(a)}};ol.render.canvas.Immediate.prototype.drawFeature=function(a,b){(a=b.getGeometryFunction()(a))&&ol.extent.intersects(this.extent_,a.getExtent())&&(this.setStyle(b),this.drawGeometry(a))};ol.render.canvas.Immediate.prototype.drawGeometryCollection=function(a){a=a.getGeometriesArray();var b;var c=0;for(b=a.length;c<b;++c)this.drawGeometry(a[c])};
ol.render.canvas.Immediate.prototype.drawPoint=function(a){var b=a.getFlatCoordinates();a=a.getStride();this.image_&&this.drawImages_(b,0,b.length,a);""!==this.text_&&this.drawText_(b,0,b.length,a)};ol.render.canvas.Immediate.prototype.drawMultiPoint=function(a){var b=a.getFlatCoordinates();a=a.getStride();this.image_&&this.drawImages_(b,0,b.length,a);""!==this.text_&&this.drawText_(b,0,b.length,a)};
ol.render.canvas.Immediate.prototype.drawLineString=function(a){if(ol.extent.intersects(this.extent_,a.getExtent())){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var b=this.context_,c=a.getFlatCoordinates();b.beginPath();this.moveToLineTo_(c,0,c.length,a.getStride(),!1);b.stroke()}""!==this.text_&&(a=a.getFlatMidpoint(),this.drawText_(a,0,2,2))}};
ol.render.canvas.Immediate.prototype.drawMultiLineString=function(a){var b=a.getExtent();if(ol.extent.intersects(this.extent_,b)){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);b=this.context_;var c=a.getFlatCoordinates(),d=0,e=a.getEnds(),f=a.getStride();b.beginPath();var g;var h=0;for(g=e.length;h<g;++h)d=this.moveToLineTo_(c,d,e[h],f,!1);b.stroke()}""!==this.text_&&(a=a.getFlatMidpoints(),this.drawText_(a,0,a.length,2))}};
ol.render.canvas.Immediate.prototype.drawPolygon=function(a){if(ol.extent.intersects(this.extent_,a.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_);this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var b=this.context_;b.beginPath();this.drawRings_(a.getOrientedFlatCoordinates(),0,a.getEnds(),a.getStride());this.fillState_&&b.fill();this.strokeState_&&b.stroke()}""!==this.text_&&(a=a.getFlatInteriorPoint(),this.drawText_(a,
0,2,2))}};
ol.render.canvas.Immediate.prototype.drawMultiPolygon=function(a){if(ol.extent.intersects(this.extent_,a.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_);this.strokeState_&&this.setContextStrokeState_(this.strokeState_);var b=this.context_,c=a.getOrientedFlatCoordinates(),d=0,e=a.getEndss(),f=a.getStride(),g;b.beginPath();var h=0;for(g=e.length;h<g;++h)d=this.drawRings_(c,d,e[h],f);this.fillState_&&b.fill();this.strokeState_&&b.stroke()}""!==
this.text_&&(a=a.getFlatInteriorPoints(),this.drawText_(a,0,a.length,2))}};ol.render.canvas.Immediate.prototype.setContextFillState_=function(a){var b=this.context_,c=this.contextFillState_;c?c.fillStyle!=a.fillStyle&&(c.fillStyle=b.fillStyle=a.fillStyle):(b.fillStyle=a.fillStyle,this.contextFillState_={fillStyle:a.fillStyle})};
ol.render.canvas.Immediate.prototype.setContextStrokeState_=function(a){var b=this.context_,c=this.contextStrokeState_;c?(c.lineCap!=a.lineCap&&(c.lineCap=b.lineCap=a.lineCap),ol.has.CANVAS_LINE_DASH&&(ol.array.equals(c.lineDash,a.lineDash)||b.setLineDash(c.lineDash=a.lineDash),c.lineDashOffset!=a.lineDashOffset&&(c.lineDashOffset=b.lineDashOffset=a.lineDashOffset)),c.lineJoin!=a.lineJoin&&(c.lineJoin=b.lineJoin=a.lineJoin),c.lineWidth!=a.lineWidth&&(c.lineWidth=b.lineWidth=a.lineWidth),c.miterLimit!=
a.miterLimit&&(c.miterLimit=b.miterLimit=a.miterLimit),c.strokeStyle!=a.strokeStyle&&(c.strokeStyle=b.strokeStyle=a.strokeStyle)):(b.lineCap=a.lineCap,ol.has.CANVAS_LINE_DASH&&(b.setLineDash(a.lineDash),b.lineDashOffset=a.lineDashOffset),b.lineJoin=a.lineJoin,b.lineWidth=a.lineWidth,b.miterLimit=a.miterLimit,b.strokeStyle=a.strokeStyle,this.contextStrokeState_={lineCap:a.lineCap,lineDash:a.lineDash,lineDashOffset:a.lineDashOffset,lineJoin:a.lineJoin,lineWidth:a.lineWidth,miterLimit:a.miterLimit,strokeStyle:a.strokeStyle})};
ol.render.canvas.Immediate.prototype.setContextTextState_=function(a){var b=this.context_,c=this.contextTextState_,d=a.textAlign?a.textAlign:ol.render.canvas.defaultTextAlign;c?(c.font!=a.font&&(c.font=b.font=a.font),c.textAlign!=d&&(c.textAlign=d),c.textBaseline!=a.textBaseline&&(c.textBaseline=b.textBaseline=a.textBaseline)):(b.font=a.font,b.textAlign=d,b.textBaseline=a.textBaseline,this.contextTextState_={font:a.font,textAlign:d,textBaseline:a.textBaseline})};
ol.render.canvas.Immediate.prototype.setFillStrokeStyle=function(a,b){a?(a=a.getColor(),this.fillState_={fillStyle:ol.colorlike.asColorLike(a?a:ol.render.canvas.defaultFillStyle)}):this.fillState_=null;if(b){a=b.getColor();var c=b.getLineCap(),d=b.getLineDash(),e=b.getLineDashOffset(),f=b.getLineJoin(),g=b.getWidth();b=b.getMiterLimit();this.strokeState_={lineCap:void 0!==c?c:ol.render.canvas.defaultLineCap,lineDash:d?d:ol.render.canvas.defaultLineDash,lineDashOffset:e?e:ol.render.canvas.defaultLineDashOffset,
lineJoin:void 0!==f?f:ol.render.canvas.defaultLineJoin,lineWidth:this.pixelRatio_*(void 0!==g?g:ol.render.canvas.defaultLineWidth),miterLimit:void 0!==b?b:ol.render.canvas.defaultMiterLimit,strokeStyle:ol.colorlike.asColorLike(a?a:ol.render.canvas.defaultStrokeStyle)}}else this.strokeState_=null};
ol.render.canvas.Immediate.prototype.setImageStyle=function(a){if(a){var b=a.getAnchor(),c=a.getImage(1),d=a.getOrigin(),e=a.getSize();this.imageAnchorX_=b[0];this.imageAnchorY_=b[1];this.imageHeight_=e[1];this.image_=c;this.imageOpacity_=a.getOpacity();this.imageOriginX_=d[0];this.imageOriginY_=d[1];this.imageRotateWithView_=a.getRotateWithView();this.imageRotation_=a.getRotation();this.imageScale_=a.getScale()*this.pixelRatio_;this.imageSnapToPixel_=a.getSnapToPixel();this.imageWidth_=e[0]}else this.image_=
null};
ol.render.canvas.Immediate.prototype.setTextStyle=function(a){if(a){var b=a.getFill();b?(b=b.getColor(),this.textFillState_={fillStyle:ol.colorlike.asColorLike(b?b:ol.render.canvas.defaultFillStyle)}):this.textFillState_=null;var c=a.getStroke();if(c){b=c.getColor();var d=c.getLineCap(),e=c.getLineDash(),f=c.getLineDashOffset(),g=c.getLineJoin(),h=c.getWidth();c=c.getMiterLimit();this.textStrokeState_={lineCap:void 0!==d?d:ol.render.canvas.defaultLineCap,lineDash:e?e:ol.render.canvas.defaultLineDash,lineDashOffset:f?
f:ol.render.canvas.defaultLineDashOffset,lineJoin:void 0!==g?g:ol.render.canvas.defaultLineJoin,lineWidth:void 0!==h?h:ol.render.canvas.defaultLineWidth,miterLimit:void 0!==c?c:ol.render.canvas.defaultMiterLimit,strokeStyle:ol.colorlike.asColorLike(b?b:ol.render.canvas.defaultStrokeStyle)}}else this.textStrokeState_=null;b=a.getFont();d=a.getOffsetX();e=a.getOffsetY();f=a.getRotateWithView();g=a.getRotation();h=a.getScale();c=a.getText();var k=a.getTextAlign();a=a.getTextBaseline();this.textState_=
{font:void 0!==b?b:ol.render.canvas.defaultFont,textAlign:void 0!==k?k:ol.render.canvas.defaultTextAlign,textBaseline:void 0!==a?a:ol.render.canvas.defaultTextBaseline};this.text_=void 0!==c?c:"";this.textOffsetX_=void 0!==d?this.pixelRatio_*d:0;this.textOffsetY_=void 0!==e?this.pixelRatio_*e:0;this.textRotateWithView_=void 0!==f?f:!1;this.textRotation_=void 0!==g?g:0;this.textScale_=this.pixelRatio_*(void 0!==h?h:1)}else this.text_=""};ol.renderer.Layer=function(a){ol.Observable.call(this);this.layer_=a};ol.inherits(ol.renderer.Layer,ol.Observable);ol.renderer.Layer.prototype.forEachFeatureAtCoordinate=ol.nullFunction;ol.renderer.Layer.prototype.hasFeatureAtCoordinate=ol.functions.FALSE;ol.renderer.Layer.prototype.createLoadedTileFinder=function(a,b,c){return function(d,e){return a.forEachLoadedTile(b,d,e,function(a){c[d]||(c[d]={});c[d][a.tileCoord.toString()]=a})}};ol.renderer.Layer.prototype.getLayer=function(){return this.layer_};
ol.renderer.Layer.prototype.handleImageChange_=function(a){a.target.getState()===ol.ImageState.LOADED&&this.renderIfReadyAndVisible()};ol.renderer.Layer.prototype.loadImage=function(a){var b=a.getState();b!=ol.ImageState.LOADED&&b!=ol.ImageState.ERROR&&ol.events.listen(a,ol.events.EventType.CHANGE,this.handleImageChange_,this);b==ol.ImageState.IDLE&&(a.load(),b=a.getState());return b==ol.ImageState.LOADED};
ol.renderer.Layer.prototype.renderIfReadyAndVisible=function(){var a=this.getLayer();a.getVisible()&&a.getSourceState()==ol.source.State.READY&&this.changed()};ol.renderer.Layer.prototype.scheduleExpireCache=function(a,b){b.canExpireCache()&&(b=function(a,b,e){b=ol.getUid(a).toString();b in e.usedTiles&&a.expireCache(e.viewState.projection,e.usedTiles[b])}.bind(null,b),a.postRenderFunctions.push(b))};
ol.renderer.Layer.prototype.updateLogos=function(a,b){b=b.getLogo();void 0!==b&&("string"===typeof b?a.logos[b]="":b&&(ol.asserts.assert("string"==typeof b.href,44),ol.asserts.assert("string"==typeof b.src,45),a.logos[b.src]=b.href))};ol.renderer.Layer.prototype.updateUsedTiles=function(a,b,c,d){b=ol.getUid(b).toString();c=c.toString();b in a?c in a[b]?a[b][c].extend(d):a[b][c]=d:(a[b]={},a[b][c]=d)};
ol.renderer.Layer.prototype.manageTilePyramid=function(a,b,c,d,e,f,g,h,k,l){var m=ol.getUid(b).toString();m in a.wantedTiles||(a.wantedTiles[m]={});var n=a.wantedTiles[m];a=a.tileQueue;var p,q,r;for(r=c.getMinZoom();r<=g;++r){var u=c.getTileRangeForExtentAndZ(f,r,u);var t=c.getResolution(r);for(p=u.minX;p<=u.maxX;++p)for(q=u.minY;q<=u.maxY;++q)if(g-r<=h){var v=b.getTile(r,p,q,d,e);v.getState()==ol.TileState.IDLE&&(n[v.getKey()]=!0,a.isKeyQueued(v.getKey())||a.enqueue([v,m,c.getTileCoordCenter(v.tileCoord),
t]));void 0!==k&&k.call(l,v)}else b.useTile(r,p,q,e)}};ol.renderer.canvas={};ol.renderer.canvas.Layer=function(a){ol.renderer.Layer.call(this,a);this.transform_=ol.transform.create()};ol.inherits(ol.renderer.canvas.Layer,ol.renderer.Layer);
ol.renderer.canvas.Layer.prototype.clip=function(a,b,c){var d=b.pixelRatio,e=b.size[0]*d,f=b.size[1]*d,g=b.viewState.rotation,h=ol.extent.getTopLeft(c),k=ol.extent.getTopRight(c),l=ol.extent.getBottomRight(c);c=ol.extent.getBottomLeft(c);ol.transform.apply(b.coordinateToPixelTransform,h);ol.transform.apply(b.coordinateToPixelTransform,k);ol.transform.apply(b.coordinateToPixelTransform,l);ol.transform.apply(b.coordinateToPixelTransform,c);a.save();ol.render.canvas.rotateAtOffset(a,-g,e/2,f/2);a.beginPath();
a.moveTo(h[0]*d,h[1]*d);a.lineTo(k[0]*d,k[1]*d);a.lineTo(l[0]*d,l[1]*d);a.lineTo(c[0]*d,c[1]*d);a.clip();ol.render.canvas.rotateAtOffset(a,g,e/2,f/2)};
ol.renderer.canvas.Layer.prototype.dispatchComposeEvent_=function(a,b,c,d){var e=this.getLayer();if(e.hasListener(a)){var f=c.size[0]*c.pixelRatio,g=c.size[1]*c.pixelRatio,h=c.viewState.rotation;ol.render.canvas.rotateAtOffset(b,-h,f/2,g/2);d=void 0!==d?d:this.getTransform(c,0);d=new ol.render.canvas.Immediate(b,c.pixelRatio,c.extent,d,c.viewState.rotation);a=new ol.render.Event(a,d,c,b,null);e.dispatchEvent(a);ol.render.canvas.rotateAtOffset(b,h,f/2,g/2)}};
ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate=function(a,b,c,d){if(this.forEachFeatureAtCoordinate(a,b,0,ol.functions.TRUE,this))return c.call(d,this.getLayer(),null)};ol.renderer.canvas.Layer.prototype.postCompose=function(a,b,c,d){this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE,a,b,d)};ol.renderer.canvas.Layer.prototype.preCompose=function(a,b,c){this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE,a,b,c)};
ol.renderer.canvas.Layer.prototype.dispatchRenderEvent=function(a,b,c){this.dispatchComposeEvent_(ol.render.EventType.RENDER,a,b,c)};ol.renderer.canvas.Layer.prototype.getTransform=function(a,b){var c=a.viewState,d=a.pixelRatio,e=d/c.resolution;return ol.transform.compose(this.transform_,d*a.size[0]/2,d*a.size[1]/2,e,-e,-c.rotation,-c.center[0]+b,-c.center[1])};ol.renderer.canvas.Layer.prototype.composeFrame=function(a,b,c){};ol.renderer.canvas.Layer.prototype.prepareFrame=function(a,b){};ol.renderer.canvas.IntermediateCanvas=function(a){ol.renderer.canvas.Layer.call(this,a);this.coordinateToCanvasPixelTransform=ol.transform.create();this.hitCanvasContext_=null};ol.inherits(ol.renderer.canvas.IntermediateCanvas,ol.renderer.canvas.Layer);
ol.renderer.canvas.IntermediateCanvas.prototype.composeFrame=function(a,b,c){this.preCompose(c,a);var d=this.getImage();if(d){var e=b.extent,f=void 0!==e&&!ol.extent.containsExtent(e,a.extent)&&ol.extent.intersects(e,a.extent);f&&this.clip(c,a,e);e=this.getImageTransform();var g=c.globalAlpha;c.globalAlpha=b.opacity;c.drawImage(d,0,0,+d.width,+d.height,Math.round(e[4]),Math.round(e[5]),Math.round(d.width*e[0]),Math.round(d.height*e[3]));c.globalAlpha=g;f&&c.restore()}this.postCompose(c,a,b)};
ol.renderer.canvas.IntermediateCanvas.prototype.getImage=function(){};ol.renderer.canvas.IntermediateCanvas.prototype.getImageTransform=function(){};ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){var f=this.getLayer();return f.getSource().forEachFeatureAtCoordinate(a,b.viewState.resolution,b.viewState.rotation,c,b.skippedFeatureUids,function(a){return d.call(e,a,f)})};
ol.renderer.canvas.IntermediateCanvas.prototype.forEachLayerAtCoordinate=function(a,b,c,d){if(this.getImage()){if(this.getLayer().getSource().forEachFeatureAtCoordinate!==ol.nullFunction)return ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate.apply(this,arguments);var e=ol.transform.apply(this.coordinateToCanvasPixelTransform,a.slice());ol.coordinate.scale(e,b.viewState.resolution/this.renderedResolution);this.hitCanvasContext_||(this.hitCanvasContext_=ol.dom.createCanvasContext2D(1,1));
this.hitCanvasContext_.clearRect(0,0,1,1);this.hitCanvasContext_.drawImage(this.getImage(),e[0],e[1],1,1,0,0,1,1);e=this.hitCanvasContext_.getImageData(0,0,1,1).data;if(0<e[3])return c.call(d,this.getLayer(),e)}};ol.renderer.canvas.ImageLayer=function(a){ol.renderer.canvas.IntermediateCanvas.call(this,a);this.image_=null;this.imageTransform_=ol.transform.create();this.skippedFeatures_=[];this.vectorRenderer_=null};ol.inherits(ol.renderer.canvas.ImageLayer,ol.renderer.canvas.IntermediateCanvas);ol.renderer.canvas.ImageLayer.handles=function(a,b){return a===ol.renderer.Type.CANVAS&&(b.getType()===ol.LayerType.IMAGE||b.getType()===ol.LayerType.VECTOR&&b.getRenderMode()===ol.layer.VectorRenderType.IMAGE)};
ol.renderer.canvas.ImageLayer.create=function(a,b){var c=new ol.renderer.canvas.ImageLayer(b);if(b.getType()===ol.LayerType.VECTOR)for(var d=ol.plugins.getLayerRendererPlugins(),e=0,f=d.length;e<f;++e){var g=d[e];g!==ol.renderer.canvas.ImageLayer&&g.handles(ol.renderer.Type.CANVAS,b)&&c.setVectorRenderer(g.create(a,b))}return c};ol.renderer.canvas.ImageLayer.prototype.getImage=function(){return this.image_?this.image_.getImage():null};ol.renderer.canvas.ImageLayer.prototype.getImageTransform=function(){return this.imageTransform_};
ol.renderer.canvas.ImageLayer.prototype.prepareFrame=function(a,b){var c=a.pixelRatio,d=a.size,e=a.viewState,f=e.center,g=e.resolution,h=this.getLayer().getSource(),k=a.viewHints,l=a.extent;void 0!==b.extent&&(l=ol.extent.getIntersection(l,b.extent));if(!k[ol.ViewHint.ANIMATING]&&!k[ol.ViewHint.INTERACTING]&&!ol.extent.isEmpty(l))if(k=e.projection,ol.ENABLE_RASTER_REPROJECTION||(e=h.getProjection())&&(k=e),e=this.vectorRenderer_){k=e.context;var m=ol.obj.assign({},a,{size:[ol.extent.getWidth(l)/g,
ol.extent.getHeight(l)/g],viewState:ol.obj.assign({},a.viewState,{rotation:0})}),n=Object.keys(m.skippedFeatureUids).sort();!e.prepareFrame(m,b)||!e.replayGroupChanged&&ol.array.equals(n,this.skippedFeatures_)||(k.canvas.width=m.size[0]*c,k.canvas.height=m.size[1]*c,e.composeFrame(m,b,k),this.image_=new ol.ImageCanvas(l,g,c,k.canvas),this.skippedFeatures_=n)}else(e=h.getImage(l,g,c,k))&&this.loadImage(e)&&(this.image_=e);this.image_&&(e=this.image_,l=e.getExtent(),b=e.getResolution(),e=e.getPixelRatio(),
k=c*b/(g*e),l=ol.transform.compose(this.imageTransform_,c*d[0]/2,c*d[1]/2,k,k,0,e*(l[0]-f[0])/b,e*(f[1]-l[3])/b),ol.transform.compose(this.coordinateToCanvasPixelTransform,c*d[0]/2-l[4],c*d[1]/2-l[5],c/g,-c/g,0,-f[0],-f[1]),this.updateLogos(a,h),this.renderedResolution=b*c/e);return!!this.image_};
ol.renderer.canvas.ImageLayer.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){return this.vectorRenderer_?this.vectorRenderer_.forEachFeatureAtCoordinate(a,b,c,d,e):ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate.call(this,a,b,c,d,e)};ol.renderer.canvas.ImageLayer.prototype.setVectorRenderer=function(a){this.vectorRenderer_=a};ol.style={};ol.style.IconImageCache=function(){this.cache_={};this.cacheSize_=0;this.maxCacheSize_=32};ol.style.IconImageCache.getKey=function(a,b,c){c=c?ol.color.asString(c):"null";return b+":"+a+":"+c};ol.style.IconImageCache.prototype.clear=function(){this.cache_={};this.cacheSize_=0};ol.style.IconImageCache.prototype.expire=function(){if(this.cacheSize_>this.maxCacheSize_){var a=0,b;for(b in this.cache_){var c=this.cache_[b];0!==(a++&3)||c.hasListener()||(delete this.cache_[b],--this.cacheSize_)}}};
ol.style.IconImageCache.prototype.get=function(a,b,c){a=ol.style.IconImageCache.getKey(a,b,c);return a in this.cache_?this.cache_[a]:null};ol.style.IconImageCache.prototype.set=function(a,b,c,d){a=ol.style.IconImageCache.getKey(a,b,c);this.cache_[a]=d;++this.cacheSize_};ol.style.IconImageCache.prototype.setSize=function(a){this.maxCacheSize_=a;this.expire()};ol.style.iconImageCache=new ol.style.IconImageCache;ol.renderer.Map=function(a,b){ol.Disposable.call(this);this.map_=b;this.layerRenderers_={};this.layerRendererListeners_={}};ol.inherits(ol.renderer.Map,ol.Disposable);ol.renderer.Map.prototype.calculateMatrices2D=function(a){var b=a.viewState,c=a.coordinateToPixelTransform,d=a.pixelToCoordinateTransform;ol.transform.compose(c,a.size[0]/2,a.size[1]/2,1/b.resolution,-1/b.resolution,-b.rotation,-b.center[0],-b.center[1]);ol.transform.invert(ol.transform.setFromArray(d,c))};
ol.renderer.Map.prototype.removeLayerRenderers=function(){for(var a in this.layerRenderers_)this.removeLayerRendererByKey_(a).dispose()};ol.renderer.Map.expireIconCache_=function(a,b){ol.style.iconImageCache.expire()};
ol.renderer.Map.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e,f,g){function h(a,c){var f=ol.getUid(a).toString(),g=b.layerStates[ol.getUid(c)].managed;if(!(f in b.skippedFeatureUids)||g)return d.call(e,a,g?c:null)}var k,l=b.viewState,m=l.resolution,n=l.projection;l=a;if(n.canWrapX()){n=n.getExtent();var p=ol.extent.getWidth(n),q=a[0];if(q<n[0]||q>n[2])l=[q+p*Math.ceil((n[0]-q)/p),a[1]]}n=b.layerStatesArray;for(p=n.length-1;0<=p;--p){var r=n[p];q=r.layer;if(ol.layer.Layer.visibleAtResolution(r,
m)&&f.call(g,q)&&(r=this.getLayerRenderer(q),q.getSource()&&(k=r.forEachFeatureAtCoordinate(q.getSource().getWrapX()?l:a,b,c,h,e)),k))return k}};ol.renderer.Map.prototype.forEachLayerAtPixel=function(a,b,c,d,e,f){};ol.renderer.Map.prototype.hasFeatureAtCoordinate=function(a,b,c,d,e){return void 0!==this.forEachFeatureAtCoordinate(a,b,c,ol.functions.TRUE,this,d,e)};
ol.renderer.Map.prototype.getLayerRenderer=function(a){var b=ol.getUid(a).toString();if(b in this.layerRenderers_)return this.layerRenderers_[b];for(var c=ol.plugins.getLayerRendererPlugins(),d,e=this.getType(),f=0,g=c.length;f<g;++f){var h=c[f];if(h.handles(e,a)){d=h.create(this,a);break}}if(d)this.layerRenderers_[b]=d,this.layerRendererListeners_[b]=ol.events.listen(d,ol.events.EventType.CHANGE,this.handleLayerRendererChange_,this);else throw Error("Unable to create renderer for layer: "+a.getType());
return d};ol.renderer.Map.prototype.getLayerRendererByKey=function(a){return this.layerRenderers_[a]};ol.renderer.Map.prototype.getLayerRenderers=function(){return this.layerRenderers_};ol.renderer.Map.prototype.getMap=function(){return this.map_};ol.renderer.Map.prototype.getType=function(){};ol.renderer.Map.prototype.handleLayerRendererChange_=function(){this.map_.render()};
ol.renderer.Map.prototype.removeLayerRendererByKey_=function(a){var b=this.layerRenderers_[a];delete this.layerRenderers_[a];ol.events.unlistenByKey(this.layerRendererListeners_[a]);delete this.layerRendererListeners_[a];return b};ol.renderer.Map.prototype.renderFrame=ol.nullFunction;ol.renderer.Map.prototype.removeUnusedLayerRenderers_=function(a,b){for(var c in this.layerRenderers_)b&&c in b.layerStates||this.removeLayerRendererByKey_(c).dispose()};
ol.renderer.Map.prototype.scheduleExpireIconCache=function(a){a.postRenderFunctions.push(ol.renderer.Map.expireIconCache_)};ol.renderer.Map.prototype.scheduleRemoveUnusedLayerRenderers=function(a){for(var b in this.layerRenderers_)if(!(b in a.layerStates)){a.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this));break}};ol.renderer.Map.sortByZIndex=function(a,b){return a.zIndex-b.zIndex};ol.renderer.canvas.Map=function(a,b){ol.renderer.Map.call(this,a,b);this.context_=ol.dom.createCanvasContext2D();this.canvas_=this.context_.canvas;this.canvas_.style.width="100%";this.canvas_.style.height="100%";this.canvas_.style.display="block";this.canvas_.className=ol.css.CLASS_UNSELECTABLE;a.insertBefore(this.canvas_,a.childNodes[0]||null);this.renderedVisible_=!0;this.transform_=ol.transform.create()};ol.inherits(ol.renderer.canvas.Map,ol.renderer.Map);
ol.renderer.canvas.Map.handles=function(a){return a===ol.renderer.Type.CANVAS};ol.renderer.canvas.Map.create=function(a,b){return new ol.renderer.canvas.Map(a,b)};ol.renderer.canvas.Map.prototype.dispatchComposeEvent_=function(a,b){var c=this.getMap(),d=this.context_;if(c.hasListener(a)){var e=b.extent,f=b.pixelRatio,g=b.viewState.rotation,h=this.getTransform(b);e=new ol.render.canvas.Immediate(d,f,e,h,g);a=new ol.render.Event(a,e,b,d,null);c.dispatchEvent(a)}};
ol.renderer.canvas.Map.prototype.getTransform=function(a){var b=a.viewState;a=a.pixelRatio/b.resolution;return ol.transform.compose(this.transform_,this.canvas_.width/2,this.canvas_.height/2,a,-a,-b.rotation,-b.center[0],-b.center[1])};ol.renderer.canvas.Map.prototype.getType=function(){return ol.renderer.Type.CANVAS};
ol.renderer.canvas.Map.prototype.renderFrame=function(a){if(a){var b=this.context_,c=a.pixelRatio,d=Math.round(a.size[0]*c),e=Math.round(a.size[1]*c);this.canvas_.width!=d||this.canvas_.height!=e?(this.canvas_.width=d,this.canvas_.height=e):b.clearRect(0,0,d,e);c=a.viewState.rotation;this.calculateMatrices2D(a);this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE,a);var f=a.layerStatesArray;ol.array.stableSort(f,ol.renderer.Map.sortByZIndex);c&&(b.save(),ol.render.canvas.rotateAtOffset(b,c,d/
2,e/2));d=a.viewState.resolution;var g;e=0;for(g=f.length;e<g;++e){var h=f[e];var k=h.layer;k=this.getLayerRenderer(k);ol.layer.Layer.visibleAtResolution(h,d)&&h.sourceState==ol.source.State.READY&&k.prepareFrame(a,h)&&k.composeFrame(a,h,b)}c&&b.restore();this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE,a);this.renderedVisible_||(this.canvas_.style.display="",this.renderedVisible_=!0);this.scheduleRemoveUnusedLayerRenderers(a);this.scheduleExpireIconCache(a)}else this.renderedVisible_&&
(this.canvas_.style.display="none",this.renderedVisible_=!1)};ol.renderer.canvas.Map.prototype.forEachLayerAtPixel=function(a,b,c,d,e,f){var g=b.viewState.resolution,h=b.layerStatesArray,k=h.length;a=ol.transform.apply(b.pixelToCoordinateTransform,a.slice());for(--k;0<=k;--k){var l=h[k];var m=l.layer;if(ol.layer.Layer.visibleAtResolution(l,g)&&e.call(f,m)&&(l=this.getLayerRenderer(m).forEachLayerAtCoordinate(a,b,c,d)))return l}};ol.renderer.canvas.TileLayer=function(a){ol.renderer.canvas.IntermediateCanvas.call(this,a);this.context=null===this.context?null:ol.dom.createCanvasContext2D();this.renderedExtent_=null;this.renderedTiles=[];this.tmpExtent=ol.extent.createEmpty();this.tmpTileRange_=new ol.TileRange(0,0,0,0);this.imageTransform_=ol.transform.create();this.zDirection=0};ol.inherits(ol.renderer.canvas.TileLayer,ol.renderer.canvas.IntermediateCanvas);
ol.renderer.canvas.TileLayer.handles=function(a,b){return a===ol.renderer.Type.CANVAS&&b.getType()===ol.LayerType.TILE};ol.renderer.canvas.TileLayer.create=function(a,b){return new ol.renderer.canvas.TileLayer(b)};ol.renderer.canvas.TileLayer.prototype.isDrawableTile_=function(a){a=a.getState();var b=this.getLayer().getUseInterimTilesOnError();return a==ol.TileState.LOADED||a==ol.TileState.EMPTY||a==ol.TileState.ERROR&&!b};
ol.renderer.canvas.TileLayer.prototype.prepareFrame=function(a,b){var c=a.pixelRatio,d=a.size,e=a.viewState,f=e.projection,g=e.resolution;e=e.center;var h=this.getLayer(),k=h.getSource(),l=k.getRevision(),m=k.getTileGridForProjection(f),n=m.getZForResolution(g,this.zDirection),p=m.getResolution(n),q=Math.round(g/p)||1,r=a.extent;void 0!==b.extent&&(r=ol.extent.getIntersection(r,b.extent));if(ol.extent.isEmpty(r))return!1;var u=m.getTileRangeForExtentAndZ(r,n),t=m.getTileRangeExtent(n,u),v=k.getTilePixelRatio(c),
w={};w[n]={};var y=this.createLoadedTileFinder(k,f,w),z=this.tmpExtent,x=this.tmpTileRange_,C=!1,A,B;for(A=u.minX;A<=u.maxX;++A)for(B=u.minY;B<=u.maxY;++B){var D=k.getTile(n,A,B,c,f);D.getState()==ol.TileState.ERROR&&(h.getUseInterimTilesOnError()?0<h.getPreload()&&(C=!0):D.setState(ol.TileState.LOADED));this.isDrawableTile_(D)||(D=D.getInterimTile());if(this.isDrawableTile_(D)){var E=ol.getUid(this);if(D.getState()==ol.TileState.LOADED){w[n][D.tileCoord.toString()]=D;var G=D.inTransition(E);C||!G&&
-1!==this.renderedTiles.indexOf(D)||(C=!0)}if(1===D.getAlpha(E,a.time))continue}E=m.getTileCoordChildTileRange(D.tileCoord,x,z);G=!1;E&&(G=y(n+1,E));G||m.forEachTileCoordParentTileRange(D.tileCoord,y,null,x,z)}D=p*c/v*q;A=a.viewHints;A=A[ol.ViewHint.ANIMATING]||A[ol.ViewHint.INTERACTING];if(!(this.renderedResolution&&16<Date.now()-a.time&&A||!C&&this.renderedExtent_&&ol.extent.containsExtent(this.renderedExtent_,r)&&this.renderedRevision==l&&q==this.oversampling_&&(A||D==this.renderedResolution))){if(D=
this.context)B=k.getTilePixelSize(n,c,f),A=Math.round(u.getWidth()*B[0]/q),B=Math.round(u.getHeight()*B[1]/q),C=D.canvas,C.width!=A||C.height!=B?(this.oversampling_=q,C.width=A,C.height=B):(this.renderedExtent_&&!ol.extent.equals(t,this.renderedExtent_)&&D.clearRect(0,0,A,B),q=this.oversampling_);this.renderedTiles.length=0;C=Object.keys(w).map(Number);C.sort(function(a,b){return a===n?1:b===n?-1:a>b?1:a<b?-1:0});E=0;for(G=C.length;E<G;++E){x=C[E];y=k.getTilePixelSize(x,c,f);D=m.getResolution(x);
var F=D/p;var M=v*k.getGutter(f);var J=w[x];for(var K in J){D=J[K];B=m.getTileCoordExtent(D.getTileCoord(),z);A=(B[0]-t[0])/p*v/q;B=(t[3]-B[3])/p*v/q;var L=y[0]*F/q;var H=y[1]*F/q;this.drawTileImage(D,a,b,A,B,L,H,M,n===x);this.renderedTiles.push(D)}}this.renderedRevision=l;this.renderedResolution=p*c/v*q;this.renderedExtent_=t}b=this.renderedResolution/g;b=ol.transform.compose(this.imageTransform_,c*d[0]/2,c*d[1]/2,b,b,0,(this.renderedExtent_[0]-e[0])/this.renderedResolution*c,(e[1]-this.renderedExtent_[3])/
this.renderedResolution*c);ol.transform.compose(this.coordinateToCanvasPixelTransform,c*d[0]/2-b[4],c*d[1]/2-b[5],c/g,-c/g,0,-e[0],-e[1]);this.updateUsedTiles(a.usedTiles,k,n,u);this.manageTilePyramid(a,k,m,c,f,r,n,h.getPreload());this.scheduleExpireCache(a,k);this.updateLogos(a,k);return 0<this.renderedTiles.length};
ol.renderer.canvas.TileLayer.prototype.drawTileImage=function(a,b,c,d,e,f,g,h,k){if(c=a.getImage(this.getLayer())){var l=ol.getUid(this),m=k?a.getAlpha(l,b.time):1;1!==m||this.getLayer().getSource().getOpaque(b.viewState.projection)||this.context.clearRect(d,e,f,g);var n=m!==this.context.globalAlpha;n&&(this.context.save(),this.context.globalAlpha=m);this.context.drawImage(c,h,h,c.width-2*h,c.height-2*h,d,e,f,g);n&&this.context.restore();1!==m?b.animate=!0:k&&a.endTransition(l)}};
ol.renderer.canvas.TileLayer.prototype.getImage=function(){var a=this.context;return a?a.canvas:null};ol.renderer.canvas.TileLayer.prototype.getImageTransform=function(){return this.imageTransform_};ol.ext={};ol.ext.rbush=function(){};
(function(){(function(a){function b(a,e,f,g,h){f=f||0;g=g||a.length-1;for(h=h||d;g>f;){if(600<g-f){var k=g-f+1,l=e-f+1,m=Math.log(k),n=.5*Math.exp(2*m/3);m=.5*Math.sqrt(m*n*(k-n)/k)*(0>l-k/2?-1:1);b(a,e,Math.max(f,Math.floor(e-l*n/k+m)),Math.min(g,Math.floor(e+(k-l)*n/k+m)),h)}k=a[e];l=f;n=g;c(a,f,e);for(0<h(a[g],k)&&c(a,f,g);l<n;){c(a,l,n);l++;for(n--;0>h(a[l],k);)l++;for(;0<h(a[n],k);)n--}0===h(a[f],k)?c(a,f,n):(n++,c(a,n,g));n<=e&&(f=n+1);e<=n&&(g=n-1)}}function c(a,b,c){var d=a[b];a[b]=a[c];a[c]=
d}function d(a,b){return a<b?-1:a>b?1:0}function e(a,b){if(!(this instanceof e))return new e(a,b);this._maxEntries=Math.max(4,a||9);this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries));b&&this._initFormat(b);this.clear()}function f(a,b){g(a,0,a.children.length,b,a)}function g(a,b,c,d,e){e||(e=r(null));e.minX=Infinity;e.minY=Infinity;e.maxX=-Infinity;e.maxY=-Infinity;for(var f;b<c;b++)f=a.children[b],h(e,a.leaf?d(f):f);return e}function h(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,
b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a}function k(a,b){return a.minX-b.minX}function l(a,b){return a.minY-b.minY}function m(a){return(a.maxX-a.minX)*(a.maxY-a.minY)}function n(a){return a.maxX-a.minX+(a.maxY-a.minY)}function p(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY}function q(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY}function r(a){return{children:a,height:1,leaf:!0,minX:Infinity,minY:Infinity,
maxX:-Infinity,maxY:-Infinity}}function u(a,b,c,d,e){for(var f=[b,c],g;f.length;)c=f.pop(),b=f.pop(),c-b<=d||(g=b+Math.ceil((c-b)/d/2)*d,t(a,g,b,c,e),f.push(b,g,g,c))}var t=b;e.prototype={all:function(){return this._all(this.data,[])},search:function(a){var b=this.data,c=[],d=this.toBBox;if(!q(a,b))return c;for(var e=[],f,g,h,k;b;){f=0;for(g=b.children.length;f<g;f++)h=b.children[f],k=b.leaf?d(h):h,q(a,k)&&(b.leaf?c.push(h):p(a,k)?this._all(h,c):e.push(h));b=e.pop()}return c},collides:function(a){var b=
this.data,c=this.toBBox;if(!q(a,b))return!1;for(var d=[],e,f,g,h;b;){e=0;for(f=b.children.length;e<f;e++)if(g=b.children[e],h=b.leaf?c(g):g,q(a,h)){if(b.leaf||p(a,h))return!0;d.push(g)}b=d.pop()}return!1},load:function(a){if(!a||!a.length)return this;if(a.length<this._minEntries){for(var b=0,c=a.length;b<c;b++)this.insert(a[b]);return this}a=this._build(a.slice(),0,a.length-1,0);this.data.children.length?this.data.height===a.height?this._splitRoot(this.data,a):(this.data.height<a.height&&(b=this.data,
this.data=a,a=b),this._insert(a,this.data.height-a.height-1,!0)):this.data=a;return this},insert:function(a){a&&this._insert(a,this.data.height-1);return this},clear:function(){this.data=r([]);return this},remove:function(a,b){if(!a)return this;for(var c=this.data,d=this.toBBox(a),e=[],f=[],g,h,k,l;c||e.length;){c||(c=e.pop(),h=e[e.length-1],g=f.pop(),l=!0);if(c.leaf){a:{k=a;var m=c.children,n=b;if(n){for(var q=0;q<m.length;q++)if(n(k,m[q])){k=q;break a}k=-1}else k=m.indexOf(k)}if(-1!==k){c.children.splice(k,
1);e.push(c);this._condense(e);break}}l||c.leaf||!p(c,d)?h?(g++,c=h.children[g],l=!1):c=null:(e.push(c),f.push(g),g=0,h=c,c=c.children[0])}return this},toBBox:function(a){return a},compareMinX:k,compareMinY:l,toJSON:function(){return this.data},fromJSON:function(a){this.data=a;return this},_all:function(a,b){for(var c=[];a;)a.leaf?b.push.apply(b,a.children):c.push.apply(c,a.children),a=c.pop();return b},_build:function(a,b,c,d){var e=c-b+1,g=this._maxEntries;if(e<=g){var h=r(a.slice(b,c+1));f(h,this.toBBox);
return h}d||(d=Math.ceil(Math.log(e)/Math.log(g)),g=Math.ceil(e/Math.pow(g,d-1)));h=r([]);h.leaf=!1;h.height=d;e=Math.ceil(e/g);g=e*Math.ceil(Math.sqrt(g));var k;for(u(a,b,c,g,this.compareMinX);b<=c;b+=g){var l=Math.min(b+g-1,c);u(a,b,l,e,this.compareMinY);for(k=b;k<=l;k+=e){var m=Math.min(k+e-1,l);h.children.push(this._build(a,k,m,d-1))}}f(h,this.toBBox);return h},_chooseSubtree:function(a,b,c,d){for(var e,f,g,h,k,l,n,p;;){d.push(b);if(b.leaf||d.length-1===c)break;n=p=Infinity;e=0;for(f=b.children.length;e<
f;e++)g=b.children[e],k=m(g),l=(Math.max(g.maxX,a.maxX)-Math.min(g.minX,a.minX))*(Math.max(g.maxY,a.maxY)-Math.min(g.minY,a.minY))-k,l<p?(p=l,n=k<n?k:n,h=g):l===p&&k<n&&(n=k,h=g);b=h||b.children[0]}return b},_insert:function(a,b,c){var d=this.toBBox;c=c?a:d(a);d=[];var e=this._chooseSubtree(c,this.data,b,d);e.children.push(a);for(h(e,c);0<=b;)if(d[b].children.length>this._maxEntries)this._split(d,b),b--;else break;this._adjustParentBBoxes(c,d,b)},_split:function(a,b){var c=a[b],d=c.children.length,
e=this._minEntries;this._chooseSplitAxis(c,e,d);d=this._chooseSplitIndex(c,e,d);d=r(c.children.splice(d,c.children.length-d));d.height=c.height;d.leaf=c.leaf;f(c,this.toBBox);f(d,this.toBBox);b?a[b-1].children.push(d):this._splitRoot(c,d)},_splitRoot:function(a,b){this.data=r([a,b]);this.data.height=a.height+1;this.data.leaf=!1;f(this.data,this.toBBox)},_chooseSplitIndex:function(a,b,c){var d,e;var f=e=Infinity;for(d=b;d<=c-b;d++){var h=g(a,0,d,this.toBBox);var k=g(a,d,c,this.toBBox);var l=Math.max(0,
Math.min(h.maxX,k.maxX)-Math.max(h.minX,k.minX))*Math.max(0,Math.min(h.maxY,k.maxY)-Math.max(h.minY,k.minY));h=m(h)+m(k);if(l<f){f=l;var n=d;e=h<e?h:e}else l===f&&h<e&&(e=h,n=d)}return n},_chooseSplitAxis:function(a,b,c){var d=a.leaf?this.compareMinX:k,e=a.leaf?this.compareMinY:l,f=this._allDistMargin(a,b,c,d);b=this._allDistMargin(a,b,c,e);f<b&&a.children.sort(d)},_allDistMargin:function(a,b,c,d){a.children.sort(d);d=this.toBBox;var e=g(a,0,b,d),f=g(a,c-b,c,d),k=n(e)+n(f),l;for(l=b;l<c-b;l++){var m=
a.children[l];h(e,a.leaf?d(m):m);k+=n(e)}for(l=c-b-1;l>=b;l--)m=a.children[l],h(f,a.leaf?d(m):m),k+=n(f);return k},_adjustParentBBoxes:function(a,b,c){for(;0<=c;c--)h(b[c],a)},_condense:function(a){for(var b=a.length-1,c;0<=b;b--)0===a[b].children.length?0<b?(c=a[b-1].children,c.splice(c.indexOf(a[b]),1)):this.clear():f(a[b],this.toBBox)},_initFormat:function(a){var b=["return a"," - b",";"];this.compareMinX=new Function("a","b",b.join(a[0]));this.compareMinY=new Function("a","b",b.join(a[1]));this.toBBox=
new Function("a","return {minX: a"+a[0]+", minY: a"+a[1]+", maxX: a"+a[2]+", maxY: a"+a[3]+"};")}};a["default"]=e})(this.rbush=this.rbush||{})}).call(ol.ext);ol.ext.rbush=ol.ext.rbush.default;ol.render.ReplayGroup=function(){};ol.render.ReplayGroup.prototype.getReplay=function(a,b){};ol.render.ReplayGroup.prototype.isEmpty=function(){};ol.render.ReplayType={CIRCLE:"Circle",DEFAULT:"Default",IMAGE:"Image",LINE_STRING:"LineString",POLYGON:"Polygon",TEXT:"Text"};ol.geom.flat.length={};ol.geom.flat.length.lineString=function(a,b,c,d){var e=a[b],f=a[b+1],g=0;for(b+=d;b<c;b+=d){var h=a[b],k=a[b+1];g+=Math.sqrt((h-e)*(h-e)+(k-f)*(k-f));e=h;f=k}return g};ol.geom.flat.length.linearRing=function(a,b,c,d){var e=ol.geom.flat.length.lineString(a,b,c,d),f=a[c-d]-a[b];a=a[c-d+1]-a[b+1];return e+=Math.sqrt(f*f+a*a)};ol.geom.flat.textpath={};
ol.geom.flat.textpath.lineString=function(a,b,c,d,e,f,g,h){var k=[],l=a[b]>a[c-d],m=e.length,n=a[b],p=a[b+1];b+=d;for(var q=a[b],r=a[b+1],u=0,t=Math.sqrt(Math.pow(q-n,2)+Math.pow(r-p,2)),v="",w=0,y,z,x,C=0;C<m;++C){z=l?m-C-1:C;z=e.charAt(z);v=l?z+v:v+z;var A=f(v)-w;w+=A;for(var B=g+A/2;b<c-d&&u+t<B;)n=q,p=r,b+=d,q=a[b],r=a[b+1],u+=t,t=Math.sqrt(Math.pow(q-n,2)+Math.pow(r-p,2));var D=B-u;B=Math.atan2(r-p,q-n);l&&(B+=0<B?-Math.PI:Math.PI);if(void 0!==x){var E=B-x;E+=E>Math.PI?-2*Math.PI:E<-Math.PI?
2*Math.PI:0;if(Math.abs(E)>h)return null}E=D/t;D=ol.math.lerp(n,q,E);E=ol.math.lerp(p,r,E);x==B?(l&&(y[0]=D,y[1]=E,y[2]=A/2),y[4]=v):(v=z,w=A,y=[D,E,A/2,B,v],l?k.unshift(y):k.push(y),x=B);g+=A}return k};ol.render.canvas.Instruction={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_CHARS:5,DRAW_IMAGE:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,STROKE:12};ol.render.replay={};ol.render.replay.ORDER=[ol.render.ReplayType.POLYGON,ol.render.ReplayType.CIRCLE,ol.render.ReplayType.LINE_STRING,ol.render.ReplayType.IMAGE,ol.render.ReplayType.TEXT,ol.render.ReplayType.DEFAULT];ol.render.replay.TEXT_ALIGN={};ol.render.replay.TEXT_ALIGN.left=0;ol.render.replay.TEXT_ALIGN.end=0;ol.render.replay.TEXT_ALIGN.center=.5;ol.render.replay.TEXT_ALIGN.right=1;ol.render.replay.TEXT_ALIGN.start=1;ol.render.replay.TEXT_ALIGN.top=0;ol.render.replay.TEXT_ALIGN.middle=.5;
ol.render.replay.TEXT_ALIGN.hanging=.2;ol.render.replay.TEXT_ALIGN.alphabetic=.8;ol.render.replay.TEXT_ALIGN.ideographic=.8;ol.render.replay.TEXT_ALIGN.bottom=1;ol.render.canvas.Replay=function(a,b,c,d,e,f){ol.render.VectorContext.call(this);this.declutterTree=f;this.tmpExtent_=ol.extent.createEmpty();this.tolerance=a;this.maxExtent=b;this.overlaps=e;this.pixelRatio=d;this.maxLineWidth=0;this.resolution=c;this.bufferedMaxExtent_=this.beginGeometryInstruction2_=this.beginGeometryInstruction1_=null;this.instructions=[];this.coordinates=[];this.coordinateCache_={};this.renderedTransform_=ol.transform.create();this.hitDetectionInstructions=[];this.pixelCoordinates_=
null;this.state={};this.viewRotation_=0;this.tmpLocalTransform_=ol.transform.create();this.resetTransform_=ol.transform.create()};ol.inherits(ol.render.canvas.Replay,ol.render.VectorContext);ol.render.canvas.Replay.prototype.replayTextBackground_=function(a,b,c,d,e,f,g){a.beginPath();a.moveTo.apply(a,b);a.lineTo.apply(a,c);a.lineTo.apply(a,d);a.lineTo.apply(a,e);a.lineTo.apply(a,b);f&&(this.fillOrigin_=f[2],this.fill_(a));g&&(this.setStrokeStyle_(a,g),a.stroke())};
ol.render.canvas.Replay.prototype.replayImage_=function(a,b,c,d,e,f,g,h,k,l,m,n,p,q,r,u,t,v){var w=t||v,y=this.tmpLocalTransform_;e*=p;f*=p;b-=e;c-=f;q&&(b=Math.round(b),c=Math.round(c));q=r+l>d.width?d.width-l:r;h=h+m>d.height?d.height-m:h;r=this.tmpExtent_;var z=u[3]+q*p+u[1],x=u[0]+h*p+u[2],C=b-u[3],A=c-u[0];if(w||0!==n){var B=[C,A];var D=[C+z,A];var E=[C+z,A+x];var G=[C,A+x]}u=null;0!==n?(e=b+e,f=c+f,u=ol.transform.compose(y,e,f,1,1,n,-e,-f),ol.extent.createOrUpdateEmpty(r),ol.extent.extendCoordinate(r,
ol.transform.apply(y,B)),ol.extent.extendCoordinate(r,ol.transform.apply(y,D)),ol.extent.extendCoordinate(r,ol.transform.apply(y,E)),ol.extent.extendCoordinate(r,ol.transform.apply(y,G))):ol.extent.createOrUpdate(C,A,C+z,A+x,r);n=a.canvas;n=r[0]<=n.width&&0<=r[2]&&r[1]<=n.height&&0<=r[3];if(g){if(n||1!=g[4])ol.extent.extend(g,r),(a=n?[a,u?u.slice(0):null,k,d,l,m,q,h,b,c,p]:null)&&w&&a.push(t,v,B,D,E,G),g.push(a)}else n&&(w&&this.replayTextBackground_(a,B,D,E,G,t,v),ol.render.canvas.drawImage(a,u,
k,d,l,m,q,h,b,c,p))};ol.render.canvas.Replay.prototype.applyPixelRatio=function(a){var b=this.pixelRatio;return 1==b?a:a.map(function(a){return a*b})};
ol.render.canvas.Replay.prototype.appendFlatCoordinates=function(a,b,c,d,e,f){var g=this.coordinates.length,h=this.getBufferedMaxExtent();f&&(b+=d);f=[a[b],a[b+1]];var k=[NaN,NaN],l=!0,m;for(m=b+d;m<c;m+=d){k[0]=a[m];k[1]=a[m+1];var n=ol.extent.coordinateRelationship(h,k);n!==p?(l&&(this.coordinates[g++]=f[0],this.coordinates[g++]=f[1]),this.coordinates[g++]=k[0],this.coordinates[g++]=k[1],l=!1):n===ol.extent.Relationship.INTERSECTING?(this.coordinates[g++]=k[0],this.coordinates[g++]=k[1],l=!1):l=
!0;f[0]=k[0];f[1]=k[1];var p=n}if(e&&l||m===b+d)this.coordinates[g++]=f[0],this.coordinates[g++]=f[1];return g};ol.render.canvas.Replay.prototype.drawCustomCoordinates_=function(a,b,c,d,e){for(var f=0,g=c.length;f<g;++f){var h=c[f];b=this.appendFlatCoordinates(a,b,h,d,!1,!1);e.push(b);b=h}return b};
ol.render.canvas.Replay.prototype.drawCustom=function(a,b,c){this.beginGeometry(a,b);var d=a.getType(),e=a.getStride(),f=this.coordinates.length,g;if(d==ol.geom.GeometryType.MULTI_POLYGON){d=a.getOrientedFlatCoordinates();var h=[];for(var k=a.getEndss(),l=g=0,m=k.length;l<m;++l){var n=[];g=this.drawCustomCoordinates_(d,g,k[l],e,n);h.push(n)}this.instructions.push([ol.render.canvas.Instruction.CUSTOM,f,h,a,c,ol.geom.flat.inflate.coordinatesss])}else d==ol.geom.GeometryType.POLYGON||d==ol.geom.GeometryType.MULTI_LINE_STRING?
(h=[],d=d==ol.geom.GeometryType.POLYGON?a.getOrientedFlatCoordinates():a.getFlatCoordinates(),this.drawCustomCoordinates_(d,0,a.getEnds(),e,h),this.instructions.push([ol.render.canvas.Instruction.CUSTOM,f,h,a,c,ol.geom.flat.inflate.coordinatess])):d==ol.geom.GeometryType.LINE_STRING||d==ol.geom.GeometryType.MULTI_POINT?(d=a.getFlatCoordinates(),e=this.appendFlatCoordinates(d,0,d.length,e,!1,!1),this.instructions.push([ol.render.canvas.Instruction.CUSTOM,f,e,a,c,ol.geom.flat.inflate.coordinates])):
d==ol.geom.GeometryType.POINT&&(d=a.getFlatCoordinates(),this.coordinates.push(d[0],d[1]),e=this.coordinates.length,this.instructions.push([ol.render.canvas.Instruction.CUSTOM,f,e,a,c]));this.endGeometry(a,b)};ol.render.canvas.Replay.prototype.beginGeometry=function(a,b){this.beginGeometryInstruction1_=[ol.render.canvas.Instruction.BEGIN_GEOMETRY,b,0];this.instructions.push(this.beginGeometryInstruction1_);this.beginGeometryInstruction2_=[ol.render.canvas.Instruction.BEGIN_GEOMETRY,b,0];this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)};
ol.render.canvas.Replay.prototype.fill_=function(a){if(this.fillOrigin_){var b=ol.transform.apply(this.renderedTransform_,this.fillOrigin_.slice());a.translate(b[0],b[1]);a.rotate(this.viewRotation_)}a.fill();this.fillOrigin_&&a.setTransform.apply(a,ol.render.canvas.resetTransform_)};ol.render.canvas.Replay.prototype.setStrokeStyle_=function(a,b){a.strokeStyle=b[1];a.lineWidth=b[2];a.lineCap=b[3];a.lineJoin=b[4];a.miterLimit=b[5];ol.has.CANVAS_LINE_DASH&&(a.lineDashOffset=b[7],a.setLineDash(b[6]))};
ol.render.canvas.Replay.prototype.renderDeclutter_=function(a,b){if(a&&5<a.length){var c=a[4];if(1==c||c==a.length-5){b={minX:a[0],minY:a[1],maxX:a[2],maxY:a[3],value:b};if(!this.declutterTree.collides(b)){this.declutterTree.insert(b);b=ol.render.canvas.drawImage;c=5;for(var d=a.length;c<d;++c){var e=a[c];e&&(11<e.length&&this.replayTextBackground_(e[0],e[13],e[14],e[15],e[16],e[11],e[12]),b.apply(void 0,e))}}a.length=5;ol.extent.createOrUpdateEmpty(a)}}};
ol.render.canvas.Replay.prototype.replay_=function(a,b,c,d,e,f){if(this.pixelCoordinates_&&ol.array.equals(b,this.renderedTransform_))var g=this.pixelCoordinates_;else this.pixelCoordinates_||(this.pixelCoordinates_=[]),g=ol.geom.flat.transform.transform2D(this.coordinates,0,this.coordinates.length,2,b,this.pixelCoordinates_),ol.transform.setFromArray(this.renderedTransform_,b);b=!ol.obj.isEmpty(c);for(var h=0,k=d.length,l,m,n,p,q,r,u,t,v,w=0,y=0,z=null,x=null,C=this.coordinateCache_,A=this.viewRotation_,
B={context:a,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:A},D=this.instructions!=d||this.overlaps?0:200;h<k;)switch(t=d[h],t[0]){case ol.render.canvas.Instruction.BEGIN_GEOMETRY:var E=t[1];b&&c[ol.getUid(E).toString()]||!E.getGeometry()?h=t[2]:void 0===f||ol.extent.intersects(f,E.getGeometry().getExtent())?++h:h=t[2]+1;break;case ol.render.canvas.Instruction.BEGIN_PATH:w>D&&(this.fill_(a),w=0);y>D&&(a.stroke(),y=0);w||y||(a.beginPath(),q=r=NaN);++h;break;case ol.render.canvas.Instruction.CIRCLE:l=
t[1];u=g[l];t=g[l+1];n=g[l+2]-u;p=g[l+3]-t;n=Math.sqrt(n*n+p*p);a.moveTo(u+n,t);a.arc(u,t,n,0,2*Math.PI,!0);++h;break;case ol.render.canvas.Instruction.CLOSE_PATH:a.closePath();++h;break;case ol.render.canvas.Instruction.CUSTOM:l=t[1];m=t[2];u=t[4];n=6==t.length?t[5]:void 0;B.geometry=t[3];B.feature=E;h in C||(C[h]=[]);t=C[h];n?n(g,l,m,2,t):(t[0]=g[l],t[1]=g[l+1],t.length=2);u(t,B);++h;break;case ol.render.canvas.Instruction.DRAW_IMAGE:l=t[1];m=t[2];v=t[3];n=t[4];p=t[5];u=e?null:t[6];var G=t[7],F=
t[8],M=t[9],J=t[10],K=t[11],L=t[12],H=t[13],I=t[14],N=t[15];if(16<t.length){var O=t[16];var P=t[17];t=t[18]}else O=ol.render.canvas.defaultPadding,P=t=!1;for(K&&(L+=A);l<m;l+=2)this.replayImage_(a,g[l],g[l+1],v,n,p,u,G,F,M,J,L,H,I,N,O,P?z:null,t?x:null);this.renderDeclutter_(u,E);++h;break;case ol.render.canvas.Instruction.DRAW_CHARS:n=t[1];p=t[2];l=t[3];u=e?null:t[4];J=t[5];m=t[6];K=t[7];L=t[8];v=t[9];G=t[10];F=t[11];H=t[12];M=t[13];t=t[14];I=ol.geom.flat.length.lineString(g,n,p,2);N=L(H);if(J||
N<=I)if(J=ol.geom.flat.textpath.lineString(g,n,p,2,H,L,(I-N)*ol.render.replay.TEXT_ALIGN[this.textStates[M].textAlign],K)){if(G)for(K=0,L=J.length;K<L;++K)H=J[K],n=H[4],I=this.getImage(n,M,"",G),n=H[2]+F,p=l*I.height+2*(.5-l)*F-v,this.replayImage_(a,H[0],H[1],I,n,p,u,I.height,1,0,0,H[3],t,!1,I.width,ol.render.canvas.defaultPadding,null,null);if(m)for(K=0,L=J.length;K<L;++K)H=J[K],n=H[4],I=this.getImage(n,M,m,""),n=H[2],p=l*I.height-v,this.replayImage_(a,H[0],H[1],I,n,p,u,I.height,1,0,0,H[3],t,!1,
I.width,ol.render.canvas.defaultPadding,null,null)}this.renderDeclutter_(u,E);++h;break;case ol.render.canvas.Instruction.END_GEOMETRY:if(void 0!==e&&(E=t[1],u=e(E)))return u;++h;break;case ol.render.canvas.Instruction.FILL:D?w++:this.fill_(a);++h;break;case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:l=t[1];m=t[2];n=g[l];p=g[l+1];u=n+.5|0;t=p+.5|0;if(u!==q||t!==r)a.moveTo(n,p),q=u,r=t;for(l+=2;l<m;l+=2)if(n=g[l],p=g[l+1],u=n+.5|0,t=p+.5|0,l==m-2||u!==q||t!==r)a.lineTo(n,p),q=u,r=t;++h;break;case ol.render.canvas.Instruction.SET_FILL_STYLE:z=
t;this.fillOrigin_=t[2];w&&(this.fill_(a),w=0,y&&(a.stroke(),y=0));a.fillStyle=t[1];++h;break;case ol.render.canvas.Instruction.SET_STROKE_STYLE:x=t;y&&(a.stroke(),y=0);this.setStrokeStyle_(a,t);++h;break;case ol.render.canvas.Instruction.STROKE:D?y++:a.stroke();++h;break;default:++h}w&&this.fill_(a);y&&a.stroke()};ol.render.canvas.Replay.prototype.replay=function(a,b,c,d){this.viewRotation_=c;this.replay_(a,b,d,this.instructions,void 0,void 0)};
ol.render.canvas.Replay.prototype.replayHitDetection=function(a,b,c,d,e,f){this.viewRotation_=c;return this.replay_(a,b,d,this.hitDetectionInstructions,e,f)};
ol.render.canvas.Replay.prototype.reverseHitDetectionInstructions=function(){var a=this.hitDetectionInstructions;a.reverse();var b,c=a.length,d=-1;for(b=0;b<c;++b){var e=a[b];var f=e[0];f==ol.render.canvas.Instruction.END_GEOMETRY?d=b:f==ol.render.canvas.Instruction.BEGIN_GEOMETRY&&(e[2]=b,ol.array.reverseSubArray(this.hitDetectionInstructions,d,b),d=-1)}};
ol.render.canvas.Replay.prototype.setFillStrokeStyle=function(a,b){var c=this.state;a?(a=a.getColor(),c.fillStyle=ol.colorlike.asColorLike(a?a:ol.render.canvas.defaultFillStyle)):c.fillStyle=void 0;b?(a=b.getColor(),c.strokeStyle=ol.colorlike.asColorLike(a?a:ol.render.canvas.defaultStrokeStyle),a=b.getLineCap(),c.lineCap=void 0!==a?a:ol.render.canvas.defaultLineCap,a=b.getLineDash(),c.lineDash=a?a.slice():ol.render.canvas.defaultLineDash,a=b.getLineDashOffset(),c.lineDashOffset=a?a:ol.render.canvas.defaultLineDashOffset,
a=b.getLineJoin(),c.lineJoin=void 0!==a?a:ol.render.canvas.defaultLineJoin,a=b.getWidth(),c.lineWidth=void 0!==a?a:ol.render.canvas.defaultLineWidth,b=b.getMiterLimit(),c.miterLimit=void 0!==b?b:ol.render.canvas.defaultMiterLimit,c.lineWidth>this.maxLineWidth&&(this.maxLineWidth=c.lineWidth,this.bufferedMaxExtent_=null)):(c.strokeStyle=void 0,c.lineCap=void 0,c.lineDash=null,c.lineDashOffset=void 0,c.lineJoin=void 0,c.lineWidth=void 0,c.miterLimit=void 0)};
ol.render.canvas.Replay.prototype.applyFill=function(a,b){var c=a.fillStyle;a=[ol.render.canvas.Instruction.SET_FILL_STYLE,c];"string"!==typeof c&&(b=b.getExtent(),a.push([b[0],b[3]]));this.instructions.push(a)};ol.render.canvas.Replay.prototype.applyStroke=function(a){this.instructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,a.strokeStyle,a.lineWidth*this.pixelRatio,a.lineCap,a.lineJoin,a.miterLimit,this.applyPixelRatio(a.lineDash),a.lineDashOffset*this.pixelRatio])};
ol.render.canvas.Replay.prototype.updateFillStyle=function(a,b,c){var d=a.fillStyle;if("string"!==typeof d||a.currentFillStyle!=d)b.call(this,a,c),a.currentFillStyle=d};
ol.render.canvas.Replay.prototype.updateStrokeStyle=function(a,b){var c=a.strokeStyle,d=a.lineCap,e=a.lineDash,f=a.lineDashOffset,g=a.lineJoin,h=a.lineWidth,k=a.miterLimit;if(a.currentStrokeStyle!=c||a.currentLineCap!=d||e!=a.currentLineDash&&!ol.array.equals(a.currentLineDash,e)||a.currentLineDashOffset!=f||a.currentLineJoin!=g||a.currentLineWidth!=h||a.currentMiterLimit!=k)b.call(this,a),a.currentStrokeStyle=c,a.currentLineCap=d,a.currentLineDash=e,a.currentLineDashOffset=f,a.currentLineJoin=g,
a.currentLineWidth=h,a.currentMiterLimit=k};ol.render.canvas.Replay.prototype.endGeometry=function(a,b){this.beginGeometryInstruction1_[2]=this.instructions.length;this.beginGeometryInstruction1_=null;this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length;this.beginGeometryInstruction2_=null;a=[ol.render.canvas.Instruction.END_GEOMETRY,b];this.instructions.push(a);this.hitDetectionInstructions.push(a)};ol.render.canvas.Replay.prototype.finish=ol.nullFunction;
ol.render.canvas.Replay.prototype.getBufferedMaxExtent=function(){this.bufferedMaxExtent_||(this.bufferedMaxExtent_=ol.extent.clone(this.maxExtent),0<this.maxLineWidth&&ol.extent.buffer(this.bufferedMaxExtent_,this.resolution*(this.maxLineWidth+1)/2,this.bufferedMaxExtent_));return this.bufferedMaxExtent_};ol.render.canvas.ImageReplay=function(a,b,c,d,e,f){ol.render.canvas.Replay.call(this,a,b,c,d,e,f);this.image_=this.hitDetectionImage_=this.declutterGroup_=null;this.width_=this.snapToPixel_=this.scale_=this.rotation_=this.rotateWithView_=this.originY_=this.originX_=this.opacity_=this.height_=this.anchorY_=this.anchorX_=void 0};ol.inherits(ol.render.canvas.ImageReplay,ol.render.canvas.Replay);
ol.render.canvas.ImageReplay.prototype.drawCoordinates_=function(a,b,c,d){return this.appendFlatCoordinates(a,b,c,d,!1,!1)};
ol.render.canvas.ImageReplay.prototype.drawPoint=function(a,b){if(this.image_){this.beginGeometry(a,b);var c=a.getFlatCoordinates(),d=a.getStride(),e=this.coordinates.length;c=this.drawCoordinates_(c,0,c.length,d);this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,e,c,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.snapToPixel_,this.width_]);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,
e,c,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.endGeometry(a,b)}};
ol.render.canvas.ImageReplay.prototype.drawMultiPoint=function(a,b){if(this.image_){this.beginGeometry(a,b);var c=a.getFlatCoordinates(),d=a.getStride(),e=this.coordinates.length;c=this.drawCoordinates_(c,0,c.length,d);this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,e,c,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.snapToPixel_,this.width_]);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,
e,c,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.endGeometry(a,b)}};
ol.render.canvas.ImageReplay.prototype.finish=function(){this.reverseHitDetectionInstructions();this.anchorY_=this.anchorX_=void 0;this.image_=this.hitDetectionImage_=null;this.width_=this.snapToPixel_=this.rotation_=this.rotateWithView_=this.originY_=this.originX_=this.opacity_=this.scale_=this.height_=void 0};
ol.render.canvas.ImageReplay.prototype.setImageStyle=function(a,b){var c=a.getAnchor(),d=a.getSize(),e=a.getHitDetectionImage(1),f=a.getImage(1),g=a.getOrigin();this.anchorX_=c[0];this.anchorY_=c[1];this.declutterGroup_=b;this.hitDetectionImage_=e;this.image_=f;this.height_=d[1];this.opacity_=a.getOpacity();this.originX_=g[0];this.originY_=g[1];this.rotateWithView_=a.getRotateWithView();this.rotation_=a.getRotation();this.scale_=a.getScale();this.snapToPixel_=a.getSnapToPixel();this.width_=d[0]};ol.render.canvas.LineStringReplay=function(a,b,c,d,e,f){ol.render.canvas.Replay.call(this,a,b,c,d,e,f)};ol.inherits(ol.render.canvas.LineStringReplay,ol.render.canvas.Replay);ol.render.canvas.LineStringReplay.prototype.drawFlatCoordinates_=function(a,b,c,d){var e=this.coordinates.length;a=this.appendFlatCoordinates(a,b,c,d,!1,!1);e=[ol.render.canvas.Instruction.MOVE_TO_LINE_TO,e,a];this.instructions.push(e);this.hitDetectionInstructions.push(e);return c};
ol.render.canvas.LineStringReplay.prototype.drawLineString=function(a,b){var c=this.state,d=c.lineWidth;void 0!==c.strokeStyle&&void 0!==d&&(this.updateStrokeStyle(c,this.applyStroke),this.beginGeometry(a,b),this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,c.strokeStyle,c.lineWidth,c.lineCap,c.lineJoin,c.miterLimit,c.lineDash,c.lineDashOffset],[ol.render.canvas.Instruction.BEGIN_PATH]),c=a.getFlatCoordinates(),d=a.getStride(),this.drawFlatCoordinates_(c,0,c.length,
d),this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]),this.endGeometry(a,b))};
ol.render.canvas.LineStringReplay.prototype.drawMultiLineString=function(a,b){var c=this.state,d=c.lineWidth;if(void 0!==c.strokeStyle&&void 0!==d){this.updateStrokeStyle(c,this.applyStroke);this.beginGeometry(a,b);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,c.strokeStyle,c.lineWidth,c.lineCap,c.lineJoin,c.miterLimit,c.lineDash,c.lineDashOffset],[ol.render.canvas.Instruction.BEGIN_PATH]);c=a.getEnds();d=a.getFlatCoordinates();var e=a.getStride(),f=0,g;var h=0;
for(g=c.length;h<g;++h)f=this.drawFlatCoordinates_(d,f,c[h],e);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);this.endGeometry(a,b)}};ol.render.canvas.LineStringReplay.prototype.finish=function(){var a=this.state;void 0!=a.lastStroke&&a.lastStroke!=this.coordinates.length&&this.instructions.push([ol.render.canvas.Instruction.STROKE]);this.reverseHitDetectionInstructions();this.state=null};
ol.render.canvas.LineStringReplay.prototype.applyStroke=function(a){void 0!=a.lastStroke&&a.lastStroke!=this.coordinates.length&&(this.instructions.push([ol.render.canvas.Instruction.STROKE]),a.lastStroke=this.coordinates.length);a.lastStroke=0;ol.render.canvas.Replay.prototype.applyStroke.call(this,a);this.instructions.push([ol.render.canvas.Instruction.BEGIN_PATH])};ol.render.canvas.PolygonReplay=function(a,b,c,d,e,f){ol.render.canvas.Replay.call(this,a,b,c,d,e,f)};ol.inherits(ol.render.canvas.PolygonReplay,ol.render.canvas.Replay);
ol.render.canvas.PolygonReplay.prototype.drawFlatCoordinatess_=function(a,b,c,d){var e=this.state,f=void 0!==e.fillStyle;e=void 0!=e.strokeStyle;var g=c.length,h=[ol.render.canvas.Instruction.BEGIN_PATH];this.instructions.push(h);this.hitDetectionInstructions.push(h);for(h=0;h<g;++h){var k=c[h],l=this.coordinates.length;b=this.appendFlatCoordinates(a,b,k,d,!0,!e);b=[ol.render.canvas.Instruction.MOVE_TO_LINE_TO,l,b];this.instructions.push(b);this.hitDetectionInstructions.push(b);e&&(b=[ol.render.canvas.Instruction.CLOSE_PATH],
this.instructions.push(b),this.hitDetectionInstructions.push(b));b=k}a=[ol.render.canvas.Instruction.FILL];this.hitDetectionInstructions.push(a);f&&this.instructions.push(a);e&&(f=[ol.render.canvas.Instruction.STROKE],this.instructions.push(f),this.hitDetectionInstructions.push(f));return b};
ol.render.canvas.PolygonReplay.prototype.drawCircle=function(a,b){var c=this.state,d=c.strokeStyle;if(void 0!==c.fillStyle||void 0!==d){this.setFillStrokeStyles_(a);this.beginGeometry(a,b);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE,ol.color.asString(ol.render.canvas.defaultFillStyle)]);void 0!==c.strokeStyle&&this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,c.strokeStyle,c.lineWidth,c.lineCap,c.lineJoin,c.miterLimit,c.lineDash,
c.lineDashOffset]);var e=a.getFlatCoordinates(),f=a.getStride();d=this.coordinates.length;this.appendFlatCoordinates(e,0,e.length,f,!1,!1);e=[ol.render.canvas.Instruction.BEGIN_PATH];d=[ol.render.canvas.Instruction.CIRCLE,d];this.instructions.push(e,d);this.hitDetectionInstructions.push(e,d);d=[ol.render.canvas.Instruction.FILL];this.hitDetectionInstructions.push(d);void 0!==c.fillStyle&&this.instructions.push(d);void 0!==c.strokeStyle&&(c=[ol.render.canvas.Instruction.STROKE],this.instructions.push(c),
this.hitDetectionInstructions.push(c));this.endGeometry(a,b)}};
ol.render.canvas.PolygonReplay.prototype.drawPolygon=function(a,b){var c=this.state;this.setFillStrokeStyles_(a);this.beginGeometry(a,b);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE,ol.color.asString(ol.render.canvas.defaultFillStyle)]);void 0!==c.strokeStyle&&this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,c.strokeStyle,c.lineWidth,c.lineCap,c.lineJoin,c.miterLimit,c.lineDash,c.lineDashOffset]);c=a.getEnds();var d=a.getOrientedFlatCoordinates(),
e=a.getStride();this.drawFlatCoordinatess_(d,0,c,e);this.endGeometry(a,b)};
ol.render.canvas.PolygonReplay.prototype.drawMultiPolygon=function(a,b){var c=this.state,d=c.strokeStyle;if(void 0!==c.fillStyle||void 0!==d){this.setFillStrokeStyles_(a);this.beginGeometry(a,b);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE,ol.color.asString(ol.render.canvas.defaultFillStyle)]);void 0!==c.strokeStyle&&this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE,c.strokeStyle,c.lineWidth,c.lineCap,c.lineJoin,c.miterLimit,c.lineDash,
c.lineDashOffset]);c=a.getEndss();d=a.getOrientedFlatCoordinates();var e=a.getStride(),f=0,g;var h=0;for(g=c.length;h<g;++h)f=this.drawFlatCoordinatess_(d,f,c[h],e);this.endGeometry(a,b)}};ol.render.canvas.PolygonReplay.prototype.finish=function(){this.reverseHitDetectionInstructions();this.state=null;var a=this.tolerance;if(0!==a){var b=this.coordinates,c;var d=0;for(c=b.length;d<c;++d)b[d]=ol.geom.flat.simplify.snap(b[d],a)}};
ol.render.canvas.PolygonReplay.prototype.setFillStrokeStyles_=function(a){var b=this.state;void 0!==b.fillStyle&&this.updateFillStyle(b,this.applyFill,a);void 0!==b.strokeStyle&&this.updateStrokeStyle(b,this.applyStroke)};ol.geom.flat.straightchunk={};ol.geom.flat.straightchunk.lineString=function(a,b,c,d,e){for(var f=c,g=c,h=0,k=0,l=c,m,n,p,q,r,u;c<d;c+=e){var t=b[c],v=b[c+1];void 0!==p&&(p=t-p,q=v-q,n=Math.sqrt(p*p+q*q),void 0!==r&&(k+=m,m=Math.acos((r*p+u*q)/(m*n)),m>a&&(k>h&&(h=k,f=l,g=c),k=0,l=c-e)),m=n,r=p,u=q);p=t;q=v}return k+n>h?[l,c]:[f,g]};ol.style.TextPlacement={POINT:"point",LINE:"line"};ol.render.canvas.TextReplay=function(a,b,c,d,e,f){ol.render.canvas.Replay.call(this,a,b,c,d,e,f);this.labels_=null;this.text_="";this.textOffsetY_=this.textOffsetX_=0;this.textRotateWithView_=void 0;this.textRotation_=0;this.textFillState_=null;this.fillStates={};this.textStrokeState_=null;this.strokeStates={};this.textState_={};this.textStates={};this.strokeKey_=this.fillKey_=this.textKey_="";this.widths_={};ol.render.canvas.labelCache.prune()};ol.inherits(ol.render.canvas.TextReplay,ol.render.canvas.Replay);
ol.render.canvas.TextReplay.measureTextWidths=function(a,b,c){var d=b.length,e=0,f;for(f=0;f<d;++f){var g=ol.render.canvas.measureTextWidth(a,b[f]);e=Math.max(e,g);c.push(g)}return e};
ol.render.canvas.TextReplay.prototype.drawText=function(a,b){var c=this.textFillState_,d=this.textStrokeState_,e=this.textState_;if(""!==this.text_&&e&&(c||d)){c=this.coordinates.length;var f=a.getType();d=null;var g=2,h=2;if(e.placement===ol.style.TextPlacement.LINE){if(!ol.extent.intersects(this.getBufferedMaxExtent(),a.getExtent()))return;d=a.getFlatCoordinates();h=a.getStride();if(f==ol.geom.GeometryType.LINE_STRING)var k=[d.length];else if(f==ol.geom.GeometryType.MULTI_LINE_STRING)k=a.getEnds();
else if(f==ol.geom.GeometryType.POLYGON)k=a.getEnds().slice(0,1);else if(f==ol.geom.GeometryType.MULTI_POLYGON){var l=a.getEndss();k=[];g=0;for(f=l.length;g<f;++g)k.push(l[g][0])}this.beginGeometry(a,b);f=e.textAlign;var m=0;l=0;for(var n=k.length;l<n;++l){if(void 0==f){g=ol.geom.flat.straightchunk.lineString(e.maxAngle,d,m,k[l],h);m=g[0];var p=g[1]}else p=k[l];for(g=m;g<p;g+=h)this.coordinates.push(d[g],d[g+1]);g=this.coordinates.length;m=k[l];this.drawChars_(c,g,this.declutterGroup_);c=g}}else{k=
this.getImage(this.text_,this.textKey_,this.fillKey_,this.strokeKey_);l=k.width/this.pixelRatio;switch(f){case ol.geom.GeometryType.POINT:case ol.geom.GeometryType.MULTI_POINT:d=a.getFlatCoordinates();g=d.length;break;case ol.geom.GeometryType.LINE_STRING:d=a.getFlatMidpoint();break;case ol.geom.GeometryType.CIRCLE:d=a.getCenter();break;case ol.geom.GeometryType.MULTI_LINE_STRING:d=a.getFlatMidpoints();g=d.length;break;case ol.geom.GeometryType.POLYGON:d=a.getFlatInteriorPoint();if(!e.overflow&&d[2]/
this.resolution<l)return;h=3;break;case ol.geom.GeometryType.MULTI_POLYGON:n=a.getFlatInteriorPoints();d=[];g=0;for(f=n.length;g<f;g+=3)(e.overflow||n[g+2]/this.resolution>=l)&&d.push(n[g],n[g+1]);g=d.length;if(0==g)return}g=this.appendFlatCoordinates(d,0,g,h,!1,!1);this.beginGeometry(a,b);if(e.backgroundFill||e.backgroundStroke)this.setFillStrokeStyle(e.backgroundFill,e.backgroundStroke),this.updateFillStyle(this.state,this.applyFill,a),this.updateStrokeStyle(this.state,this.applyStroke);this.drawTextImage_(k,
c,g)}this.endGeometry(a,b)}};
ol.render.canvas.TextReplay.prototype.getImage=function(a,b,c,d){var e=d+b+a+c+this.pixelRatio,f=ol.render.canvas.labelCache;if(!f.containsKey(e)){var g=d?this.strokeStates[d]||this.textStrokeState_:null,h=c?this.fillStates[c]||this.textFillState_:null,k=this.textStates[b]||this.textState_,l=k.scale*this.pixelRatio,m=ol.render.replay.TEXT_ALIGN[k.textAlign||ol.render.canvas.defaultTextAlign];b=d&&g.lineWidth?g.lineWidth:0;a=a.split("\n");var n=a.length,p=[],q=ol.render.canvas.TextReplay.measureTextWidths(k.font,a,
p),r=ol.render.canvas.measureTextHeight(k.font);q=ol.dom.createCanvasContext2D(Math.ceil((q+b)*l),Math.ceil((r*n+b)*l));var u=q.canvas;f.set(e,u);1!=l&&q.scale(l,l);q.font=k.font;d&&(q.strokeStyle=g.strokeStyle,q.lineWidth=b*(ol.has.SAFARI?l:1),q.lineCap=g.lineCap,q.lineJoin=g.lineJoin,q.miterLimit=g.miterLimit,ol.has.CANVAS_LINE_DASH&&g.lineDash.length&&(q.setLineDash(g.lineDash),q.lineDashOffset=g.lineDashOffset));c&&(q.fillStyle=h.fillStyle);q.textBaseline="middle";q.textAlign="center";g=.5-m;
h=m*u.width/l+g*b;if(d)for(d=0;d<n;++d)q.strokeText(a[d],h+g*p[d],.5*(b+r)+d*r);if(c)for(d=0;d<n;++d)q.fillText(a[d],h+g*p[d],.5*(b+r)+d*r)}return f.get(e)};
ol.render.canvas.TextReplay.prototype.drawTextImage_=function(a,b,c){var d=this.textState_,e=this.textStrokeState_,f=this.pixelRatio,g=ol.render.replay.TEXT_ALIGN[d.textAlign||ol.render.canvas.defaultTextAlign],h=ol.render.replay.TEXT_ALIGN[d.textBaseline];e=e&&e.lineWidth?e.lineWidth:0;g=g*a.width/f+2*(.5-g)*e;h=h*a.height/f+2*(.5-h)*e;this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,b,c,a,(g-this.textOffsetX_)*f,(h-this.textOffsetY_)*f,this.declutterGroup_,a.height,1,0,0,this.textRotateWithView_,
this.textRotation_,1,!0,a.width,d.padding==ol.render.canvas.defaultPadding?ol.render.canvas.defaultPadding:d.padding.map(function(a){return a*f}),!!d.backgroundFill,!!d.backgroundStroke]);this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE,b,c,a,(g-this.textOffsetX_)*f,(h-this.textOffsetY_)*f,this.declutterGroup_,a.height,1,0,0,this.textRotateWithView_,this.textRotation_,1/f,!0,a.width,d.padding,!!d.backgroundFill,!!d.backgroundStroke])};
ol.render.canvas.TextReplay.prototype.drawChars_=function(a,b,c){var d=this.textStrokeState_,e=this.textState_,f=this.textFillState_,g=this.strokeKey_;d&&(g in this.strokeStates||(this.strokeStates[g]={strokeStyle:d.strokeStyle,lineCap:d.lineCap,lineDashOffset:d.lineDashOffset,lineWidth:d.lineWidth,lineJoin:d.lineJoin,miterLimit:d.miterLimit,lineDash:d.lineDash}));var h=this.textKey_;this.textKey_ in this.textStates||(this.textStates[this.textKey_]={font:e.font,textAlign:e.textAlign||ol.render.canvas.defaultTextAlign,
scale:e.scale});var k=this.fillKey_;f&&(k in this.fillStates||(this.fillStates[k]={fillStyle:f.fillStyle}));var l=this.pixelRatio;f=ol.render.replay.TEXT_ALIGN[e.textBaseline];var m=this.textOffsetY_*l,n=this.text_,p=e.font,q=e.scale;d=d?d.lineWidth*q/2:0;var r=this.widths_[p];r||(this.widths_[p]=r={});this.instructions.push([ol.render.canvas.Instruction.DRAW_CHARS,a,b,f,c,e.overflow,k,e.maxAngle,function(a){var b=r[a];b||(b=r[a]=ol.render.canvas.measureTextWidth(p,a));return b*q*l},m,g,d*l,n,h,1]);
this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_CHARS,a,b,f,c,e.overflow,k,e.maxAngle,function(a){var b=r[a];b||(b=r[a]=ol.render.canvas.measureTextWidth(p,a));return b*q},m,g,d,n,h,1/l])};
ol.render.canvas.TextReplay.prototype.setTextStyle=function(a,b){var c,d;if(a){this.declutterGroup_=b;(d=a.getFill())?(b=this.textFillState_,b||(b=this.textFillState_={}),b.fillStyle=ol.colorlike.asColorLike(d.getColor()||ol.render.canvas.defaultFillStyle)):b=this.textFillState_=null;if(c=a.getStroke()){d=this.textStrokeState_;d||(d=this.textStrokeState_={});var e=c.getLineDash(),f=c.getLineDashOffset(),g=c.getWidth(),h=c.getMiterLimit();d.lineCap=c.getLineCap()||ol.render.canvas.defaultLineCap;d.lineDash=
e?e.slice():ol.render.canvas.defaultLineDash;d.lineDashOffset=void 0===f?ol.render.canvas.defaultLineDashOffset:f;d.lineJoin=c.getLineJoin()||ol.render.canvas.defaultLineJoin;d.lineWidth=void 0===g?ol.render.canvas.defaultLineWidth:g;d.miterLimit=void 0===h?ol.render.canvas.defaultMiterLimit:h;d.strokeStyle=ol.colorlike.asColorLike(c.getColor()||ol.render.canvas.defaultStrokeStyle)}else d=this.textStrokeState_=null;c=this.textState_;e=a.getFont()||ol.render.canvas.defaultFont;ol.render.canvas.checkFont(e);
f=a.getScale();c.overflow=a.getOverflow();c.font=e;c.maxAngle=a.getMaxAngle();c.placement=a.getPlacement();c.textAlign=a.getTextAlign();c.textBaseline=a.getTextBaseline()||ol.render.canvas.defaultTextBaseline;c.backgroundFill=a.getBackgroundFill();c.backgroundStroke=a.getBackgroundStroke();c.padding=a.getPadding()||ol.render.canvas.defaultPadding;c.scale=void 0===f?1:f;e=a.getOffsetX();f=a.getOffsetY();g=a.getRotateWithView();h=a.getRotation();this.text_=a.getText()||"";this.textOffsetX_=void 0===
e?0:e;this.textOffsetY_=void 0===f?0:f;this.textRotateWithView_=void 0===g?!1:g;this.textRotation_=void 0===h?0:h;this.strokeKey_=d?("string"==typeof d.strokeStyle?d.strokeStyle:ol.getUid(d.strokeStyle))+d.lineCap+d.lineDashOffset+"|"+d.lineWidth+d.lineJoin+d.miterLimit+"["+d.lineDash.join()+"]":"";this.textKey_=c.font+c.scale+(c.textAlign||"?");this.fillKey_=b?"string"==typeof b.fillStyle?b.fillStyle:"|"+ol.getUid(b.fillStyle):""}else this.text_=""};ol.render.canvas.ReplayGroup=function(a,b,c,d,e,f,g){ol.render.ReplayGroup.call(this);this.declutterTree_=f;this.declutterGroup_=null;this.tolerance_=a;this.maxExtent_=b;this.overlaps_=e;this.pixelRatio_=d;this.resolution_=c;this.renderBuffer_=g;this.replaysByZIndex_={};this.hitDetectionContext_=ol.dom.createCanvasContext2D(1,1);this.hitDetectionTransform_=ol.transform.create()};ol.inherits(ol.render.canvas.ReplayGroup,ol.render.ReplayGroup);ol.render.canvas.ReplayGroup.circleArrayCache_={0:[[!0]]};
ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_=function(a,b,c){var d,e=Math.floor(a.length/2);if(b>=e)for(d=e;d<b;d++)a[d][c]=!0;else if(b<e)for(d=b+1;d<e;d++)a[d][c]=!0};
ol.render.canvas.ReplayGroup.getCircleArray_=function(a){if(void 0!==ol.render.canvas.ReplayGroup.circleArrayCache_[a])return ol.render.canvas.ReplayGroup.circleArrayCache_[a];for(var b=2*a+1,c=Array(b),d=0;d<b;d++)c[d]=Array(b);b=a;for(var e=d=0;b>=d;)ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a+b,a+d),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a+d,a+b),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a-d,a+b),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,
a-b,a+d),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a-b,a-d),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a-d,a-b),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a+d,a-b),ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(c,a+b,a-d),d++,e+=1+2*d,0<2*(e-b)+1&&(--b,e+=1-2*b);return ol.render.canvas.ReplayGroup.circleArrayCache_[a]=c};
ol.render.canvas.ReplayGroup.replayDeclutter=function(a,b,c){for(var d=Object.keys(a).map(Number).sort(ol.array.numberSafeCompareFunction),e={},f=0,g=d.length;f<g;++f)for(var h=a[d[f].toString()],k=0,l=h.length;k<l;){var m=h[k++],n=h[k++];m.replay(b,n,c,e)}};ol.render.canvas.ReplayGroup.prototype.addDeclutter=function(a){var b=null;this.declutterTree_&&(a?(b=this.declutterGroup_,b[4]++):(b=this.declutterGroup_=ol.extent.createEmpty(),b.push(1)));return b};
ol.render.canvas.ReplayGroup.prototype.clip=function(a,b){b=this.getClipCoords(b);a.beginPath();a.moveTo(b[0],b[1]);a.lineTo(b[2],b[3]);a.lineTo(b[4],b[5]);a.lineTo(b[6],b[7]);a.clip()};ol.render.canvas.ReplayGroup.prototype.hasReplays=function(a){for(var b in this.replaysByZIndex_)for(var c=this.replaysByZIndex_[b],d=0,e=a.length;d<e;++d)if(a[d]in c)return!0;return!1};ol.render.canvas.ReplayGroup.prototype.finish=function(){for(var a in this.replaysByZIndex_){var b=this.replaysByZIndex_[a],c;for(c in b)b[c].finish()}};
ol.render.canvas.ReplayGroup.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e,f,g){function h(a){for(var b=m.getImageData(0,0,k,k).data,c=0;c<k;c++)for(var d=0;d<k;d++)if(p[c][d]&&0<b[4*(d*k+c)+3]){if(!q||t!=ol.render.ReplayType.IMAGE&&t!=ol.render.ReplayType.TEXT||-1!==q.indexOf(a))var e=f(a);if(e)return e;m.clearRect(0,0,k,k);return}}d=Math.round(d);var k=2*d+1,l=ol.transform.compose(this.hitDetectionTransform_,d+.5,d+.5,1/b,-1/b,-c,-a[0],-a[1]),m=this.hitDetectionContext_;m.canvas.width!==
k||m.canvas.height!==k?(m.canvas.width=k,m.canvas.height=k):m.clearRect(0,0,k,k);if(void 0!==this.renderBuffer_){var n=ol.extent.createEmpty();ol.extent.extendCoordinate(n,a);ol.extent.buffer(n,b*(this.renderBuffer_+d),n)}var p=ol.render.canvas.ReplayGroup.getCircleArray_(d),q;this.declutterTree_&&(q=this.declutterTree_.all().map(function(a){return a.value}));a=Object.keys(this.replaysByZIndex_).map(Number);a.sort(ol.array.numberSafeCompareFunction);for(b=a.length-1;0<=b;--b){var r=a[b].toString();
var u=this.replaysByZIndex_[r];for(d=ol.render.replay.ORDER.length-1;0<=d;--d){var t=ol.render.replay.ORDER[d];var v=u[t];if(void 0!==v)if(!g||t!=ol.render.ReplayType.IMAGE&&t!=ol.render.ReplayType.TEXT){if(v=v.replayHitDetection(m,l,c,e,h,n))return v}else{var w=g[r];w?w.push(v,l.slice(0)):g[r]=[v,l.slice(0)]}}}};ol.render.canvas.ReplayGroup.prototype.getClipCoords=function(a){var b=this.maxExtent_,c=b[0],d=b[1],e=b[2];b=b[3];c=[c,d,c,b,e,b,e,d];ol.geom.flat.transform.transform2D(c,0,8,2,a,c);return c};
ol.render.canvas.ReplayGroup.prototype.getReplay=function(a,b){var c=void 0!==a?a.toString():"0";a=this.replaysByZIndex_[c];void 0===a&&(a={},this.replaysByZIndex_[c]=a);c=a[b];void 0===c&&(c=new ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_[b](this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_,this.overlaps_,this.declutterTree_),a[b]=c);return c};ol.render.canvas.ReplayGroup.prototype.getReplays=function(){return this.replaysByZIndex_};
ol.render.canvas.ReplayGroup.prototype.isEmpty=function(){return ol.obj.isEmpty(this.replaysByZIndex_)};
ol.render.canvas.ReplayGroup.prototype.replay=function(a,b,c,d,e,f){var g=Object.keys(this.replaysByZIndex_).map(Number);g.sort(ol.array.numberSafeCompareFunction);a.save();this.clip(a,b);e=e?e:ol.render.replay.ORDER;var h,k;var l=0;for(h=g.length;l<h;++l){var m=g[l].toString();var n=this.replaysByZIndex_[m];var p=0;for(k=e.length;p<k;++p){var q=e[p];var r=n[q];void 0!==r&&(!f||q!=ol.render.ReplayType.IMAGE&&q!=ol.render.ReplayType.TEXT?r.replay(a,b,c,d):(q=f[m])?q.push(r,b.slice(0)):f[m]=[r,b.slice(0)])}}a.restore()};
ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_={Circle:ol.render.canvas.PolygonReplay,Default:ol.render.canvas.Replay,Image:ol.render.canvas.ImageReplay,LineString:ol.render.canvas.LineStringReplay,Polygon:ol.render.canvas.PolygonReplay,Text:ol.render.canvas.TextReplay};ol.renderer.vector={};ol.renderer.vector.defaultOrder=function(a,b){return ol.getUid(a)-ol.getUid(b)};ol.renderer.vector.getSquaredTolerance=function(a,b){a=ol.renderer.vector.getTolerance(a,b);return a*a};ol.renderer.vector.getTolerance=function(a,b){return ol.SIMPLIFY_TOLERANCE*a/b};
ol.renderer.vector.renderCircleGeometry_=function(a,b,c,d){var e=c.getFill(),f=c.getStroke();if(e||f){var g=a.getReplay(c.getZIndex(),ol.render.ReplayType.CIRCLE);g.setFillStrokeStyle(e,f);g.drawCircle(b,d)}if(e=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(e,a.addDeclutter(!1)),c.drawText(b,d)};
ol.renderer.vector.renderFeature=function(a,b,c,d,e,f){var g=!1,h;if(h=c.getImage()){var k=h.getImageState();k==ol.ImageState.LOADED||k==ol.ImageState.ERROR?h.unlistenImageChange(e,f):(k==ol.ImageState.IDLE&&h.load(),h.getImageState(),h.listenImageChange(e,f),g=!0)}ol.renderer.vector.renderFeature_(a,b,c,d);return g};
ol.renderer.vector.renderFeature_=function(a,b,c,d){var e=c.getGeometryFunction()(b);if(e)if(d=e.getSimplifiedGeometry(d),c.getRenderer())ol.renderer.vector.renderGeometry_(a,d,c,b);else(0,ol.renderer.vector.GEOMETRY_RENDERERS_[d.getType()])(a,d,c,b)};
ol.renderer.vector.renderGeometry_=function(a,b,c,d){if(b.getType()==ol.geom.GeometryType.GEOMETRY_COLLECTION){b=b.getGeometries();for(var e=0,f=b.length;e<f;++e)ol.renderer.vector.renderGeometry_(a,b[e],c,d)}else a.getReplay(c.getZIndex(),ol.render.ReplayType.DEFAULT).drawCustom(b,d,c.getRenderer())};
ol.renderer.vector.renderGeometryCollectionGeometry_=function(a,b,c,d){b=b.getGeometriesArray();var e;var f=0;for(e=b.length;f<e;++f)(0,ol.renderer.vector.GEOMETRY_RENDERERS_[b[f].getType()])(a,b[f],c,d)};
ol.renderer.vector.renderLineStringGeometry_=function(a,b,c,d){var e=c.getStroke();if(e){var f=a.getReplay(c.getZIndex(),ol.render.ReplayType.LINE_STRING);f.setFillStrokeStyle(null,e);f.drawLineString(b,d)}if(e=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(e,a.addDeclutter(!1)),c.drawText(b,d)};
ol.renderer.vector.renderMultiLineStringGeometry_=function(a,b,c,d){var e=c.getStroke();if(e){var f=a.getReplay(c.getZIndex(),ol.render.ReplayType.LINE_STRING);f.setFillStrokeStyle(null,e);f.drawMultiLineString(b,d)}if(e=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(e,a.addDeclutter(!1)),c.drawText(b,d)};
ol.renderer.vector.renderMultiPolygonGeometry_=function(a,b,c,d){var e=c.getFill(),f=c.getStroke();if(f||e){var g=a.getReplay(c.getZIndex(),ol.render.ReplayType.POLYGON);g.setFillStrokeStyle(e,f);g.drawMultiPolygon(b,d)}if(e=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(e,a.addDeclutter(!1)),c.drawText(b,d)};
ol.renderer.vector.renderPointGeometry_=function(a,b,c,d){var e=c.getImage();if(e){if(e.getImageState()!=ol.ImageState.LOADED)return;var f=a.getReplay(c.getZIndex(),ol.render.ReplayType.IMAGE);f.setImageStyle(e,a.addDeclutter(!1));f.drawPoint(b,d)}if(f=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(f,a.addDeclutter(!!e)),c.drawText(b,d)};
ol.renderer.vector.renderMultiPointGeometry_=function(a,b,c,d){var e=c.getImage();if(e){if(e.getImageState()!=ol.ImageState.LOADED)return;var f=a.getReplay(c.getZIndex(),ol.render.ReplayType.IMAGE);f.setImageStyle(e,a.addDeclutter(!1));f.drawMultiPoint(b,d)}if(f=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(f,a.addDeclutter(!!e)),c.drawText(b,d)};
ol.renderer.vector.renderPolygonGeometry_=function(a,b,c,d){var e=c.getFill(),f=c.getStroke();if(e||f){var g=a.getReplay(c.getZIndex(),ol.render.ReplayType.POLYGON);g.setFillStrokeStyle(e,f);g.drawPolygon(b,d)}if(e=c.getText())c=a.getReplay(c.getZIndex(),ol.render.ReplayType.TEXT),c.setTextStyle(e,a.addDeclutter(!1)),c.drawText(b,d)};
ol.renderer.vector.GEOMETRY_RENDERERS_={Point:ol.renderer.vector.renderPointGeometry_,LineString:ol.renderer.vector.renderLineStringGeometry_,Polygon:ol.renderer.vector.renderPolygonGeometry_,MultiPoint:ol.renderer.vector.renderMultiPointGeometry_,MultiLineString:ol.renderer.vector.renderMultiLineStringGeometry_,MultiPolygon:ol.renderer.vector.renderMultiPolygonGeometry_,GeometryCollection:ol.renderer.vector.renderGeometryCollectionGeometry_,Circle:ol.renderer.vector.renderCircleGeometry_};ol.renderer.canvas.VectorLayer=function(a){ol.renderer.canvas.Layer.call(this,a);this.declutterTree_=a.getDeclutter()?ol.ext.rbush(9):null;this.dirty_=!1;this.renderedRevision_=-1;this.renderedResolution_=NaN;this.renderedExtent_=ol.extent.createEmpty();this.replayGroup_=this.renderedRenderOrder_=null;this.replayGroupChanged=!0;this.context=ol.dom.createCanvasContext2D();ol.events.listen(ol.render.canvas.labelCache,ol.events.EventType.CLEAR,this.handleFontsChanged_,this)};
ol.inherits(ol.renderer.canvas.VectorLayer,ol.renderer.canvas.Layer);ol.renderer.canvas.VectorLayer.handles=function(a,b){return a===ol.renderer.Type.CANVAS&&b.getType()===ol.LayerType.VECTOR};ol.renderer.canvas.VectorLayer.create=function(a,b){return new ol.renderer.canvas.VectorLayer(b)};ol.renderer.canvas.VectorLayer.prototype.disposeInternal=function(){ol.events.unlisten(ol.render.canvas.labelCache,ol.events.EventType.CLEAR,this.handleFontsChanged_,this);ol.renderer.canvas.Layer.prototype.disposeInternal.call(this)};
ol.renderer.canvas.VectorLayer.prototype.composeFrame=function(a,b,c){var d=a.extent,e=a.pixelRatio,f=b.managed?a.skippedFeatureUids:{},g=a.viewState,h=g.projection,k=g.rotation,l=h.getExtent(),m=this.getLayer().getSource(),n=this.getTransform(a,0);this.preCompose(c,a,n);var p=b.extent;(g=void 0!==p)&&this.clip(c,a,p);var q=this.replayGroup_;if(q&&!q.isEmpty()){this.declutterTree_&&this.declutterTree_.clear();var r=this.getLayer(),u=p=0,t=1!==b.opacity;r=r.hasListener(ol.render.EventType.RENDER);
if(t||r){var v=c.canvas.width;var w=c.canvas.height;if(k){var y=Math.round(Math.sqrt(v*v+w*w));p=(y-v)/2;u=(y-w)/2;v=w=y}this.context.canvas.width=v;this.context.canvas.height=w;v=this.context}else v=c;w=v.globalAlpha;t||(v.globalAlpha=b.opacity);v!=c&&v.translate(p,u);y=a.size[0]*e;e*=a.size[1];ol.render.canvas.rotateAtOffset(v,-k,y/2,e/2);q.replay(v,n,k,f);if(m.getWrapX()&&h.canWrapX()&&!ol.extent.containsExtent(l,d)){h=d[0];m=ol.extent.getWidth(l);for(var z=0;h<l[0];)--z,n=m*z,n=this.getTransform(a,
n),q.replay(v,n,k,f),h+=m;z=0;for(h=d[2];h>l[2];)++z,n=m*z,n=this.getTransform(a,n),q.replay(v,n,k,f),h-=m;n=this.getTransform(a,0)}ol.render.canvas.rotateAtOffset(v,k,y/2,e/2);v!=c&&(r&&this.dispatchRenderEvent(v,a,n),t?(d=c.globalAlpha,c.globalAlpha=b.opacity,c.drawImage(v.canvas,-p,-u),c.globalAlpha=d):c.drawImage(v.canvas,-p,-u),v.translate(-p,-u));t||(v.globalAlpha=w)}g&&c.restore();this.postCompose(c,a,b,n)};
ol.renderer.canvas.VectorLayer.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){if(this.replayGroup_){var f=b.viewState.resolution;b=b.viewState.rotation;var g=this.getLayer(),h={};return this.replayGroup_.forEachFeatureAtCoordinate(a,f,b,c,{},function(a){var b=ol.getUid(a).toString();if(!(b in h))return h[b]=!0,d.call(e,a,g)},null)}};ol.renderer.canvas.VectorLayer.prototype.handleFontsChanged_=function(a){a=this.getLayer();a.getVisible()&&this.replayGroup_&&a.changed()};
ol.renderer.canvas.VectorLayer.prototype.handleStyleImageChange_=function(a){this.renderIfReadyAndVisible()};
ol.renderer.canvas.VectorLayer.prototype.prepareFrame=function(a,b){var c=this.getLayer();b=c.getSource();this.updateLogos(a,b);var d=a.viewHints[ol.ViewHint.ANIMATING],e=a.viewHints[ol.ViewHint.INTERACTING],f=c.getUpdateWhileAnimating(),g=c.getUpdateWhileInteracting();if(!this.dirty_&&!f&&d||!g&&e)return!0;f=a.extent;var h=a.viewState;g=h.projection;var k=h.resolution,l=a.pixelRatio;d=c.getRevision();var m=c.getRenderBuffer();e=c.getRenderOrder();void 0===e&&(e=ol.renderer.vector.defaultOrder);f=
ol.extent.buffer(f,m*k);m=h.projection.getExtent();b.getWrapX()&&h.projection.canWrapX()&&!ol.extent.containsExtent(m,a.extent)&&(a=ol.extent.getWidth(m),a=Math.max(ol.extent.getWidth(f)/2,a),f[0]=m[0]-a,f[2]=m[2]+a);if(!this.dirty_&&this.renderedResolution_==k&&this.renderedRevision_==d&&this.renderedRenderOrder_==e&&ol.extent.containsExtent(this.renderedExtent_,f))return this.replayGroupChanged=!1,!0;this.replayGroup_=null;this.dirty_=!1;var n=new ol.render.canvas.ReplayGroup(ol.renderer.vector.getTolerance(k,
l),f,k,l,b.getOverlaps(),this.declutterTree_,c.getRenderBuffer());b.loadFeatures(f,k,g);a=function(a){var b=a.getStyleFunction();if(b)var d=b.call(a,k);else(b=c.getStyleFunction())&&(d=b(a,k));d&&(a=this.renderFeature(a,k,l,d,n),this.dirty_=this.dirty_||a)}.bind(this);if(e){var p=[];b.forEachFeatureInExtent(f,function(a){p.push(a)},this);p.sort(e);b=0;for(g=p.length;b<g;++b)a(p[b])}else b.forEachFeatureInExtent(f,a,this);n.finish();this.renderedResolution_=k;this.renderedRevision_=d;this.renderedRenderOrder_=
e;this.renderedExtent_=f;this.replayGroup_=n;return this.replayGroupChanged=!0};ol.renderer.canvas.VectorLayer.prototype.renderFeature=function(a,b,c,d,e){if(!d)return!1;var f=!1;if(Array.isArray(d))for(var g=0,h=d.length;g<h;++g)f=ol.renderer.vector.renderFeature(e,a,d[g],ol.renderer.vector.getSquaredTolerance(b,c),this.handleStyleImageChange_,this)||f;else f=ol.renderer.vector.renderFeature(e,a,d,ol.renderer.vector.getSquaredTolerance(b,c),this.handleStyleImageChange_,this);return f};ol.layer.VectorTileRenderType={IMAGE:"image",HYBRID:"hybrid",VECTOR:"vector"};ol.renderer.canvas.VectorTileLayer=function(a){this.context=null;ol.renderer.canvas.TileLayer.call(this,a);this.declutterTree_=a.getDeclutter()?ol.ext.rbush(9):null;this.dirty_=!1;this.tmpTransform_=ol.transform.create();this.zDirection=a.getRenderMode()==ol.layer.VectorTileRenderType.VECTOR?1:0;ol.events.listen(ol.render.canvas.labelCache,ol.events.EventType.CLEAR,this.handleFontsChanged_,this)};ol.inherits(ol.renderer.canvas.VectorTileLayer,ol.renderer.canvas.TileLayer);
ol.renderer.canvas.VectorTileLayer.handles=function(a,b){return a===ol.renderer.Type.CANVAS&&b.getType()===ol.LayerType.VECTOR_TILE};ol.renderer.canvas.VectorTileLayer.create=function(a,b){return new ol.renderer.canvas.VectorTileLayer(b)};ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS={image:[ol.render.ReplayType.POLYGON,ol.render.ReplayType.CIRCLE,ol.render.ReplayType.LINE_STRING,ol.render.ReplayType.IMAGE,ol.render.ReplayType.TEXT],hybrid:[ol.render.ReplayType.POLYGON,ol.render.ReplayType.LINE_STRING]};
ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS={image:[ol.render.ReplayType.DEFAULT],hybrid:[ol.render.ReplayType.IMAGE,ol.render.ReplayType.TEXT,ol.render.ReplayType.DEFAULT],vector:ol.render.replay.ORDER};ol.renderer.canvas.VectorTileLayer.prototype.disposeInternal=function(){ol.events.unlisten(ol.render.canvas.labelCache,ol.events.EventType.CLEAR,this.handleFontsChanged_,this);ol.renderer.canvas.TileLayer.prototype.disposeInternal.call(this)};
ol.renderer.canvas.VectorTileLayer.prototype.prepareFrame=function(a,b){var c=this.getLayer(),d=c.getRevision();this.renderedLayerRevision_!=d&&(this.renderedTiles.length=0,c=c.getRenderMode(),this.context||c==ol.layer.VectorTileRenderType.VECTOR||(this.context=ol.dom.createCanvasContext2D()),this.context&&c==ol.layer.VectorTileRenderType.VECTOR&&(this.context=null));this.renderedLayerRevision_=d;return ol.renderer.canvas.TileLayer.prototype.prepareFrame.apply(this,arguments)};
ol.renderer.canvas.VectorTileLayer.prototype.createReplayGroup_=function(a,b){var c=this.getLayer(),d=b.pixelRatio;b=b.viewState.projection;var e=c.getRevision(),f=c.getRenderOrder()||null,g=a.getReplayState(c);if(g.dirty||g.renderedRevision!=e||g.renderedRenderOrder!=f){var h=c.getSource(),k=h.getTileGrid(),l=h.getTileGridForProjection(b),m=l.getResolution(a.tileCoord[0]);l=l.getTileCoordExtent(a.wrappedTileCoord);for(var n=0,p=a.tileKeys.length;n<p;++n){var q=a.getTile(a.tileKeys[n]);if(q.getState()!=
ol.TileState.ERROR){var r=k.getTileCoordExtent(q.tileCoord),u=ol.extent.getIntersection(l,r),t=ol.extent.equals(r,u)?null:ol.extent.buffer(u,c.getRenderBuffer()*m),v=q.getProjection(),w=!1;ol.proj.equivalent(b,v)||(w=!0,q.setProjection(b));g.dirty=!1;u=new ol.render.canvas.ReplayGroup(0,u,m,d,h.getOverlaps(),this.declutterTree_,c.getRenderBuffer());var y=ol.renderer.vector.getSquaredTolerance(m,d),z=q.getFeatures();f&&f!==g.renderedRenderOrder&&z.sort(f);for(var x,C=0,A=z.length;C<A;++C)if(x=z[C],
w&&(v.getUnits()==ol.proj.Units.TILE_PIXELS&&(v.setWorldExtent(r),v.setExtent(q.getExtent())),x.getGeometry().transform(v,b)),!t||ol.extent.intersects(t,x.getGeometry().getExtent())){var B=void 0,D=x.getStyleFunction();D?B=D.call(x,m):(D=c.getStyleFunction())&&(B=D(x,m));B&&(B=this.renderFeature(x,y,B,u),this.dirty_=this.dirty_||B,g.dirty=g.dirty||B)}u.finish();for(var E in u.getReplays());q.setReplayGroup(c,a.tileCoord.toString(),u)}}g.renderedRevision=e;g.renderedRenderOrder=f}};
ol.renderer.canvas.VectorTileLayer.prototype.drawTileImage=function(a,b,c,d,e,f,g,h,k){var l=a;this.createReplayGroup_(l,b);this.context&&(this.renderTileImage_(l,b,c),ol.renderer.canvas.TileLayer.prototype.drawTileImage.apply(this,arguments))};
ol.renderer.canvas.VectorTileLayer.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){var f=b.viewState.resolution,g=b.viewState.rotation;c=void 0==c?0:c;var h=this.getLayer(),k={},l=this.renderedTiles;b=h.getSource().getTileGridForProjection(b.viewState.projection);var m;var n=0;for(m=l.length;n<m;++n){var p=l[n];var q=p.wrappedTileCoord;q=b.getTileCoordExtent(q,this.tmpExtent);var r=ol.extent.buffer(q,c*f,r);if(ol.extent.containsCoordinate(r,a)){q=0;for(var u=p.tileKeys.length;q<u;++q){var t=
p.getTile(p.tileKeys[q]);if(t.getState()!=ol.TileState.ERROR){t=t.getReplayGroup(h,p.tileCoord.toString());var v=v||t.forEachFeatureAtCoordinate(a,f,g,c,{},function(a){var b=ol.getUid(a).toString();if(!(b in k))return k[b]=!0,d.call(e,a,h)},null)}}}}return v};
ol.renderer.canvas.VectorTileLayer.prototype.getReplayTransform_=function(a,b){var c=this.getLayer().getSource().getTileGrid(),d=a.tileCoord;a=c.getResolution(d[0]);var e=b.viewState,f=b.pixelRatio,g=e.resolution/f;d=c.getTileCoordExtent(d,this.tmpExtent);c=e.center;d=ol.extent.getTopLeft(d);b=b.size;return ol.transform.compose(this.tmpTransform_,Math.round(f*b[0]/2),Math.round(f*b[1]/2),a/g,a/g,e.rotation,(d[0]-c[0])/a,(c[1]-d[1])/a)};
ol.renderer.canvas.VectorTileLayer.prototype.handleFontsChanged_=function(a){a=this.getLayer();a.getVisible()&&void 0!==this.renderedLayerRevision_&&a.changed()};ol.renderer.canvas.VectorTileLayer.prototype.handleStyleImageChange_=function(a){this.renderIfReadyAndVisible()};
ol.renderer.canvas.VectorTileLayer.prototype.postCompose=function(a,b,c){var d=this.getLayer(),e=d.getDeclutter()?{}:null,f=d.getSource(),g=d.getRenderMode(),h=ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS[g],k=b.pixelRatio,l=b.viewState.rotation,m=b.size;if(l){var n=Math.round(k*m[0]/2);var p=Math.round(k*m[1]/2);ol.render.canvas.rotateAtOffset(a,-l,n,p)}e&&this.declutterTree_.clear();k=this.renderedTiles;f=f.getTileGridForProjection(b.viewState.projection);m=[];for(var q=[],r=k.length-1;0<=
r;--r){var u=k[r];if(u.getState()!=ol.TileState.ABORT)for(var t=u.tileCoord,v=f.getTileCoordExtent(t)[0]-f.getTileCoordExtent(u.wrappedTileCoord)[0],w=void 0,y=0,z=u.tileKeys.length;y<z;++y){var x=u.getTile(u.tileKeys[y]);if(x.getState()!=ol.TileState.ERROR){var C=x.getReplayGroup(d,t.toString());if(g==ol.layer.VectorTileRenderType.VECTOR||C.hasReplays(h)){w||(w=this.getTransform(b,v));x=x.tileCoord[0];var A=C.getClipCoords(w);a.save();a.globalAlpha=c.opacity;for(var B=0,D=m.length;B<D;++B){var E=
m[B];x<q[B]&&(a.beginPath(),a.moveTo(A[0],A[1]),a.lineTo(A[2],A[3]),a.lineTo(A[4],A[5]),a.lineTo(A[6],A[7]),a.moveTo(E[6],E[7]),a.lineTo(E[4],E[5]),a.lineTo(E[2],E[3]),a.lineTo(E[0],E[1]),a.clip())}C.replay(a,w,l,{},h,e);a.restore();m.push(A);q.push(x)}}}}e&&ol.render.canvas.ReplayGroup.replayDeclutter(e,a,l);l&&ol.render.canvas.rotateAtOffset(a,l,n,p);ol.renderer.canvas.TileLayer.prototype.postCompose.apply(this,arguments)};
ol.renderer.canvas.VectorTileLayer.prototype.renderFeature=function(a,b,c,d){if(!c)return!1;var e=!1;if(Array.isArray(c))for(var f=0,g=c.length;f<g;++f)e=ol.renderer.vector.renderFeature(d,a,c[f],b,this.handleStyleImageChange_,this)||e;else e=ol.renderer.vector.renderFeature(d,a,c,b,this.handleStyleImageChange_,this);return e};
ol.renderer.canvas.VectorTileLayer.prototype.renderTileImage_=function(a,b,c){c=this.getLayer();var d=a.getReplayState(c),e=c.getRevision(),f=ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS[c.getRenderMode()];if(f&&d.renderedTileRevision!==e){d.renderedTileRevision=e;var g=a.wrappedTileCoord,h=g[0];d=b.pixelRatio;var k=c.getSource(),l=k.getTileGridForProjection(b.viewState.projection);e=l.getResolution(h);var m=a.getContext(c);b=k.getTilePixelSize(h,d,b.viewState.projection);m.canvas.width=b[0];
m.canvas.height=b[1];b=l.getTileCoordExtent(g);g=0;for(l=a.tileKeys.length;g<l;++g)if(h=a.getTile(a.tileKeys[g]),h.getState()!=ol.TileState.ERROR){k=d/e;var n=ol.transform.reset(this.tmpTransform_);ol.transform.scale(n,k,-k);ol.transform.translate(n,-b[0],-b[3]);h.getReplayGroup(c,a.tileCoord.toString()).replay(m,n,0,{},f)}}};ol.plugins.register(ol.PluginType.MAP_RENDERER,ol.renderer.canvas.Map);ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER,[ol.renderer.canvas.ImageLayer,ol.renderer.canvas.TileLayer,ol.renderer.canvas.VectorLayer,ol.renderer.canvas.VectorTileLayer]);ol.CanvasMap=function(a){a=ol.obj.assign({},a);delete a.renderer;a.controls||(a.controls=ol.control.defaults());a.interactions||(a.interactions=ol.interaction.defaults());ol.PluggableMap.call(this,a)};ol.inherits(ol.CanvasMap,ol.PluggableMap);ol.DeviceOrientation=function(a){ol.Object.call(this);a=a?a:{};this.listenerKey_=null;ol.events.listen(this,ol.Object.getChangeEventType(ol.DeviceOrientation.Property_.TRACKING),this.handleTrackingChanged_,this);this.setTracking(void 0!==a.tracking?a.tracking:!1)};ol.inherits(ol.DeviceOrientation,ol.Object);ol.DeviceOrientation.prototype.disposeInternal=function(){this.setTracking(!1);ol.Object.prototype.disposeInternal.call(this)};
ol.DeviceOrientation.prototype.orientationChange_=function(a){if(null!==a.alpha){var b=ol.math.toRadians(a.alpha);this.set(ol.DeviceOrientation.Property_.ALPHA,b);"boolean"===typeof a.absolute&&a.absolute?this.set(ol.DeviceOrientation.Property_.HEADING,b):"number"===typeof a.webkitCompassHeading&&-1!=a.webkitCompassAccuracy&&(b=ol.math.toRadians(a.webkitCompassHeading),this.set(ol.DeviceOrientation.Property_.HEADING,b))}null!==a.beta&&this.set(ol.DeviceOrientation.Property_.BETA,ol.math.toRadians(a.beta));
null!==a.gamma&&this.set(ol.DeviceOrientation.Property_.GAMMA,ol.math.toRadians(a.gamma));this.changed()};ol.DeviceOrientation.prototype.getAlpha=function(){return this.get(ol.DeviceOrientation.Property_.ALPHA)};ol.DeviceOrientation.prototype.getBeta=function(){return this.get(ol.DeviceOrientation.Property_.BETA)};ol.DeviceOrientation.prototype.getGamma=function(){return this.get(ol.DeviceOrientation.Property_.GAMMA)};ol.DeviceOrientation.prototype.getHeading=function(){return this.get(ol.DeviceOrientation.Property_.HEADING)};
ol.DeviceOrientation.prototype.getTracking=function(){return this.get(ol.DeviceOrientation.Property_.TRACKING)};ol.DeviceOrientation.prototype.handleTrackingChanged_=function(){if(ol.has.DEVICE_ORIENTATION){var a=this.getTracking();a&&!this.listenerKey_?this.listenerKey_=ol.events.listen(window,"deviceorientation",this.orientationChange_,this):a||null===this.listenerKey_||(ol.events.unlistenByKey(this.listenerKey_),this.listenerKey_=null)}};
ol.DeviceOrientation.prototype.setTracking=function(a){this.set(ol.DeviceOrientation.Property_.TRACKING,a)};ol.DeviceOrientation.Property_={ALPHA:"alpha",BETA:"beta",GAMMA:"gamma",HEADING:"heading",TRACKING:"tracking"};ol.style.Image=function(a){this.opacity_=a.opacity;this.rotateWithView_=a.rotateWithView;this.rotation_=a.rotation;this.scale_=a.scale;this.snapToPixel_=a.snapToPixel};ol.style.Image.prototype.getOpacity=function(){return this.opacity_};ol.style.Image.prototype.getRotateWithView=function(){return this.rotateWithView_};ol.style.Image.prototype.getRotation=function(){return this.rotation_};ol.style.Image.prototype.getScale=function(){return this.scale_};ol.style.Image.prototype.getSnapToPixel=function(){return this.snapToPixel_};
ol.style.Image.prototype.getAnchor=function(){};ol.style.Image.prototype.getImage=function(a){};ol.style.Image.prototype.getHitDetectionImage=function(a){};ol.style.Image.prototype.getImageState=function(){};ol.style.Image.prototype.getImageSize=function(){};ol.style.Image.prototype.getHitDetectionImageSize=function(){};ol.style.Image.prototype.getOrigin=function(){};ol.style.Image.prototype.getSize=function(){};ol.style.Image.prototype.setOpacity=function(a){this.opacity_=a};
ol.style.Image.prototype.setRotateWithView=function(a){this.rotateWithView_=a};ol.style.Image.prototype.setRotation=function(a){this.rotation_=a};ol.style.Image.prototype.setScale=function(a){this.scale_=a};ol.style.Image.prototype.setSnapToPixel=function(a){this.snapToPixel_=a};ol.style.Image.prototype.listenImageChange=function(a,b){};ol.style.Image.prototype.load=function(){};ol.style.Image.prototype.unlistenImageChange=function(a,b){};ol.style.RegularShape=function(a){this.hitDetectionCanvas_=this.canvas_=this.checksums_=null;this.fill_=void 0!==a.fill?a.fill:null;this.origin_=[0,0];this.points_=a.points;this.radius_=void 0!==a.radius?a.radius:a.radius1;this.radius2_=a.radius2;this.angle_=void 0!==a.angle?a.angle:0;this.stroke_=void 0!==a.stroke?a.stroke:null;this.hitDetectionImageSize_=this.imageSize_=this.size_=this.anchor_=null;this.atlasManager_=a.atlasManager;this.render_(this.atlasManager_);ol.style.Image.call(this,{opacity:1,
rotateWithView:void 0!==a.rotateWithView?a.rotateWithView:!1,rotation:void 0!==a.rotation?a.rotation:0,scale:1,snapToPixel:void 0!==a.snapToPixel?a.snapToPixel:!0})};ol.inherits(ol.style.RegularShape,ol.style.Image);
ol.style.RegularShape.prototype.clone=function(){var a=new ol.style.RegularShape({fill:this.getFill()?this.getFill().clone():void 0,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),snapToPixel:this.getSnapToPixel(),stroke:this.getStroke()?this.getStroke().clone():void 0,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),atlasManager:this.atlasManager_});a.setOpacity(this.getOpacity());a.setScale(this.getScale());return a};
ol.style.RegularShape.prototype.getAnchor=function(){return this.anchor_};ol.style.RegularShape.prototype.getAngle=function(){return this.angle_};ol.style.RegularShape.prototype.getFill=function(){return this.fill_};ol.style.RegularShape.prototype.getHitDetectionImage=function(a){return this.hitDetectionCanvas_};ol.style.RegularShape.prototype.getImage=function(a){return this.canvas_};ol.style.RegularShape.prototype.getImageSize=function(){return this.imageSize_};
ol.style.RegularShape.prototype.getHitDetectionImageSize=function(){return this.hitDetectionImageSize_};ol.style.RegularShape.prototype.getImageState=function(){return ol.ImageState.LOADED};ol.style.RegularShape.prototype.getOrigin=function(){return this.origin_};ol.style.RegularShape.prototype.getPoints=function(){return this.points_};ol.style.RegularShape.prototype.getRadius=function(){return this.radius_};ol.style.RegularShape.prototype.getRadius2=function(){return this.radius2_};
ol.style.RegularShape.prototype.getSize=function(){return this.size_};ol.style.RegularShape.prototype.getStroke=function(){return this.stroke_};ol.style.RegularShape.prototype.listenImageChange=function(a,b){};ol.style.RegularShape.prototype.load=function(){};ol.style.RegularShape.prototype.unlistenImageChange=function(a,b){};
ol.style.RegularShape.prototype.render_=function(a){var b="",c="",d=0,e=null,f=0,g=0;if(this.stroke_){var h=this.stroke_.getColor();null===h&&(h=ol.render.canvas.defaultStrokeStyle);h=ol.colorlike.asColorLike(h);g=this.stroke_.getWidth();void 0===g&&(g=ol.render.canvas.defaultLineWidth);e=this.stroke_.getLineDash();f=this.stroke_.getLineDashOffset();ol.has.CANVAS_LINE_DASH||(e=null,f=0);c=this.stroke_.getLineJoin();void 0===c&&(c=ol.render.canvas.defaultLineJoin);b=this.stroke_.getLineCap();void 0===
b&&(b=ol.render.canvas.defaultLineCap);d=this.stroke_.getMiterLimit();void 0===d&&(d=ol.render.canvas.defaultMiterLimit)}var k=2*(this.radius_+g)+1;b={strokeStyle:h,strokeWidth:g,size:k,lineCap:b,lineDash:e,lineDashOffset:f,lineJoin:c,miterLimit:d};if(void 0===a){var l=ol.dom.createCanvasContext2D(k,k);this.canvas_=l.canvas;a=k=this.canvas_.width;this.draw_(b,l,0,0);this.createHitDetectionCanvas_(b)}else k=Math.round(k),(c=!this.fill_)&&(l=this.drawHitDetectionCanvas_.bind(this,b)),d=this.getChecksum(),
l=a.add(d,k,k,this.draw_.bind(this,b),l),this.canvas_=l.image,this.origin_=[l.offsetX,l.offsetY],a=l.image.width,c?(this.hitDetectionCanvas_=l.hitImage,this.hitDetectionImageSize_=[l.hitImage.width,l.hitImage.height]):(this.hitDetectionCanvas_=this.canvas_,this.hitDetectionImageSize_=[a,a]);this.anchor_=[k/2,k/2];this.size_=[k,k];this.imageSize_=[a,a]};
ol.style.RegularShape.prototype.draw_=function(a,b,c,d){b.setTransform(1,0,0,1,0,0);b.translate(c,d);b.beginPath();var e=this.points_;if(Infinity===e)b.arc(a.size/2,a.size/2,this.radius_,0,2*Math.PI,!0);else{var f=void 0!==this.radius2_?this.radius2_:this.radius_;f!==this.radius_&&(e*=2);for(c=0;c<=e;c++){d=2*c*Math.PI/e-Math.PI/2+this.angle_;var g=0===c%2?this.radius_:f;b.lineTo(a.size/2+g*Math.cos(d),a.size/2+g*Math.sin(d))}}this.fill_&&(c=this.fill_.getColor(),null===c&&(c=ol.render.canvas.defaultFillStyle),
b.fillStyle=ol.colorlike.asColorLike(c),b.fill());this.stroke_&&(b.strokeStyle=a.strokeStyle,b.lineWidth=a.strokeWidth,a.lineDash&&(b.setLineDash(a.lineDash),b.lineDashOffset=a.lineDashOffset),b.lineCap=a.lineCap,b.lineJoin=a.lineJoin,b.miterLimit=a.miterLimit,b.stroke());b.closePath()};
ol.style.RegularShape.prototype.createHitDetectionCanvas_=function(a){this.hitDetectionImageSize_=[a.size,a.size];if(this.fill_)this.hitDetectionCanvas_=this.canvas_;else{var b=ol.dom.createCanvasContext2D(a.size,a.size);this.hitDetectionCanvas_=b.canvas;this.drawHitDetectionCanvas_(a,b,0,0)}};
ol.style.RegularShape.prototype.drawHitDetectionCanvas_=function(a,b,c,d){b.setTransform(1,0,0,1,0,0);b.translate(c,d);b.beginPath();c=this.points_;if(Infinity===c)b.arc(a.size/2,a.size/2,this.radius_,0,2*Math.PI,!0);else{d=void 0!==this.radius2_?this.radius2_:this.radius_;d!==this.radius_&&(c*=2);var e;for(e=0;e<=c;e++){var f=2*e*Math.PI/c-Math.PI/2+this.angle_;var g=0===e%2?this.radius_:d;b.lineTo(a.size/2+g*Math.cos(f),a.size/2+g*Math.sin(f))}}b.fillStyle=ol.render.canvas.defaultFillStyle;b.fill();
this.stroke_&&(b.strokeStyle=a.strokeStyle,b.lineWidth=a.strokeWidth,a.lineDash&&(b.setLineDash(a.lineDash),b.lineDashOffset=a.lineDashOffset),b.stroke());b.closePath()};
ol.style.RegularShape.prototype.getChecksum=function(){var a=this.stroke_?this.stroke_.getChecksum():"-",b=this.fill_?this.fill_.getChecksum():"-";this.checksums_&&a==this.checksums_[1]&&b==this.checksums_[2]&&this.radius_==this.checksums_[3]&&this.radius2_==this.checksums_[4]&&this.angle_==this.checksums_[5]&&this.points_==this.checksums_[6]||(this.checksums_=["r"+a+b+(void 0!==this.radius_?this.radius_.toString():"-")+(void 0!==this.radius2_?this.radius2_.toString():"-")+(void 0!==this.angle_?this.angle_.toString():
"-")+(void 0!==this.points_?this.points_.toString():"-"),a,b,this.radius_,this.radius2_,this.angle_,this.points_]);return this.checksums_[0]};ol.style.Circle=function(a){a=a||{};ol.style.RegularShape.call(this,{points:Infinity,fill:a.fill,radius:a.radius,snapToPixel:a.snapToPixel,stroke:a.stroke,atlasManager:a.atlasManager})};ol.inherits(ol.style.Circle,ol.style.RegularShape);
ol.style.Circle.prototype.clone=function(){var a=new ol.style.Circle({fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,radius:this.getRadius(),snapToPixel:this.getSnapToPixel(),atlasManager:this.atlasManager_});a.setOpacity(this.getOpacity());a.setScale(this.getScale());return a};ol.style.Circle.prototype.setRadius=function(a){this.radius_=a;this.render_(this.atlasManager_)};ol.style.Fill=function(a){a=a||{};this.color_=void 0!==a.color?a.color:null;this.checksum_=void 0};ol.style.Fill.prototype.clone=function(){var a=this.getColor();return new ol.style.Fill({color:a&&a.slice?a.slice():a||void 0})};ol.style.Fill.prototype.getColor=function(){return this.color_};ol.style.Fill.prototype.setColor=function(a){this.color_=a;this.checksum_=void 0};
ol.style.Fill.prototype.getChecksum=function(){void 0===this.checksum_&&(this.checksum_=this.color_ instanceof CanvasPattern||this.color_ instanceof CanvasGradient?ol.getUid(this.color_).toString():"f"+(this.color_?ol.color.asString(this.color_):"-"));return this.checksum_};ol.style.Stroke=function(a){a=a||{};this.color_=void 0!==a.color?a.color:null;this.lineCap_=a.lineCap;this.lineDash_=void 0!==a.lineDash?a.lineDash:null;this.lineDashOffset_=a.lineDashOffset;this.lineJoin_=a.lineJoin;this.miterLimit_=a.miterLimit;this.width_=a.width;this.checksum_=void 0};
ol.style.Stroke.prototype.clone=function(){var a=this.getColor();return new ol.style.Stroke({color:a&&a.slice?a.slice():a||void 0,lineCap:this.getLineCap(),lineDash:this.getLineDash()?this.getLineDash().slice():void 0,lineDashOffset:this.getLineDashOffset(),lineJoin:this.getLineJoin(),miterLimit:this.getMiterLimit(),width:this.getWidth()})};ol.style.Stroke.prototype.getColor=function(){return this.color_};ol.style.Stroke.prototype.getLineCap=function(){return this.lineCap_};
ol.style.Stroke.prototype.getLineDash=function(){return this.lineDash_};ol.style.Stroke.prototype.getLineDashOffset=function(){return this.lineDashOffset_};ol.style.Stroke.prototype.getLineJoin=function(){return this.lineJoin_};ol.style.Stroke.prototype.getMiterLimit=function(){return this.miterLimit_};ol.style.Stroke.prototype.getWidth=function(){return this.width_};ol.style.Stroke.prototype.setColor=function(a){this.color_=a;this.checksum_=void 0};
ol.style.Stroke.prototype.setLineCap=function(a){this.lineCap_=a;this.checksum_=void 0};ol.style.Stroke.prototype.setLineDash=function(a){this.lineDash_=a;this.checksum_=void 0};ol.style.Stroke.prototype.setLineDashOffset=function(a){this.lineDashOffset_=a;this.checksum_=void 0};ol.style.Stroke.prototype.setLineJoin=function(a){this.lineJoin_=a;this.checksum_=void 0};ol.style.Stroke.prototype.setMiterLimit=function(a){this.miterLimit_=a;this.checksum_=void 0};
ol.style.Stroke.prototype.setWidth=function(a){this.width_=a;this.checksum_=void 0};
ol.style.Stroke.prototype.getChecksum=function(){void 0===this.checksum_&&(this.checksum_="s",this.checksum_=this.color_?"string"===typeof this.color_?this.checksum_+this.color_:this.checksum_+ol.getUid(this.color_).toString():this.checksum_+"-",this.checksum_+=","+(void 0!==this.lineCap_?this.lineCap_.toString():"-")+","+(this.lineDash_?this.lineDash_.toString():"-")+","+(void 0!==this.lineDashOffset_?this.lineDashOffset_:"-")+","+(void 0!==this.lineJoin_?this.lineJoin_:"-")+","+(void 0!==this.miterLimit_?
this.miterLimit_.toString():"-")+","+(void 0!==this.width_?this.width_.toString():"-"));return this.checksum_};ol.style.Style=function(a){a=a||{};this.geometry_=null;this.geometryFunction_=ol.style.Style.defaultGeometryFunction;void 0!==a.geometry&&this.setGeometry(a.geometry);this.fill_=void 0!==a.fill?a.fill:null;this.image_=void 0!==a.image?a.image:null;this.renderer_=void 0!==a.renderer?a.renderer:null;this.stroke_=void 0!==a.stroke?a.stroke:null;this.text_=void 0!==a.text?a.text:null;this.zIndex_=a.zIndex};
ol.style.Style.prototype.clone=function(){var a=this.getGeometry();a&&a.clone&&(a=a.clone());return new ol.style.Style({geometry:a,fill:this.getFill()?this.getFill().clone():void 0,image:this.getImage()?this.getImage().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,text:this.getText()?this.getText().clone():void 0,zIndex:this.getZIndex()})};ol.style.Style.prototype.getRenderer=function(){return this.renderer_};
ol.style.Style.prototype.setRenderer=function(a){this.renderer_=a};ol.style.Style.prototype.getGeometry=function(){return this.geometry_};ol.style.Style.prototype.getGeometryFunction=function(){return this.geometryFunction_};ol.style.Style.prototype.getFill=function(){return this.fill_};ol.style.Style.prototype.setFill=function(a){this.fill_=a};ol.style.Style.prototype.getImage=function(){return this.image_};ol.style.Style.prototype.setImage=function(a){this.image_=a};
ol.style.Style.prototype.getStroke=function(){return this.stroke_};ol.style.Style.prototype.setStroke=function(a){this.stroke_=a};ol.style.Style.prototype.getText=function(){return this.text_};ol.style.Style.prototype.setText=function(a){this.text_=a};ol.style.Style.prototype.getZIndex=function(){return this.zIndex_};
ol.style.Style.prototype.setGeometry=function(a){"function"===typeof a?this.geometryFunction_=a:"string"===typeof a?this.geometryFunction_=function(b){return b.get(a)}:a?void 0!==a&&(this.geometryFunction_=function(){return a}):this.geometryFunction_=ol.style.Style.defaultGeometryFunction;this.geometry_=a};ol.style.Style.prototype.setZIndex=function(a){this.zIndex_=a};
ol.style.Style.createFunction=function(a){if("function"!==typeof a){if(Array.isArray(a))var b=a;else ol.asserts.assert(a instanceof ol.style.Style,41),b=[a];a=function(){return b}}return a};ol.style.Style.default_=null;
ol.style.Style.defaultFunction=function(a,b){ol.style.Style.default_||(a=new ol.style.Fill({color:"rgba(255,255,255,0.4)"}),b=new ol.style.Stroke({color:"#3399CC",width:1.25}),ol.style.Style.default_=[new ol.style.Style({image:new ol.style.Circle({fill:a,stroke:b,radius:5}),fill:a,stroke:b})]);return ol.style.Style.default_};
ol.style.Style.createDefaultEditing=function(){var a={},b=[255,255,255,1],c=[0,153,255,1];a[ol.geom.GeometryType.POLYGON]=[new ol.style.Style({fill:new ol.style.Fill({color:[255,255,255,.5]})})];a[ol.geom.GeometryType.MULTI_POLYGON]=a[ol.geom.GeometryType.POLYGON];a[ol.geom.GeometryType.LINE_STRING]=[new ol.style.Style({stroke:new ol.style.Stroke({color:b,width:5})}),new ol.style.Style({stroke:new ol.style.Stroke({color:c,width:3})})];a[ol.geom.GeometryType.MULTI_LINE_STRING]=a[ol.geom.GeometryType.LINE_STRING];
a[ol.geom.GeometryType.CIRCLE]=a[ol.geom.GeometryType.POLYGON].concat(a[ol.geom.GeometryType.LINE_STRING]);a[ol.geom.GeometryType.POINT]=[new ol.style.Style({image:new ol.style.Circle({radius:6,fill:new ol.style.Fill({color:c}),stroke:new ol.style.Stroke({color:b,width:1.5})}),zIndex:Infinity})];a[ol.geom.GeometryType.MULTI_POINT]=a[ol.geom.GeometryType.POINT];a[ol.geom.GeometryType.GEOMETRY_COLLECTION]=a[ol.geom.GeometryType.POLYGON].concat(a[ol.geom.GeometryType.LINE_STRING],a[ol.geom.GeometryType.POINT]);
return a};ol.style.Style.defaultGeometryFunction=function(a){return a.getGeometry()};ol.Feature=function(a){ol.Object.call(this);this.id_=void 0;this.geometryName_="geometry";this.style_=null;this.styleFunction_=void 0;this.geometryChangeKey_=null;ol.events.listen(this,ol.Object.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);void 0!==a&&(a instanceof ol.geom.Geometry||!a?this.setGeometry(a):this.setProperties(a))};ol.inherits(ol.Feature,ol.Object);
ol.Feature.prototype.clone=function(){var a=new ol.Feature(this.getProperties());a.setGeometryName(this.getGeometryName());var b=this.getGeometry();b&&a.setGeometry(b.clone());(b=this.getStyle())&&a.setStyle(b);return a};ol.Feature.prototype.getGeometry=function(){return this.get(this.geometryName_)};ol.Feature.prototype.getId=function(){return this.id_};ol.Feature.prototype.getGeometryName=function(){return this.geometryName_};ol.Feature.prototype.getStyle=function(){return this.style_};
ol.Feature.prototype.getStyleFunction=function(){return this.styleFunction_};ol.Feature.prototype.handleGeometryChange_=function(){this.changed()};ol.Feature.prototype.handleGeometryChanged_=function(){this.geometryChangeKey_&&(ol.events.unlistenByKey(this.geometryChangeKey_),this.geometryChangeKey_=null);var a=this.getGeometry();a&&(this.geometryChangeKey_=ol.events.listen(a,ol.events.EventType.CHANGE,this.handleGeometryChange_,this));this.changed()};
ol.Feature.prototype.setGeometry=function(a){this.set(this.geometryName_,a)};ol.Feature.prototype.setStyle=function(a){this.styleFunction_=(this.style_=a)?ol.Feature.createStyleFunction(a):void 0;this.changed()};ol.Feature.prototype.setId=function(a){this.id_=a;this.changed()};
ol.Feature.prototype.setGeometryName=function(a){ol.events.unlisten(this,ol.Object.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);this.geometryName_=a;ol.events.listen(this,ol.Object.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);this.handleGeometryChanged_()};
ol.Feature.createStyleFunction=function(a){if("function"===typeof a)var b=2==a.length?function(b){return a(this,b)}:a;else{if(Array.isArray(a))var c=a;else ol.asserts.assert(a instanceof ol.style.Style,41),c=[a];b=function(){return c}}return b};ol.GeolocationProperty={ACCURACY:"accuracy",ACCURACY_GEOMETRY:"accuracyGeometry",ALTITUDE:"altitude",ALTITUDE_ACCURACY:"altitudeAccuracy",HEADING:"heading",POSITION:"position",PROJECTION:"projection",SPEED:"speed",TRACKING:"tracking",TRACKING_OPTIONS:"trackingOptions"};ol.Geolocation=function(a){ol.Object.call(this);a=a||{};this.position_=null;this.transform_=ol.proj.identityTransform;this.sphere_=new ol.Sphere(ol.proj.EPSG4326.RADIUS);this.watchId_=void 0;ol.events.listen(this,ol.Object.getChangeEventType(ol.GeolocationProperty.PROJECTION),this.handleProjectionChanged_,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.GeolocationProperty.TRACKING),this.handleTrackingChanged_,this);void 0!==a.projection&&this.setProjection(a.projection);void 0!==a.trackingOptions&&
this.setTrackingOptions(a.trackingOptions);this.setTracking(void 0!==a.tracking?a.tracking:!1)};ol.inherits(ol.Geolocation,ol.Object);ol.Geolocation.prototype.disposeInternal=function(){this.setTracking(!1);ol.Object.prototype.disposeInternal.call(this)};ol.Geolocation.prototype.handleProjectionChanged_=function(){var a=this.getProjection();a&&(this.transform_=ol.proj.getTransformFromProjections(ol.proj.get("EPSG:4326"),a),this.position_&&this.set(ol.GeolocationProperty.POSITION,this.transform_(this.position_)))};
ol.Geolocation.prototype.handleTrackingChanged_=function(){if(ol.has.GEOLOCATION){var a=this.getTracking();a&&void 0===this.watchId_?this.watchId_=navigator.geolocation.watchPosition(this.positionChange_.bind(this),this.positionError_.bind(this),this.getTrackingOptions()):a||void 0===this.watchId_||(navigator.geolocation.clearWatch(this.watchId_),this.watchId_=void 0)}};
ol.Geolocation.prototype.positionChange_=function(a){a=a.coords;this.set(ol.GeolocationProperty.ACCURACY,a.accuracy);this.set(ol.GeolocationProperty.ALTITUDE,null===a.altitude?void 0:a.altitude);this.set(ol.GeolocationProperty.ALTITUDE_ACCURACY,null===a.altitudeAccuracy?void 0:a.altitudeAccuracy);this.set(ol.GeolocationProperty.HEADING,null===a.heading?void 0:ol.math.toRadians(a.heading));this.position_?(this.position_[0]=a.longitude,this.position_[1]=a.latitude):this.position_=[a.longitude,a.latitude];
var b=this.transform_(this.position_);this.set(ol.GeolocationProperty.POSITION,b);this.set(ol.GeolocationProperty.SPEED,null===a.speed?void 0:a.speed);a=ol.geom.Polygon.circular(this.sphere_,this.position_,a.accuracy);a.applyTransform(this.transform_);this.set(ol.GeolocationProperty.ACCURACY_GEOMETRY,a);this.changed()};ol.Geolocation.prototype.positionError_=function(a){a.type=ol.events.EventType.ERROR;this.setTracking(!1);this.dispatchEvent(a)};ol.Geolocation.prototype.getAccuracy=function(){return this.get(ol.GeolocationProperty.ACCURACY)};
ol.Geolocation.prototype.getAccuracyGeometry=function(){return this.get(ol.GeolocationProperty.ACCURACY_GEOMETRY)||null};ol.Geolocation.prototype.getAltitude=function(){return this.get(ol.GeolocationProperty.ALTITUDE)};ol.Geolocation.prototype.getAltitudeAccuracy=function(){return this.get(ol.GeolocationProperty.ALTITUDE_ACCURACY)};ol.Geolocation.prototype.getHeading=function(){return this.get(ol.GeolocationProperty.HEADING)};ol.Geolocation.prototype.getPosition=function(){return this.get(ol.GeolocationProperty.POSITION)};
ol.Geolocation.prototype.getProjection=function(){return this.get(ol.GeolocationProperty.PROJECTION)};ol.Geolocation.prototype.getSpeed=function(){return this.get(ol.GeolocationProperty.SPEED)};ol.Geolocation.prototype.getTracking=function(){return this.get(ol.GeolocationProperty.TRACKING)};ol.Geolocation.prototype.getTrackingOptions=function(){return this.get(ol.GeolocationProperty.TRACKING_OPTIONS)};ol.Geolocation.prototype.setProjection=function(a){this.set(ol.GeolocationProperty.PROJECTION,ol.proj.get(a))};
ol.Geolocation.prototype.setTracking=function(a){this.set(ol.GeolocationProperty.TRACKING,a)};ol.Geolocation.prototype.setTrackingOptions=function(a){this.set(ol.GeolocationProperty.TRACKING_OPTIONS,a)};ol.geom.flat.interpolate={};
ol.geom.flat.interpolate.lineString=function(a,b,c,d,e,f){var g=NaN,h=NaN,k=(c-b)/d;if(1===k)g=a[b],h=a[b+1];else if(2==k)g=(1-e)*a[b]+e*a[b+d],h=(1-e)*a[b+1]+e*a[b+d+1];else if(0!==k){h=a[b];k=a[b+1];var l=0;g=[0];var m;for(m=b+d;m<c;m+=d){var n=a[m],p=a[m+1];l+=Math.sqrt((n-h)*(n-h)+(p-k)*(p-k));g.push(l);h=n;k=p}e*=l;c=ol.array.binarySearch(g,e);0>c?(e=(e-g[-c-2])/(g[-c-1]-g[-c-2]),b+=(-c-2)*d,g=ol.math.lerp(a[b],a[b+d],e),h=ol.math.lerp(a[b+1],a[b+d+1],e)):(g=a[b+c*d],h=a[b+c*d+1])}return f?(f[0]=
g,f[1]=h,f):[g,h]};ol.geom.flat.interpolate.lineStringCoordinateAtM=function(a,b,c,d,e,f){if(c==b)return null;if(e<a[b+d-1])return f?(c=a.slice(b,b+d),c[d-1]=e,c):null;if(a[c-1]<e)return f?(c=a.slice(c-d,c),c[d-1]=e,c):null;if(e==a[b+d-1])return a.slice(b,b+d);b/=d;for(c/=d;b<c;)f=b+c>>1,e<a[(f+1)*d-1]?c=f:b=f+1;c=a[b*d-1];if(e==c)return a.slice((b-1)*d,(b-1)*d+d);f=(e-c)/(a[(b+1)*d-1]-c);c=[];var g;for(g=0;g<d-1;++g)c.push(ol.math.lerp(a[(b-1)*d+g],a[b*d+g],f));c.push(e);return c};
ol.geom.flat.interpolate.lineStringsCoordinateAtM=function(a,b,c,d,e,f,g){if(g)return ol.geom.flat.interpolate.lineStringCoordinateAtM(a,b,c[c.length-1],d,e,f);if(e<a[d-1])return f?(a=a.slice(0,d),a[d-1]=e,a):null;if(a[a.length-1]<e)return f?(a=a.slice(a.length-d),a[d-1]=e,a):null;f=0;for(g=c.length;f<g;++f){var h=c[f];if(b!=h){if(e<a[b+d-1])break;else if(e<=a[h-1])return ol.geom.flat.interpolate.lineStringCoordinateAtM(a,b,h,d,e,!1);b=h}}return null};ol.geom.LineString=function(a,b){ol.geom.SimpleGeometry.call(this);this.flatMidpoint_=null;this.maxDeltaRevision_=this.maxDelta_=this.flatMidpointRevision_=-1;this.setCoordinates(a,b)};ol.inherits(ol.geom.LineString,ol.geom.SimpleGeometry);ol.geom.LineString.prototype.appendCoordinate=function(a){this.flatCoordinates?ol.array.extend(this.flatCoordinates,a):this.flatCoordinates=a.slice();this.changed()};
ol.geom.LineString.prototype.clone=function(){var a=new ol.geom.LineString(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return a};
ol.geom.LineString.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision());return ol.geom.flat.closest.getClosestPoint(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,a,b,c,d)};
ol.geom.LineString.prototype.forEachSegment=function(a,b){return ol.geom.flat.segments.forEach(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a,b)};ol.geom.LineString.prototype.getCoordinateAtM=function(a,b){return this.layout!=ol.geom.GeometryLayout.XYM&&this.layout!=ol.geom.GeometryLayout.XYZM?null:ol.geom.flat.interpolate.lineStringCoordinateAtM(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a,void 0!==b?b:!1)};
ol.geom.LineString.prototype.getCoordinates=function(){return ol.geom.flat.inflate.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)};ol.geom.LineString.prototype.getCoordinateAt=function(a,b){return ol.geom.flat.interpolate.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a,b)};ol.geom.LineString.prototype.getLength=function(){return ol.geom.flat.length.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)};
ol.geom.LineString.prototype.getFlatMidpoint=function(){this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_),this.flatMidpointRevision_=this.getRevision());return this.flatMidpoint_};
ol.geom.LineString.prototype.getSimplifiedGeometryInternal=function(a){var b=[];b.length=ol.geom.flat.simplify.douglasPeucker(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a,b,0);a=new ol.geom.LineString(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,b);return a};ol.geom.LineString.prototype.getType=function(){return ol.geom.GeometryType.LINE_STRING};
ol.geom.LineString.prototype.intersectsExtent=function(a){return ol.geom.flat.intersectsextent.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,a)};ol.geom.LineString.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ol.geom.flat.deflate.coordinates(this.flatCoordinates,0,a,this.stride),this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null)};
ol.geom.LineString.prototype.setFlatCoordinates=function(a,b){this.setFlatCoordinatesInternal(a,b);this.changed()};ol.geom.flat.geodesic={};ol.geom.flat.geodesic.line_=function(a,b,c){for(var d=[],e=a(0),f=a(1),g=b(e),h=b(f),k=[f,e],l=[h,g],m=[1,0],n={},p=1E5,q,r,u,t,v;0<--p&&0<m.length;)u=m.pop(),e=k.pop(),g=l.pop(),f=u.toString(),f in n||(d.push(g[0],g[1]),n[f]=!0),t=m.pop(),f=k.pop(),h=l.pop(),v=(u+t)/2,q=a(v),r=b(q),ol.math.squaredSegmentDistance(r[0],r[1],g[0],g[1],h[0],h[1])<c?(d.push(h[0],h[1]),f=t.toString(),n[f]=!0):(m.push(t,v,v,u),l.push(h,r,r,g),k.push(f,q,q,e));return d};
ol.geom.flat.geodesic.greatCircleArc=function(a,b,c,d,e,f){var g=ol.proj.get("EPSG:4326"),h=Math.cos(ol.math.toRadians(b)),k=Math.sin(ol.math.toRadians(b)),l=Math.cos(ol.math.toRadians(d)),m=Math.sin(ol.math.toRadians(d)),n=Math.cos(ol.math.toRadians(c-a)),p=Math.sin(ol.math.toRadians(c-a)),q=k*m+h*l*n;return ol.geom.flat.geodesic.line_(function(b){if(1<=q)return[c,d];var e=b*Math.acos(q);b=Math.cos(e);var f=Math.sin(e),g=Math.atan2(p*l,h*m-k*l*n);e=Math.asin(k*b+h*f*Math.cos(g));b=ol.math.toRadians(a)+
Math.atan2(Math.sin(g)*f*h,b-k*Math.sin(e));return[ol.math.toDegrees(b),ol.math.toDegrees(e)]},ol.proj.getTransform(g,e),f)};ol.geom.flat.geodesic.meridian=function(a,b,c,d,e){var f=ol.proj.get("EPSG:4326");return ol.geom.flat.geodesic.line_(function(d){return[a,b+(c-b)*d]},ol.proj.getTransform(f,d),e)};ol.geom.flat.geodesic.parallel=function(a,b,c,d,e){var f=ol.proj.get("EPSG:4326");return ol.geom.flat.geodesic.line_(function(d){return[b+(c-b)*d,a]},ol.proj.getTransform(f,d),e)};ol.style.Text=function(a){a=a||{};this.font_=a.font;this.rotation_=a.rotation;this.rotateWithView_=a.rotateWithView;this.scale_=a.scale;this.text_=a.text;this.textAlign_=a.textAlign;this.textBaseline_=a.textBaseline;this.fill_=void 0!==a.fill?a.fill:new ol.style.Fill({color:ol.style.Text.DEFAULT_FILL_COLOR_});this.maxAngle_=void 0!==a.maxAngle?a.maxAngle:Math.PI/4;this.placement_=void 0!==a.placement?a.placement:ol.style.TextPlacement.POINT;var b=void 0===a.overflow?a.exceedLength:a.overflow;this.overflow_=
void 0!==b?b:!1;this.stroke_=void 0!==a.stroke?a.stroke:null;this.offsetX_=void 0!==a.offsetX?a.offsetX:0;this.offsetY_=void 0!==a.offsetY?a.offsetY:0;this.backgroundFill_=a.backgroundFill?a.backgroundFill:null;this.backgroundStroke_=a.backgroundStroke?a.backgroundStroke:null;this.padding_=void 0===a.padding?null:a.padding};ol.style.Text.DEFAULT_FILL_COLOR_="#333";
ol.style.Text.prototype.clone=function(){return new ol.style.Text({font:this.getFont(),placement:this.getPlacement(),maxAngle:this.getMaxAngle(),overflow:this.getOverflow(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),scale:this.getScale(),text:this.getText(),textAlign:this.getTextAlign(),textBaseline:this.getTextBaseline(),fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,offsetX:this.getOffsetX(),offsetY:this.getOffsetY()})};
ol.style.Text.prototype.getOverflow=function(){return this.overflow_};ol.style.Text.prototype.getFont=function(){return this.font_};ol.style.Text.prototype.getMaxAngle=function(){return this.maxAngle_};ol.style.Text.prototype.getPlacement=function(){return this.placement_};ol.style.Text.prototype.getOffsetX=function(){return this.offsetX_};ol.style.Text.prototype.getOffsetY=function(){return this.offsetY_};ol.style.Text.prototype.getFill=function(){return this.fill_};
ol.style.Text.prototype.getRotateWithView=function(){return this.rotateWithView_};ol.style.Text.prototype.getRotation=function(){return this.rotation_};ol.style.Text.prototype.getScale=function(){return this.scale_};ol.style.Text.prototype.getStroke=function(){return this.stroke_};ol.style.Text.prototype.getText=function(){return this.text_};ol.style.Text.prototype.getTextAlign=function(){return this.textAlign_};ol.style.Text.prototype.getTextBaseline=function(){return this.textBaseline_};
ol.style.Text.prototype.getBackgroundFill=function(){return this.backgroundFill_};ol.style.Text.prototype.getBackgroundStroke=function(){return this.backgroundStroke_};ol.style.Text.prototype.getPadding=function(){return this.padding_};ol.style.Text.prototype.setOverflow=function(a){this.overflow_=a};ol.style.Text.prototype.setFont=function(a){this.font_=a};ol.style.Text.prototype.setMaxAngle=function(a){this.maxAngle_=a};ol.style.Text.prototype.setOffsetX=function(a){this.offsetX_=a};
ol.style.Text.prototype.setOffsetY=function(a){this.offsetY_=a};ol.style.Text.prototype.setPlacement=function(a){this.placement_=a};ol.style.Text.prototype.setFill=function(a){this.fill_=a};ol.style.Text.prototype.setRotation=function(a){this.rotation_=a};ol.style.Text.prototype.setScale=function(a){this.scale_=a};ol.style.Text.prototype.setStroke=function(a){this.stroke_=a};ol.style.Text.prototype.setText=function(a){this.text_=a};
ol.style.Text.prototype.setTextAlign=function(a){this.textAlign_=a};ol.style.Text.prototype.setTextBaseline=function(a){this.textBaseline_=a};ol.style.Text.prototype.setBackgroundFill=function(a){this.backgroundFill_=a};ol.style.Text.prototype.setBackgroundStroke=function(a){this.backgroundStroke_=a};ol.style.Text.prototype.setPadding=function(a){this.padding_=a};ol.Graticule=function(a){a=a||{};this.projection_=this.map_=null;this.maxLon_=this.maxLat_=Infinity;this.minLon_=this.minLat_=-Infinity;this.maxLonP_=this.maxLatP_=Infinity;this.minLonP_=this.minLatP_=-Infinity;this.targetSize_=void 0!==a.targetSize?a.targetSize:100;this.maxLines_=void 0!==a.maxLines?a.maxLines:100;this.meridians_=[];this.parallels_=[];this.strokeStyle_=void 0!==a.strokeStyle?a.strokeStyle:ol.Graticule.DEFAULT_STROKE_STYLE_;this.toLonLatTransform_=this.fromLonLatTransform_=void 0;
this.parallelsLabels_=this.meridiansLabels_=this.projectionCenterLonLat_=null;if(1==a.showLabels){var b=ol.coordinate.degreesToStringHDMS;this.lonLabelFormatter_=void 0==a.lonLabelFormatter?b.bind(this,"EW"):a.lonLabelFormatter;this.latLabelFormatter_=void 0==a.latLabelFormatter?b.bind(this,"NS"):a.latLabelFormatter;this.lonLabelPosition_=void 0==a.lonLabelPosition?0:a.lonLabelPosition;this.latLabelPosition_=void 0==a.latLabelPosition?1:a.latLabelPosition;this.lonLabelStyle_=void 0!==a.lonLabelStyle?
a.lonLabelStyle:new ol.style.Text({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new ol.style.Fill({color:"rgba(0,0,0,1)"}),stroke:new ol.style.Stroke({color:"rgba(255,255,255,1)",width:3})});this.latLabelStyle_=void 0!==a.latLabelStyle?a.latLabelStyle:new ol.style.Text({font:"12px Calibri,sans-serif",textAlign:"end",fill:new ol.style.Fill({color:"rgba(0,0,0,1)"}),stroke:new ol.style.Stroke({color:"rgba(255,255,255,1)",width:3})});this.meridiansLabels_=[];this.parallelsLabels_=[]}this.setMap(void 0!==
a.map?a.map:null)};ol.Graticule.DEFAULT_STROKE_STYLE_=new ol.style.Stroke({color:"rgba(0,0,0,0.2)"});ol.Graticule.intervals_=[90,45,30,20,10,5,2,1,.5,.2,.1,.05,.01,.005,.002,.001];ol.Graticule.prototype.addMeridian_=function(a,b,c,d,e,f){b=this.getMeridian_(a,b,c,d,f);ol.extent.intersects(b.getExtent(),e)&&(this.meridiansLabels_&&(e=this.getMeridianPoint_(b,e,f),this.meridiansLabels_[f]={geom:e,text:this.lonLabelFormatter_(a)}),this.meridians_[f++]=b);return f};
ol.Graticule.prototype.getMeridianPoint_=function(a,b,c){a=a.getFlatCoordinates();b=ol.math.clamp(b[1]+Math.abs(b[1]-b[3])*this.lonLabelPosition_,Math.max(b[1],a[1]),Math.min(b[3],a[a.length-1]));b=[a[0],b];c=void 0!==this.meridiansLabels_[c]?this.meridiansLabels_[c].geom:new ol.geom.Point(null);c.setCoordinates(b);return c};
ol.Graticule.prototype.addParallel_=function(a,b,c,d,e,f){b=this.getParallel_(a,b,c,d,f);ol.extent.intersects(b.getExtent(),e)&&(this.parallelsLabels_&&(e=this.getParallelPoint_(b,e,f),this.parallelsLabels_[f]={geom:e,text:this.latLabelFormatter_(a)}),this.parallels_[f++]=b);return f};
ol.Graticule.prototype.getParallelPoint_=function(a,b,c){a=a.getFlatCoordinates();b=[ol.math.clamp(b[0]+Math.abs(b[0]-b[2])*this.latLabelPosition_,Math.max(b[0],a[0]),Math.min(b[2],a[a.length-2])),a[1]];c=void 0!==this.parallelsLabels_[c]?this.parallelsLabels_[c].geom:new ol.geom.Point(null);c.setCoordinates(b);return c};
ol.Graticule.prototype.createGraticule_=function(a,b,c,d){c=this.getInterval_(c);if(-1==c)this.meridians_.length=this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),this.parallelsLabels_&&(this.parallelsLabels_.length=0);else{var e=this.toLonLatTransform_(b);b=e[0];e=e[1];var f=this.maxLines_;var g=[Math.max(a[0],this.minLonP_),Math.max(a[1],this.minLatP_),Math.min(a[2],this.maxLonP_),Math.min(a[3],this.maxLatP_)];g=ol.proj.transformExtent(g,this.projection_,"EPSG:4326");
var h=g[3],k=g[2],l=g[1],m=g[0];b=Math.floor(b/c)*c;var n=ol.math.clamp(b,this.minLon_,this.maxLon_);var p=this.addMeridian_(n,l,h,d,a,0);for(g=0;n!=this.minLon_&&g++<f;)n=Math.max(n-c,this.minLon_),p=this.addMeridian_(n,l,h,d,a,p);n=ol.math.clamp(b,this.minLon_,this.maxLon_);for(g=0;n!=this.maxLon_&&g++<f;)n=Math.min(n+c,this.maxLon_),p=this.addMeridian_(n,l,h,d,a,p);this.meridians_.length=p;this.meridiansLabels_&&(this.meridiansLabels_.length=p);e=Math.floor(e/c)*c;b=ol.math.clamp(e,this.minLat_,
this.maxLat_);p=this.addParallel_(b,m,k,d,a,0);for(g=0;b!=this.minLat_&&g++<f;)b=Math.max(b-c,this.minLat_),p=this.addParallel_(b,m,k,d,a,p);b=ol.math.clamp(e,this.minLat_,this.maxLat_);for(g=0;b!=this.maxLat_&&g++<f;)b=Math.min(b+c,this.maxLat_),p=this.addParallel_(b,m,k,d,a,p);this.parallels_.length=p;this.parallelsLabels_&&(this.parallelsLabels_.length=p)}};
ol.Graticule.prototype.getInterval_=function(a){var b=this.projectionCenterLonLat_[0],c=this.projectionCenterLonLat_[1],d=-1,e,f=Math.pow(this.targetSize_*a,2),g=[],h=[];a=0;for(e=ol.Graticule.intervals_.length;a<e;++a){var k=ol.Graticule.intervals_[a]/2;g[0]=b-k;g[1]=c-k;h[0]=b+k;h[1]=c+k;this.fromLonLatTransform_(g,g);this.fromLonLatTransform_(h,h);k=Math.pow(h[0]-g[0],2)+Math.pow(h[1]-g[1],2);if(k<=f)break;d=ol.Graticule.intervals_[a]}return d};ol.Graticule.prototype.getMap=function(){return this.map_};
ol.Graticule.prototype.getMeridian_=function(a,b,c,d,e){a=ol.geom.flat.geodesic.meridian(a,b,c,this.projection_,d);e=void 0!==this.meridians_[e]?this.meridians_[e]:new ol.geom.LineString(null);e.setFlatCoordinates(ol.geom.GeometryLayout.XY,a);return e};ol.Graticule.prototype.getMeridians=function(){return this.meridians_};
ol.Graticule.prototype.getParallel_=function(a,b,c,d,e){a=ol.geom.flat.geodesic.parallel(a,b,c,this.projection_,d);e=void 0!==this.parallels_[e]?this.parallels_[e]:new ol.geom.LineString(null);e.setFlatCoordinates(ol.geom.GeometryLayout.XY,a);return e};ol.Graticule.prototype.getParallels=function(){return this.parallels_};
ol.Graticule.prototype.handlePostCompose_=function(a){var b=a.vectorContext,c=a.frameState;a=c.extent;var d=c.viewState,e=d.center,f=d.projection;d=d.resolution;c=c.pixelRatio;c=d*d/(4*c*c);this.projection_&&ol.proj.equivalent(this.projection_,f)||this.updateProjectionInfo_(f);this.createGraticule_(a,e,d,c);b.setFillStrokeStyle(null,this.strokeStyle_);a=0;for(e=this.meridians_.length;a<e;++a)f=this.meridians_[a],b.drawGeometry(f);a=0;for(e=this.parallels_.length;a<e;++a)f=this.parallels_[a],b.drawGeometry(f);
if(this.meridiansLabels_)for(a=0,e=this.meridiansLabels_.length;a<e;++a)f=this.meridiansLabels_[a],this.lonLabelStyle_.setText(f.text),b.setTextStyle(this.lonLabelStyle_),b.drawGeometry(f.geom);if(this.parallelsLabels_)for(a=0,e=this.parallelsLabels_.length;a<e;++a)f=this.parallelsLabels_[a],this.latLabelStyle_.setText(f.text),b.setTextStyle(this.latLabelStyle_),b.drawGeometry(f.geom)};
ol.Graticule.prototype.updateProjectionInfo_=function(a){var b=ol.proj.get("EPSG:4326"),c=a.getExtent(),d=a.getWorldExtent(),e=ol.proj.transformExtent(d,b,a),f=d[2],g=d[1],h=d[0],k=e[3],l=e[2],m=e[1];e=e[0];this.maxLat_=d[3];this.maxLon_=f;this.minLat_=g;this.minLon_=h;this.maxLatP_=k;this.maxLonP_=l;this.minLatP_=m;this.minLonP_=e;this.fromLonLatTransform_=ol.proj.getTransform(b,a);this.toLonLatTransform_=ol.proj.getTransform(a,b);this.projectionCenterLonLat_=this.toLonLatTransform_(ol.extent.getCenter(c));
this.projection_=a};ol.Graticule.prototype.setMap=function(a){this.map_&&(this.map_.un(ol.render.EventType.POSTCOMPOSE,this.handlePostCompose_,this),this.map_.render());a&&(a.on(ol.render.EventType.POSTCOMPOSE,this.handlePostCompose_,this),a.render());this.map_=a};ol.Image=function(a,b,c,d,e,f){ol.ImageBase.call(this,a,b,c,ol.ImageState.IDLE);this.src_=d;this.image_=new Image;null!==e&&(this.image_.crossOrigin=e);this.imageListenerKeys_=null;this.state=ol.ImageState.IDLE;this.imageLoadFunction_=f};ol.inherits(ol.Image,ol.ImageBase);ol.Image.prototype.getImage=function(){return this.image_};ol.Image.prototype.handleImageError_=function(){this.state=ol.ImageState.ERROR;this.unlistenImage_();this.changed()};
ol.Image.prototype.handleImageLoad_=function(){void 0===this.resolution&&(this.resolution=ol.extent.getHeight(this.extent)/this.image_.height);this.state=ol.ImageState.LOADED;this.unlistenImage_();this.changed()};
ol.Image.prototype.load=function(){if(this.state==ol.ImageState.IDLE||this.state==ol.ImageState.ERROR)this.state=ol.ImageState.LOADING,this.changed(),this.imageListenerKeys_=[ol.events.listenOnce(this.image_,ol.events.EventType.ERROR,this.handleImageError_,this),ol.events.listenOnce(this.image_,ol.events.EventType.LOAD,this.handleImageLoad_,this)],this.imageLoadFunction_(this,this.src_)};ol.Image.prototype.setImage=function(a){this.image_=a};
ol.Image.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(ol.events.unlistenByKey);this.imageListenerKeys_=null};ol.Tile=function(a,b,c){ol.events.EventTarget.call(this);c=c?c:{};this.tileCoord=a;this.state=b;this.interimTile=null;this.key="";this.transition_=void 0===c.transition?250:c.transition;this.transitionStarts_={}};ol.inherits(ol.Tile,ol.events.EventTarget);ol.Tile.prototype.changed=function(){this.dispatchEvent(ol.events.EventType.CHANGE)};ol.Tile.prototype.getKey=function(){return this.key+"/"+this.tileCoord};
ol.Tile.prototype.getInterimTile=function(){if(!this.interimTile)return this;var a=this.interimTile;do{if(a.getState()==ol.TileState.LOADED)return a;a=a.interimTile}while(a);return this};ol.Tile.prototype.refreshInterimChain=function(){if(this.interimTile){var a=this.interimTile,b=this;do{if(a.getState()==ol.TileState.LOADED){a.interimTile=null;break}else a.getState()==ol.TileState.LOADING?b=a:a.getState()==ol.TileState.IDLE?b.interimTile=a.interimTile:b=a;a=b.interimTile}while(a)}};
ol.Tile.prototype.getTileCoord=function(){return this.tileCoord};ol.Tile.prototype.getState=function(){return this.state};ol.Tile.prototype.setState=function(a){this.state=a;this.changed()};ol.Tile.prototype.load=function(){};ol.Tile.prototype.getAlpha=function(a,b){if(!this.transition_)return 1;var c=this.transitionStarts_[a];if(!c)c=b,this.transitionStarts_[a]=c;else if(-1===c)return 1;a=b-c+1E3/60;return a>=this.transition_?1:ol.easing.easeIn(a/this.transition_)};
ol.Tile.prototype.inTransition=function(a){return this.transition_?-1!==this.transitionStarts_[a]:!1};ol.Tile.prototype.endTransition=function(a){this.transition_&&(this.transitionStarts_[a]=-1)};ol.ImageTile=function(a,b,c,d,e,f){ol.Tile.call(this,a,b,f);this.crossOrigin_=d;this.src_=c;this.image_=new Image;null!==d&&(this.image_.crossOrigin=d);this.imageListenerKeys_=null;this.tileLoadFunction_=e};ol.inherits(ol.ImageTile,ol.Tile);ol.ImageTile.prototype.disposeInternal=function(){this.state==ol.TileState.LOADING&&(this.unlistenImage_(),this.image_=ol.ImageTile.getBlankImage());this.interimTile&&this.interimTile.dispose();this.state=ol.TileState.ABORT;this.changed();ol.Tile.prototype.disposeInternal.call(this)};
ol.ImageTile.prototype.getImage=function(){return this.image_};ol.ImageTile.prototype.getKey=function(){return this.src_};ol.ImageTile.prototype.handleImageError_=function(){this.state=ol.TileState.ERROR;this.unlistenImage_();this.image_=ol.ImageTile.getBlankImage();this.changed()};ol.ImageTile.prototype.handleImageLoad_=function(){this.state=this.image_.naturalWidth&&this.image_.naturalHeight?ol.TileState.LOADED:ol.TileState.EMPTY;this.unlistenImage_();this.changed()};
ol.ImageTile.prototype.load=function(){this.state==ol.TileState.ERROR&&(this.state=ol.TileState.IDLE,this.image_=new Image,null!==this.crossOrigin_&&(this.image_.crossOrigin=this.crossOrigin_));this.state==ol.TileState.IDLE&&(this.state=ol.TileState.LOADING,this.changed(),this.imageListenerKeys_=[ol.events.listenOnce(this.image_,ol.events.EventType.ERROR,this.handleImageError_,this),ol.events.listenOnce(this.image_,ol.events.EventType.LOAD,this.handleImageLoad_,this)],this.tileLoadFunction_(this,
this.src_))};ol.ImageTile.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(ol.events.unlistenByKey);this.imageListenerKeys_=null};ol.ImageTile.getBlankImage=function(){var a=ol.dom.createCanvasContext2D(1,1);a.fillStyle="rgba(0,0,0,0)";a.fillRect(0,0,1,1);return a.canvas};ol.webgl.Shader=function(a){this.source_=a};ol.webgl.Shader.prototype.getType=function(){};ol.webgl.Shader.prototype.getSource=function(){return this.source_};ol.webgl.Shader.prototype.isAnimated=ol.functions.FALSE;ol.webgl.Fragment=function(a){ol.webgl.Shader.call(this,a)};ol.inherits(ol.webgl.Fragment,ol.webgl.Shader);ol.webgl.Fragment.prototype.getType=function(){return ol.webgl.FRAGMENT_SHADER};ol.webgl.Vertex=function(a){ol.webgl.Shader.call(this,a)};ol.inherits(ol.webgl.Vertex,ol.webgl.Shader);ol.webgl.Vertex.prototype.getType=function(){return ol.webgl.VERTEX_SHADER};ol.render.webgl={};ol.render.webgl.circlereplay={};ol.render.webgl.circlereplay.defaultshader={};
ol.render.webgl.circlereplay.defaultshader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n":"precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}");
ol.render.webgl.circlereplay.defaultshader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n":
"varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}");ol.render.webgl.circlereplay.defaultshader.Locations=function(a,b){this.u_projectionMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_projectionMatrix":"h");this.u_offsetScaleMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetScaleMatrix":"i");this.u_offsetRotateMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetRotateMatrix":"j");this.u_lineWidth=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_lineWidth":"k");this.u_pixelRatio=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_pixelRatio":"l");this.u_opacity=
a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_opacity":"m");this.u_fillColor=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_fillColor":"n");this.u_strokeColor=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_strokeColor":"o");this.u_size=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_size":"p");this.a_position=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_position":"e");this.a_instruction=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_instruction":"f");this.a_radius=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_radius":"g")};ol.vec={};ol.vec.Mat4={};ol.vec.Mat4.create=function(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]};ol.vec.Mat4.fromTransform=function(a,b){a[0]=b[0];a[1]=b[1];a[4]=b[2];a[5]=b[3];a[12]=b[4];a[13]=b[5];return a};ol.render.webgl.Replay=function(a,b){ol.render.VectorContext.call(this);this.tolerance=a;this.maxExtent=b;this.origin=ol.extent.getCenter(b);this.projectionMatrix_=ol.transform.create();this.offsetRotateMatrix_=ol.transform.create();this.offsetScaleMatrix_=ol.transform.create();this.tmpMat4_=ol.vec.Mat4.create();this.indices=[];this.indicesBuffer=null;this.startIndices=[];this.startIndicesFeature=[];this.vertices=[];this.verticesBuffer=null;this.lineStringReplay=void 0};
ol.inherits(ol.render.webgl.Replay,ol.render.VectorContext);ol.render.webgl.Replay.prototype.getDeleteResourcesFunction=function(a){};ol.render.webgl.Replay.prototype.finish=function(a){};ol.render.webgl.Replay.prototype.setUpProgram=function(a,b,c,d){};ol.render.webgl.Replay.prototype.shutDownProgram=function(a,b){};ol.render.webgl.Replay.prototype.drawReplay=function(a,b,c,d){};ol.render.webgl.Replay.prototype.drawHitDetectionReplayOneByOne=function(a,b,c,d,e){};
ol.render.webgl.Replay.prototype.drawHitDetectionReplay=function(a,b,c,d,e,f){return e?this.drawHitDetectionReplayOneByOne(a,b,c,d,f):this.drawHitDetectionReplayAll(a,b,c,d)};ol.render.webgl.Replay.prototype.drawHitDetectionReplayAll=function(a,b,c,d){a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);this.drawReplay(a,b,c,!0);if(a=d(null))return a};
ol.render.webgl.Replay.prototype.replay=function(a,b,c,d,e,f,g,h,k,l,m){var n=a.getGL();if(this.lineStringReplay){var p=n.isEnabled(n.STENCIL_TEST);var q=n.getParameter(n.STENCIL_FUNC);var r=n.getParameter(n.STENCIL_VALUE_MASK);var u=n.getParameter(n.STENCIL_REF);var t=n.getParameter(n.STENCIL_WRITEMASK);var v=n.getParameter(n.STENCIL_FAIL);var w=n.getParameter(n.STENCIL_PASS_DEPTH_PASS);var y=n.getParameter(n.STENCIL_PASS_DEPTH_FAIL);n.enable(n.STENCIL_TEST);n.clear(n.STENCIL_BUFFER_BIT);n.stencilMask(255);
n.stencilFunc(n.ALWAYS,1,255);n.stencilOp(n.KEEP,n.KEEP,n.REPLACE);this.lineStringReplay.replay(a,b,c,d,e,f,g,h,k,l,m);n.stencilMask(0);n.stencilFunc(n.NOTEQUAL,1,255)}a.bindBuffer(ol.webgl.ARRAY_BUFFER,this.verticesBuffer);a.bindBuffer(ol.webgl.ELEMENT_ARRAY_BUFFER,this.indicesBuffer);f=this.setUpProgram(n,a,e,f);var z=ol.transform.reset(this.projectionMatrix_);ol.transform.scale(z,2/(c*e[0]),2/(c*e[1]));ol.transform.rotate(z,-d);ol.transform.translate(z,-(b[0]-this.origin[0]),-(b[1]-this.origin[1]));
b=ol.transform.reset(this.offsetScaleMatrix_);ol.transform.scale(b,2/e[0],2/e[1]);e=ol.transform.reset(this.offsetRotateMatrix_);0!==d&&ol.transform.rotate(e,-d);n.uniformMatrix4fv(f.u_projectionMatrix,!1,ol.vec.Mat4.fromTransform(this.tmpMat4_,z));n.uniformMatrix4fv(f.u_offsetScaleMatrix,!1,ol.vec.Mat4.fromTransform(this.tmpMat4_,b));n.uniformMatrix4fv(f.u_offsetRotateMatrix,!1,ol.vec.Mat4.fromTransform(this.tmpMat4_,e));n.uniform1f(f.u_opacity,g);var x;void 0===k?this.drawReplay(n,a,h,!1):x=this.drawHitDetectionReplay(n,
a,h,k,l,m);this.shutDownProgram(n,f);this.lineStringReplay&&(p||n.disable(n.STENCIL_TEST),n.clear(n.STENCIL_BUFFER_BIT),n.stencilFunc(q,u,r),n.stencilMask(t),n.stencilOp(v,y,w));return x};ol.render.webgl.Replay.prototype.drawElements=function(a,b,c,d){a.drawElements(ol.webgl.TRIANGLES,d-c,b.hasOESElementIndexUint?ol.webgl.UNSIGNED_INT:ol.webgl.UNSIGNED_SHORT,c*(b.hasOESElementIndexUint?4:2))};ol.render.webgl.defaultFont="10px sans-serif";ol.render.webgl.defaultFillStyle=[0,0,0,1];ol.render.webgl.defaultLineCap="round";ol.render.webgl.defaultLineDash=[];ol.render.webgl.defaultLineDashOffset=0;ol.render.webgl.defaultLineJoin="round";ol.render.webgl.defaultMiterLimit=10;ol.render.webgl.defaultStrokeStyle=[0,0,0,1];ol.render.webgl.defaultTextAlign=.5;ol.render.webgl.defaultTextBaseline=.5;ol.render.webgl.defaultLineWidth=1;
ol.render.webgl.triangleIsCounterClockwise=function(a,b,c,d,e,f){a=(c-a)*(f-b)-(e-a)*(d-b);return a<=ol.render.webgl.EPSILON&&a>=-ol.render.webgl.EPSILON?void 0:0<a};ol.render.webgl.EPSILON=Number.EPSILON||2.220446049250313E-16;ol.webgl.Buffer=function(a,b){this.arr_=void 0!==a?a:[];this.usage_=void 0!==b?b:ol.webgl.Buffer.Usage_.STATIC_DRAW};ol.webgl.Buffer.prototype.getArray=function(){return this.arr_};ol.webgl.Buffer.prototype.getUsage=function(){return this.usage_};ol.webgl.Buffer.Usage_={STATIC_DRAW:ol.webgl.STATIC_DRAW,STREAM_DRAW:ol.webgl.STREAM_DRAW,DYNAMIC_DRAW:ol.webgl.DYNAMIC_DRAW};ol.render.webgl.CircleReplay=function(a,b){ol.render.webgl.Replay.call(this,a,b);this.defaultLocations_=null;this.styles_=[];this.styleIndices_=[];this.radius_=0;this.state_={fillColor:null,strokeColor:null,lineDash:null,lineDashOffset:void 0,lineWidth:void 0,changed:!1}};ol.inherits(ol.render.webgl.CircleReplay,ol.render.webgl.Replay);
ol.render.webgl.CircleReplay.prototype.drawCoordinates_=function(a,b,c,d){for(var e=this.vertices.length,f=this.indices.length,g=e/4;b<c;b+=d)this.vertices[e++]=a[b],this.vertices[e++]=a[b+1],this.vertices[e++]=0,this.vertices[e++]=this.radius_,this.vertices[e++]=a[b],this.vertices[e++]=a[b+1],this.vertices[e++]=1,this.vertices[e++]=this.radius_,this.vertices[e++]=a[b],this.vertices[e++]=a[b+1],this.vertices[e++]=2,this.vertices[e++]=this.radius_,this.vertices[e++]=a[b],this.vertices[e++]=a[b+1],
this.vertices[e++]=3,this.vertices[e++]=this.radius_,this.indices[f++]=g,this.indices[f++]=g+1,this.indices[f++]=g+2,this.indices[f++]=g+2,this.indices[f++]=g+3,this.indices[f++]=g,g+=4};
ol.render.webgl.CircleReplay.prototype.drawCircle=function(a,b){var c=a.getRadius(),d=a.getStride();c?(this.startIndices.push(this.indices.length),this.startIndicesFeature.push(b),this.state_.changed&&(this.styleIndices_.push(this.indices.length),this.state_.changed=!1),this.radius_=c,a=a.getFlatCoordinates(),a=ol.geom.flat.transform.translate(a,0,2,d,-this.origin[0],-this.origin[1]),this.drawCoordinates_(a,0,2,d)):this.state_.changed&&(this.styles_.pop(),this.styles_.length&&(d=this.styles_[this.styles_.length-
1],this.state_.fillColor=d[0],this.state_.strokeColor=d[1],this.state_.lineWidth=d[2],this.state_.changed=!1))};ol.render.webgl.CircleReplay.prototype.finish=function(a){this.verticesBuffer=new ol.webgl.Buffer(this.vertices);this.indicesBuffer=new ol.webgl.Buffer(this.indices);this.startIndices.push(this.indices.length);0===this.styleIndices_.length&&0<this.styles_.length&&(this.styles_=[]);this.indices=this.vertices=null};
ol.render.webgl.CircleReplay.prototype.getDeleteResourcesFunction=function(a){var b=this.verticesBuffer,c=this.indicesBuffer;return function(){a.deleteBuffer(b);a.deleteBuffer(c)}};
ol.render.webgl.CircleReplay.prototype.setUpProgram=function(a,b,c,d){var e=b.getProgram(ol.render.webgl.circlereplay.defaultshader.fragment,ol.render.webgl.circlereplay.defaultshader.vertex);if(this.defaultLocations_)var f=this.defaultLocations_;else this.defaultLocations_=f=new ol.render.webgl.circlereplay.defaultshader.Locations(a,e);b.useProgram(e);a.enableVertexAttribArray(f.a_position);a.vertexAttribPointer(f.a_position,2,ol.webgl.FLOAT,!1,16,0);a.enableVertexAttribArray(f.a_instruction);a.vertexAttribPointer(f.a_instruction,
1,ol.webgl.FLOAT,!1,16,8);a.enableVertexAttribArray(f.a_radius);a.vertexAttribPointer(f.a_radius,1,ol.webgl.FLOAT,!1,16,12);a.uniform2fv(f.u_size,c);a.uniform1f(f.u_pixelRatio,d);return f};ol.render.webgl.CircleReplay.prototype.shutDownProgram=function(a,b){a.disableVertexAttribArray(b.a_position);a.disableVertexAttribArray(b.a_instruction);a.disableVertexAttribArray(b.a_radius)};
ol.render.webgl.CircleReplay.prototype.drawReplay=function(a,b,c,d){if(ol.obj.isEmpty(c)){var e=this.startIndices[this.startIndices.length-1];for(c=this.styleIndices_.length-1;0<=c;--c){d=this.styleIndices_[c];var f=this.styles_[c];this.setFillStyle_(a,f[0]);this.setStrokeStyle_(a,f[1],f[2]);this.drawElements(a,b,d,e);e=d}}else this.drawReplaySkipping_(a,b,c)};
ol.render.webgl.CircleReplay.prototype.drawHitDetectionReplayOneByOne=function(a,b,c,d,e){var f,g;var h=this.startIndices.length-2;var k=this.startIndices[h+1];for(f=this.styleIndices_.length-1;0<=f;--f){var l=this.styles_[f];this.setFillStyle_(a,l[0]);this.setStrokeStyle_(a,l[1],l[2]);for(g=this.styleIndices_[f];0<=h&&this.startIndices[h]>=g;){l=this.startIndices[h];var m=this.startIndicesFeature[h];var n=ol.getUid(m).toString();if(void 0===c[n]&&m.getGeometry()&&(void 0===e||ol.extent.intersects(e,
m.getGeometry().getExtent()))&&(a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.drawElements(a,b,l,k),k=d(m)))return k;h--;k=l}}};
ol.render.webgl.CircleReplay.prototype.drawReplaySkipping_=function(a,b,c){var d,e;var f=this.startIndices.length-2;var g=e=this.startIndices[f+1];for(d=this.styleIndices_.length-1;0<=d;--d){var h=this.styles_[d];this.setFillStyle_(a,h[0]);this.setStrokeStyle_(a,h[1],h[2]);for(h=this.styleIndices_[d];0<=f&&this.startIndices[f]>=h;){var k=this.startIndices[f];var l=this.startIndicesFeature[f];l=ol.getUid(l).toString();c[l]&&(e!==g&&this.drawElements(a,b,e,g),g=k);f--;e=k}e!==g&&this.drawElements(a,
b,e,g);e=g=h}};ol.render.webgl.CircleReplay.prototype.setFillStyle_=function(a,b){a.uniform4fv(this.defaultLocations_.u_fillColor,b)};ol.render.webgl.CircleReplay.prototype.setStrokeStyle_=function(a,b,c){a.uniform4fv(this.defaultLocations_.u_strokeColor,b);a.uniform1f(this.defaultLocations_.u_lineWidth,c)};
ol.render.webgl.CircleReplay.prototype.setFillStrokeStyle=function(a,b){if(b){var c=b.getLineDash();this.state_.lineDash=c?c:ol.render.webgl.defaultLineDash;c=b.getLineDashOffset();this.state_.lineDashOffset=c?c:ol.render.webgl.defaultLineDashOffset;c=b.getColor();c=c instanceof CanvasGradient||c instanceof CanvasPattern?ol.render.webgl.defaultStrokeStyle:ol.color.asArray(c).map(function(a,b){return 3!=b?a/255:a})||ol.render.webgl.defaultStrokeStyle;b=b.getWidth();b=void 0!==b?b:ol.render.webgl.defaultLineWidth}else c=
[0,0,0,0],b=0;a=a?a.getColor():[0,0,0,0];a=a instanceof CanvasGradient||a instanceof CanvasPattern?ol.render.webgl.defaultFillStyle:ol.color.asArray(a).map(function(a,b){return 3!=b?a/255:a})||ol.render.webgl.defaultFillStyle;this.state_.strokeColor&&ol.array.equals(this.state_.strokeColor,c)&&this.state_.fillColor&&ol.array.equals(this.state_.fillColor,a)&&this.state_.lineWidth===b||(this.state_.changed=!0,this.state_.fillColor=a,this.state_.strokeColor=c,this.state_.lineWidth=b,this.styles_.push([a,
c,b]))};ol.render.webgl.texturereplay={};ol.render.webgl.texturereplay.defaultshader={};
ol.render.webgl.texturereplay.defaultshader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":"precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.texturereplay.defaultshader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n":
"varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}");ol.render.webgl.texturereplay.defaultshader.Locations=function(a,b){this.u_projectionMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_projectionMatrix":"h");this.u_offsetScaleMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetScaleMatrix":"i");this.u_offsetRotateMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetRotateMatrix":"j");this.u_opacity=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_opacity":"k");this.u_image=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_image":"l");this.a_position=a.getAttribLocation(b,
ol.DEBUG_WEBGL?"a_position":"c");this.a_texCoord=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_texCoord":"d");this.a_offsets=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_offsets":"e");this.a_opacity=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_opacity":"f");this.a_rotateWithView=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_rotateWithView":"g")};ol.webgl.ContextEventType={LOST:"webglcontextlost",RESTORED:"webglcontextrestored"};ol.webgl.Context=function(a,b){this.canvas_=a;this.gl_=b;this.bufferCache_={};this.shaderCache_={};this.programCache_={};this.hitDetectionRenderbuffer_=this.hitDetectionTexture_=this.hitDetectionFramebuffer_=this.currentProgram_=null;(this.hasOESElementIndexUint=ol.array.includes(ol.WEBGL_EXTENSIONS,"OES_element_index_uint"))&&b.getExtension("OES_element_index_uint");ol.events.listen(this.canvas_,ol.webgl.ContextEventType.LOST,this.handleWebGLContextLost,this);ol.events.listen(this.canvas_,ol.webgl.ContextEventType.RESTORED,
this.handleWebGLContextRestored,this)};ol.inherits(ol.webgl.Context,ol.Disposable);
ol.webgl.Context.prototype.bindBuffer=function(a,b){var c=this.getGL(),d=b.getArray(),e=String(ol.getUid(b));if(e in this.bufferCache_)c.bindBuffer(a,this.bufferCache_[e].buffer);else{var f=c.createBuffer();c.bindBuffer(a,f);var g;a==ol.webgl.ARRAY_BUFFER?g=new Float32Array(d):a==ol.webgl.ELEMENT_ARRAY_BUFFER&&(g=this.hasOESElementIndexUint?new Uint32Array(d):new Uint16Array(d));c.bufferData(a,g,b.getUsage());this.bufferCache_[e]={buf:b,buffer:f}}};
ol.webgl.Context.prototype.deleteBuffer=function(a){var b=this.getGL();a=String(ol.getUid(a));var c=this.bufferCache_[a];b.isContextLost()||b.deleteBuffer(c.buffer);delete this.bufferCache_[a]};
ol.webgl.Context.prototype.disposeInternal=function(){ol.events.unlistenAll(this.canvas_);var a=this.getGL();if(!a.isContextLost()){for(var b in this.bufferCache_)a.deleteBuffer(this.bufferCache_[b].buffer);for(b in this.programCache_)a.deleteProgram(this.programCache_[b]);for(b in this.shaderCache_)a.deleteShader(this.shaderCache_[b]);a.deleteFramebuffer(this.hitDetectionFramebuffer_);a.deleteRenderbuffer(this.hitDetectionRenderbuffer_);a.deleteTexture(this.hitDetectionTexture_)}};
ol.webgl.Context.prototype.getCanvas=function(){return this.canvas_};ol.webgl.Context.prototype.getGL=function(){return this.gl_};ol.webgl.Context.prototype.getHitDetectionFramebuffer=function(){this.hitDetectionFramebuffer_||this.initHitDetectionFramebuffer_();return this.hitDetectionFramebuffer_};
ol.webgl.Context.prototype.getShader=function(a){var b=String(ol.getUid(a));if(b in this.shaderCache_)return this.shaderCache_[b];var c=this.getGL(),d=c.createShader(a.getType());c.shaderSource(d,a.getSource());c.compileShader(d);return this.shaderCache_[b]=d};
ol.webgl.Context.prototype.getProgram=function(a,b){var c=ol.getUid(a)+"/"+ol.getUid(b);if(c in this.programCache_)return this.programCache_[c];var d=this.getGL(),e=d.createProgram();d.attachShader(e,this.getShader(a));d.attachShader(e,this.getShader(b));d.linkProgram(e);return this.programCache_[c]=e};
ol.webgl.Context.prototype.handleWebGLContextLost=function(){ol.obj.clear(this.bufferCache_);ol.obj.clear(this.shaderCache_);ol.obj.clear(this.programCache_);this.hitDetectionRenderbuffer_=this.hitDetectionTexture_=this.hitDetectionFramebuffer_=this.currentProgram_=null};ol.webgl.Context.prototype.handleWebGLContextRestored=function(){};
ol.webgl.Context.prototype.initHitDetectionFramebuffer_=function(){var a=this.gl_,b=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,b);var c=ol.webgl.Context.createEmptyTexture(a,1,1),d=a.createRenderbuffer();a.bindRenderbuffer(a.RENDERBUFFER,d);a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,1,1);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0);a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,d);a.bindTexture(a.TEXTURE_2D,null);a.bindRenderbuffer(a.RENDERBUFFER,
null);a.bindFramebuffer(a.FRAMEBUFFER,null);this.hitDetectionFramebuffer_=b;this.hitDetectionTexture_=c;this.hitDetectionRenderbuffer_=d};ol.webgl.Context.prototype.useProgram=function(a){if(a==this.currentProgram_)return!1;this.getGL().useProgram(a);this.currentProgram_=a;return!0};
ol.webgl.Context.createTexture_=function(a,b,c){var d=a.createTexture();a.bindTexture(a.TEXTURE_2D,d);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR);void 0!==b&&a.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_WRAP_S,b);void 0!==c&&a.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_WRAP_T,c);return d};
ol.webgl.Context.createEmptyTexture=function(a,b,c,d,e){d=ol.webgl.Context.createTexture_(a,d,e);a.texImage2D(a.TEXTURE_2D,0,a.RGBA,b,c,0,a.RGBA,a.UNSIGNED_BYTE,null);return d};ol.webgl.Context.createTexture=function(a,b,c,d){c=ol.webgl.Context.createTexture_(a,c,d);a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,b);return c};ol.render.webgl.TextureReplay=function(a,b){ol.render.webgl.Replay.call(this,a,b);this.anchorY=this.anchorX=void 0;this.groupIndices=[];this.hitDetectionGroupIndices=[];this.imageWidth=this.imageHeight=this.height=void 0;this.defaultLocations=null;this.width=this.scale=this.rotation=this.rotateWithView=this.originY=this.originX=this.opacity=void 0};ol.inherits(ol.render.webgl.TextureReplay,ol.render.webgl.Replay);
ol.render.webgl.TextureReplay.prototype.getDeleteResourcesFunction=function(a){var b=this.verticesBuffer,c=this.indicesBuffer,d=this.getTextures(!0),e=a.getGL();return function(){if(!e.isContextLost()){var f;var g=0;for(f=d.length;g<f;++g)e.deleteTexture(d[g])}a.deleteBuffer(b);a.deleteBuffer(c)}};
ol.render.webgl.TextureReplay.prototype.drawCoordinates=function(a,b,c,d){var e=this.anchorX,f=this.anchorY,g=this.height,h=this.imageHeight,k=this.imageWidth,l=this.opacity,m=this.originX,n=this.originY,p=this.rotateWithView?1:0,q=-this.rotation,r=this.scale,u=this.width,t=Math.cos(q);q=Math.sin(q);for(var v=this.indices.length,w=this.vertices.length,y,z,x,C,A;b<c;b+=d)C=a[b]-this.origin[0],A=a[b+1]-this.origin[1],y=w/8,z=-r*e,x=-r*(g-f),this.vertices[w++]=C,this.vertices[w++]=A,this.vertices[w++]=
z*t-x*q,this.vertices[w++]=z*q+x*t,this.vertices[w++]=m/k,this.vertices[w++]=(n+g)/h,this.vertices[w++]=l,this.vertices[w++]=p,z=r*(u-e),x=-r*(g-f),this.vertices[w++]=C,this.vertices[w++]=A,this.vertices[w++]=z*t-x*q,this.vertices[w++]=z*q+x*t,this.vertices[w++]=(m+u)/k,this.vertices[w++]=(n+g)/h,this.vertices[w++]=l,this.vertices[w++]=p,z=r*(u-e),x=r*f,this.vertices[w++]=C,this.vertices[w++]=A,this.vertices[w++]=z*t-x*q,this.vertices[w++]=z*q+x*t,this.vertices[w++]=(m+u)/k,this.vertices[w++]=n/h,
this.vertices[w++]=l,this.vertices[w++]=p,z=-r*e,x=r*f,this.vertices[w++]=C,this.vertices[w++]=A,this.vertices[w++]=z*t-x*q,this.vertices[w++]=z*q+x*t,this.vertices[w++]=m/k,this.vertices[w++]=n/h,this.vertices[w++]=l,this.vertices[w++]=p,this.indices[v++]=y,this.indices[v++]=y+1,this.indices[v++]=y+2,this.indices[v++]=y,this.indices[v++]=y+2,this.indices[v++]=y+3;return w};
ol.render.webgl.TextureReplay.prototype.createTextures=function(a,b,c,d){var e,f=b.length;for(e=0;e<f;++e){var g=b[e];var h=ol.getUid(g).toString();h in c?g=c[h]:(g=ol.webgl.Context.createTexture(d,g,ol.webgl.CLAMP_TO_EDGE,ol.webgl.CLAMP_TO_EDGE),c[h]=g);a[e]=g}};
ol.render.webgl.TextureReplay.prototype.setUpProgram=function(a,b,c,d){c=b.getProgram(ol.render.webgl.texturereplay.defaultshader.fragment,ol.render.webgl.texturereplay.defaultshader.vertex);this.defaultLocations?d=this.defaultLocations:this.defaultLocations=d=new ol.render.webgl.texturereplay.defaultshader.Locations(a,c);b.useProgram(c);a.enableVertexAttribArray(d.a_position);a.vertexAttribPointer(d.a_position,2,ol.webgl.FLOAT,!1,32,0);a.enableVertexAttribArray(d.a_offsets);a.vertexAttribPointer(d.a_offsets,
2,ol.webgl.FLOAT,!1,32,8);a.enableVertexAttribArray(d.a_texCoord);a.vertexAttribPointer(d.a_texCoord,2,ol.webgl.FLOAT,!1,32,16);a.enableVertexAttribArray(d.a_opacity);a.vertexAttribPointer(d.a_opacity,1,ol.webgl.FLOAT,!1,32,24);a.enableVertexAttribArray(d.a_rotateWithView);a.vertexAttribPointer(d.a_rotateWithView,1,ol.webgl.FLOAT,!1,32,28);return d};
ol.render.webgl.TextureReplay.prototype.shutDownProgram=function(a,b){a.disableVertexAttribArray(b.a_position);a.disableVertexAttribArray(b.a_offsets);a.disableVertexAttribArray(b.a_texCoord);a.disableVertexAttribArray(b.a_opacity);a.disableVertexAttribArray(b.a_rotateWithView)};
ol.render.webgl.TextureReplay.prototype.drawReplay=function(a,b,c,d){var e=d?this.getHitDetectionTextures():this.getTextures();d=d?this.hitDetectionGroupIndices:this.groupIndices;if(ol.obj.isEmpty(c)){var f;c=0;var g=e.length;for(f=0;c<g;++c){a.bindTexture(ol.webgl.TEXTURE_2D,e[c]);var h=d[c];this.drawElements(a,b,f,h);f=h}}else this.drawReplaySkipping(a,b,c,e,d)};
ol.render.webgl.TextureReplay.prototype.drawReplaySkipping=function(a,b,c,d,e){var f=0,g;var h=0;for(g=d.length;h<g;++h){a.bindTexture(ol.webgl.TEXTURE_2D,d[h]);for(var k=0<h?e[h-1]:0,l=e[h],m=k;f<this.startIndices.length&&this.startIndices[f]<=l;){var n=ol.getUid(this.startIndicesFeature[f]).toString();void 0!==c[n]?(m!==k&&this.drawElements(a,b,m,k),k=m=f===this.startIndices.length-1?l:this.startIndices[f+1]):k=f===this.startIndices.length-1?l:this.startIndices[f+1];f++}m!==k&&this.drawElements(a,
b,m,k)}};
ol.render.webgl.TextureReplay.prototype.drawHitDetectionReplayOneByOne=function(a,b,c,d,e){var f,g,h=this.startIndices.length-1,k=this.getHitDetectionTextures();for(f=k.length-1;0<=f;--f){a.bindTexture(ol.webgl.TEXTURE_2D,k[f]);var l=0<f?this.hitDetectionGroupIndices[f-1]:0;for(g=this.hitDetectionGroupIndices[f];0<=h&&this.startIndices[h]>=l;){var m=this.startIndices[h];var n=this.startIndicesFeature[h];var p=ol.getUid(n).toString();if(void 0===c[p]&&n.getGeometry()&&(void 0===e||ol.extent.intersects(e,n.getGeometry().getExtent()))&&
(a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.drawElements(a,b,m,g),g=d(n)))return g;g=m;h--}}};ol.render.webgl.TextureReplay.prototype.finish=function(a){this.imageWidth=this.imageHeight=this.height=this.anchorY=this.anchorX=void 0;this.indices=null;this.scale=this.rotation=this.rotateWithView=this.originY=this.originX=this.opacity=void 0;this.vertices=null;this.width=void 0};ol.render.webgl.TextureReplay.prototype.getTextures=function(a){};
ol.render.webgl.TextureReplay.prototype.getHitDetectionTextures=function(){};ol.render.webgl.ImageReplay=function(a,b){ol.render.webgl.TextureReplay.call(this,a,b);this.images_=[];this.hitDetectionImages_=[];this.textures_=[];this.hitDetectionTextures_=[]};ol.inherits(ol.render.webgl.ImageReplay,ol.render.webgl.TextureReplay);ol.render.webgl.ImageReplay.prototype.drawMultiPoint=function(a,b){this.startIndices.push(this.indices.length);this.startIndicesFeature.push(b);b=a.getFlatCoordinates();a=a.getStride();this.drawCoordinates(b,0,b.length,a)};
ol.render.webgl.ImageReplay.prototype.drawPoint=function(a,b){this.startIndices.push(this.indices.length);this.startIndicesFeature.push(b);b=a.getFlatCoordinates();a=a.getStride();this.drawCoordinates(b,0,b.length,a)};
ol.render.webgl.ImageReplay.prototype.finish=function(a){var b=a.getGL();this.groupIndices.push(this.indices.length);this.hitDetectionGroupIndices.push(this.indices.length);this.verticesBuffer=new ol.webgl.Buffer(this.vertices);this.indicesBuffer=new ol.webgl.Buffer(this.indices);var c={};this.createTextures(this.textures_,this.images_,c,b);this.createTextures(this.hitDetectionTextures_,this.hitDetectionImages_,c,b);this.hitDetectionImages_=this.images_=null;ol.render.webgl.TextureReplay.prototype.finish.call(this,
a)};
ol.render.webgl.ImageReplay.prototype.setImageStyle=function(a){var b=a.getAnchor(),c=a.getImage(1),d=a.getImageSize(),e=a.getHitDetectionImage(1),f=a.getOpacity(),g=a.getOrigin(),h=a.getRotateWithView(),k=a.getRotation(),l=a.getSize();a=a.getScale();if(0===this.images_.length)this.images_.push(c);else{var m=this.images_[this.images_.length-1];ol.getUid(m)!=ol.getUid(c)&&(this.groupIndices.push(this.indices.length),this.images_.push(c))}0===this.hitDetectionImages_.length?this.hitDetectionImages_.push(e):(m=
this.hitDetectionImages_[this.hitDetectionImages_.length-1],ol.getUid(m)!=ol.getUid(e)&&(this.hitDetectionGroupIndices.push(this.indices.length),this.hitDetectionImages_.push(e)));this.anchorX=b[0];this.anchorY=b[1];this.height=l[1];this.imageHeight=d[1];this.imageWidth=d[0];this.opacity=f;this.originX=g[0];this.originY=g[1];this.rotation=k;this.rotateWithView=h;this.scale=a;this.width=l[0]};
ol.render.webgl.ImageReplay.prototype.getTextures=function(a){return a?this.textures_.concat(this.hitDetectionTextures_):this.textures_};ol.render.webgl.ImageReplay.prototype.getHitDetectionTextures=function(){return this.hitDetectionTextures_};ol.geom.flat.topology={};ol.geom.flat.topology.lineStringIsClosed=function(a,b,c,d){var e=c-d;return a[b]===a[e]&&a[b+1]===a[e+1]&&3<(c-b)/d?!!ol.geom.flat.area.linearRing(a,b,c,d):!1};ol.render.webgl.linestringreplay={};ol.render.webgl.linestringreplay.defaultshader={};
ol.render.webgl.linestringreplay.defaultshader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":"precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.linestringreplay.defaultshader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n":
"varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}");ol.render.webgl.linestringreplay.defaultshader.Locations=function(a,b){this.u_projectionMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_projectionMatrix":"h");this.u_offsetScaleMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetScaleMatrix":"i");this.u_offsetRotateMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetRotateMatrix":"j");this.u_lineWidth=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_lineWidth":"k");this.u_miterLimit=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_miterLimit":"l");this.u_opacity=
a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_opacity":"m");this.u_color=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_color":"n");this.u_size=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_size":"o");this.u_pixelRatio=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_pixelRatio":"p");this.a_lastPos=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_lastPos":"d");this.a_position=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_position":"e");this.a_nextPos=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_nextPos":"f");this.a_direction=a.getAttribLocation(b,
ol.DEBUG_WEBGL?"a_direction":"g")};ol.render.webgl.LineStringReplay=function(a,b){ol.render.webgl.Replay.call(this,a,b);this.defaultLocations_=null;this.styles_=[];this.styleIndices_=[];this.state_={strokeColor:null,lineCap:void 0,lineDash:null,lineDashOffset:void 0,lineJoin:void 0,lineWidth:void 0,miterLimit:void 0,changed:!1}};ol.inherits(ol.render.webgl.LineStringReplay,ol.render.webgl.Replay);
ol.render.webgl.LineStringReplay.prototype.drawCoordinates_=function(a,b,c,d){var e,f=this.vertices.length,g=this.indices.length,h="bevel"===this.state_.lineJoin?0:"miter"===this.state_.lineJoin?1:2,k="butt"===this.state_.lineCap?0:"square"===this.state_.lineCap?1:2,l=ol.geom.flat.topology.lineStringIsClosed(a,b,c,d),m=g,n=1;for(e=b;e<c;e+=d){var p=f/7;var q=r;var r=u||[a[e],a[e+1]];if(e===b){var u=[a[e+d],a[e+d+1]];if(c-b===2*d&&ol.array.equals(r,u))break;if(l){q=[a[c-2*d],a[c-2*d+1]];var t=u}else{k&&
(f=this.addVertices_([0,0],r,u,n*ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP*k,f),f=this.addVertices_([0,0],r,u,-n*ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP*k,f),this.indices[g++]=p+2,this.indices[g++]=p,this.indices[g++]=p+1,this.indices[g++]=p+1,this.indices[g++]=p+3,this.indices[g++]=p+2);f=this.addVertices_([0,0],r,u,n*ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE*(k||1),f);f=this.addVertices_([0,0],r,u,-n*ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE*
(k||1),f);m=f/7-1;continue}}else if(e===c-d){l?u=t:(q=q||[0,0],f=this.addVertices_(q,r,[0,0],n*ol.render.webgl.LineStringReplay.Instruction_.END_LINE*(k||1),f),f=this.addVertices_(q,r,[0,0],-n*ol.render.webgl.LineStringReplay.Instruction_.END_LINE*(k||1),f),this.indices[g++]=p,this.indices[g++]=m-1,this.indices[g++]=m,this.indices[g++]=m,this.indices[g++]=p+1,this.indices[g++]=p,k&&(f=this.addVertices_(q,r,[0,0],n*ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP*k,f),f=this.addVertices_(q,
r,[0,0],-n*ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP*k,f),this.indices[g++]=p+2,this.indices[g++]=p,this.indices[g++]=p+1,this.indices[g++]=p+1,this.indices[g++]=p+3,this.indices[g++]=p+2));break}else u=[a[e+d],a[e+d+1]];var v=ol.render.webgl.triangleIsCounterClockwise(q[0],q[1],r[0],r[1],u[0],u[1])?-1:1;f=this.addVertices_(q,r,u,v*ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST*(h||1),f);f=this.addVertices_(q,r,u,v*ol.render.webgl.LineStringReplay.Instruction_.BEVEL_SECOND*
(h||1),f);f=this.addVertices_(q,r,u,-v*ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM*(h||1),f);e>b&&(this.indices[g++]=p,this.indices[g++]=m-1,this.indices[g++]=m,this.indices[g++]=p+2,this.indices[g++]=p,this.indices[g++]=0<n*v?m:m-1);this.indices[g++]=p;this.indices[g++]=p+2;this.indices[g++]=p+1;m=p+2;n=v;h&&(f=this.addVertices_(q,r,u,v*ol.render.webgl.LineStringReplay.Instruction_.MITER_TOP*h,f),this.indices[g++]=p+1,this.indices[g++]=p+3,this.indices[g++]=p)}l&&(p=p||f/7,v=ol.geom.flat.orient.linearRingIsClockwise([q[0],
q[1],r[0],r[1],u[0],u[1]],0,6,2)?1:-1,f=this.addVertices_(q,r,u,v*ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST*(h||1),f),this.addVertices_(q,r,u,-v*ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM*(h||1),f),this.indices[g++]=p,this.indices[g++]=m-1,this.indices[g++]=m,this.indices[g++]=p+1,this.indices[g++]=p,this.indices[g++]=0<n*v?m:m-1)};
ol.render.webgl.LineStringReplay.prototype.addVertices_=function(a,b,c,d,e){this.vertices[e++]=a[0];this.vertices[e++]=a[1];this.vertices[e++]=b[0];this.vertices[e++]=b[1];this.vertices[e++]=c[0];this.vertices[e++]=c[1];this.vertices[e++]=d;return e};ol.render.webgl.LineStringReplay.prototype.isValid_=function(a,b,c,d){c-=b;return c<2*d?!1:c===2*d?!ol.array.equals([a[b],a[b+1]],[a[b+d],a[b+d+1]]):!0};
ol.render.webgl.LineStringReplay.prototype.drawLineString=function(a,b){var c=a.getFlatCoordinates();a=a.getStride();this.isValid_(c,0,c.length,a)&&(c=ol.geom.flat.transform.translate(c,0,c.length,a,-this.origin[0],-this.origin[1]),this.state_.changed&&(this.styleIndices_.push(this.indices.length),this.state_.changed=!1),this.startIndices.push(this.indices.length),this.startIndicesFeature.push(b),this.drawCoordinates_(c,0,c.length,a))};
ol.render.webgl.LineStringReplay.prototype.drawMultiLineString=function(a,b){var c=this.indices.length,d=a.getEnds();d.unshift(0);var e=a.getFlatCoordinates();a=a.getStride();var f;if(1<d.length){var g=1;for(f=d.length;g<f;++g)if(this.isValid_(e,d[g-1],d[g],a)){var h=ol.geom.flat.transform.translate(e,d[g-1],d[g],a,-this.origin[0],-this.origin[1]);this.drawCoordinates_(h,0,h.length,a)}}this.indices.length>c&&(this.startIndices.push(c),this.startIndicesFeature.push(b),this.state_.changed&&(this.styleIndices_.push(c),
this.state_.changed=!1))};ol.render.webgl.LineStringReplay.prototype.drawPolygonCoordinates=function(a,b,c){ol.geom.flat.topology.lineStringIsClosed(a,0,a.length,c)||(a.push(a[0]),a.push(a[1]));this.drawCoordinates_(a,0,a.length,c);if(b.length){var d;a=0;for(d=b.length;a<d;++a)ol.geom.flat.topology.lineStringIsClosed(b[a],0,b[a].length,c)||(b[a].push(b[a][0]),b[a].push(b[a][1])),this.drawCoordinates_(b[a],0,b[a].length,c)}};
ol.render.webgl.LineStringReplay.prototype.setPolygonStyle=function(a,b){b=void 0===b?this.indices.length:b;this.startIndices.push(b);this.startIndicesFeature.push(a);this.state_.changed&&(this.styleIndices_.push(b),this.state_.changed=!1)};ol.render.webgl.LineStringReplay.prototype.getCurrentIndex=function(){return this.indices.length};
ol.render.webgl.LineStringReplay.prototype.finish=function(a){this.verticesBuffer=new ol.webgl.Buffer(this.vertices);this.indicesBuffer=new ol.webgl.Buffer(this.indices);this.startIndices.push(this.indices.length);0===this.styleIndices_.length&&0<this.styles_.length&&(this.styles_=[]);this.indices=this.vertices=null};ol.render.webgl.LineStringReplay.prototype.getDeleteResourcesFunction=function(a){var b=this.verticesBuffer,c=this.indicesBuffer;return function(){a.deleteBuffer(b);a.deleteBuffer(c)}};
ol.render.webgl.LineStringReplay.prototype.setUpProgram=function(a,b,c,d){var e=b.getProgram(ol.render.webgl.linestringreplay.defaultshader.fragment,ol.render.webgl.linestringreplay.defaultshader.vertex);if(this.defaultLocations_)var f=this.defaultLocations_;else this.defaultLocations_=f=new ol.render.webgl.linestringreplay.defaultshader.Locations(a,e);b.useProgram(e);a.enableVertexAttribArray(f.a_lastPos);a.vertexAttribPointer(f.a_lastPos,2,ol.webgl.FLOAT,!1,28,0);a.enableVertexAttribArray(f.a_position);
a.vertexAttribPointer(f.a_position,2,ol.webgl.FLOAT,!1,28,8);a.enableVertexAttribArray(f.a_nextPos);a.vertexAttribPointer(f.a_nextPos,2,ol.webgl.FLOAT,!1,28,16);a.enableVertexAttribArray(f.a_direction);a.vertexAttribPointer(f.a_direction,1,ol.webgl.FLOAT,!1,28,24);a.uniform2fv(f.u_size,c);a.uniform1f(f.u_pixelRatio,d);return f};
ol.render.webgl.LineStringReplay.prototype.shutDownProgram=function(a,b){a.disableVertexAttribArray(b.a_lastPos);a.disableVertexAttribArray(b.a_position);a.disableVertexAttribArray(b.a_nextPos);a.disableVertexAttribArray(b.a_direction)};
ol.render.webgl.LineStringReplay.prototype.drawReplay=function(a,b,c,d){var e=a.getParameter(a.DEPTH_FUNC),f=a.getParameter(a.DEPTH_WRITEMASK);d||(a.enable(a.DEPTH_TEST),a.depthMask(!0),a.depthFunc(a.NOTEQUAL));if(ol.obj.isEmpty(c)){var g=this.startIndices[this.startIndices.length-1];for(c=this.styleIndices_.length-1;0<=c;--c){var h=this.styleIndices_[c];var k=this.styles_[c];this.setStrokeStyle_(a,k[0],k[1],k[2]);this.drawElements(a,b,h,g);a.clear(a.DEPTH_BUFFER_BIT);g=h}}else this.drawReplaySkipping_(a,
b,c);d||(a.disable(a.DEPTH_TEST),a.clear(a.DEPTH_BUFFER_BIT),a.depthMask(f),a.depthFunc(e))};
ol.render.webgl.LineStringReplay.prototype.drawReplaySkipping_=function(a,b,c){var d,e;var f=this.startIndices.length-2;var g=e=this.startIndices[f+1];for(d=this.styleIndices_.length-1;0<=d;--d){var h=this.styles_[d];this.setStrokeStyle_(a,h[0],h[1],h[2]);for(h=this.styleIndices_[d];0<=f&&this.startIndices[f]>=h;){var k=this.startIndices[f];var l=this.startIndicesFeature[f];l=ol.getUid(l).toString();c[l]&&(e!==g&&(this.drawElements(a,b,e,g),a.clear(a.DEPTH_BUFFER_BIT)),g=k);f--;e=k}e!==g&&(this.drawElements(a,
b,e,g),a.clear(a.DEPTH_BUFFER_BIT));e=g=h}};
ol.render.webgl.LineStringReplay.prototype.drawHitDetectionReplayOneByOne=function(a,b,c,d,e){var f,g;var h=this.startIndices.length-2;var k=this.startIndices[h+1];for(f=this.styleIndices_.length-1;0<=f;--f){var l=this.styles_[f];this.setStrokeStyle_(a,l[0],l[1],l[2]);for(g=this.styleIndices_[f];0<=h&&this.startIndices[h]>=g;){l=this.startIndices[h];var m=this.startIndicesFeature[h];var n=ol.getUid(m).toString();if(void 0===c[n]&&m.getGeometry()&&(void 0===e||ol.extent.intersects(e,m.getGeometry().getExtent()))&&
(a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.drawElements(a,b,l,k),k=d(m)))return k;h--;k=l}}};ol.render.webgl.LineStringReplay.prototype.setStrokeStyle_=function(a,b,c,d){a.uniform4fv(this.defaultLocations_.u_color,b);a.uniform1f(this.defaultLocations_.u_lineWidth,c);a.uniform1f(this.defaultLocations_.u_miterLimit,d)};
ol.render.webgl.LineStringReplay.prototype.setFillStrokeStyle=function(a,b){a=b.getLineCap();this.state_.lineCap=void 0!==a?a:ol.render.webgl.defaultLineCap;a=b.getLineDash();this.state_.lineDash=a?a:ol.render.webgl.defaultLineDash;a=b.getLineDashOffset();this.state_.lineDashOffset=a?a:ol.render.webgl.defaultLineDashOffset;a=b.getLineJoin();this.state_.lineJoin=void 0!==a?a:ol.render.webgl.defaultLineJoin;a=b.getColor();a=a instanceof CanvasGradient||a instanceof CanvasPattern?ol.render.webgl.defaultStrokeStyle:
ol.color.asArray(a).map(function(a,b){return 3!=b?a/255:a})||ol.render.webgl.defaultStrokeStyle;var c=b.getWidth();c=void 0!==c?c:ol.render.webgl.defaultLineWidth;b=b.getMiterLimit();b=void 0!==b?b:ol.render.webgl.defaultMiterLimit;this.state_.strokeColor&&ol.array.equals(this.state_.strokeColor,a)&&this.state_.lineWidth===c&&this.state_.miterLimit===b||(this.state_.changed=!0,this.state_.strokeColor=a,this.state_.lineWidth=c,this.state_.miterLimit=b,this.styles_.push([a,c,b]))};
ol.render.webgl.LineStringReplay.Instruction_={ROUND:2,BEGIN_LINE:3,END_LINE:5,BEGIN_LINE_CAP:7,END_LINE_CAP:11,BEVEL_FIRST:13,BEVEL_SECOND:17,MITER_BOTTOM:19,MITER_TOP:23};ol.render.webgl.polygonreplay={};ol.render.webgl.polygonreplay.defaultshader={};ol.render.webgl.polygonreplay.defaultshader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":"precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.polygonreplay.defaultshader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n":"attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}");ol.render.webgl.polygonreplay.defaultshader.Locations=function(a,b){this.u_projectionMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_projectionMatrix":"b");this.u_offsetScaleMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetScaleMatrix":"c");this.u_offsetRotateMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_offsetRotateMatrix":"d");this.u_color=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_color":"e");this.u_opacity=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_opacity":"f");this.a_position=a.getAttribLocation(b,
ol.DEBUG_WEBGL?"a_position":"a")};ol.structs.LinkedList=function(a){this.head_=this.last_=this.first_=void 0;this.circular_=void 0===a?!0:a;this.length_=0};ol.structs.LinkedList.prototype.insertItem=function(a){a={prev:void 0,next:void 0,data:a};var b=this.head_;if(b){var c=b.next;a.prev=b;a.next=c;b.next=a;c&&(c.prev=a);b===this.last_&&(this.last_=a)}else this.last_=this.first_=a,this.circular_&&(a.next=a,a.prev=a);this.head_=a;this.length_++};
ol.structs.LinkedList.prototype.removeItem=function(){var a=this.head_;if(a){var b=a.next,c=a.prev;b&&(b.prev=c);c&&(c.next=b);this.head_=b||c;this.first_===this.last_?this.last_=this.first_=this.head_=void 0:this.first_===a?this.first_=this.head_:this.last_===a&&(this.last_=c?this.head_.prev:this.head_);this.length_--}};ol.structs.LinkedList.prototype.firstItem=function(){if(this.head_=this.first_)return this.head_.data};ol.structs.LinkedList.prototype.lastItem=function(){if(this.head_=this.last_)return this.head_.data};
ol.structs.LinkedList.prototype.nextItem=function(){if(this.head_&&this.head_.next)return this.head_=this.head_.next,this.head_.data};ol.structs.LinkedList.prototype.getNextItem=function(){if(this.head_&&this.head_.next)return this.head_.next.data};ol.structs.LinkedList.prototype.prevItem=function(){if(this.head_&&this.head_.prev)return this.head_=this.head_.prev,this.head_.data};ol.structs.LinkedList.prototype.getPrevItem=function(){if(this.head_&&this.head_.prev)return this.head_.prev.data};
ol.structs.LinkedList.prototype.getCurrItem=function(){if(this.head_)return this.head_.data};ol.structs.LinkedList.prototype.setFirstItem=function(){this.circular_&&this.head_&&(this.first_=this.head_,this.last_=this.head_.prev)};
ol.structs.LinkedList.prototype.concat=function(a){if(a.head_){if(this.head_){var b=this.head_.next;this.head_.next=a.first_;a.first_.prev=this.head_;b.prev=a.last_;a.last_.next=b;this.length_+=a.length_}else this.head_=a.head_,this.first_=a.first_,this.last_=a.last_,this.length_=a.length_;a.head_=void 0;a.first_=void 0;a.last_=void 0;a.length_=0}};ol.structs.LinkedList.prototype.getLength=function(){return this.length_};ol.structs.RBush=function(a){this.rbush_=ol.ext.rbush(a);this.items_={}};ol.structs.RBush.prototype.insert=function(a,b){a={minX:a[0],minY:a[1],maxX:a[2],maxY:a[3],value:b};this.rbush_.insert(a);this.items_[ol.getUid(b)]=a};ol.structs.RBush.prototype.load=function(a,b){for(var c=Array(b.length),d=0,e=b.length;d<e;d++){var f=a[d],g=b[d];f={minX:f[0],minY:f[1],maxX:f[2],maxY:f[3],value:g};c[d]=f;this.items_[ol.getUid(g)]=f}this.rbush_.load(c)};
ol.structs.RBush.prototype.remove=function(a){a=ol.getUid(a);var b=this.items_[a];delete this.items_[a];return null!==this.rbush_.remove(b)};ol.structs.RBush.prototype.update=function(a,b){var c=this.items_[ol.getUid(b)];ol.extent.equals([c.minX,c.minY,c.maxX,c.maxY],a)||(this.remove(b),this.insert(a,b))};ol.structs.RBush.prototype.getAll=function(){return this.rbush_.all().map(function(a){return a.value})};
ol.structs.RBush.prototype.getInExtent=function(a){return this.rbush_.search({minX:a[0],minY:a[1],maxX:a[2],maxY:a[3]}).map(function(a){return a.value})};ol.structs.RBush.prototype.forEach=function(a,b){return this.forEach_(this.getAll(),a,b)};ol.structs.RBush.prototype.forEachInExtent=function(a,b,c){return this.forEach_(this.getInExtent(a),b,c)};ol.structs.RBush.prototype.forEach_=function(a,b,c){for(var d,e=0,f=a.length;e<f&&!(d=b.call(c,a[e]));e++);return d};
ol.structs.RBush.prototype.isEmpty=function(){return ol.obj.isEmpty(this.items_)};ol.structs.RBush.prototype.clear=function(){this.rbush_.clear();this.items_={}};ol.structs.RBush.prototype.getExtent=function(a){var b=this.rbush_.data;return ol.extent.createOrUpdate(b.minX,b.minY,b.maxX,b.maxY,a)};ol.structs.RBush.prototype.concat=function(a){this.rbush_.load(a.rbush_.all());for(var b in a.items_)this.items_[b|0]=a.items_[b|0]};ol.render.webgl.PolygonReplay=function(a,b){ol.render.webgl.Replay.call(this,a,b);this.lineStringReplay=new ol.render.webgl.LineStringReplay(a,b);this.defaultLocations_=null;this.styles_=[];this.styleIndices_=[];this.state_={fillColor:null,changed:!1}};ol.inherits(ol.render.webgl.PolygonReplay,ol.render.webgl.Replay);
ol.render.webgl.PolygonReplay.prototype.drawCoordinates_=function(a,b,c){var d=new ol.structs.LinkedList,e=new ol.structs.RBush;this.processFlatCoordinates_(a,c,d,e,!0);a=this.getMaxCoords_(d);if(b.length){var f,g=[];var h=0;for(f=b.length;h<f;++h){var k={list:new ol.structs.LinkedList,maxCoords:void 0,rtree:new ol.structs.RBush};g.push(k);this.processFlatCoordinates_(b[h],c,k.list,k.rtree,!1);this.classifyPoints_(k.list,k.rtree,!0);k.maxCoords=this.getMaxCoords_(k.list)}g.sort(function(a,b){return b.maxCoords[0]===
a.maxCoords[0]?a.maxCoords[1]-b.maxCoords[1]:b.maxCoords[0]-a.maxCoords[0]});for(h=0;h<g.length;++h){b=g[h].list;f=c=b.firstItem();do{if(this.getIntersections_(f,e).length){var l=!0;break}f=b.nextItem()}while(c!==f);!l&&this.bridgeHole_(b,g[h].maxCoords[0],d,a[0],e)&&(e.concat(g[h].rtree),this.classifyPoints_(d,e,!1))}}else this.classifyPoints_(d,e,!1);this.triangulate_(d,e)};
ol.render.webgl.PolygonReplay.prototype.processFlatCoordinates_=function(a,b,c,d,e){var f=ol.geom.flat.orient.linearRingIsClockwise(a,0,a.length,b),g,h=this.vertices.length/2,k=[],l=[];if(e===f){f=e=this.createPoint_(a[0],a[1],h++);var m=b;for(g=a.length;m<g;m+=b){var n=this.createPoint_(a[m],a[m+1],h++);l.push(this.insertItem_(f,n,c));k.push([Math.min(f.x,n.x),Math.min(f.y,n.y),Math.max(f.x,n.x),Math.max(f.y,n.y)]);f=n}}else for(m=a.length-b,f=e=this.createPoint_(a[m],a[m+1],h++),m-=b,g=0;m>=g;m-=
b)n=this.createPoint_(a[m],a[m+1],h++),l.push(this.insertItem_(f,n,c)),k.push([Math.min(f.x,n.x),Math.min(f.y,n.y),Math.max(f.x,n.x),Math.max(f.y,n.y)]),f=n;l.push(this.insertItem_(n,e,c));k.push([Math.min(f.x,n.x),Math.min(f.y,n.y),Math.max(f.x,n.x),Math.max(f.y,n.y)]);d.load(k,l)};ol.render.webgl.PolygonReplay.prototype.getMaxCoords_=function(a){var b=a.firstItem(),c=b,d=[c.p0.x,c.p0.y];do c=a.nextItem(),c.p0.x>d[0]&&(d=[c.p0.x,c.p0.y]);while(c!==b);return d};
ol.render.webgl.PolygonReplay.prototype.classifyPoints_=function(a,b,c){var d=a.firstItem(),e=d,f=a.nextItem(),g=!1;do{var h=c?ol.render.webgl.triangleIsCounterClockwise(f.p1.x,f.p1.y,e.p1.x,e.p1.y,e.p0.x,e.p0.y):ol.render.webgl.triangleIsCounterClockwise(e.p0.x,e.p0.y,e.p1.x,e.p1.y,f.p1.x,f.p1.y);void 0===h?(this.removeItem_(e,f,a,b),g=!0,f===d&&(d=a.getNextItem()),f=e,a.prevItem()):e.p1.reflex!==h&&(e.p1.reflex=h,g=!0);e=f;f=a.nextItem()}while(e!==d);return g};
ol.render.webgl.PolygonReplay.prototype.bridgeHole_=function(a,b,c,d,e){for(var f=a.firstItem();f.p1.x!==b;)f=a.nextItem();b=f.p1;d={x:d,y:b.y,i:-1};var g=Infinity,h;var k=this.getIntersections_({p0:b,p1:d},e,!0);var l=0;for(h=k.length;l<h;++l){var m=k[l],n=this.calculateIntersection_(b,d,m.p0,m.p1,!0),p=Math.abs(b.x-n[0]);if(p<g&&void 0!==ol.render.webgl.triangleIsCounterClockwise(b.x,b.y,m.p0.x,m.p0.y,m.p1.x,m.p1.y)){g=p;var q={x:n[0],y:n[1],i:-1};f=m}}if(Infinity===g)return!1;k=f.p1;if(0<g&&(f=
this.getPointsInTriangle_(b,q,f.p1,e),f.length))for(q=Infinity,l=0,h=f.length;l<h;++l)if(g=f[l],m=Math.atan2(b.y-g.y,d.x-g.x),m<q||m===q&&g.x<k.x)q=m,k=g;for(f=c.firstItem();f.p1.x!==k.x||f.p1.y!==k.y;)f=c.nextItem();d={x:b.x,y:b.y,i:b.i,reflex:void 0};l={x:f.p1.x,y:f.p1.y,i:f.p1.i,reflex:void 0};a.getNextItem().p0=d;this.insertItem_(b,f.p1,a,e);this.insertItem_(l,d,a,e);f.p1=l;a.setFirstItem();c.concat(a);return!0};
ol.render.webgl.PolygonReplay.prototype.triangulate_=function(a,b){for(var c=!1,d=this.isSimple_(a,b);3<a.getLength();)if(d){if(!this.clipEars_(a,b,d,c)&&!this.classifyPoints_(a,b,c)&&!this.resolveSelfIntersections_(a,b,!0))break}else if(!this.clipEars_(a,b,d,c)&&!this.classifyPoints_(a,b,c)&&!this.resolveSelfIntersections_(a,b))if(d=this.isSimple_(a,b))c=!this.isClockwise_(a),this.classifyPoints_(a,b,c);else{this.splitPolygon_(a,b);break}3===a.getLength()&&(b=this.indices.length,this.indices[b++]=
a.getPrevItem().p0.i,this.indices[b++]=a.getCurrItem().p0.i,this.indices[b++]=a.getNextItem().p0.i)};
ol.render.webgl.PolygonReplay.prototype.clipEars_=function(a,b,c,d){var e=this.indices.length,f=a.firstItem(),g=a.getPrevItem(),h=f,k=a.nextItem(),l=a.getNextItem(),m=!1;do{var n=h.p0;var p=h.p1;var q=k.p1;if(!1===p.reflex){var r=c?0===this.getPointsInTriangle_(n,p,q,b,!0).length:d?this.diagonalIsInside_(l.p1,q,p,n,g.p0):this.diagonalIsInside_(g.p0,n,p,q,l.p1);!c&&0!==this.getIntersections_({p0:n,p1:q},b).length||!r||!c&&!1!==n.reflex&&!1!==q.reflex&&ol.geom.flat.orient.linearRingIsClockwise([g.p0.x,
g.p0.y,n.x,n.y,p.x,p.y,q.x,q.y,l.p1.x,l.p1.y],0,10,2)!==!d||(this.indices[e++]=n.i,this.indices[e++]=p.i,this.indices[e++]=q.i,this.removeItem_(h,k,a,b),k===f&&(f=l),m=!0)}g=a.getPrevItem();h=a.getCurrItem();k=a.nextItem();l=a.getNextItem()}while(h!==f&&3<a.getLength());return m};
ol.render.webgl.PolygonReplay.prototype.resolveSelfIntersections_=function(a,b,c){var d=a.firstItem();a.nextItem();var e=d,f=a.nextItem(),g=!1;do{var h=this.calculateIntersection_(e.p0,e.p1,f.p0,f.p1,c);if(h){g=this.indices.length;var k=this.vertices.length/2,l=a.prevItem();a.removeItem();b.remove(l);var m=l===d;c?(h[0]===e.p0.x&&h[1]===e.p0.y?(a.prevItem(),h=e.p0,f.p0=h,b.remove(e),m=m||e===d):(h=f.p1,e.p1=h,b.remove(f),m=m||f===d),a.removeItem()):(h=this.createPoint_(h[0],h[1],k),e.p1=h,f.p0=h,
b.update([Math.min(e.p0.x,e.p1.x),Math.min(e.p0.y,e.p1.y),Math.max(e.p0.x,e.p1.x),Math.max(e.p0.y,e.p1.y)],e),b.update([Math.min(f.p0.x,f.p1.x),Math.min(f.p0.y,f.p1.y),Math.max(f.p0.x,f.p1.x),Math.max(f.p0.y,f.p1.y)],f));this.indices[g++]=l.p0.i;this.indices[g++]=l.p1.i;this.indices[g++]=h.i;g=!0;if(m)break}e=a.getPrevItem();f=a.nextItem()}while(e!==d);return g};
ol.render.webgl.PolygonReplay.prototype.isSimple_=function(a,b){var c=a.firstItem(),d=c;do{if(this.getIntersections_(d,b).length)return!1;d=a.nextItem()}while(d!==c);return!0};ol.render.webgl.PolygonReplay.prototype.isClockwise_=function(a){var b=2*a.getLength(),c=Array(b),d=a.firstItem(),e=d,f=0;do c[f++]=e.p0.x,c[f++]=e.p0.y,e=a.nextItem();while(e!==d);return ol.geom.flat.orient.linearRingIsClockwise(c,0,b,2)};
ol.render.webgl.PolygonReplay.prototype.splitPolygon_=function(a,b){var c=a.firstItem(),d=c;do{var e=this.getIntersections_(d,b);if(e.length){c=e[0];e=this.vertices.length/2;var f=this.calculateIntersection_(d.p0,d.p1,c.p0,c.p1);e=this.createPoint_(f[0],f[1],e);f=new ol.structs.LinkedList;var g=new ol.structs.RBush;this.insertItem_(e,d.p1,f,g);d.p1=e;b.update([Math.min(d.p0.x,e.x),Math.min(d.p0.y,e.y),Math.max(d.p0.x,e.x),Math.max(d.p0.y,e.y)],d);for(d=a.nextItem();d!==c;)this.insertItem_(d.p0,d.p1,
f,g),b.remove(d),a.removeItem(),d=a.getCurrItem();this.insertItem_(c.p0,e,f,g);c.p0=e;b.update([Math.min(c.p1.x,e.x),Math.min(c.p1.y,e.y),Math.max(c.p1.x,e.x),Math.max(c.p1.y,e.y)],c);this.classifyPoints_(a,b,!1);this.triangulate_(a,b);this.classifyPoints_(f,g,!1);this.triangulate_(f,g);break}d=a.nextItem()}while(d!==c)};ol.render.webgl.PolygonReplay.prototype.createPoint_=function(a,b,c){var d=this.vertices.length;this.vertices[d++]=a;this.vertices[d++]=b;return{x:a,y:b,i:c,reflex:void 0}};
ol.render.webgl.PolygonReplay.prototype.insertItem_=function(a,b,c,d){var e={p0:a,p1:b};c.insertItem(e);d&&d.insert([Math.min(a.x,b.x),Math.min(a.y,b.y),Math.max(a.x,b.x),Math.max(a.y,b.y)],e);return e};ol.render.webgl.PolygonReplay.prototype.removeItem_=function(a,b,c,d){c.getCurrItem()===b&&(c.removeItem(),a.p1=b.p1,d.remove(b),d.update([Math.min(a.p0.x,a.p1.x),Math.min(a.p0.y,a.p1.y),Math.max(a.p0.x,a.p1.x),Math.max(a.p0.y,a.p1.y)],a))};
ol.render.webgl.PolygonReplay.prototype.getPointsInTriangle_=function(a,b,c,d,e){var f,g,h=[],k=d.getInExtent([Math.min(a.x,b.x,c.x),Math.min(a.y,b.y,c.y),Math.max(a.x,b.x,c.x),Math.max(a.y,b.y,c.y)]);d=0;for(f=k.length;d<f;++d)for(g in k[d]){var l=k[d][g];"object"!==typeof l||e&&!l.reflex||l.x===a.x&&l.y===a.y||l.x===b.x&&l.y===b.y||l.x===c.x&&l.y===c.y||-1!==h.indexOf(l)||!ol.geom.flat.contains.linearRingContainsXY([a.x,a.y,b.x,b.y,c.x,c.y],0,6,2,l.x,l.y)||h.push(l)}return h};
ol.render.webgl.PolygonReplay.prototype.getIntersections_=function(a,b,c){var d=a.p0,e=a.p1;b=b.getInExtent([Math.min(d.x,e.x),Math.min(d.y,e.y),Math.max(d.x,e.x),Math.max(d.y,e.y)]);var f=[],g;var h=0;for(g=b.length;h<g;++h){var k=b[h];a!==k&&(c||k.p0!==e||k.p1!==d)&&this.calculateIntersection_(d,e,k.p0,k.p1,c)&&f.push(k)}return f};
ol.render.webgl.PolygonReplay.prototype.calculateIntersection_=function(a,b,c,d,e){var f=(d.y-c.y)*(b.x-a.x)-(d.x-c.x)*(b.y-a.y);if(0!==f&&(d=((d.x-c.x)*(a.y-c.y)-(d.y-c.y)*(a.x-c.x))/f,c=((b.x-a.x)*(a.y-c.y)-(b.y-a.y)*(a.x-c.x))/f,!e&&d>ol.render.webgl.EPSILON&&d<1-ol.render.webgl.EPSILON&&c>ol.render.webgl.EPSILON&&c<1-ol.render.webgl.EPSILON||e&&0<=d&&1>=d&&0<=c&&1>=c))return[a.x+d*(b.x-a.x),a.y+d*(b.y-a.y)]};
ol.render.webgl.PolygonReplay.prototype.diagonalIsInside_=function(a,b,c,d,e){if(void 0===b.reflex||void 0===d.reflex)return!1;var f=(c.x-d.x)*(b.y-d.y)>(c.y-d.y)*(b.x-d.x);e=(e.x-d.x)*(b.y-d.y)<(e.y-d.y)*(b.x-d.x);a=(a.x-b.x)*(d.y-b.y)>(a.y-b.y)*(d.x-b.x);c=(c.x-b.x)*(d.y-b.y)<(c.y-b.y)*(d.x-b.x);b=b.reflex?c||a:c&&a;return(d.reflex?e||f:e&&f)&&b};
ol.render.webgl.PolygonReplay.prototype.drawMultiPolygon=function(a,b){var c=a.getEndss(),d=a.getStride(),e=this.indices.length,f=this.lineStringReplay.getCurrentIndex();a=a.getFlatCoordinates();var g,h,k;var l=h=0;for(g=c.length;l<g;++l){var m=c[l];if(0<m.length){var n=ol.geom.flat.transform.translate(a,h,m[0],d,-this.origin[0],-this.origin[1]);if(n.length){var p=[];h=1;for(k=m.length;h<k;++h)if(m[h]!==m[h-1]){var q=ol.geom.flat.transform.translate(a,m[h-1],m[h],d,-this.origin[0],-this.origin[1]);
p.push(q)}this.lineStringReplay.drawPolygonCoordinates(n,p,d);this.drawCoordinates_(n,p,d)}}h=m[m.length-1]}this.indices.length>e&&(this.startIndices.push(e),this.startIndicesFeature.push(b),this.state_.changed&&(this.styleIndices_.push(e),this.state_.changed=!1));this.lineStringReplay.getCurrentIndex()>f&&this.lineStringReplay.setPolygonStyle(b,f)};
ol.render.webgl.PolygonReplay.prototype.drawPolygon=function(a,b){var c=a.getEnds(),d=a.getStride();if(0<c.length){a=a.getFlatCoordinates().map(Number);var e=ol.geom.flat.transform.translate(a,0,c[0],d,-this.origin[0],-this.origin[1]);if(e.length){var f=[],g;var h=1;for(g=c.length;h<g;++h)if(c[h]!==c[h-1]){var k=ol.geom.flat.transform.translate(a,c[h-1],c[h],d,-this.origin[0],-this.origin[1]);f.push(k)}this.startIndices.push(this.indices.length);this.startIndicesFeature.push(b);this.state_.changed&&
(this.styleIndices_.push(this.indices.length),this.state_.changed=!1);this.lineStringReplay.setPolygonStyle(b);this.lineStringReplay.drawPolygonCoordinates(e,f,d);this.drawCoordinates_(e,f,d)}}};
ol.render.webgl.PolygonReplay.prototype.finish=function(a){this.verticesBuffer=new ol.webgl.Buffer(this.vertices);this.indicesBuffer=new ol.webgl.Buffer(this.indices);this.startIndices.push(this.indices.length);this.lineStringReplay.finish(a);0===this.styleIndices_.length&&0<this.styles_.length&&(this.styles_=[]);this.indices=this.vertices=null};
ol.render.webgl.PolygonReplay.prototype.getDeleteResourcesFunction=function(a){var b=this.verticesBuffer,c=this.indicesBuffer,d=this.lineStringReplay.getDeleteResourcesFunction(a);return function(){a.deleteBuffer(b);a.deleteBuffer(c);d()}};
ol.render.webgl.PolygonReplay.prototype.setUpProgram=function(a,b,c,d){c=b.getProgram(ol.render.webgl.polygonreplay.defaultshader.fragment,ol.render.webgl.polygonreplay.defaultshader.vertex);this.defaultLocations_?d=this.defaultLocations_:this.defaultLocations_=d=new ol.render.webgl.polygonreplay.defaultshader.Locations(a,c);b.useProgram(c);a.enableVertexAttribArray(d.a_position);a.vertexAttribPointer(d.a_position,2,ol.webgl.FLOAT,!1,8,0);return d};
ol.render.webgl.PolygonReplay.prototype.shutDownProgram=function(a,b){a.disableVertexAttribArray(b.a_position)};
ol.render.webgl.PolygonReplay.prototype.drawReplay=function(a,b,c,d){var e=a.getParameter(a.DEPTH_FUNC),f=a.getParameter(a.DEPTH_WRITEMASK);d||(a.enable(a.DEPTH_TEST),a.depthMask(!0),a.depthFunc(a.NOTEQUAL));if(ol.obj.isEmpty(c)){var g=this.startIndices[this.startIndices.length-1];for(c=this.styleIndices_.length-1;0<=c;--c){var h=this.styleIndices_[c];var k=this.styles_[c];this.setFillStyle_(a,k);this.drawElements(a,b,h,g);g=h}}else this.drawReplaySkipping_(a,b,c);d||(a.disable(a.DEPTH_TEST),a.clear(a.DEPTH_BUFFER_BIT),
a.depthMask(f),a.depthFunc(e))};
ol.render.webgl.PolygonReplay.prototype.drawHitDetectionReplayOneByOne=function(a,b,c,d,e){var f,g;var h=this.startIndices.length-2;var k=this.startIndices[h+1];for(f=this.styleIndices_.length-1;0<=f;--f){var l=this.styles_[f];this.setFillStyle_(a,l);for(g=this.styleIndices_[f];0<=h&&this.startIndices[h]>=g;){l=this.startIndices[h];var m=this.startIndicesFeature[h];var n=ol.getUid(m).toString();if(void 0===c[n]&&m.getGeometry()&&(void 0===e||ol.extent.intersects(e,m.getGeometry().getExtent()))&&(a.clear(a.COLOR_BUFFER_BIT|
a.DEPTH_BUFFER_BIT),this.drawElements(a,b,l,k),k=d(m)))return k;h--;k=l}}};
ol.render.webgl.PolygonReplay.prototype.drawReplaySkipping_=function(a,b,c){var d,e;var f=this.startIndices.length-2;var g=e=this.startIndices[f+1];for(d=this.styleIndices_.length-1;0<=d;--d){var h=this.styles_[d];this.setFillStyle_(a,h);for(h=this.styleIndices_[d];0<=f&&this.startIndices[f]>=h;){var k=this.startIndices[f];var l=this.startIndicesFeature[f];l=ol.getUid(l).toString();c[l]&&(e!==g&&(this.drawElements(a,b,e,g),a.clear(a.DEPTH_BUFFER_BIT)),g=k);f--;e=k}e!==g&&(this.drawElements(a,b,e,
g),a.clear(a.DEPTH_BUFFER_BIT));e=g=h}};ol.render.webgl.PolygonReplay.prototype.setFillStyle_=function(a,b){a.uniform4fv(this.defaultLocations_.u_color,b)};
ol.render.webgl.PolygonReplay.prototype.setFillStrokeStyle=function(a,b){a=a?a.getColor():[0,0,0,0];a=a instanceof CanvasGradient||a instanceof CanvasPattern?ol.render.webgl.defaultFillStyle:ol.color.asArray(a).map(function(a,b){return 3!=b?a/255:a})||ol.render.webgl.defaultFillStyle;this.state_.fillColor&&ol.array.equals(a,this.state_.fillColor)||(this.state_.fillColor=a,this.state_.changed=!0,this.styles_.push(a));b||(b=new ol.style.Stroke({color:[0,0,0,0],lineWidth:0}));this.lineStringReplay.setFillStrokeStyle(null,
b)};ol.style.Atlas=function(a,b){this.space_=b;this.emptyBlocks_=[{x:0,y:0,width:a,height:a}];this.entries_={};this.context_=ol.dom.createCanvasContext2D(a,a);this.canvas_=this.context_.canvas};ol.style.Atlas.prototype.get=function(a){return this.entries_[a]||null};
ol.style.Atlas.prototype.add=function(a,b,c,d,e){var f;var g=0;for(f=this.emptyBlocks_.length;g<f;++g){var h=this.emptyBlocks_[g];if(h.width>=b+this.space_&&h.height>=c+this.space_)return f={offsetX:h.x+this.space_,offsetY:h.y+this.space_,image:this.canvas_},this.entries_[a]=f,d.call(e,this.context_,h.x+this.space_,h.y+this.space_),this.split_(g,h,b+this.space_,c+this.space_),f}return null};
ol.style.Atlas.prototype.split_=function(a,b,c,d){if(b.width-c>b.height-d){var e={x:b.x+c,y:b.y,width:b.width-c,height:b.height};b={x:b.x,y:b.y+d,width:c,height:b.height-d}}else e={x:b.x+c,y:b.y,width:b.width-c,height:d},b={x:b.x,y:b.y+d,width:b.width,height:b.height-d};this.updateBlocks_(a,e,b)};ol.style.Atlas.prototype.updateBlocks_=function(a,b,c){a=[a,1];0<b.width&&0<b.height&&a.push(b);0<c.width&&0<c.height&&a.push(c);this.emptyBlocks_.splice.apply(this.emptyBlocks_,a)};ol.style.AtlasManager=function(a){a=a||{};this.currentSize_=void 0!==a.initialSize?a.initialSize:ol.INITIAL_ATLAS_SIZE;this.maxSize_=void 0!==a.maxSize?a.maxSize:-1!=ol.MAX_ATLAS_SIZE?ol.MAX_ATLAS_SIZE:void 0!==ol.WEBGL_MAX_TEXTURE_SIZE?ol.WEBGL_MAX_TEXTURE_SIZE:2048;this.space_=void 0!==a.space?a.space:1;this.atlases_=[new ol.style.Atlas(this.currentSize_,this.space_)];this.currentHitSize_=this.currentSize_;this.hitAtlases_=[new ol.style.Atlas(this.currentHitSize_,this.space_)]};
ol.style.AtlasManager.prototype.getInfo=function(a){var b=this.getInfo_(this.atlases_,a);if(!b)return null;a=this.getInfo_(this.hitAtlases_,a);return this.mergeInfos_(b,a)};ol.style.AtlasManager.prototype.getInfo_=function(a,b){var c;var d=0;for(c=a.length;d<c;++d){var e=a[d];if(e=e.get(b))return e}return null};ol.style.AtlasManager.prototype.mergeInfos_=function(a,b){return{offsetX:a.offsetX,offsetY:a.offsetY,image:a.image,hitImage:b.image}};
ol.style.AtlasManager.prototype.add=function(a,b,c,d,e,f){if(b+this.space_>this.maxSize_||c+this.space_>this.maxSize_)return null;d=this.add_(!1,a,b,c,d,f);if(!d)return null;a=this.add_(!0,a,b,c,void 0!==e?e:ol.nullFunction,f);return this.mergeInfos_(d,a)};
ol.style.AtlasManager.prototype.add_=function(a,b,c,d,e,f){var g=a?this.hitAtlases_:this.atlases_,h;var k=0;for(h=g.length;k<h;++k){var l=g[k];if(l=l.add(b,c,d,e,f))return l;l||k!==h-1||(a?this.currentHitSize_=l=Math.min(2*this.currentHitSize_,this.maxSize_):this.currentSize_=l=Math.min(2*this.currentSize_,this.maxSize_),l=new ol.style.Atlas(l,this.space_),g.push(l),++h)}return null};ol.render.webgl.TextReplay=function(a,b){ol.render.webgl.TextureReplay.call(this,a,b);this.images_=[];this.textures_=[];this.measureCanvas_=ol.dom.createCanvasContext2D(0,0).canvas;this.state_={strokeColor:null,lineCap:void 0,lineDash:null,lineDashOffset:void 0,lineJoin:void 0,lineWidth:0,miterLimit:void 0,fillColor:null,font:void 0,scale:void 0};this.text_="";this.offsetY_=this.offsetX_=this.textBaseline_=this.textAlign_=void 0;this.atlases_={};this.currAtlas_=void 0;this.opacity=this.scale=1};
ol.inherits(ol.render.webgl.TextReplay,ol.render.webgl.TextureReplay);
ol.render.webgl.TextReplay.prototype.drawText=function(a,b){if(this.text_){var c=null,d=2,e=2;switch(a.getType()){case ol.geom.GeometryType.POINT:case ol.geom.GeometryType.MULTI_POINT:c=a.getFlatCoordinates();d=c.length;e=a.getStride();break;case ol.geom.GeometryType.CIRCLE:c=a.getCenter();break;case ol.geom.GeometryType.LINE_STRING:c=a.getFlatMidpoint();break;case ol.geom.GeometryType.MULTI_LINE_STRING:c=a.getFlatMidpoints();d=c.length;break;case ol.geom.GeometryType.POLYGON:c=a.getFlatInteriorPoint();
break;case ol.geom.GeometryType.MULTI_POLYGON:c=a.getFlatInteriorPoints(),d=c.length}this.startIndices.push(this.indices.length);this.startIndicesFeature.push(b);a=this.currAtlas_;b=this.text_.split("\n");var f=this.getTextSize_(b),g,h,k,l=Math.round(f[0]*this.textAlign_-this.offsetX_),m=Math.round(f[1]*this.textBaseline_-this.offsetY_),n=this.state_.lineWidth/2*this.state_.scale;f=0;for(g=b.length;f<g;++f){var p=0;var q=a.height*f;var r=b[f].split("");var u=0;for(h=r.length;u<h;++u){if(k=a.atlas.getInfo(r[u])){var t=
k.image;this.anchorX=l-p;this.anchorY=m-q;this.originX=0===u?k.offsetX-n:k.offsetX;this.originY=k.offsetY;this.height=a.height;this.width=0===u||u===r.length-1?a.width[r[u]]+n:a.width[r[u]];this.imageHeight=t.height;this.imageWidth=t.width;0===this.images_.length?this.images_.push(t):(k=this.images_[this.images_.length-1],ol.getUid(k)!=ol.getUid(t)&&(this.groupIndices.push(this.indices.length),this.images_.push(t)));this.drawText_(c,0,d,e)}p+=this.width}}}};
ol.render.webgl.TextReplay.prototype.getTextSize_=function(a){var b=this,c=this.currAtlas_,d=a.length*c.height;return[a.map(function(a){var d=0,e;var h=0;for(e=a.length;h<e;++h){var k=a[h];c.width[k]||b.addCharToAtlas_(k);d+=c.width[k]?c.width[k]:0}return d}).reduce(function(a,b){return Math.max(a,b)}),d]};ol.render.webgl.TextReplay.prototype.drawText_=function(a,b,c,d){var e;for(e=b;e<c;e+=d)this.drawCoordinates(a,b,c,d)};
ol.render.webgl.TextReplay.prototype.addCharToAtlas_=function(a){if(1===a.length){var b=this.currAtlas_,c=this.state_,d=this.measureCanvas_.getContext("2d");d.font=c.font;d=Math.ceil(d.measureText(a).width*c.scale);b.atlas.add(a,d,b.height,function(b,d,g){b.font=c.font;b.fillStyle=c.fillColor;b.strokeStyle=c.strokeColor;b.lineWidth=c.lineWidth;b.lineCap=c.lineCap;b.lineJoin=c.lineJoin;b.miterLimit=c.miterLimit;b.textAlign="left";b.textBaseline="top";ol.has.CANVAS_LINE_DASH&&c.lineDash&&(b.setLineDash(c.lineDash),
b.lineDashOffset=c.lineDashOffset);1!==c.scale&&b.setTransform(c.scale,0,0,c.scale,0,0);c.strokeColor&&b.strokeText(a,d,g);c.fillColor&&b.fillText(a,d,g)})&&(b.width[a]=d)}};
ol.render.webgl.TextReplay.prototype.finish=function(a){var b=a.getGL();this.groupIndices.push(this.indices.length);this.hitDetectionGroupIndices=this.groupIndices;this.verticesBuffer=new ol.webgl.Buffer(this.vertices);this.indicesBuffer=new ol.webgl.Buffer(this.indices);this.createTextures(this.textures_,this.images_,{},b);this.state_={strokeColor:null,lineCap:void 0,lineDash:null,lineDashOffset:void 0,lineJoin:void 0,lineWidth:0,miterLimit:void 0,fillColor:null,font:void 0,scale:void 0};this.text_=
"";this.offsetY_=this.offsetX_=this.textBaseline_=this.textAlign_=void 0;this.images_=null;this.atlases_={};this.currAtlas_=void 0;ol.render.webgl.TextureReplay.prototype.finish.call(this,a)};
ol.render.webgl.TextReplay.prototype.setTextStyle=function(a){var b=this.state_,c=a.getFill(),d=a.getStroke();a&&a.getText()&&(c||d)?(c?(c=c.getColor(),b.fillColor=ol.colorlike.asColorLike(c?c:ol.render.webgl.defaultFillStyle)):b.fillColor=null,d?(c=d.getColor(),b.strokeColor=ol.colorlike.asColorLike(c?c:ol.render.webgl.defaultStrokeStyle),b.lineWidth=d.getWidth()||ol.render.webgl.defaultLineWidth,b.lineCap=d.getLineCap()||ol.render.webgl.defaultLineCap,b.lineDashOffset=d.getLineDashOffset()||ol.render.webgl.defaultLineDashOffset,
b.lineJoin=d.getLineJoin()||ol.render.webgl.defaultLineJoin,b.miterLimit=d.getMiterLimit()||ol.render.webgl.defaultMiterLimit,d=d.getLineDash(),b.lineDash=d?d.slice():ol.render.webgl.defaultLineDash):(b.strokeColor=null,b.lineWidth=0),b.font=a.getFont()||ol.render.webgl.defaultFont,b.scale=a.getScale()||1,this.text_=a.getText(),d=ol.render.replay.TEXT_ALIGN[a.getTextAlign()],c=ol.render.replay.TEXT_ALIGN[a.getTextBaseline()],this.textAlign_=void 0===d?ol.render.webgl.defaultTextAlign:d,this.textBaseline_=
void 0===c?ol.render.webgl.defaultTextBaseline:c,this.offsetX_=a.getOffsetX()||0,this.offsetY_=a.getOffsetY()||0,this.rotateWithView=!!a.getRotateWithView(),this.rotation=a.getRotation()||0,this.currAtlas_=this.getAtlas_(b)):this.text_=""};
ol.render.webgl.TextReplay.prototype.getAtlas_=function(a){var b=[];for(c in a)if(a[c]||0===a[c])Array.isArray(a[c])?b=b.concat(a[c]):b.push(a[c]);b=this.calculateHash_(b);if(!this.atlases_[b]){var c=this.measureCanvas_.getContext("2d");c.font=a.font;c=Math.ceil((1.5*c.measureText("M").width+a.lineWidth/2)*a.scale);this.atlases_[b]={atlas:new ol.style.AtlasManager({space:a.lineWidth+1}),width:{},height:c}}return this.atlases_[b]};
ol.render.webgl.TextReplay.prototype.calculateHash_=function(a){var b,c="";var d=0;for(b=a.length;d<b;++d)c+=a[d];return c};ol.render.webgl.TextReplay.prototype.getTextures=function(a){return this.textures_};ol.render.webgl.TextReplay.prototype.getHitDetectionTextures=function(){return this.textures_};ol.render.webgl.ReplayGroup=function(a,b,c){ol.render.ReplayGroup.call(this);this.maxExtent_=b;this.tolerance_=a;this.renderBuffer_=c;this.replaysByZIndex_={}};ol.inherits(ol.render.webgl.ReplayGroup,ol.render.ReplayGroup);ol.render.webgl.ReplayGroup.prototype.addDeclutter=function(a,b){};
ol.render.webgl.ReplayGroup.prototype.getDeleteResourcesFunction=function(a){var b=[],c;for(c in this.replaysByZIndex_){var d=this.replaysByZIndex_[c],e;for(e in d)b.push(d[e].getDeleteResourcesFunction(a))}return function(){for(var a=b.length,c,d=0;d<a;d++)c=b[d].apply(this,arguments);return c}};ol.render.webgl.ReplayGroup.prototype.finish=function(a){for(var b in this.replaysByZIndex_){var c=this.replaysByZIndex_[b],d;for(d in c)c[d].finish(a)}};
ol.render.webgl.ReplayGroup.prototype.getReplay=function(a,b){var c=void 0!==a?a.toString():"0";a=this.replaysByZIndex_[c];void 0===a&&(a={},this.replaysByZIndex_[c]=a);c=a[b];void 0===c&&(c=new ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_[b](this.tolerance_,this.maxExtent_),a[b]=c);return c};ol.render.webgl.ReplayGroup.prototype.isEmpty=function(){return ol.obj.isEmpty(this.replaysByZIndex_)};
ol.render.webgl.ReplayGroup.prototype.replay=function(a,b,c,d,e,f,g,h){var k=Object.keys(this.replaysByZIndex_).map(Number);k.sort(ol.array.numberSafeCompareFunction);var l,m;var n=0;for(l=k.length;n<l;++n){var p=this.replaysByZIndex_[k[n].toString()];var q=0;for(m=ol.render.replay.ORDER.length;q<m;++q){var r=p[ol.render.replay.ORDER[q]];void 0!==r&&r.replay(a,b,c,d,e,f,g,h,void 0,!1)}}};
ol.render.webgl.ReplayGroup.prototype.replayHitDetection_=function(a,b,c,d,e,f,g,h,k,l,m){var n=Object.keys(this.replaysByZIndex_).map(Number);n.sort(function(a,b){return b-a});var p,q;var r=0;for(p=n.length;r<p;++r){var u=this.replaysByZIndex_[n[r].toString()];for(q=ol.render.replay.ORDER.length-1;0<=q;--q){var t=u[ol.render.replay.ORDER[q]];if(void 0!==t&&(t=t.replay(a,b,c,d,e,f,g,h,k,l,m)))return t}}};
ol.render.webgl.ReplayGroup.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e,f,g,h,k,l){var m=b.getGL();m.bindFramebuffer(m.FRAMEBUFFER,b.getHitDetectionFramebuffer());var n;void 0!==this.renderBuffer_&&(n=ol.extent.buffer(ol.extent.createOrUpdateFromCoordinate(a),d*this.renderBuffer_));return this.replayHitDetection_(b,a,d,e,ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_,g,h,k,function(a){var b=new Uint8Array(4);m.readPixels(0,0,1,1,m.RGBA,m.UNSIGNED_BYTE,b);if(0<b[3]&&(a=l(a)))return a},
!0,n)};ol.render.webgl.ReplayGroup.prototype.hasFeatureAtCoordinate=function(a,b,c,d,e,f,g,h,k){var l=b.getGL();l.bindFramebuffer(l.FRAMEBUFFER,b.getHitDetectionFramebuffer());return void 0!==this.replayHitDetection_(b,a,d,e,ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_,g,h,k,function(a){a=new Uint8Array(4);l.readPixels(0,0,1,1,l.RGBA,l.UNSIGNED_BYTE,a);return 0<a[3]},!1)};ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_=[1,1];
ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_={Circle:ol.render.webgl.CircleReplay,Image:ol.render.webgl.ImageReplay,LineString:ol.render.webgl.LineStringReplay,Polygon:ol.render.webgl.PolygonReplay,Text:ol.render.webgl.TextReplay};ol.render.webgl.Immediate=function(a,b,c,d,e,f,g){ol.render.VectorContext.call(this);this.context_=a;this.center_=b;this.extent_=f;this.pixelRatio_=g;this.size_=e;this.rotation_=d;this.resolution_=c;this.textStyle_=this.strokeStyle_=this.fillStyle_=this.imageStyle_=null};ol.inherits(ol.render.webgl.Immediate,ol.render.VectorContext);
ol.render.webgl.Immediate.prototype.drawText_=function(a,b){var c=this.context_;a=a.getReplay(0,ol.render.ReplayType.TEXT);a.setTextStyle(this.textStyle_);a.drawText(b,null);a.finish(c);a.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);a.getDeleteResourcesFunction(c)()};ol.render.webgl.Immediate.prototype.setStyle=function(a){this.setFillStrokeStyle(a.getFill(),a.getStroke());this.setImageStyle(a.getImage());this.setTextStyle(a.getText())};
ol.render.webgl.Immediate.prototype.drawGeometry=function(a){switch(a.getType()){case ol.geom.GeometryType.POINT:this.drawPoint(a,null);break;case ol.geom.GeometryType.LINE_STRING:this.drawLineString(a,null);break;case ol.geom.GeometryType.POLYGON:this.drawPolygon(a,null);break;case ol.geom.GeometryType.MULTI_POINT:this.drawMultiPoint(a,null);break;case ol.geom.GeometryType.MULTI_LINE_STRING:this.drawMultiLineString(a,null);break;case ol.geom.GeometryType.MULTI_POLYGON:this.drawMultiPolygon(a,null);
break;case ol.geom.GeometryType.GEOMETRY_COLLECTION:this.drawGeometryCollection(a,null);break;case ol.geom.GeometryType.CIRCLE:this.drawCircle(a,null)}};ol.render.webgl.Immediate.prototype.drawFeature=function(a,b){(a=b.getGeometryFunction()(a))&&ol.extent.intersects(this.extent_,a.getExtent())&&(this.setStyle(b),this.drawGeometry(a))};ol.render.webgl.Immediate.prototype.drawGeometryCollection=function(a,b){a=a.getGeometriesArray();var c;b=0;for(c=a.length;b<c;++b)this.drawGeometry(a[b])};
ol.render.webgl.Immediate.prototype.drawPoint=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.IMAGE);e.setImageStyle(this.imageStyle_);e.drawPoint(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawMultiPoint=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.IMAGE);e.setImageStyle(this.imageStyle_);e.drawMultiPoint(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawLineString=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.LINE_STRING);e.setFillStrokeStyle(null,this.strokeStyle_);e.drawLineString(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawMultiLineString=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.LINE_STRING);e.setFillStrokeStyle(null,this.strokeStyle_);e.drawMultiLineString(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawPolygon=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.POLYGON);e.setFillStrokeStyle(this.fillStyle_,this.strokeStyle_);e.drawPolygon(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawMultiPolygon=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.POLYGON);e.setFillStrokeStyle(this.fillStyle_,this.strokeStyle_);e.drawMultiPolygon(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.drawCircle=function(a,b){var c=this.context_,d=new ol.render.webgl.ReplayGroup(1,this.extent_),e=d.getReplay(0,ol.render.ReplayType.CIRCLE);e.setFillStrokeStyle(this.fillStyle_,this.strokeStyle_);e.drawCircle(a,b);e.finish(c);e.replay(this.context_,this.center_,this.resolution_,this.rotation_,this.size_,this.pixelRatio_,1,{},void 0,!1);e.getDeleteResourcesFunction(c)();this.textStyle_&&this.drawText_(d,a)};
ol.render.webgl.Immediate.prototype.setImageStyle=function(a){this.imageStyle_=a};ol.render.webgl.Immediate.prototype.setFillStrokeStyle=function(a,b){this.fillStyle_=a;this.strokeStyle_=b};ol.render.webgl.Immediate.prototype.setTextStyle=function(a){this.textStyle_=a};ol.renderer.webgl={};ol.renderer.webgl.defaultmapshader={};ol.renderer.webgl.defaultmapshader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n":"precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}");
ol.renderer.webgl.defaultmapshader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n":"varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}");ol.renderer.webgl.defaultmapshader.Locations=function(a,b){this.u_texCoordMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_texCoordMatrix":"d");this.u_projectionMatrix=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_projectionMatrix":"e");this.u_opacity=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_opacity":"f");this.u_texture=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_texture":"g");this.a_position=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_position":"b");this.a_texCoord=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_texCoord":
"c")};ol.renderer.webgl.Layer=function(a,b){ol.renderer.Layer.call(this,b);this.mapRenderer=a;this.arrayBuffer_=new ol.webgl.Buffer([-1,-1,0,0,1,-1,1,0,-1,1,0,1,1,1,1,1]);this.framebuffer=this.texture=null;this.framebufferDimension=void 0;this.texCoordMatrix=ol.transform.create();this.projectionMatrix=ol.transform.create();this.tmpMat4_=ol.vec.Mat4.create();this.defaultLocations_=null};ol.inherits(ol.renderer.webgl.Layer,ol.renderer.Layer);
ol.renderer.webgl.Layer.prototype.bindFramebuffer=function(a,b){var c=this.mapRenderer.getGL();if(void 0===this.framebufferDimension||this.framebufferDimension!=b){var d=function(a,b,c){a.isContextLost()||(a.deleteFramebuffer(b),a.deleteTexture(c))}.bind(null,c,this.framebuffer,this.texture);a.postRenderFunctions.push(d);a=ol.webgl.Context.createEmptyTexture(c,b,b);d=c.createFramebuffer();c.bindFramebuffer(ol.webgl.FRAMEBUFFER,d);c.framebufferTexture2D(ol.webgl.FRAMEBUFFER,ol.webgl.COLOR_ATTACHMENT0,
ol.webgl.TEXTURE_2D,a,0);this.texture=a;this.framebuffer=d;this.framebufferDimension=b}else c.bindFramebuffer(ol.webgl.FRAMEBUFFER,this.framebuffer)};
ol.renderer.webgl.Layer.prototype.composeFrame=function(a,b,c){this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE,c,a);c.bindBuffer(ol.webgl.ARRAY_BUFFER,this.arrayBuffer_);var d=c.getGL(),e=c.getProgram(ol.renderer.webgl.defaultmapshader.fragment,ol.renderer.webgl.defaultmapshader.vertex);if(this.defaultLocations_)var f=this.defaultLocations_;else this.defaultLocations_=f=new ol.renderer.webgl.defaultmapshader.Locations(d,e);c.useProgram(e)&&(d.enableVertexAttribArray(f.a_position),d.vertexAttribPointer(f.a_position,
2,ol.webgl.FLOAT,!1,16,0),d.enableVertexAttribArray(f.a_texCoord),d.vertexAttribPointer(f.a_texCoord,2,ol.webgl.FLOAT,!1,16,8),d.uniform1i(f.u_texture,0));d.uniformMatrix4fv(f.u_texCoordMatrix,!1,ol.vec.Mat4.fromTransform(this.tmpMat4_,this.getTexCoordMatrix()));d.uniformMatrix4fv(f.u_projectionMatrix,!1,ol.vec.Mat4.fromTransform(this.tmpMat4_,this.getProjectionMatrix()));d.uniform1f(f.u_opacity,b.opacity);d.bindTexture(ol.webgl.TEXTURE_2D,this.getTexture());d.drawArrays(ol.webgl.TRIANGLE_STRIP,0,
4);this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE,c,a)};ol.renderer.webgl.Layer.prototype.dispatchComposeEvent_=function(a,b,c){var d=this.getLayer();if(d.hasListener(a)){var e=c.viewState;e=new ol.render.webgl.Immediate(b,e.center,e.resolution,e.rotation,c.size,c.extent,c.pixelRatio);a=new ol.render.Event(a,e,c,null,b);d.dispatchEvent(a)}};ol.renderer.webgl.Layer.prototype.getTexCoordMatrix=function(){return this.texCoordMatrix};ol.renderer.webgl.Layer.prototype.getTexture=function(){return this.texture};
ol.renderer.webgl.Layer.prototype.getProjectionMatrix=function(){return this.projectionMatrix};ol.renderer.webgl.Layer.prototype.handleWebGLContextLost=function(){this.framebuffer=this.texture=null;this.framebufferDimension=void 0};ol.renderer.webgl.Layer.prototype.prepareFrame=function(a,b,c){};ol.renderer.webgl.Layer.prototype.forEachLayerAtPixel=function(a,b,c,d){};ol.renderer.webgl.ImageLayer=function(a,b){ol.renderer.webgl.Layer.call(this,a,b);this.hitTransformationMatrix_=this.hitCanvasContext_=this.image_=null};ol.inherits(ol.renderer.webgl.ImageLayer,ol.renderer.webgl.Layer);ol.renderer.webgl.ImageLayer.handles=function(a,b){return a===ol.renderer.Type.WEBGL&&b.getType()===ol.LayerType.IMAGE};ol.renderer.webgl.ImageLayer.create=function(a,b){return new ol.renderer.webgl.ImageLayer(a,b)};
ol.renderer.webgl.ImageLayer.prototype.createTexture_=function(a){a=a.getImage();var b=this.mapRenderer.getGL();return ol.webgl.Context.createTexture(b,a,ol.webgl.CLAMP_TO_EDGE,ol.webgl.CLAMP_TO_EDGE)};ol.renderer.webgl.ImageLayer.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){var f=this.getLayer();return f.getSource().forEachFeatureAtCoordinate(a,b.viewState.resolution,b.viewState.rotation,c,b.skippedFeatureUids,function(a){return d.call(e,a,f)})};
ol.renderer.webgl.ImageLayer.prototype.prepareFrame=function(a,b,c){var d=this.mapRenderer.getGL(),e=a.pixelRatio,f=a.viewState,g=f.center,h=f.resolution,k=f.rotation;c=this.image_;var l=this.texture,m=this.getLayer().getSource(),n=a.viewHints,p=a.extent;void 0!==b.extent&&(p=ol.extent.getIntersection(p,b.extent));n[ol.ViewHint.ANIMATING]||n[ol.ViewHint.INTERACTING]||ol.extent.isEmpty(p)||(b=f.projection,ol.ENABLE_RASTER_REPROJECTION||(f=m.getProjection())&&(b=f),(p=m.getImage(p,h,e,b))&&this.loadImage(p)&&
(c=p,l=this.createTexture_(p),this.texture&&(d=function(a,b){a.isContextLost()||a.deleteTexture(b)}.bind(null,d,this.texture),a.postRenderFunctions.push(d))));c&&(d=this.mapRenderer.getContext().getCanvas(),this.updateProjectionMatrix_(d.width,d.height,e,g,h,k,c.getExtent()),this.hitTransformationMatrix_=null,e=this.texCoordMatrix,ol.transform.reset(e),ol.transform.scale(e,1,-1),ol.transform.translate(e,0,-1),this.image_=c,this.texture=l,this.updateLogos(a,m));return!!c};
ol.renderer.webgl.ImageLayer.prototype.updateProjectionMatrix_=function(a,b,c,d,e,f,g){a*=e;b*=e;e=this.projectionMatrix;ol.transform.reset(e);ol.transform.scale(e,2*c/a,2*c/b);ol.transform.rotate(e,-f);ol.transform.translate(e,g[0]-d[0],g[1]-d[1]);ol.transform.scale(e,(g[2]-g[0])/2,(g[3]-g[1])/2);ol.transform.translate(e,1,1)};ol.renderer.webgl.ImageLayer.prototype.hasFeatureAtCoordinate=function(a,b){return void 0!==this.forEachFeatureAtCoordinate(a,b,0,ol.functions.TRUE,this)};
ol.renderer.webgl.ImageLayer.prototype.forEachLayerAtPixel=function(a,b,c,d){if(this.image_&&this.image_.getImage())if(this.getLayer().getSource().forEachFeatureAtCoordinate!==ol.nullFunction){var e=ol.transform.apply(b.pixelToCoordinateTransform,a.slice());if(this.forEachFeatureAtCoordinate(e,b,0,ol.functions.TRUE,this))return c.call(d,this.getLayer(),null)}else if(e=[this.image_.getImage().width,this.image_.getImage().height],this.hitTransformationMatrix_||(this.hitTransformationMatrix_=this.getHitTransformationMatrix_(b.size,
e)),b=ol.transform.apply(this.hitTransformationMatrix_,a.slice()),!(0>b[0]||b[0]>e[0]||0>b[1]||b[1]>e[1])&&(this.hitCanvasContext_||(this.hitCanvasContext_=ol.dom.createCanvasContext2D(1,1)),this.hitCanvasContext_.clearRect(0,0,1,1),this.hitCanvasContext_.drawImage(this.image_.getImage(),b[0],b[1],1,1,0,0,1,1),b=this.hitCanvasContext_.getImageData(0,0,1,1).data,0<b[3]))return c.call(d,this.getLayer(),b)};
ol.renderer.webgl.ImageLayer.prototype.getHitTransformationMatrix_=function(a,b){var c=ol.transform.create();ol.transform.translate(c,-1,-1);ol.transform.scale(c,2/a[0],2/a[1]);ol.transform.translate(c,0,a[1]);ol.transform.scale(c,1,-1);a=ol.transform.invert(this.projectionMatrix.slice());var d=ol.transform.create();ol.transform.translate(d,0,b[1]);ol.transform.scale(d,1,-1);ol.transform.scale(d,b[0]/2,b[1]/2);ol.transform.translate(d,1,1);ol.transform.multiply(d,a);ol.transform.multiply(d,c);return d};ol.renderer.webgl.Map=function(a,b){ol.renderer.Map.call(this,a,b);this.canvas_=document.createElement("CANVAS");this.canvas_.style.width="100%";this.canvas_.style.height="100%";this.canvas_.style.display="block";this.canvas_.className=ol.css.CLASS_UNSELECTABLE;a.insertBefore(this.canvas_,a.childNodes[0]||null);this.clipTileCanvasHeight_=this.clipTileCanvasWidth_=0;this.clipTileContext_=ol.dom.createCanvasContext2D();this.renderedVisible_=!0;this.gl_=ol.webgl.getContext(this.canvas_,{antialias:!0,
depth:!0,failIfMajorPerformanceCaveat:!0,preserveDrawingBuffer:!1,stencil:!0});this.context_=new ol.webgl.Context(this.canvas_,this.gl_);ol.events.listen(this.canvas_,ol.webgl.ContextEventType.LOST,this.handleWebGLContextLost,this);ol.events.listen(this.canvas_,ol.webgl.ContextEventType.RESTORED,this.handleWebGLContextRestored,this);this.textureCache_=new ol.structs.LRUCache;this.focus_=null;this.tileTextureQueue_=new ol.structs.PriorityQueue(function(a){var b=a[1];a=a[2];var c=b[0]-this.focus_[0];
b=b[1]-this.focus_[1];return 65536*Math.log(a)+Math.sqrt(c*c+b*b)/a}.bind(this),function(a){return a[0].getKey()});this.loadNextTileTexture_=function(a,b){this.tileTextureQueue_.isEmpty()||(this.tileTextureQueue_.reprioritize(),a=this.tileTextureQueue_.dequeue(),this.bindTileTexture(a[0],a[3],a[4],ol.webgl.LINEAR,ol.webgl.LINEAR));return!1}.bind(this);this.textureCacheFrameMarkerCount_=0;this.initializeGL_()};ol.inherits(ol.renderer.webgl.Map,ol.renderer.Map);
ol.renderer.webgl.Map.handles=function(a){return ol.has.WEBGL&&a===ol.renderer.Type.WEBGL};ol.renderer.webgl.Map.create=function(a,b){return new ol.renderer.webgl.Map(a,b)};
ol.renderer.webgl.Map.prototype.bindTileTexture=function(a,b,c,d,e){var f=this.getGL(),g=a.getKey();if(this.textureCache_.containsKey(g))a=this.textureCache_.get(g),f.bindTexture(ol.webgl.TEXTURE_2D,a.texture),a.magFilter!=d&&(f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_MAG_FILTER,d),a.magFilter=d),a.minFilter!=e&&(f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_MIN_FILTER,e),a.minFilter=e);else{var h=f.createTexture();f.bindTexture(ol.webgl.TEXTURE_2D,h);if(0<c){var k=this.clipTileContext_.canvas,
l=this.clipTileContext_;this.clipTileCanvasWidth_!==b[0]||this.clipTileCanvasHeight_!==b[1]?(k.width=b[0],k.height=b[1],this.clipTileCanvasWidth_=b[0],this.clipTileCanvasHeight_=b[1]):l.clearRect(0,0,b[0],b[1]);l.drawImage(a.getImage(),c,c,b[0],b[1],0,0,b[0],b[1]);f.texImage2D(ol.webgl.TEXTURE_2D,0,ol.webgl.RGBA,ol.webgl.RGBA,ol.webgl.UNSIGNED_BYTE,k)}else f.texImage2D(ol.webgl.TEXTURE_2D,0,ol.webgl.RGBA,ol.webgl.RGBA,ol.webgl.UNSIGNED_BYTE,a.getImage());f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_MAG_FILTER,
d);f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_MIN_FILTER,e);f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_WRAP_S,ol.webgl.CLAMP_TO_EDGE);f.texParameteri(ol.webgl.TEXTURE_2D,ol.webgl.TEXTURE_WRAP_T,ol.webgl.CLAMP_TO_EDGE);this.textureCache_.set(g,{texture:h,magFilter:d,minFilter:e})}};
ol.renderer.webgl.Map.prototype.dispatchComposeEvent_=function(a,b){var c=this.getMap();if(c.hasListener(a)){var d=this.context_,e=b.viewState;e=new ol.render.webgl.Immediate(d,e.center,e.resolution,e.rotation,b.size,b.extent,b.pixelRatio);a=new ol.render.Event(a,e,b,null,d);c.dispatchEvent(a)}};ol.renderer.webgl.Map.prototype.disposeInternal=function(){var a=this.getGL();a.isContextLost()||this.textureCache_.forEach(function(b){b&&a.deleteTexture(b.texture)});this.context_.dispose();ol.renderer.Map.prototype.disposeInternal.call(this)};
ol.renderer.webgl.Map.prototype.expireCache_=function(a,b){a=this.getGL();for(var c;this.textureCache_.getCount()-this.textureCacheFrameMarkerCount_>ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK;){if(c=this.textureCache_.peekLast())a.deleteTexture(c.texture);else if(+this.textureCache_.peekLastKey()==b.index)break;else--this.textureCacheFrameMarkerCount_;this.textureCache_.pop()}};ol.renderer.webgl.Map.prototype.getContext=function(){return this.context_};ol.renderer.webgl.Map.prototype.getGL=function(){return this.gl_};
ol.renderer.webgl.Map.prototype.getTileTextureQueue=function(){return this.tileTextureQueue_};ol.renderer.webgl.Map.prototype.getType=function(){return ol.renderer.Type.WEBGL};ol.renderer.webgl.Map.prototype.handleWebGLContextLost=function(a){a.preventDefault();this.textureCache_.clear();this.textureCacheFrameMarkerCount_=0;a=this.getLayerRenderers();for(var b in a)a[b].handleWebGLContextLost()};ol.renderer.webgl.Map.prototype.handleWebGLContextRestored=function(){this.initializeGL_();this.getMap().render()};
ol.renderer.webgl.Map.prototype.initializeGL_=function(){var a=this.gl_;a.activeTexture(ol.webgl.TEXTURE0);a.blendFuncSeparate(ol.webgl.SRC_ALPHA,ol.webgl.ONE_MINUS_SRC_ALPHA,ol.webgl.ONE,ol.webgl.ONE_MINUS_SRC_ALPHA);a.disable(ol.webgl.CULL_FACE);a.disable(ol.webgl.DEPTH_TEST);a.disable(ol.webgl.SCISSOR_TEST);a.disable(ol.webgl.STENCIL_TEST)};ol.renderer.webgl.Map.prototype.isTileTextureLoaded=function(a){return this.textureCache_.containsKey(a.getKey())};
ol.renderer.webgl.Map.prototype.renderFrame=function(a){var b=this.getContext(),c=this.getGL();if(c.isContextLost())return!1;if(!a)return this.renderedVisible_&&(this.canvas_.style.display="none",this.renderedVisible_=!1),!1;this.focus_=a.focus;this.textureCache_.set((-a.index).toString(),null);++this.textureCacheFrameMarkerCount_;this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE,a);var d=[],e=a.layerStatesArray;ol.array.stableSort(e,ol.renderer.Map.sortByZIndex);var f=a.viewState.resolution,
g;var h=0;for(g=e.length;h<g;++h){var k=e[h];if(ol.layer.Layer.visibleAtResolution(k,f)&&k.sourceState==ol.source.State.READY){var l=this.getLayerRenderer(k.layer);l.prepareFrame(a,k,b)&&d.push(k)}}e=a.size[0]*a.pixelRatio;f=a.size[1]*a.pixelRatio;if(this.canvas_.width!=e||this.canvas_.height!=f)this.canvas_.width=e,this.canvas_.height=f;c.bindFramebuffer(ol.webgl.FRAMEBUFFER,null);c.clearColor(0,0,0,0);c.clear(ol.webgl.COLOR_BUFFER_BIT);c.enable(ol.webgl.BLEND);c.viewport(0,0,this.canvas_.width,
this.canvas_.height);h=0;for(g=d.length;h<g;++h)k=d[h],l=this.getLayerRenderer(k.layer),l.composeFrame(a,k,b);this.renderedVisible_||(this.canvas_.style.display="",this.renderedVisible_=!0);this.calculateMatrices2D(a);this.textureCache_.getCount()-this.textureCacheFrameMarkerCount_>ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK&&a.postRenderFunctions.push(this.expireCache_.bind(this));this.tileTextureQueue_.isEmpty()||(a.postRenderFunctions.push(this.loadNextTileTexture_),a.animate=!0);this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE,
a);this.scheduleRemoveUnusedLayerRenderers(a);this.scheduleExpireIconCache(a)};ol.renderer.webgl.Map.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e,f,g){if(this.getGL().isContextLost())return!1;var h=b.viewState,k=b.layerStatesArray,l;for(l=k.length-1;0<=l;--l){var m=k[l];var n=m.layer;if(ol.layer.Layer.visibleAtResolution(m,h.resolution)&&f.call(g,n)&&(m=this.getLayerRenderer(n).forEachFeatureAtCoordinate(a,b,c,d,e)))return m}};
ol.renderer.webgl.Map.prototype.hasFeatureAtCoordinate=function(a,b,c,d,e){c=!1;if(this.getGL().isContextLost())return!1;var f=b.viewState,g=b.layerStatesArray,h;for(h=g.length-1;0<=h;--h){var k=g[h],l=k.layer;if(ol.layer.Layer.visibleAtResolution(k,f.resolution)&&d.call(e,l)&&(c=this.getLayerRenderer(l).hasFeatureAtCoordinate(a,b)))return!0}return c};
ol.renderer.webgl.Map.prototype.forEachLayerAtPixel=function(a,b,c,d,e,f){if(this.getGL().isContextLost())return!1;f=b.viewState;var g=b.layerStatesArray,h;for(h=g.length-1;0<=h;--h){var k=g[h];var l=k.layer;if(ol.layer.Layer.visibleAtResolution(k,f.resolution)&&e.call(d,l)&&(k=this.getLayerRenderer(l).forEachLayerAtPixel(a,b,c,d)))return k}};ol.renderer.webgl.tilelayershader={};ol.renderer.webgl.tilelayershader.fragment=new ol.webgl.Fragment(ol.DEBUG_WEBGL?"precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n":"precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}");
ol.renderer.webgl.tilelayershader.vertex=new ol.webgl.Vertex(ol.DEBUG_WEBGL?"varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n":"varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}");ol.renderer.webgl.tilelayershader.Locations=function(a,b){this.u_tileOffset=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_tileOffset":"d");this.u_texture=a.getUniformLocation(b,ol.DEBUG_WEBGL?"u_texture":"e");this.a_position=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_position":"b");this.a_texCoord=a.getAttribLocation(b,ol.DEBUG_WEBGL?"a_texCoord":"c")};ol.renderer.webgl.TileLayer=function(a,b){ol.renderer.webgl.Layer.call(this,a,b);this.fragmentShader_=ol.renderer.webgl.tilelayershader.fragment;this.vertexShader_=ol.renderer.webgl.tilelayershader.vertex;this.locations_=null;this.renderArrayBuffer_=new ol.webgl.Buffer([0,0,0,1,1,0,1,1,0,1,0,0,1,1,1,0]);this.renderedFramebufferExtent_=this.renderedTileRange_=null;this.renderedRevision_=-1;this.tmpSize_=[0,0]};ol.inherits(ol.renderer.webgl.TileLayer,ol.renderer.webgl.Layer);
ol.renderer.webgl.TileLayer.handles=function(a,b){return a===ol.renderer.Type.WEBGL&&b.getType()===ol.LayerType.TILE};ol.renderer.webgl.TileLayer.create=function(a,b){return new ol.renderer.webgl.TileLayer(a,b)};ol.renderer.webgl.TileLayer.prototype.disposeInternal=function(){this.mapRenderer.getContext().deleteBuffer(this.renderArrayBuffer_);ol.renderer.webgl.Layer.prototype.disposeInternal.call(this)};
ol.renderer.webgl.TileLayer.prototype.createLoadedTileFinder=function(a,b,c){var d=this.mapRenderer;return function(e,f){return a.forEachLoadedTile(b,e,f,function(a){var b=d.isTileTextureLoaded(a);b&&(c[e]||(c[e]={}),c[e][a.tileCoord.toString()]=a);return b})}};ol.renderer.webgl.TileLayer.prototype.handleWebGLContextLost=function(){ol.renderer.webgl.Layer.prototype.handleWebGLContextLost.call(this);this.locations_=null};
ol.renderer.webgl.TileLayer.prototype.prepareFrame=function(a,b,c){var d=this.mapRenderer,e=c.getGL(),f=a.viewState,g=f.projection,h=this.getLayer(),k=h.getSource(),l=k.getTileGridForProjection(g),m=l.getZForResolution(f.resolution),n=l.getResolution(m),p=k.getTilePixelSize(m,a.pixelRatio,g),q=p[0]/ol.size.toSize(l.getTileSize(m),this.tmpSize_)[0],r=n/q,u=k.getTilePixelRatio(q)*k.getGutter(g),t=f.center,v=a.extent,w=l.getTileRangeForExtentAndZ(v,m);if(this.renderedTileRange_&&this.renderedTileRange_.equals(w)&&
this.renderedRevision_==k.getRevision())r=this.renderedFramebufferExtent_;else{var y=w.getSize(),z=ol.math.roundUpToPowerOfTwo(Math.max(y[0]*p[0],y[1]*p[1]));y=r*z;var x=l.getOrigin(m),C=x[0]+w.minX*p[0]*r;r=x[1]+w.minY*p[1]*r;r=[C,r,C+y,r+y];this.bindFramebuffer(a,z);e.viewport(0,0,z,z);e.clearColor(0,0,0,0);e.clear(ol.webgl.COLOR_BUFFER_BIT);e.disable(ol.webgl.BLEND);z=c.getProgram(this.fragmentShader_,this.vertexShader_);c.useProgram(z);this.locations_||(this.locations_=new ol.renderer.webgl.tilelayershader.Locations(e,
z));c.bindBuffer(ol.webgl.ARRAY_BUFFER,this.renderArrayBuffer_);e.enableVertexAttribArray(this.locations_.a_position);e.vertexAttribPointer(this.locations_.a_position,2,ol.webgl.FLOAT,!1,16,0);e.enableVertexAttribArray(this.locations_.a_texCoord);e.vertexAttribPointer(this.locations_.a_texCoord,2,ol.webgl.FLOAT,!1,16,8);e.uniform1i(this.locations_.u_texture,0);c={};c[m]={};var A=this.createLoadedTileFinder(k,g,c),B=h.getUseInterimTilesOnError();z=!0;C=ol.extent.createEmpty();var D=new ol.TileRange(0,
0,0,0),E,G;for(E=w.minX;E<=w.maxX;++E)for(G=w.minY;G<=w.maxY;++G){x=k.getTile(m,E,G,q,g);if(void 0!==b.extent){var F=l.getTileCoordExtent(x.tileCoord,C);if(!ol.extent.intersects(F,b.extent))continue}F=x.getState();(F=F==ol.TileState.LOADED||F==ol.TileState.EMPTY||F==ol.TileState.ERROR&&!B)||(x=x.getInterimTile());F=x.getState();if(F==ol.TileState.LOADED){if(d.isTileTextureLoaded(x)){c[m][x.tileCoord.toString()]=x;continue}}else if(F==ol.TileState.EMPTY||F==ol.TileState.ERROR&&!B)continue;z=!1;F=l.forEachTileCoordParentTileRange(x.tileCoord,
A,null,D,C);F||(x=l.getTileCoordChildTileRange(x.tileCoord,D,C))&&A(m+1,x)}b=Object.keys(c).map(Number);b.sort(ol.array.numberSafeCompareFunction);A=new Float32Array(4);var M;B=0;for(D=b.length;B<D;++B)for(M in E=c[b[B]],E)x=E[M],F=l.getTileCoordExtent(x.tileCoord,C),A[0]=2*(F[2]-F[0])/y,A[1]=2*(F[3]-F[1])/y,A[2]=2*(F[0]-r[0])/y-1,A[3]=2*(F[1]-r[1])/y-1,e.uniform4fv(this.locations_.u_tileOffset,A),d.bindTileTexture(x,p,u*q,ol.webgl.LINEAR,ol.webgl.LINEAR),e.drawArrays(ol.webgl.TRIANGLE_STRIP,0,4);
z?(this.renderedTileRange_=w,this.renderedFramebufferExtent_=r,this.renderedRevision_=k.getRevision()):(this.renderedFramebufferExtent_=this.renderedTileRange_=null,this.renderedRevision_=-1,a.animate=!0)}this.updateUsedTiles(a.usedTiles,k,m,w);var J=d.getTileTextureQueue();this.manageTilePyramid(a,k,l,q,g,v,m,h.getPreload(),function(a){a.getState()!=ol.TileState.LOADED||d.isTileTextureLoaded(a)||J.isKeyQueued(a.getKey())||J.enqueue([a,l.getTileCoordCenter(a.tileCoord),l.getResolution(a.tileCoord[0]),
p,u*q])},this);this.scheduleExpireCache(a,k);this.updateLogos(a,k);e=this.texCoordMatrix;ol.transform.reset(e);ol.transform.translate(e,(Math.round(t[0]/n)*n-r[0])/(r[2]-r[0]),(Math.round(t[1]/n)*n-r[1])/(r[3]-r[1]));0!==f.rotation&&ol.transform.rotate(e,f.rotation);ol.transform.scale(e,a.size[0]*f.resolution/(r[2]-r[0]),a.size[1]*f.resolution/(r[3]-r[1]));ol.transform.translate(e,-.5,-.5);return!0};
ol.renderer.webgl.TileLayer.prototype.forEachLayerAtPixel=function(a,b,c,d){if(this.framebuffer){a=ol.transform.apply(this.texCoordMatrix,[a[0]/b.size[0],(b.size[1]-a[1])/b.size[1]].slice());a=[a[0]*this.framebufferDimension,a[1]*this.framebufferDimension];b=this.mapRenderer.getContext().getGL();b.bindFramebuffer(b.FRAMEBUFFER,this.framebuffer);var e=new Uint8Array(4);b.readPixels(a[0],a[1],1,1,b.RGBA,b.UNSIGNED_BYTE,e);if(0<e[3])return c.call(d,this.getLayer(),e)}};ol.renderer.webgl.VectorLayer=function(a,b){ol.renderer.webgl.Layer.call(this,a,b);this.dirty_=!1;this.renderedRevision_=-1;this.renderedResolution_=NaN;this.renderedExtent_=ol.extent.createEmpty();this.layerState_=this.replayGroup_=this.renderedRenderOrder_=null};ol.inherits(ol.renderer.webgl.VectorLayer,ol.renderer.webgl.Layer);ol.renderer.webgl.VectorLayer.handles=function(a,b){return a===ol.renderer.Type.WEBGL&&b.getType()===ol.LayerType.VECTOR};
ol.renderer.webgl.VectorLayer.create=function(a,b){return new ol.renderer.webgl.VectorLayer(a,b)};ol.renderer.webgl.VectorLayer.prototype.composeFrame=function(a,b,c){this.layerState_=b;var d=a.viewState,e=this.replayGroup_,f=a.size,g=a.pixelRatio,h=this.mapRenderer.getGL();e&&!e.isEmpty()&&(h.enable(h.SCISSOR_TEST),h.scissor(0,0,f[0]*g,f[1]*g),e.replay(c,d.center,d.resolution,d.rotation,f,g,b.opacity,b.managed?a.skippedFeatureUids:{}),h.disable(h.SCISSOR_TEST))};
ol.renderer.webgl.VectorLayer.prototype.disposeInternal=function(){var a=this.replayGroup_;if(a){var b=this.mapRenderer.getContext();a.getDeleteResourcesFunction(b)();this.replayGroup_=null}ol.renderer.webgl.Layer.prototype.disposeInternal.call(this)};
ol.renderer.webgl.VectorLayer.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e){if(this.replayGroup_&&this.layerState_){c=this.mapRenderer.getContext();var f=b.viewState,g=this.getLayer(),h={};return this.replayGroup_.forEachFeatureAtCoordinate(a,c,f.center,f.resolution,f.rotation,b.size,b.pixelRatio,this.layerState_.opacity,{},function(a){var b=ol.getUid(a).toString();if(!(b in h))return h[b]=!0,d.call(e,a,g)})}};
ol.renderer.webgl.VectorLayer.prototype.hasFeatureAtCoordinate=function(a,b){if(this.replayGroup_&&this.layerState_){var c=this.mapRenderer.getContext(),d=b.viewState;return this.replayGroup_.hasFeatureAtCoordinate(a,c,d.center,d.resolution,d.rotation,b.size,b.pixelRatio,this.layerState_.opacity,b.skippedFeatureUids)}return!1};
ol.renderer.webgl.VectorLayer.prototype.forEachLayerAtPixel=function(a,b,c,d){a=ol.transform.apply(b.pixelToCoordinateTransform,a.slice());if(this.hasFeatureAtCoordinate(a,b))return c.call(d,this.getLayer(),null)};ol.renderer.webgl.VectorLayer.prototype.handleStyleImageChange_=function(a){this.renderIfReadyAndVisible()};
ol.renderer.webgl.VectorLayer.prototype.prepareFrame=function(a,b,c){var d=this.getLayer();b=d.getSource();this.updateLogos(a,b);var e=a.viewHints[ol.ViewHint.ANIMATING],f=a.viewHints[ol.ViewHint.INTERACTING],g=d.getUpdateWhileAnimating(),h=d.getUpdateWhileInteracting();if(!this.dirty_&&!g&&e||!h&&f)return!0;h=a.extent;f=a.viewState;e=f.projection;var k=f.resolution,l=a.pixelRatio;f=d.getRevision();var m=d.getRenderBuffer();g=d.getRenderOrder();void 0===g&&(g=ol.renderer.vector.defaultOrder);h=ol.extent.buffer(h,
m*k);if(!this.dirty_&&this.renderedResolution_==k&&this.renderedRevision_==f&&this.renderedRenderOrder_==g&&ol.extent.containsExtent(this.renderedExtent_,h))return!0;this.replayGroup_&&a.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(c));this.dirty_=!1;var n=new ol.render.webgl.ReplayGroup(ol.renderer.vector.getTolerance(k,l),h,d.getRenderBuffer());b.loadFeatures(h,k,e);a=function(a){var b=a.getStyleFunction();if(b)var c=b.call(a,k);else(b=d.getStyleFunction())&&(c=b(a,k));
c&&(a=this.renderFeature(a,k,l,c,n),this.dirty_=this.dirty_||a)};if(g){var p=[];b.forEachFeatureInExtent(h,function(a){p.push(a)},this);p.sort(g);p.forEach(a,this)}else b.forEachFeatureInExtent(h,a,this);n.finish(c);this.renderedResolution_=k;this.renderedRevision_=f;this.renderedRenderOrder_=g;this.renderedExtent_=h;this.replayGroup_=n;return!0};
ol.renderer.webgl.VectorLayer.prototype.renderFeature=function(a,b,c,d,e){if(!d)return!1;var f=!1;if(Array.isArray(d))for(var g=d.length-1;0<=g;--g)f=ol.renderer.vector.renderFeature(e,a,d[g],ol.renderer.vector.getSquaredTolerance(b,c),this.handleStyleImageChange_,this)||f;else f=ol.renderer.vector.renderFeature(e,a,d,ol.renderer.vector.getSquaredTolerance(b,c),this.handleStyleImageChange_,this)||f;return f};ol.ENABLE_CANVAS&&(ol.plugins.register(ol.PluginType.MAP_RENDERER,ol.renderer.canvas.Map),ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER,[ol.renderer.canvas.ImageLayer,ol.renderer.canvas.TileLayer,ol.renderer.canvas.VectorLayer,ol.renderer.canvas.VectorTileLayer]));ol.ENABLE_WEBGL&&(ol.plugins.register(ol.PluginType.MAP_RENDERER,ol.renderer.webgl.Map),ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER,[ol.renderer.webgl.ImageLayer,ol.renderer.webgl.TileLayer,ol.renderer.webgl.VectorLayer]));
ol.Map=function(a){a=ol.obj.assign({},a);a.controls||(a.controls=ol.control.defaults());a.interactions||(a.interactions=ol.interaction.defaults());ol.PluggableMap.call(this,a)};ol.inherits(ol.Map,ol.PluggableMap);ol.OverlayPositioning={BOTTOM_LEFT:"bottom-left",BOTTOM_CENTER:"bottom-center",BOTTOM_RIGHT:"bottom-right",CENTER_LEFT:"center-left",CENTER_CENTER:"center-center",CENTER_RIGHT:"center-right",TOP_LEFT:"top-left",TOP_CENTER:"top-center",TOP_RIGHT:"top-right"};ol.Overlay=function(a){ol.Object.call(this);this.options=a;this.id=a.id;this.insertFirst=void 0!==a.insertFirst?a.insertFirst:!0;this.stopEvent=void 0!==a.stopEvent?a.stopEvent:!0;this.element=document.createElement("DIV");this.element.className=void 0!==a.className?a.className:"ol-overlay-container "+ol.css.CLASS_SELECTABLE;this.element.style.position="absolute";this.autoPan=void 0!==a.autoPan?a.autoPan:!1;this.autoPanAnimation=a.autoPanAnimation||{};this.autoPanMargin=void 0!==a.autoPanMargin?a.autoPanMargin:
20;this.rendered={bottom_:"",left_:"",right_:"",top_:"",visible:!0};this.mapPostrenderListenerKey=null;ol.events.listen(this,ol.Object.getChangeEventType(ol.Overlay.Property.ELEMENT),this.handleElementChanged,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.Overlay.Property.MAP),this.handleMapChanged,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),this.handleOffsetChanged,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.Overlay.Property.POSITION),
this.handlePositionChanged,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.Overlay.Property.POSITIONING),this.handlePositioningChanged,this);void 0!==a.element&&this.setElement(a.element);this.setOffset(void 0!==a.offset?a.offset:[0,0]);this.setPositioning(void 0!==a.positioning?a.positioning:ol.OverlayPositioning.TOP_LEFT);void 0!==a.position&&this.setPosition(a.position)};ol.inherits(ol.Overlay,ol.Object);ol.Overlay.prototype.getElement=function(){return this.get(ol.Overlay.Property.ELEMENT)};
ol.Overlay.prototype.getId=function(){return this.id};ol.Overlay.prototype.getMap=function(){return this.get(ol.Overlay.Property.MAP)};ol.Overlay.prototype.getOffset=function(){return this.get(ol.Overlay.Property.OFFSET)};ol.Overlay.prototype.getPosition=function(){return this.get(ol.Overlay.Property.POSITION)};ol.Overlay.prototype.getPositioning=function(){return this.get(ol.Overlay.Property.POSITIONING)};
ol.Overlay.prototype.handleElementChanged=function(){ol.dom.removeChildren(this.element);var a=this.getElement();a&&this.element.appendChild(a)};
ol.Overlay.prototype.handleMapChanged=function(){this.mapPostrenderListenerKey&&(ol.dom.removeNode(this.element),ol.events.unlistenByKey(this.mapPostrenderListenerKey),this.mapPostrenderListenerKey=null);var a=this.getMap();a&&(this.mapPostrenderListenerKey=ol.events.listen(a,ol.MapEventType.POSTRENDER,this.render,this),this.updatePixelPosition(),a=this.stopEvent?a.getOverlayContainerStopEvent():a.getOverlayContainer(),this.insertFirst?a.insertBefore(this.element,a.childNodes[0]||null):a.appendChild(this.element))};
ol.Overlay.prototype.render=function(){this.updatePixelPosition()};ol.Overlay.prototype.handleOffsetChanged=function(){this.updatePixelPosition()};ol.Overlay.prototype.handlePositionChanged=function(){this.updatePixelPosition();this.get(ol.Overlay.Property.POSITION)&&this.autoPan&&this.panIntoView()};ol.Overlay.prototype.handlePositioningChanged=function(){this.updatePixelPosition()};ol.Overlay.prototype.setElement=function(a){this.set(ol.Overlay.Property.ELEMENT,a)};
ol.Overlay.prototype.setMap=function(a){this.set(ol.Overlay.Property.MAP,a)};ol.Overlay.prototype.setOffset=function(a){this.set(ol.Overlay.Property.OFFSET,a)};ol.Overlay.prototype.setPosition=function(a){this.set(ol.Overlay.Property.POSITION,a)};
ol.Overlay.prototype.panIntoView=function(){var a=this.getMap();if(a&&a.getTargetElement()){var b=this.getRect(a.getTargetElement(),a.getSize()),c=this.getElement(),d=this.getRect(c,[ol.dom.outerWidth(c),ol.dom.outerHeight(c)]);c=this.autoPanMargin;if(!ol.extent.containsExtent(b,d)){var e=d[0]-b[0],f=b[2]-d[2],g=d[1]-b[1];d=b[3]-d[3];b=[0,0];0>e?b[0]=e-c:0>f&&(b[0]=Math.abs(f)+c);0>g?b[1]=g-c:0>d&&(b[1]=Math.abs(d)+c);if(0!==b[0]||0!==b[1])c=a.getView().getCenter(),c=a.getPixelFromCoordinate(c),c=
[c[0]+b[0],c[1]+b[1]],a.getView().animate({center:a.getCoordinateFromPixel(c),duration:this.autoPanAnimation.duration,easing:this.autoPanAnimation.easing})}}};ol.Overlay.prototype.getRect=function(a,b){var c=a.getBoundingClientRect();a=c.left+window.pageXOffset;c=c.top+window.pageYOffset;return[a,c,a+b[0],c+b[1]]};ol.Overlay.prototype.setPositioning=function(a){this.set(ol.Overlay.Property.POSITIONING,a)};
ol.Overlay.prototype.setVisible=function(a){this.rendered.visible!==a&&(this.element.style.display=a?"":"none",this.rendered.visible=a)};ol.Overlay.prototype.updatePixelPosition=function(){var a=this.getMap(),b=this.getPosition();a&&a.isRendered()&&b?(b=a.getPixelFromCoordinate(b),a=a.getSize(),this.updateRenderedPosition(b,a)):this.setVisible(!1)};
ol.Overlay.prototype.updateRenderedPosition=function(a,b){var c=this.element.style,d=this.getOffset(),e=this.getPositioning();this.setVisible(!0);var f=d[0];d=d[1];if(e==ol.OverlayPositioning.BOTTOM_RIGHT||e==ol.OverlayPositioning.CENTER_RIGHT||e==ol.OverlayPositioning.TOP_RIGHT)""!==this.rendered.left_&&(this.rendered.left_=c.left=""),f=Math.round(b[0]-a[0]-f)+"px",this.rendered.right_!=f&&(this.rendered.right_=c.right=f);else{""!==this.rendered.right_&&(this.rendered.right_=c.right="");if(e==ol.OverlayPositioning.BOTTOM_CENTER||
e==ol.OverlayPositioning.CENTER_CENTER||e==ol.OverlayPositioning.TOP_CENTER)f-=this.element.offsetWidth/2;f=Math.round(a[0]+f)+"px";this.rendered.left_!=f&&(this.rendered.left_=c.left=f)}if(e==ol.OverlayPositioning.BOTTOM_LEFT||e==ol.OverlayPositioning.BOTTOM_CENTER||e==ol.OverlayPositioning.BOTTOM_RIGHT)""!==this.rendered.top_&&(this.rendered.top_=c.top=""),a=Math.round(b[1]-a[1]-d)+"px",this.rendered.bottom_!=a&&(this.rendered.bottom_=c.bottom=a);else{""!==this.rendered.bottom_&&(this.rendered.bottom_=
c.bottom="");if(e==ol.OverlayPositioning.CENTER_LEFT||e==ol.OverlayPositioning.CENTER_CENTER||e==ol.OverlayPositioning.CENTER_RIGHT)d-=this.element.offsetHeight/2;a=Math.round(a[1]+d)+"px";this.rendered.top_!=a&&(this.rendered.top_=c.top=a)}};ol.Overlay.prototype.getOptions=function(){return this.options};ol.Overlay.Property={ELEMENT:"element",MAP:"map",OFFSET:"offset",POSITION:"position",POSITIONING:"positioning"};ol.VectorTile=function(a,b,c,d,e,f){ol.Tile.call(this,a,b,f);this.consumers=0;this.extent_=null;this.format_=d;this.features_=null;this.replayGroups_={};this.tileLoadFunction_=e;this.url_=c};ol.inherits(ol.VectorTile,ol.Tile);ol.VectorTile.prototype.disposeInternal=function(){this.features_=null;this.replayGroups_={};this.state=ol.TileState.ABORT;this.changed();ol.Tile.prototype.disposeInternal.call(this)};ol.VectorTile.prototype.getExtent=function(){return this.extent_||ol.VectorTile.DEFAULT_EXTENT};
ol.VectorTile.prototype.getFormat=function(){return this.format_};ol.VectorTile.prototype.getFeatures=function(){return this.features_};ol.VectorTile.prototype.getKey=function(){return this.url_};ol.VectorTile.prototype.getProjection=function(){return this.projection_};ol.VectorTile.prototype.getReplayGroup=function(a,b){return this.replayGroups_[ol.getUid(a)+","+b]};
ol.VectorTile.prototype.load=function(){this.state==ol.TileState.IDLE&&(this.setState(ol.TileState.LOADING),this.tileLoadFunction_(this,this.url_),this.loader_(null,NaN,null))};ol.VectorTile.prototype.onLoad=function(a,b,c){this.setProjection(b);this.setFeatures(a);this.setExtent(c)};ol.VectorTile.prototype.onError=function(){this.setState(ol.TileState.ERROR)};ol.VectorTile.prototype.setExtent=function(a){this.extent_=a};ol.VectorTile.prototype.setFeatures=function(a){this.features_=a;this.setState(ol.TileState.LOADED)};
ol.VectorTile.prototype.setProjection=function(a){this.projection_=a};ol.VectorTile.prototype.setReplayGroup=function(a,b,c){this.replayGroups_[ol.getUid(a)+","+b]=c};ol.VectorTile.prototype.setLoader=function(a){this.loader_=a};ol.VectorTile.DEFAULT_EXTENT=[0,0,4096,4096];ol.control.FullScreen=function(a){a=a?a:{};this.cssClassName_=void 0!==a.className?a.className:"ol-full-screen";var b=void 0!==a.label?a.label:"\u2922";this.labelNode_="string"===typeof b?document.createTextNode(b):b;b=void 0!==a.labelActive?a.labelActive:"\u00d7";this.labelActiveNode_="string"===typeof b?document.createTextNode(b):b;var c=a.tipLabel?a.tipLabel:"Toggle full-screen";b=document.createElement("button");b.className=this.cssClassName_+"-"+ol.control.FullScreen.isFullScreen();b.setAttribute("type",
"button");b.title=c;b.appendChild(this.labelNode_);ol.events.listen(b,ol.events.EventType.CLICK,this.handleClick_,this);c=this.cssClassName_+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL+" "+(ol.control.FullScreen.isFullScreenSupported()?"":ol.css.CLASS_UNSUPPORTED);var d=document.createElement("div");d.className=c;d.appendChild(b);ol.control.Control.call(this,{element:d,target:a.target});this.keys_=void 0!==a.keys?a.keys:!1;this.source_=a.source};ol.inherits(ol.control.FullScreen,ol.control.Control);
ol.control.FullScreen.prototype.handleClick_=function(a){a.preventDefault();this.handleFullScreen_()};ol.control.FullScreen.prototype.handleFullScreen_=function(){if(ol.control.FullScreen.isFullScreenSupported()){var a=this.getMap();a&&(ol.control.FullScreen.isFullScreen()?ol.control.FullScreen.exitFullScreen():(a=this.source_?"string"===typeof this.source_?document.getElementById(this.source_):this.source_:a.getTargetElement(),this.keys_?ol.control.FullScreen.requestFullScreenWithKeys(a):ol.control.FullScreen.requestFullScreen(a)))}};
ol.control.FullScreen.prototype.handleFullScreenChange_=function(){var a=this.element.firstElementChild,b=this.getMap();ol.control.FullScreen.isFullScreen()?(a.className=this.cssClassName_+"-true",ol.dom.replaceNode(this.labelActiveNode_,this.labelNode_)):(a.className=this.cssClassName_+"-false",ol.dom.replaceNode(this.labelNode_,this.labelActiveNode_));b&&b.updateSize()};
ol.control.FullScreen.prototype.setMap=function(a){ol.control.Control.prototype.setMap.call(this,a);a&&this.listenerKeys.push(ol.events.listen(document,ol.control.FullScreen.getChangeType_(),this.handleFullScreenChange_,this))};ol.control.FullScreen.isFullScreenSupported=function(){var a=document.body;return!!(a.webkitRequestFullscreen||a.mozRequestFullScreen&&document.mozFullScreenEnabled||a.msRequestFullscreen&&document.msFullscreenEnabled||a.requestFullscreen&&document.fullscreenEnabled)};
ol.control.FullScreen.isFullScreen=function(){return!!(document.webkitIsFullScreen||document.mozFullScreen||document.msFullscreenElement||document.fullscreenElement)};ol.control.FullScreen.requestFullScreen=function(a){a.requestFullscreen?a.requestFullscreen():a.msRequestFullscreen?a.msRequestFullscreen():a.mozRequestFullScreen?a.mozRequestFullScreen():a.webkitRequestFullscreen&&a.webkitRequestFullscreen()};
ol.control.FullScreen.requestFullScreenWithKeys=function(a){a.mozRequestFullScreenWithKeys?a.mozRequestFullScreenWithKeys():a.webkitRequestFullscreen?a.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT):ol.control.FullScreen.requestFullScreen(a)};ol.control.FullScreen.exitFullScreen=function(){document.exitFullscreen?document.exitFullscreen():document.msExitFullscreen?document.msExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()};
ol.control.FullScreen.getChangeType_=function(){var a;return function(){if(!a){var b=document.body;b.webkitRequestFullscreen?a="webkitfullscreenchange":b.mozRequestFullScreen?a="mozfullscreenchange":b.msRequestFullscreen?a="MSFullscreenChange":b.requestFullscreen&&(a="fullscreenchange")}return a}}();ol.control.MousePosition=function(a){a=a?a:{};var b=document.createElement("DIV");b.className=void 0!==a.className?a.className:"ol-mouse-position";ol.control.Control.call(this,{element:b,render:a.render?a.render:ol.control.MousePosition.render,target:a.target});ol.events.listen(this,ol.Object.getChangeEventType(ol.control.MousePosition.Property_.PROJECTION),this.handleProjectionChanged_,this);a.coordinateFormat&&this.setCoordinateFormat(a.coordinateFormat);a.projection&&this.setProjection(a.projection);
this.undefinedHTML_=void 0!==a.undefinedHTML?a.undefinedHTML:"";this.renderedHTML_=b.innerHTML;this.lastMouseMovePixel_=this.transform_=this.mapProjection_=null};ol.inherits(ol.control.MousePosition,ol.control.Control);ol.control.MousePosition.render=function(a){a=a.frameState;a?this.mapProjection_!=a.viewState.projection&&(this.mapProjection_=a.viewState.projection,this.transform_=null):this.mapProjection_=null;this.updateHTML_(this.lastMouseMovePixel_)};
ol.control.MousePosition.prototype.handleProjectionChanged_=function(){this.transform_=null};ol.control.MousePosition.prototype.getCoordinateFormat=function(){return this.get(ol.control.MousePosition.Property_.COORDINATE_FORMAT)};ol.control.MousePosition.prototype.getProjection=function(){return this.get(ol.control.MousePosition.Property_.PROJECTION)};ol.control.MousePosition.prototype.handleMouseMove=function(a){this.lastMouseMovePixel_=this.getMap().getEventPixel(a);this.updateHTML_(this.lastMouseMovePixel_)};
ol.control.MousePosition.prototype.handleMouseOut=function(a){this.updateHTML_(null);this.lastMouseMovePixel_=null};ol.control.MousePosition.prototype.setMap=function(a){ol.control.Control.prototype.setMap.call(this,a);a&&(a=a.getViewport(),this.listenerKeys.push(ol.events.listen(a,ol.events.EventType.MOUSEMOVE,this.handleMouseMove,this),ol.events.listen(a,ol.events.EventType.MOUSEOUT,this.handleMouseOut,this)))};
ol.control.MousePosition.prototype.setCoordinateFormat=function(a){this.set(ol.control.MousePosition.Property_.COORDINATE_FORMAT,a)};ol.control.MousePosition.prototype.setProjection=function(a){this.set(ol.control.MousePosition.Property_.PROJECTION,ol.proj.get(a))};
ol.control.MousePosition.prototype.updateHTML_=function(a){var b=this.undefinedHTML_;if(a&&this.mapProjection_){if(!this.transform_){var c=this.getProjection();this.transform_=c?ol.proj.getTransformFromProjections(this.mapProjection_,c):ol.proj.identityTransform}if(a=this.getMap().getCoordinateFromPixel(a))this.transform_(a,a),b=(b=this.getCoordinateFormat())?b(a):a.toString()}this.renderedHTML_&&b==this.renderedHTML_||(this.renderedHTML_=this.element.innerHTML=b)};
ol.control.MousePosition.Property_={PROJECTION:"projection",COORDINATE_FORMAT:"coordinateFormat"};ol.control.OverviewMap=function(a){a=a?a:{};this.collapsed_=void 0!==a.collapsed?a.collapsed:!0;this.collapsible_=void 0!==a.collapsible?a.collapsible:!0;this.collapsible_||(this.collapsed_=!1);var b=void 0!==a.className?a.className:"ol-overviewmap",c=void 0!==a.tipLabel?a.tipLabel:"Overview map",d=void 0!==a.collapseLabel?a.collapseLabel:"\u00ab";"string"===typeof d?(this.collapseLabel_=document.createElement("span"),this.collapseLabel_.textContent=d):this.collapseLabel_=d;d=void 0!==a.label?a.label:
"\u00bb";"string"===typeof d?(this.label_=document.createElement("span"),this.label_.textContent=d):this.label_=d;var e=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_;d=document.createElement("button");d.setAttribute("type","button");d.title=c;d.appendChild(e);ol.events.listen(d,ol.events.EventType.CLICK,this.handleClick_,this);this.ovmapDiv_=document.createElement("DIV");this.ovmapDiv_.className="ol-overviewmap-map";var f=this.ovmap_=new ol.PluggableMap({controls:new ol.Collection,
interactions:new ol.Collection,view:a.view});a.layers&&a.layers.forEach(function(a){f.addLayer(a)},this);c=document.createElement("DIV");c.className="ol-overviewmap-box";c.style.boxSizing="border-box";this.boxOverlay_=new ol.Overlay({position:[0,0],positioning:ol.OverlayPositioning.BOTTOM_LEFT,element:c});this.ovmap_.addOverlay(this.boxOverlay_);b=b+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL+(this.collapsed_&&this.collapsible_?" ol-collapsed":"")+(this.collapsible_?"":" ol-uncollapsible");
c=document.createElement("div");c.className=b;c.appendChild(this.ovmapDiv_);c.appendChild(d);ol.control.Control.call(this,{element:c,render:a.render?a.render:ol.control.OverviewMap.render,target:a.target});var g=this,h=this.boxOverlay_,k=this.boxOverlay_.getElement(),l=function(a){a=f.getEventCoordinate({clientX:a.clientX-k.offsetWidth/2,clientY:a.clientY+k.offsetHeight/2});h.setPosition(a)},m=function(a){a=f.getEventCoordinate(a);g.getMap().getView().setCenter(a);window.removeEventListener("mousemove",
l);window.removeEventListener("mouseup",m)};k.addEventListener("mousedown",function(){window.addEventListener("mousemove",l);window.addEventListener("mouseup",m)})};ol.inherits(ol.control.OverviewMap,ol.control.Control);
ol.control.OverviewMap.prototype.setMap=function(a){var b=this.getMap();a!==b&&(b&&((b=b.getView())&&this.unbindView_(b),this.ovmap_.setTarget(null)),ol.control.Control.prototype.setMap.call(this,a),a&&(this.ovmap_.setTarget(this.ovmapDiv_),this.listenerKeys.push(ol.events.listen(a,ol.ObjectEventType.PROPERTYCHANGE,this.handleMapPropertyChange_,this)),0===this.ovmap_.getLayers().getLength()&&this.ovmap_.setLayerGroup(a.getLayerGroup()),a=a.getView()))&&(this.bindView_(a),a.isDef()&&(this.ovmap_.updateSize(),
this.resetExtent_()))};ol.control.OverviewMap.prototype.handleMapPropertyChange_=function(a){a.key===ol.MapProperty.VIEW&&((a=a.oldValue)&&this.unbindView_(a),a=this.getMap().getView(),this.bindView_(a))};ol.control.OverviewMap.prototype.bindView_=function(a){ol.events.listen(a,ol.Object.getChangeEventType(ol.ViewProperty.ROTATION),this.handleRotationChanged_,this)};
ol.control.OverviewMap.prototype.unbindView_=function(a){ol.events.unlisten(a,ol.Object.getChangeEventType(ol.ViewProperty.ROTATION),this.handleRotationChanged_,this)};ol.control.OverviewMap.prototype.handleRotationChanged_=function(){this.ovmap_.getView().setRotation(this.getMap().getView().getRotation())};ol.control.OverviewMap.render=function(a){this.validateExtent_();this.updateBox_()};
ol.control.OverviewMap.prototype.validateExtent_=function(){var a=this.getMap(),b=this.ovmap_;if(a.isRendered()&&b.isRendered()){var c=a.getSize();a=a.getView().calculateExtent(c);var d=b.getSize();c=b.getView().calculateExtent(d);var e=b.getPixelFromCoordinate(ol.extent.getTopLeft(a)),f=b.getPixelFromCoordinate(ol.extent.getBottomRight(a));b=Math.abs(e[0]-f[0]);e=Math.abs(e[1]-f[1]);f=d[0];d=d[1];b<f*ol.OVERVIEWMAP_MIN_RATIO||e<d*ol.OVERVIEWMAP_MIN_RATIO||b>f*ol.OVERVIEWMAP_MAX_RATIO||e>d*ol.OVERVIEWMAP_MAX_RATIO?
this.resetExtent_():ol.extent.containsExtent(c,a)||this.recenter_()}};ol.control.OverviewMap.prototype.resetExtent_=function(){if(0!==ol.OVERVIEWMAP_MAX_RATIO&&0!==ol.OVERVIEWMAP_MIN_RATIO){var a=this.getMap(),b=this.ovmap_,c=a.getSize();a=a.getView().calculateExtent(c);b=b.getView();ol.extent.scaleFromCenter(a,1/(Math.pow(2,Math.log(ol.OVERVIEWMAP_MAX_RATIO/ol.OVERVIEWMAP_MIN_RATIO)/Math.LN2/2)*ol.OVERVIEWMAP_MIN_RATIO));b.fit(a)}};
ol.control.OverviewMap.prototype.recenter_=function(){var a=this.getMap(),b=this.ovmap_;a=a.getView();b.getView().setCenter(a.getCenter())};
ol.control.OverviewMap.prototype.updateBox_=function(){var a=this.getMap(),b=this.ovmap_;if(a.isRendered()&&b.isRendered()){var c=a.getSize(),d=a.getView(),e=b.getView(),f=d.getRotation();b=this.boxOverlay_;a=this.boxOverlay_.getElement();var g=d.calculateExtent(c);c=e.getResolution();d=ol.extent.getBottomLeft(g);e=ol.extent.getTopRight(g);f=this.calculateCoordinateRotate_(f,d);b.setPosition(f);a&&(a.style.width=Math.abs((d[0]-e[0])/c)+"px",a.style.height=Math.abs((e[1]-d[1])/c)+"px")}};
ol.control.OverviewMap.prototype.calculateCoordinateRotate_=function(a,b){var c=this.getMap().getView().getCenter();if(c){var d=[b[0]-c[0],b[1]-c[1]];ol.coordinate.rotate(d,a);ol.coordinate.add(d,c)}return d};ol.control.OverviewMap.prototype.handleClick_=function(a){a.preventDefault();this.handleToggle_()};
ol.control.OverviewMap.prototype.handleToggle_=function(){this.element.classList.toggle("ol-collapsed");this.collapsed_?ol.dom.replaceNode(this.collapseLabel_,this.label_):ol.dom.replaceNode(this.label_,this.collapseLabel_);this.collapsed_=!this.collapsed_;var a=this.ovmap_;this.collapsed_||a.isRendered()||(a.updateSize(),this.resetExtent_(),ol.events.listenOnce(a,ol.MapEventType.POSTRENDER,function(a){this.updateBox_()},this))};ol.control.OverviewMap.prototype.getCollapsible=function(){return this.collapsible_};
ol.control.OverviewMap.prototype.setCollapsible=function(a){this.collapsible_!==a&&(this.collapsible_=a,this.element.classList.toggle("ol-uncollapsible"),!a&&this.collapsed_&&this.handleToggle_())};ol.control.OverviewMap.prototype.setCollapsed=function(a){this.collapsible_&&this.collapsed_!==a&&this.handleToggle_()};ol.control.OverviewMap.prototype.getCollapsed=function(){return this.collapsed_};ol.control.OverviewMap.prototype.getOverviewMap=function(){return this.ovmap_};ol.control.ScaleLineUnits={DEGREES:"degrees",IMPERIAL:"imperial",NAUTICAL:"nautical",METRIC:"metric",US:"us"};ol.control.ScaleLine=function(a){a=a?a:{};var b=void 0!==a.className?a.className:"ol-scale-line";this.innerElement_=document.createElement("DIV");this.innerElement_.className=b+"-inner";this.element_=document.createElement("DIV");this.element_.className=b+" "+ol.css.CLASS_UNSELECTABLE;this.element_.appendChild(this.innerElement_);this.viewState_=null;this.minWidth_=void 0!==a.minWidth?a.minWidth:64;this.renderedVisible_=!1;this.renderedWidth_=void 0;this.renderedHTML_="";ol.control.Control.call(this,
{element:this.element_,render:a.render?a.render:ol.control.ScaleLine.render,target:a.target});ol.events.listen(this,ol.Object.getChangeEventType(ol.control.ScaleLine.Property_.UNITS),this.handleUnitsChanged_,this);this.setUnits(a.units||ol.control.ScaleLineUnits.METRIC)};ol.inherits(ol.control.ScaleLine,ol.control.Control);ol.control.ScaleLine.LEADING_DIGITS=[1,2,5];ol.control.ScaleLine.prototype.getUnits=function(){return this.get(ol.control.ScaleLine.Property_.UNITS)};
ol.control.ScaleLine.render=function(a){this.viewState_=(a=a.frameState)?a.viewState:null;this.updateElement_()};ol.control.ScaleLine.prototype.handleUnitsChanged_=function(){this.updateElement_()};ol.control.ScaleLine.prototype.setUnits=function(a){this.set(ol.control.ScaleLine.Property_.UNITS,a)};
ol.control.ScaleLine.prototype.updateElement_=function(){var a=this.viewState_;if(a){var b=a.center,c=a.projection,d=this.getUnits();a=ol.proj.getPointResolution(c,a.resolution,b,d==ol.control.ScaleLineUnits.DEGREES?ol.proj.Units.DEGREES:ol.proj.Units.METERS);d!=ol.control.ScaleLineUnits.METRIC&&(a*=c.getMetersPerUnit());var e=this.minWidth_*a;b="";d==ol.control.ScaleLineUnits.DEGREES?(b=ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES],c.getUnits()==ol.proj.Units.DEGREES?e*=b:a/=b,e<b/60?(b="\u2033",
a*=3600):e<b?(b="\u2032",a*=60):b="\u00b0"):d==ol.control.ScaleLineUnits.IMPERIAL?.9144>e?(b="in",a/=.0254):1609.344>e?(b="ft",a/=.3048):(b="mi",a/=1609.344):d==ol.control.ScaleLineUnits.NAUTICAL?(a/=1852,b="nm"):d==ol.control.ScaleLineUnits.METRIC?.001>e?(b="\u03bcm",a*=1E6):1>e?(b="mm",a*=1E3):1E3>e?b="m":(b="km",a/=1E3):d==ol.control.ScaleLineUnits.US?.9144>e?(b="in",a*=39.37):1609.344>e?(b="ft",a/=.30480061):(b="mi",a/=1609.3472):ol.asserts.assert(!1,33);for(d=3*Math.floor(Math.log(this.minWidth_*
a)/Math.log(10));;){e=ol.control.ScaleLine.LEADING_DIGITS[(d%3+3)%3]*Math.pow(10,Math.floor(d/3));c=Math.round(e/a);if(isNaN(c)){this.element_.style.display="none";this.renderedVisible_=!1;return}if(c>=this.minWidth_)break;++d}a=e+" "+b;this.renderedHTML_!=a&&(this.renderedHTML_=this.innerElement_.innerHTML=a);this.renderedWidth_!=c&&(this.innerElement_.style.width=c+"px",this.renderedWidth_=c);this.renderedVisible_||(this.element_.style.display="",this.renderedVisible_=!0)}else this.renderedVisible_&&
(this.element_.style.display="none",this.renderedVisible_=!1)};ol.control.ScaleLine.Property_={UNITS:"units"};ol.control.ZoomSlider=function(a){a=a?a:{};this.currentResolution_=void 0;this.direction_=ol.control.ZoomSlider.Direction_.VERTICAL;this.widthLimit_=this.heightLimit_=0;this.thumbSize_=null;this.sliderInitialized_=!1;this.duration_=void 0!==a.duration?a.duration:200;var b=void 0!==a.className?a.className:"ol-zoomslider",c=document.createElement("button");c.setAttribute("type","button");c.className=b+"-thumb "+ol.css.CLASS_UNSELECTABLE;var d=document.createElement("div");d.className=b+" "+ol.css.CLASS_UNSELECTABLE+
" "+ol.css.CLASS_CONTROL;d.appendChild(c);this.dragger_=new ol.pointer.PointerEventHandler(d);ol.events.listen(this.dragger_,ol.pointer.EventType.POINTERDOWN,this.handleDraggerStart_,this);ol.events.listen(this.dragger_,ol.pointer.EventType.POINTERMOVE,this.handleDraggerDrag_,this);ol.events.listen(this.dragger_,ol.pointer.EventType.POINTERUP,this.handleDraggerEnd_,this);ol.events.listen(d,ol.events.EventType.CLICK,this.handleContainerClick_,this);ol.events.listen(c,ol.events.EventType.CLICK,ol.events.Event.stopPropagation);
ol.control.Control.call(this,{element:d,render:a.render?a.render:ol.control.ZoomSlider.render})};ol.inherits(ol.control.ZoomSlider,ol.control.Control);ol.control.ZoomSlider.prototype.disposeInternal=function(){this.dragger_.dispose();ol.control.Control.prototype.disposeInternal.call(this)};ol.control.ZoomSlider.Direction_={VERTICAL:0,HORIZONTAL:1};ol.control.ZoomSlider.prototype.setMap=function(a){ol.control.Control.prototype.setMap.call(this,a);a&&a.render()};
ol.control.ZoomSlider.prototype.initSlider_=function(){var a=this.element,b=a.offsetWidth,c=a.offsetHeight,d=a.firstElementChild,e=getComputedStyle(d);a=d.offsetWidth+parseFloat(e.marginRight)+parseFloat(e.marginLeft);d=d.offsetHeight+parseFloat(e.marginTop)+parseFloat(e.marginBottom);this.thumbSize_=[a,d];b>c?(this.direction_=ol.control.ZoomSlider.Direction_.HORIZONTAL,this.widthLimit_=b-a):(this.direction_=ol.control.ZoomSlider.Direction_.VERTICAL,this.heightLimit_=c-d);this.sliderInitialized_=
!0};ol.control.ZoomSlider.render=function(a){a.frameState&&(this.sliderInitialized_||this.initSlider_(),a=a.frameState.viewState.resolution,a!==this.currentResolution_&&(this.currentResolution_=a,this.setThumbPosition_(a)))};
ol.control.ZoomSlider.prototype.handleContainerClick_=function(a){var b=this.getMap().getView();a=this.getRelativePosition_(a.offsetX-this.thumbSize_[0]/2,a.offsetY-this.thumbSize_[1]/2);a=this.getResolutionForPosition_(a);b.animate({resolution:b.constrainResolution(a),duration:this.duration_,easing:ol.easing.easeOut})};
ol.control.ZoomSlider.prototype.handleDraggerStart_=function(a){this.dragging_||a.originalEvent.target!==this.element.firstElementChild||(this.getMap().getView().setHint(ol.ViewHint.INTERACTING,1),this.previousX_=a.clientX,this.previousY_=a.clientY,this.dragging_=!0)};
ol.control.ZoomSlider.prototype.handleDraggerDrag_=function(a){if(this.dragging_){var b=this.element.firstElementChild,c=a.clientX-this.previousX_+parseInt(b.style.left,10);b=a.clientY-this.previousY_+parseInt(b.style.top,10);c=this.getRelativePosition_(c,b);this.currentResolution_=this.getResolutionForPosition_(c);this.getMap().getView().setResolution(this.currentResolution_);this.setThumbPosition_(this.currentResolution_);this.previousX_=a.clientX;this.previousY_=a.clientY}};
ol.control.ZoomSlider.prototype.handleDraggerEnd_=function(a){this.dragging_&&(a=this.getMap().getView(),a.setHint(ol.ViewHint.INTERACTING,-1),a.animate({resolution:a.constrainResolution(this.currentResolution_),duration:this.duration_,easing:ol.easing.easeOut}),this.dragging_=!1,this.previousY_=this.previousX_=void 0)};
ol.control.ZoomSlider.prototype.setThumbPosition_=function(a){a=this.getPositionForResolution_(a);var b=this.element.firstElementChild;this.direction_==ol.control.ZoomSlider.Direction_.HORIZONTAL?b.style.left=this.widthLimit_*a+"px":b.style.top=this.heightLimit_*a+"px"};ol.control.ZoomSlider.prototype.getRelativePosition_=function(a,b){return ol.math.clamp(this.direction_===ol.control.ZoomSlider.Direction_.HORIZONTAL?a/this.widthLimit_:b/this.heightLimit_,0,1)};
ol.control.ZoomSlider.prototype.getResolutionForPosition_=function(a){return this.getMap().getView().getResolutionForValueFunction()(1-a)};ol.control.ZoomSlider.prototype.getPositionForResolution_=function(a){return 1-this.getMap().getView().getValueForResolutionFunction()(a)};ol.control.ZoomToExtent=function(a){a=a?a:{};this.extent=a.extent?a.extent:null;var b=void 0!==a.className?a.className:"ol-zoom-extent",c=void 0!==a.label?a.label:"E",d=void 0!==a.tipLabel?a.tipLabel:"Fit to extent",e=document.createElement("button");e.setAttribute("type","button");e.title=d;e.appendChild("string"===typeof c?document.createTextNode(c):c);ol.events.listen(e,ol.events.EventType.CLICK,this.handleClick_,this);b=b+" "+ol.css.CLASS_UNSELECTABLE+" "+ol.css.CLASS_CONTROL;c=document.createElement("div");
c.className=b;c.appendChild(e);ol.control.Control.call(this,{element:c,target:a.target})};ol.inherits(ol.control.ZoomToExtent,ol.control.Control);ol.control.ZoomToExtent.prototype.handleClick_=function(a){a.preventDefault();this.handleZoomToExtent()};ol.control.ZoomToExtent.prototype.handleZoomToExtent=function(){var a=this.getMap().getView(),b=this.extent?this.extent:a.getProjection().getExtent();a.fit(b)};ol.format={};ol.format.FormatType={ARRAY_BUFFER:"arraybuffer",JSON:"json",TEXT:"text",XML:"xml"};ol.xml={};ol.xml.DOCUMENT=document.implementation.createDocument("","",null);ol.xml.createElementNS=function(a,b){return ol.xml.DOCUMENT.createElementNS(a,b)};ol.xml.getAllTextContent=function(a,b){return ol.xml.getAllTextContent_(a,b,[]).join("")};
ol.xml.getAllTextContent_=function(a,b,c){if(a.nodeType==Node.CDATA_SECTION_NODE||a.nodeType==Node.TEXT_NODE)b?c.push(String(a.nodeValue).replace(/(\r\n|\r|\n)/g,"")):c.push(a.nodeValue);else for(a=a.firstChild;a;a=a.nextSibling)ol.xml.getAllTextContent_(a,b,c);return c};ol.xml.isDocument=function(a){return a instanceof Document};ol.xml.isNode=function(a){return a instanceof Node};ol.xml.getAttributeNS=function(a,b,c){return a.getAttributeNS(b,c)||""};
ol.xml.setAttributeNS=function(a,b,c,d){a.setAttributeNS(b,c,d)};ol.xml.parse=function(a){return(new DOMParser).parseFromString(a,"application/xml")};ol.xml.makeArrayExtender=function(a,b){return function(c,d){c=a.call(b,c,d);void 0!==c&&ol.array.extend(d[d.length-1],c)}};ol.xml.makeArrayPusher=function(a,b){return function(c,d){c=a.call(void 0!==b?b:this,c,d);void 0!==c&&d[d.length-1].push(c)}};
ol.xml.makeReplacer=function(a,b){return function(c,d){c=a.call(void 0!==b?b:this,c,d);void 0!==c&&(d[d.length-1]=c)}};ol.xml.makeObjectPropertyPusher=function(a,b,c){return function(d,e){var f=a.call(void 0!==c?c:this,d,e);void 0!==f&&(e=e[e.length-1],d=void 0!==b?b:d.localName,(d in e?e[d]:e[d]=[]).push(f))}};ol.xml.makeObjectPropertySetter=function(a,b,c){return function(d,e){var f=a.call(void 0!==c?c:this,d,e);void 0!==f&&(e[e.length-1][void 0!==b?b:d.localName]=f)}};
ol.xml.makeChildAppender=function(a,b){return function(c,d,e){a.call(void 0!==b?b:this,c,d,e);e[e.length-1].node.appendChild(c)}};ol.xml.makeArraySerializer=function(a,b){var c,d;return function(b,f,g){if(void 0===c){c={};var e={};e[b.localName]=a;c[b.namespaceURI]=e;d=ol.xml.makeSimpleNodeFactory(b.localName)}ol.xml.serialize(c,d,f,g)}};
ol.xml.makeSimpleNodeFactory=function(a,b){return function(c,d,e){c=d[d.length-1].node;d=a;void 0===d&&(d=e);e=b;void 0===b&&(e=c.namespaceURI);return ol.xml.createElementNS(e,d)}};ol.xml.OBJECT_PROPERTY_NODE_FACTORY=ol.xml.makeSimpleNodeFactory();ol.xml.makeSequence=function(a,b){for(var c=b.length,d=Array(c),e=0;e<c;++e)d[e]=a[b[e]];return d};ol.xml.makeStructureNS=function(a,b,c){c=void 0!==c?c:{};var d;var e=0;for(d=a.length;e<d;++e)c[a[e]]=b;return c};
ol.xml.parseNode=function(a,b,c,d){for(b=b.firstElementChild;b;b=b.nextElementSibling){var e=a[b.namespaceURI];void 0!==e&&(e=e[b.localName],void 0!==e&&e.call(d,b,c))}};ol.xml.pushParseAndPop=function(a,b,c,d,e){d.push(a);ol.xml.parseNode(b,c,d,e);return d.pop()};ol.xml.serialize=function(a,b,c,d,e,f){for(var g=(void 0!==e?e:c).length,h,k,l=0;l<g;++l)h=c[l],void 0!==h&&(k=b.call(f,h,d,void 0!==e?e[l]:void 0),void 0!==k&&a[k.namespaceURI][k.localName].call(f,k,h,d))};
ol.xml.pushSerializeAndPop=function(a,b,c,d,e,f,g){e.push(a);ol.xml.serialize(b,c,d,e,f,g);return e.pop()};ol.featureloader={};
ol.featureloader.loadFeaturesXhr=function(a,b,c,d){return function(e,f,g){var h=new XMLHttpRequest;h.open("GET","function"===typeof a?a(e,f,g):a,!0);b.getType()==ol.format.FormatType.ARRAY_BUFFER&&(h.responseType="arraybuffer");h.onload=function(a){if(!h.status||200<=h.status&&300>h.status){a=b.getType();if(a==ol.format.FormatType.JSON||a==ol.format.FormatType.TEXT)var e=h.responseText;else a==ol.format.FormatType.XML?(e=h.responseXML)||(e=ol.xml.parse(h.responseText)):a==ol.format.FormatType.ARRAY_BUFFER&&(e=
h.response);e?c.call(this,b.readFeatures(e,{featureProjection:g}),b.readProjection(e),b.getLastExtent()):d.call(this)}else d.call(this)}.bind(this);h.onerror=function(){d.call(this)}.bind(this);h.send()}};ol.featureloader.xhr=function(a,b){return ol.featureloader.loadFeaturesXhr(a,b,function(a,b){this.addFeatures(a)},ol.nullFunction)};ol.format.Feature=function(){this.defaultFeatureProjection=this.defaultDataProjection=null};ol.format.Feature.prototype.getReadOptions=function(a,b){var c;b&&(c={dataProjection:b.dataProjection?b.dataProjection:this.readProjection(a),featureProjection:b.featureProjection});return this.adaptOptions(c)};ol.format.Feature.prototype.adaptOptions=function(a){return ol.obj.assign({dataProjection:this.defaultDataProjection,featureProjection:this.defaultFeatureProjection},a)};
ol.format.Feature.prototype.getLastExtent=function(){return null};ol.format.Feature.prototype.getType=function(){};ol.format.Feature.prototype.readFeature=function(a,b){};ol.format.Feature.prototype.readFeatures=function(a,b){};ol.format.Feature.prototype.readGeometry=function(a,b){};ol.format.Feature.prototype.readProjection=function(a){};ol.format.Feature.prototype.writeFeature=function(a,b){};ol.format.Feature.prototype.writeFeatures=function(a,b){};
ol.format.Feature.prototype.writeGeometry=function(a,b){};ol.format.Feature.transformWithOptions=function(a,b,c){var d=c?ol.proj.get(c.featureProjection):null,e=c?ol.proj.get(c.dataProjection):null;d=d&&e&&!ol.proj.equivalent(d,e)?a instanceof ol.geom.Geometry?(b?a.clone():a).transform(b?d:e,b?e:d):ol.proj.transformExtent(a,e,d):a;if(b&&c&&void 0!==c.decimals){var f=Math.pow(10,c.decimals);d===a&&(d=d.clone());d.applyTransform(function(a){for(var b=0,c=a.length;b<c;++b)a[b]=Math.round(a[b]*f)/f;return a})}return d};ol.format.JSONFeature=function(){ol.format.Feature.call(this)};ol.inherits(ol.format.JSONFeature,ol.format.Feature);ol.format.JSONFeature.prototype.getObject_=function(a){return"string"===typeof a?(a=JSON.parse(a))?a:null:null!==a?a:null};ol.format.JSONFeature.prototype.getType=function(){return ol.format.FormatType.JSON};ol.format.JSONFeature.prototype.readFeature=function(a,b){return this.readFeatureFromObject(this.getObject_(a),this.getReadOptions(a,b))};
ol.format.JSONFeature.prototype.readFeatures=function(a,b){return this.readFeaturesFromObject(this.getObject_(a),this.getReadOptions(a,b))};ol.format.JSONFeature.prototype.readFeatureFromObject=function(a,b){};ol.format.JSONFeature.prototype.readFeaturesFromObject=function(a,b){};ol.format.JSONFeature.prototype.readGeometry=function(a,b){return this.readGeometryFromObject(this.getObject_(a),this.getReadOptions(a,b))};ol.format.JSONFeature.prototype.readGeometryFromObject=function(a,b){};
ol.format.JSONFeature.prototype.readProjection=function(a){return this.readProjectionFromObject(this.getObject_(a))};ol.format.JSONFeature.prototype.readProjectionFromObject=function(a){};ol.format.JSONFeature.prototype.writeFeature=function(a,b){return JSON.stringify(this.writeFeatureObject(a,b))};ol.format.JSONFeature.prototype.writeFeatureObject=function(a,b){};ol.format.JSONFeature.prototype.writeFeatures=function(a,b){return JSON.stringify(this.writeFeaturesObject(a,b))};
ol.format.JSONFeature.prototype.writeFeaturesObject=function(a,b){};ol.format.JSONFeature.prototype.writeGeometry=function(a,b){return JSON.stringify(this.writeGeometryObject(a,b))};ol.format.JSONFeature.prototype.writeGeometryObject=function(a,b){};ol.geom.MultiLineString=function(a,b){ol.geom.SimpleGeometry.call(this);this.ends_=[];this.maxDeltaRevision_=this.maxDelta_=-1;this.setCoordinates(a,b)};ol.inherits(ol.geom.MultiLineString,ol.geom.SimpleGeometry);ol.geom.MultiLineString.prototype.appendLineString=function(a){this.flatCoordinates?ol.array.extend(this.flatCoordinates,a.getFlatCoordinates().slice()):this.flatCoordinates=a.getFlatCoordinates().slice();this.ends_.push(this.flatCoordinates.length);this.changed()};
ol.geom.MultiLineString.prototype.clone=function(){var a=new ol.geom.MultiLineString(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice());return a};
ol.geom.MultiLineString.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision());return ol.geom.flat.closest.getsClosestPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,a,b,c,d)};
ol.geom.MultiLineString.prototype.getCoordinateAtM=function(a,b,c){return this.layout!=ol.geom.GeometryLayout.XYM&&this.layout!=ol.geom.GeometryLayout.XYZM||0===this.flatCoordinates.length?null:ol.geom.flat.interpolate.lineStringsCoordinateAtM(this.flatCoordinates,0,this.ends_,this.stride,a,void 0!==b?b:!1,void 0!==c?c:!1)};ol.geom.MultiLineString.prototype.getCoordinates=function(){return ol.geom.flat.inflate.coordinatess(this.flatCoordinates,0,this.ends_,this.stride)};
ol.geom.MultiLineString.prototype.getEnds=function(){return this.ends_};ol.geom.MultiLineString.prototype.getLineString=function(a){if(0>a||this.ends_.length<=a)return null;var b=new ol.geom.LineString(null);b.setFlatCoordinates(this.layout,this.flatCoordinates.slice(0===a?0:this.ends_[a-1],this.ends_[a]));return b};
ol.geom.MultiLineString.prototype.getLineStrings=function(){var a=this.flatCoordinates,b=this.ends_,c=this.layout,d=[],e=0,f;var g=0;for(f=b.length;g<f;++g){var h=b[g],k=new ol.geom.LineString(null);k.setFlatCoordinates(c,a.slice(e,h));d.push(k);e=h}return d};
ol.geom.MultiLineString.prototype.getFlatMidpoints=function(){var a=[],b=this.flatCoordinates,c=0,d=this.ends_,e=this.stride,f;var g=0;for(f=d.length;g<f;++g){var h=d[g];c=ol.geom.flat.interpolate.lineString(b,c,h,e,.5);ol.array.extend(a,c);c=h}return a};
ol.geom.MultiLineString.prototype.getSimplifiedGeometryInternal=function(a){var b=[],c=[];b.length=ol.geom.flat.simplify.douglasPeuckers(this.flatCoordinates,0,this.ends_,this.stride,a,b,0,c);a=new ol.geom.MultiLineString(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,b,c);return a};ol.geom.MultiLineString.prototype.getType=function(){return ol.geom.GeometryType.MULTI_LINE_STRING};
ol.geom.MultiLineString.prototype.intersectsExtent=function(a){return ol.geom.flat.intersectsextent.lineStrings(this.flatCoordinates,0,this.ends_,this.stride,a)};
ol.geom.MultiLineString.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,2),this.flatCoordinates||(this.flatCoordinates=[]),a=ol.geom.flat.deflate.coordinatess(this.flatCoordinates,0,a,this.stride,this.ends_),this.flatCoordinates.length=0===a.length?0:a[a.length-1],this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null,this.ends_)};ol.geom.MultiLineString.prototype.setFlatCoordinates=function(a,b,c){this.setFlatCoordinatesInternal(a,b);this.ends_=c;this.changed()};
ol.geom.MultiLineString.prototype.setLineStrings=function(a){var b=this.getLayout(),c=[],d=[],e;var f=0;for(e=a.length;f<e;++f){var g=a[f];0===f&&(b=g.getLayout());ol.array.extend(c,g.getFlatCoordinates());d.push(c.length)}this.setFlatCoordinates(b,c,d)};ol.geom.MultiPoint=function(a,b){ol.geom.SimpleGeometry.call(this);this.setCoordinates(a,b)};ol.inherits(ol.geom.MultiPoint,ol.geom.SimpleGeometry);ol.geom.MultiPoint.prototype.appendPoint=function(a){this.flatCoordinates?ol.array.extend(this.flatCoordinates,a.getFlatCoordinates()):this.flatCoordinates=a.getFlatCoordinates().slice();this.changed()};ol.geom.MultiPoint.prototype.clone=function(){var a=new ol.geom.MultiPoint(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return a};
ol.geom.MultiPoint.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;var e=this.flatCoordinates,f=this.stride,g;var h=0;for(g=e.length;h<g;h+=f){var k=ol.math.squaredDistance(a,b,e[h],e[h+1]);if(k<d){d=k;for(k=0;k<f;++k)c[k]=e[h+k];c.length=f}}return d};ol.geom.MultiPoint.prototype.getCoordinates=function(){return ol.geom.flat.inflate.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)};
ol.geom.MultiPoint.prototype.getPoint=function(a){var b=this.flatCoordinates?this.flatCoordinates.length/this.stride:0;if(0>a||b<=a)return null;b=new ol.geom.Point(null);b.setFlatCoordinates(this.layout,this.flatCoordinates.slice(a*this.stride,(a+1)*this.stride));return b};ol.geom.MultiPoint.prototype.getPoints=function(){var a=this.flatCoordinates,b=this.layout,c=this.stride,d=[],e;var f=0;for(e=a.length;f<e;f+=c){var g=new ol.geom.Point(null);g.setFlatCoordinates(b,a.slice(f,f+c));d.push(g)}return d};
ol.geom.MultiPoint.prototype.getType=function(){return ol.geom.GeometryType.MULTI_POINT};ol.geom.MultiPoint.prototype.intersectsExtent=function(a){var b=this.flatCoordinates,c=this.stride,d;var e=0;for(d=b.length;e<d;e+=c){var f=b[e];var g=b[e+1];if(ol.extent.containsXY(a,f,g))return!0}return!1};
ol.geom.MultiPoint.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ol.geom.flat.deflate.coordinates(this.flatCoordinates,0,a,this.stride),this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null)};ol.geom.MultiPoint.prototype.setFlatCoordinates=function(a,b){this.setFlatCoordinatesInternal(a,b);this.changed()};ol.geom.flat.center={};ol.geom.flat.center.linearRingss=function(a,b,c,d){var e=[],f;ol.extent.createEmpty();var g=0;for(f=c.length;g<f;++g){var h=c[g];b=ol.extent.createOrUpdateFromFlatCoordinates(a,b,h[0],d);e.push((b[0]+b[2])/2,(b[1]+b[3])/2);b=h[h.length-1]}return e};ol.geom.MultiPolygon=function(a,b){ol.geom.SimpleGeometry.call(this);this.endss_=[];this.flatInteriorPointsRevision_=-1;this.flatInteriorPoints_=null;this.orientedRevision_=this.maxDeltaRevision_=this.maxDelta_=-1;this.orientedFlatCoordinates_=null;this.setCoordinates(a,b)};ol.inherits(ol.geom.MultiPolygon,ol.geom.SimpleGeometry);
ol.geom.MultiPolygon.prototype.appendPolygon=function(a){if(this.flatCoordinates){var b=this.flatCoordinates.length;ol.array.extend(this.flatCoordinates,a.getFlatCoordinates());a=a.getEnds().slice();var c;var d=0;for(c=a.length;d<c;++d)a[d]+=b}else this.flatCoordinates=a.getFlatCoordinates().slice(),a=a.getEnds().slice(),this.endss_.push();this.endss_.push(a);this.changed()};
ol.geom.MultiPolygon.prototype.clone=function(){for(var a=new ol.geom.MultiPolygon(null),b=this.endss_.length,c=Array(b),d=0;d<b;++d)c[d]=this.endss_[d].slice();a.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),c);return a};
ol.geom.MultiPolygon.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ol.geom.flat.closest.getssMaxSquaredDelta(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision());return ol.geom.flat.closest.getssClosestPoint(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,a,b,c,d)};
ol.geom.MultiPolygon.prototype.containsXY=function(a,b){return ol.geom.flat.contains.linearRingssContainsXY(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,a,b)};ol.geom.MultiPolygon.prototype.getArea=function(){return ol.geom.flat.area.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)};
ol.geom.MultiPolygon.prototype.getCoordinates=function(a){if(void 0!==a){var b=this.getOrientedFlatCoordinates().slice();ol.geom.flat.orient.orientLinearRingss(b,0,this.endss_,this.stride,a)}else b=this.flatCoordinates;return ol.geom.flat.inflate.coordinatesss(b,0,this.endss_,this.stride)};ol.geom.MultiPolygon.prototype.getEndss=function(){return this.endss_};
ol.geom.MultiPolygon.prototype.getFlatInteriorPoints=function(){if(this.flatInteriorPointsRevision_!=this.getRevision()){var a=ol.geom.flat.center.linearRingss(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=ol.geom.flat.interiorpoint.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,a);this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_};
ol.geom.MultiPolygon.prototype.getInteriorPoints=function(){var a=new ol.geom.MultiPoint(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XYM,this.getFlatInteriorPoints().slice());return a};
ol.geom.MultiPolygon.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var a=this.flatCoordinates;ol.geom.flat.orient.linearRingssAreOriented(a,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=a:(this.orientedFlatCoordinates_=a.slice(),this.orientedFlatCoordinates_.length=ol.geom.flat.orient.orientLinearRingss(this.orientedFlatCoordinates_,0,this.endss_,this.stride));this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_};
ol.geom.MultiPolygon.prototype.getSimplifiedGeometryInternal=function(a){var b=[],c=[];b.length=ol.geom.flat.simplify.quantizess(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(a),b,0,c);a=new ol.geom.MultiPolygon(null);a.setFlatCoordinates(ol.geom.GeometryLayout.XY,b,c);return a};
ol.geom.MultiPolygon.prototype.getPolygon=function(a){if(0>a||this.endss_.length<=a)return null;if(0===a)var b=0;else b=this.endss_[a-1],b=b[b.length-1];a=this.endss_[a].slice();var c=a[a.length-1];if(0!==b){var d;var e=0;for(d=a.length;e<d;++e)a[e]-=b}e=new ol.geom.Polygon(null);e.setFlatCoordinates(this.layout,this.flatCoordinates.slice(b,c),a);return e};
ol.geom.MultiPolygon.prototype.getPolygons=function(){var a=this.layout,b=this.flatCoordinates,c=this.endss_,d=[],e=0,f,g;var h=0;for(f=c.length;h<f;++h){var k=c[h].slice(),l=k[k.length-1];if(0!==e){var m=0;for(g=k.length;m<g;++m)k[m]-=e}m=new ol.geom.Polygon(null);m.setFlatCoordinates(a,b.slice(e,l),k);d.push(m);e=l}return d};ol.geom.MultiPolygon.prototype.getType=function(){return ol.geom.GeometryType.MULTI_POLYGON};
ol.geom.MultiPolygon.prototype.intersectsExtent=function(a){return ol.geom.flat.intersectsextent.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,a)};
ol.geom.MultiPolygon.prototype.setCoordinates=function(a,b){a?(this.setLayout(b,a,3),this.flatCoordinates||(this.flatCoordinates=[]),a=ol.geom.flat.deflate.coordinatesss(this.flatCoordinates,0,a,this.stride,this.endss_),0===a.length?this.flatCoordinates.length=0:(a=a[a.length-1],this.flatCoordinates.length=0===a.length?0:a[a.length-1]),this.changed()):this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null,this.endss_)};
ol.geom.MultiPolygon.prototype.setFlatCoordinates=function(a,b,c){this.setFlatCoordinatesInternal(a,b);this.endss_=c;this.changed()};ol.geom.MultiPolygon.prototype.setPolygons=function(a){var b=this.getLayout(),c=[],d=[],e;var f=0;for(e=a.length;f<e;++f){var g=a[f];0===f&&(b=g.getLayout());var h=c.length;var k=g.getEnds();var l;var m=0;for(l=k.length;m<l;++m)k[m]+=h;ol.array.extend(c,g.getFlatCoordinates());d.push(k)}this.setFlatCoordinates(b,c,d)};ol.format.EsriJSON=function(a){a=a?a:{};ol.format.JSONFeature.call(this);this.geometryName_=a.geometryName};ol.inherits(ol.format.EsriJSON,ol.format.JSONFeature);
ol.format.EsriJSON.readGeometry_=function(a,b){if(!a)return null;if("number"===typeof a.x&&"number"===typeof a.y)var c=ol.geom.GeometryType.POINT;else if(a.points)c=ol.geom.GeometryType.MULTI_POINT;else if(a.paths)c=1===a.paths.length?ol.geom.GeometryType.LINE_STRING:ol.geom.GeometryType.MULTI_LINE_STRING;else if(a.rings){c=ol.format.EsriJSON.getGeometryLayout_(a);var d=ol.format.EsriJSON.convertRings_(a.rings,c);a=ol.obj.assign({},a);1===d.length?(c=ol.geom.GeometryType.POLYGON,a.rings=d[0]):(c=
ol.geom.GeometryType.MULTI_POLYGON,a.rings=d)}return ol.format.Feature.transformWithOptions((0,ol.format.EsriJSON.GEOMETRY_READERS_[c])(a),!1,b)};
ol.format.EsriJSON.convertRings_=function(a,b){var c=[],d=[],e=[],f;var g=0;for(f=a.length;g<f;++g)c.length=0,ol.geom.flat.deflate.coordinates(c,0,a[g],b.length),ol.geom.flat.orient.linearRingIsClockwise(c,0,c.length,b.length)?d.push([a[g]]):e.push(a[g]);for(;e.length;){a=e.shift();b=!1;for(g=d.length-1;0<=g;g--)if(ol.extent.containsExtent((new ol.geom.LinearRing(d[g][0])).getExtent(),(new ol.geom.LinearRing(a)).getExtent())){d[g].push(a);b=!0;break}b||d.push([a.reverse()])}return d};
ol.format.EsriJSON.readPointGeometry_=function(a){return void 0!==a.m&&void 0!==a.z?new ol.geom.Point([a.x,a.y,a.z,a.m],ol.geom.GeometryLayout.XYZM):void 0!==a.z?new ol.geom.Point([a.x,a.y,a.z],ol.geom.GeometryLayout.XYZ):void 0!==a.m?new ol.geom.Point([a.x,a.y,a.m],ol.geom.GeometryLayout.XYM):new ol.geom.Point([a.x,a.y])};ol.format.EsriJSON.readLineStringGeometry_=function(a){var b=ol.format.EsriJSON.getGeometryLayout_(a);return new ol.geom.LineString(a.paths[0],b)};
ol.format.EsriJSON.readMultiLineStringGeometry_=function(a){var b=ol.format.EsriJSON.getGeometryLayout_(a);return new ol.geom.MultiLineString(a.paths,b)};ol.format.EsriJSON.getGeometryLayout_=function(a){var b=ol.geom.GeometryLayout.XY;!0===a.hasZ&&!0===a.hasM?b=ol.geom.GeometryLayout.XYZM:!0===a.hasZ?b=ol.geom.GeometryLayout.XYZ:!0===a.hasM&&(b=ol.geom.GeometryLayout.XYM);return b};
ol.format.EsriJSON.readMultiPointGeometry_=function(a){var b=ol.format.EsriJSON.getGeometryLayout_(a);return new ol.geom.MultiPoint(a.points,b)};ol.format.EsriJSON.readMultiPolygonGeometry_=function(a){var b=ol.format.EsriJSON.getGeometryLayout_(a);return new ol.geom.MultiPolygon(a.rings,b)};ol.format.EsriJSON.readPolygonGeometry_=function(a){var b=ol.format.EsriJSON.getGeometryLayout_(a);return new ol.geom.Polygon(a.rings,b)};
ol.format.EsriJSON.writePointGeometry_=function(a,b){b=a.getCoordinates();var c;a=a.getLayout();a===ol.geom.GeometryLayout.XYZ?c={x:b[0],y:b[1],z:b[2]}:a===ol.geom.GeometryLayout.XYM?c={x:b[0],y:b[1],m:b[2]}:a===ol.geom.GeometryLayout.XYZM?c={x:b[0],y:b[1],z:b[2],m:b[3]}:a===ol.geom.GeometryLayout.XY?c={x:b[0],y:b[1]}:ol.asserts.assert(!1,34);return c};
ol.format.EsriJSON.getHasZM_=function(a){a=a.getLayout();return{hasZ:a===ol.geom.GeometryLayout.XYZ||a===ol.geom.GeometryLayout.XYZM,hasM:a===ol.geom.GeometryLayout.XYM||a===ol.geom.GeometryLayout.XYZM}};ol.format.EsriJSON.writeLineStringGeometry_=function(a,b){b=ol.format.EsriJSON.getHasZM_(a);return{hasZ:b.hasZ,hasM:b.hasM,paths:[a.getCoordinates()]}};ol.format.EsriJSON.writePolygonGeometry_=function(a,b){b=ol.format.EsriJSON.getHasZM_(a);return{hasZ:b.hasZ,hasM:b.hasM,rings:a.getCoordinates(!1)}};
ol.format.EsriJSON.writeMultiLineStringGeometry_=function(a,b){b=ol.format.EsriJSON.getHasZM_(a);return{hasZ:b.hasZ,hasM:b.hasM,paths:a.getCoordinates()}};ol.format.EsriJSON.writeMultiPointGeometry_=function(a,b){b=ol.format.EsriJSON.getHasZM_(a);return{hasZ:b.hasZ,hasM:b.hasM,points:a.getCoordinates()}};
ol.format.EsriJSON.writeMultiPolygonGeometry_=function(a,b){b=ol.format.EsriJSON.getHasZM_(a);a=a.getCoordinates(!1);for(var c=[],d=0;d<a.length;d++)for(var e=a[d].length-1;0<=e;e--)c.push(a[d][e]);return{hasZ:b.hasZ,hasM:b.hasM,rings:c}};ol.format.EsriJSON.GEOMETRY_READERS_={};ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POINT]=ol.format.EsriJSON.readPointGeometry_;ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.LINE_STRING]=ol.format.EsriJSON.readLineStringGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POLYGON]=ol.format.EsriJSON.readPolygonGeometry_;ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POINT]=ol.format.EsriJSON.readMultiPointGeometry_;ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_LINE_STRING]=ol.format.EsriJSON.readMultiLineStringGeometry_;ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POLYGON]=ol.format.EsriJSON.readMultiPolygonGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_={};ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POINT]=ol.format.EsriJSON.writePointGeometry_;ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.LINE_STRING]=ol.format.EsriJSON.writeLineStringGeometry_;ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POLYGON]=ol.format.EsriJSON.writePolygonGeometry_;ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POINT]=ol.format.EsriJSON.writeMultiPointGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_LINE_STRING]=ol.format.EsriJSON.writeMultiLineStringGeometry_;ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POLYGON]=ol.format.EsriJSON.writeMultiPolygonGeometry_;
ol.format.EsriJSON.prototype.readFeatureFromObject=function(a,b){var c=ol.format.EsriJSON.readGeometry_(a.geometry,b),d=new ol.Feature;this.geometryName_&&d.setGeometryName(this.geometryName_);d.setGeometry(c);b&&b.idField&&a.attributes[b.idField]&&d.setId(a.attributes[b.idField]);a.attributes&&d.setProperties(a.attributes);return d};
ol.format.EsriJSON.prototype.readFeaturesFromObject=function(a,b){b=b?b:{};if(a.features){var c=[],d=a.features,e;b.idField=a.objectIdFieldName;a=0;for(e=d.length;a<e;++a)c.push(this.readFeatureFromObject(d[a],b));return c}return[this.readFeatureFromObject(a,b)]};ol.format.EsriJSON.prototype.readGeometryFromObject=function(a,b){return ol.format.EsriJSON.readGeometry_(a,b)};
ol.format.EsriJSON.prototype.readProjectionFromObject=function(a){return a.spatialReference&&a.spatialReference.wkid?ol.proj.get("EPSG:"+a.spatialReference.wkid):null};ol.format.EsriJSON.writeGeometry_=function(a,b){return(0,ol.format.EsriJSON.GEOMETRY_WRITERS_[a.getType()])(ol.format.Feature.transformWithOptions(a,!0,b),b)};ol.format.EsriJSON.prototype.writeGeometryObject=function(a,b){return ol.format.EsriJSON.writeGeometry_(a,this.adaptOptions(b))};
ol.format.EsriJSON.prototype.writeFeatureObject=function(a,b){b=this.adaptOptions(b);var c={},d=a.getGeometry();d&&(c.geometry=ol.format.EsriJSON.writeGeometry_(d,b),b&&b.featureProjection&&(c.geometry.spatialReference={wkid:ol.proj.get(b.featureProjection).getCode().split(":").pop()}));b=a.getProperties();delete b[a.getGeometryName()];ol.obj.isEmpty(b)?c.attributes={}:c.attributes=b;return c};
ol.format.EsriJSON.prototype.writeFeaturesObject=function(a,b){b=this.adaptOptions(b);var c=[],d;var e=0;for(d=a.length;e<d;++e)c.push(this.writeFeatureObject(a[e],b));return{features:c}};ol.format.XMLFeature=function(){this.xmlSerializer_=new XMLSerializer;ol.format.Feature.call(this)};ol.inherits(ol.format.XMLFeature,ol.format.Feature);ol.format.XMLFeature.prototype.getType=function(){return ol.format.FormatType.XML};ol.format.XMLFeature.prototype.readFeature=function(a,b){return ol.xml.isDocument(a)?this.readFeatureFromDocument(a,b):ol.xml.isNode(a)?this.readFeatureFromNode(a,b):"string"===typeof a?(a=ol.xml.parse(a),this.readFeatureFromDocument(a,b)):null};
ol.format.XMLFeature.prototype.readFeatureFromDocument=function(a,b){a=this.readFeaturesFromDocument(a,b);return 0<a.length?a[0]:null};ol.format.XMLFeature.prototype.readFeatureFromNode=function(a,b){return null};ol.format.XMLFeature.prototype.readFeatures=function(a,b){return ol.xml.isDocument(a)?this.readFeaturesFromDocument(a,b):ol.xml.isNode(a)?this.readFeaturesFromNode(a,b):"string"===typeof a?(a=ol.xml.parse(a),this.readFeaturesFromDocument(a,b)):[]};
ol.format.XMLFeature.prototype.readFeaturesFromDocument=function(a,b){var c=[];for(a=a.firstChild;a;a=a.nextSibling)a.nodeType==Node.ELEMENT_NODE&&ol.array.extend(c,this.readFeaturesFromNode(a,b));return c};ol.format.XMLFeature.prototype.readFeaturesFromNode=function(a,b){};
ol.format.XMLFeature.prototype.readGeometry=function(a,b){return ol.xml.isDocument(a)?this.readGeometryFromDocument(a,b):ol.xml.isNode(a)?this.readGeometryFromNode(a,b):"string"===typeof a?(a=ol.xml.parse(a),this.readGeometryFromDocument(a,b)):null};ol.format.XMLFeature.prototype.readGeometryFromDocument=function(a,b){return null};ol.format.XMLFeature.prototype.readGeometryFromNode=function(a,b){return null};
ol.format.XMLFeature.prototype.readProjection=function(a){return ol.xml.isDocument(a)?this.readProjectionFromDocument(a):ol.xml.isNode(a)?this.readProjectionFromNode(a):"string"===typeof a?(a=ol.xml.parse(a),this.readProjectionFromDocument(a)):null};ol.format.XMLFeature.prototype.readProjectionFromDocument=function(a){return this.defaultDataProjection};ol.format.XMLFeature.prototype.readProjectionFromNode=function(a){return this.defaultDataProjection};
ol.format.XMLFeature.prototype.writeFeature=function(a,b){a=this.writeFeatureNode(a,b);return this.xmlSerializer_.serializeToString(a)};ol.format.XMLFeature.prototype.writeFeatureNode=function(a,b){return null};ol.format.XMLFeature.prototype.writeFeatures=function(a,b){a=this.writeFeaturesNode(a,b);return this.xmlSerializer_.serializeToString(a)};ol.format.XMLFeature.prototype.writeFeaturesNode=function(a,b){return null};
ol.format.XMLFeature.prototype.writeGeometry=function(a,b){a=this.writeGeometryNode(a,b);return this.xmlSerializer_.serializeToString(a)};ol.format.XMLFeature.prototype.writeGeometryNode=function(a,b){return null};ol.format.GMLBase=function(a){a=a?a:{};this.featureType=a.featureType;this.featureNS=a.featureNS;this.srsName=a.srsName;this.schemaLocation="";this.FEATURE_COLLECTION_PARSERS={};this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS]={featureMember:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFeaturesInternal),featureMembers:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFeaturesInternal)};ol.format.XMLFeature.call(this)};ol.inherits(ol.format.GMLBase,ol.format.XMLFeature);
ol.format.GMLBase.GMLNS="http://www.opengis.net/gml";ol.format.GMLBase.ONLY_WHITESPACE_RE_=/^[\s\xa0]*$/;
ol.format.GMLBase.prototype.readFeaturesInternal=function(a,b){var c=a.localName,d=null;if("FeatureCollection"==c)d="http://www.opengis.net/wfs"===a.namespaceURI?ol.xml.pushParseAndPop([],this.FEATURE_COLLECTION_PARSERS,a,b,this):ol.xml.pushParseAndPop(null,this.FEATURE_COLLECTION_PARSERS,a,b,this);else if("featureMembers"==c||"featureMember"==c){var e=b[0],f=e.featureType;d=e.featureNS;var g;if(!f&&a.childNodes){f=[];d={};var h=0;for(g=a.childNodes.length;h<g;++h){var k=a.childNodes[h];if(1===k.nodeType){var l=
k.nodeName.split(":").pop();if(-1===f.indexOf(l)){var m="",n=0;k=k.namespaceURI;for(var p in d){if(d[p]===k){m=p;break}++n}m||(m="p"+n,d[m]=k);f.push(m+":"+l)}}}"featureMember"!=c&&(e.featureType=f,e.featureNS=d)}"string"===typeof d&&(h=d,d={},d.p0=h);p={};f=Array.isArray(f)?f:[f];for(var q in d){e={};h=0;for(g=f.length;h<g;++h)(-1===f[h].indexOf(":")?"p0":f[h].split(":")[0])===q&&(e[f[h].split(":").pop()]="featureMembers"==c?ol.xml.makeArrayPusher(this.readFeatureElement,this):ol.xml.makeReplacer(this.readFeatureElement,
this));p[d[q]]=e}d="featureMember"==c?ol.xml.pushParseAndPop(void 0,p,a,b):ol.xml.pushParseAndPop([],p,a,b)}null===d&&(d=[]);return d};ol.format.GMLBase.prototype.readGeometryElement=function(a,b){var c=b[0];c.srsName=a.firstElementChild.getAttribute("srsName");c.srsDimension=a.firstElementChild.getAttribute("srsDimension");if(a=ol.xml.pushParseAndPop(null,this.GEOMETRY_PARSERS_,a,b,this))return ol.format.Feature.transformWithOptions(a,!1,c)};
ol.format.GMLBase.prototype.readFeatureElement=function(a,b){var c=a.getAttribute("fid")||ol.xml.getAttributeNS(a,ol.format.GMLBase.GMLNS,"id"),d={},e;for(a=a.firstElementChild;a;a=a.nextElementSibling){var f=a.localName;if(0===a.childNodes.length||1===a.childNodes.length&&(3===a.firstChild.nodeType||4===a.firstChild.nodeType)){var g=ol.xml.getAllTextContent(a,!1);ol.format.GMLBase.ONLY_WHITESPACE_RE_.test(g)&&(g=void 0);d[f]=g}else"boundedBy"!==f&&(e=f),d[f]=this.readGeometryElement(a,b)}b=new ol.Feature(d);
e&&b.setGeometryName(e);c&&b.setId(c);return b};ol.format.GMLBase.prototype.readPoint=function(a,b){if(a=this.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.Point(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b};ol.format.GMLBase.prototype.readMultiPoint=function(a,b){if(a=ol.xml.pushParseAndPop([],this.MULTIPOINT_PARSERS_,a,b,this))return new ol.geom.MultiPoint(a)};
ol.format.GMLBase.prototype.readMultiLineString=function(a,b){if(a=ol.xml.pushParseAndPop([],this.MULTILINESTRING_PARSERS_,a,b,this))return b=new ol.geom.MultiLineString(null),b.setLineStrings(a),b};ol.format.GMLBase.prototype.readMultiPolygon=function(a,b){if(a=ol.xml.pushParseAndPop([],this.MULTIPOLYGON_PARSERS_,a,b,this))return b=new ol.geom.MultiPolygon(null),b.setPolygons(a),b};ol.format.GMLBase.prototype.pointMemberParser_=function(a,b){ol.xml.parseNode(this.POINTMEMBER_PARSERS_,a,b,this)};
ol.format.GMLBase.prototype.lineStringMemberParser_=function(a,b){ol.xml.parseNode(this.LINESTRINGMEMBER_PARSERS_,a,b,this)};ol.format.GMLBase.prototype.polygonMemberParser_=function(a,b){ol.xml.parseNode(this.POLYGONMEMBER_PARSERS_,a,b,this)};ol.format.GMLBase.prototype.readLineString=function(a,b){if(a=this.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.LineString(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b};
ol.format.GMLBase.prototype.readFlatLinearRing_=function(a,b){if(a=ol.xml.pushParseAndPop(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS_,a,b,this))return a};ol.format.GMLBase.prototype.readLinearRing=function(a,b){if(a=this.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.LinearRing(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b};
ol.format.GMLBase.prototype.readPolygon=function(a,b){if((a=ol.xml.pushParseAndPop([null],this.FLAT_LINEAR_RINGS_PARSERS_,a,b,this))&&a[0]){b=new ol.geom.Polygon(null);var c=a[0],d=[c.length],e;var f=1;for(e=a.length;f<e;++f)ol.array.extend(c,a[f]),d.push(c.length);b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,c,d);return b}};ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_=function(a,b){return ol.xml.pushParseAndPop(null,this.GEOMETRY_FLAT_COORDINATES_PARSERS_,a,b,this)};
ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_={"http://www.opengis.net/gml":{pointMember:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.pointMemberParser_),pointMembers:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.pointMemberParser_)}};ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_={"http://www.opengis.net/gml":{lineStringMember:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.lineStringMemberParser_),lineStringMembers:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.lineStringMemberParser_)}};
ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_={"http://www.opengis.net/gml":{polygonMember:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.polygonMemberParser_),polygonMembers:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.polygonMemberParser_)}};ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_={"http://www.opengis.net/gml":{Point:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_)}};ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readLineString)}};
ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readPolygon)}};ol.format.GMLBase.prototype.RING_PARSERS={"http://www.opengis.net/gml":{LinearRing:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFlatLinearRing_)}};ol.format.GMLBase.prototype.readGeometryFromNode=function(a,b){return(a=this.readGeometryElement(a,[this.getReadOptions(a,b?b:{})]))?a:null};
ol.format.GMLBase.prototype.readFeaturesFromNode=function(a,b){var c={featureType:this.featureType,featureNS:this.featureNS};b&&ol.obj.assign(c,this.getReadOptions(a,b));return this.readFeaturesInternal(a,[c])||[]};ol.format.GMLBase.prototype.readProjectionFromNode=function(a){return ol.proj.get(this.srsName?this.srsName:a.firstElementChild.getAttribute("srsName"))};ol.format.XSD={};ol.format.XSD.NAMESPACE_URI="http://www.w3.org/2001/XMLSchema";ol.format.XSD.readBoolean=function(a){a=ol.xml.getAllTextContent(a,!1);return ol.format.XSD.readBooleanString(a)};ol.format.XSD.readBooleanString=function(a){if(a=/^\s*(true|1)|(false|0)\s*$/.exec(a))return void 0!==a[1]||!1};ol.format.XSD.readDateTime=function(a){a=ol.xml.getAllTextContent(a,!1);a=Date.parse(a);return isNaN(a)?void 0:a/1E3};ol.format.XSD.readDecimal=function(a){a=ol.xml.getAllTextContent(a,!1);return ol.format.XSD.readDecimalString(a)};
ol.format.XSD.readDecimalString=function(a){if(a=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(a))return parseFloat(a[1])};ol.format.XSD.readNonNegativeInteger=function(a){a=ol.xml.getAllTextContent(a,!1);return ol.format.XSD.readNonNegativeIntegerString(a)};ol.format.XSD.readNonNegativeIntegerString=function(a){if(a=/^\s*(\d+)\s*$/.exec(a))return parseInt(a[1],10)};ol.format.XSD.readString=function(a){return ol.xml.getAllTextContent(a,!1).trim()};
ol.format.XSD.writeBooleanTextNode=function(a,b){ol.format.XSD.writeStringTextNode(a,b?"1":"0")};ol.format.XSD.writeCDATASection=function(a,b){a.appendChild(ol.xml.DOCUMENT.createCDATASection(b))};
ol.format.XSD.writeDateTimeTextNode=function(a,b){b=new Date(1E3*b);b=b.getUTCFullYear()+"-"+ol.string.padNumber(b.getUTCMonth()+1,2)+"-"+ol.string.padNumber(b.getUTCDate(),2)+"T"+ol.string.padNumber(b.getUTCHours(),2)+":"+ol.string.padNumber(b.getUTCMinutes(),2)+":"+ol.string.padNumber(b.getUTCSeconds(),2)+"Z";a.appendChild(ol.xml.DOCUMENT.createTextNode(b))};ol.format.XSD.writeDecimalTextNode=function(a,b){b=b.toPrecision();a.appendChild(ol.xml.DOCUMENT.createTextNode(b))};
ol.format.XSD.writeNonNegativeIntegerTextNode=function(a,b){a.appendChild(ol.xml.DOCUMENT.createTextNode(b.toString()))};ol.format.XSD.writeStringTextNode=function(a,b){a.appendChild(ol.xml.DOCUMENT.createTextNode(b))};ol.format.GML3=function(a){a=a?a:{};ol.format.GMLBase.call(this,a);this.surface_=void 0!==a.surface?a.surface:!1;this.curve_=void 0!==a.curve?a.curve:!1;this.multiCurve_=void 0!==a.multiCurve?a.multiCurve:!0;this.multiSurface_=void 0!==a.multiSurface?a.multiSurface:!0;this.schemaLocation=a.schemaLocation?a.schemaLocation:ol.format.GML3.schemaLocation_;this.hasZ=void 0!==a.hasZ?a.hasZ:!1};ol.inherits(ol.format.GML3,ol.format.GMLBase);ol.format.GML3.schemaLocation_=ol.format.GMLBase.GMLNS+" http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
ol.format.GML3.prototype.readMultiCurve_=function(a,b){if(a=ol.xml.pushParseAndPop([],this.MULTICURVE_PARSERS_,a,b,this))return b=new ol.geom.MultiLineString(null),b.setLineStrings(a),b};ol.format.GML3.prototype.readMultiSurface_=function(a,b){if(a=ol.xml.pushParseAndPop([],this.MULTISURFACE_PARSERS_,a,b,this))return b=new ol.geom.MultiPolygon(null),b.setPolygons(a),b};ol.format.GML3.prototype.curveMemberParser_=function(a,b){ol.xml.parseNode(this.CURVEMEMBER_PARSERS_,a,b,this)};
ol.format.GML3.prototype.surfaceMemberParser_=function(a,b){ol.xml.parseNode(this.SURFACEMEMBER_PARSERS_,a,b,this)};ol.format.GML3.prototype.readPatch_=function(a,b){return ol.xml.pushParseAndPop([null],this.PATCHES_PARSERS_,a,b,this)};ol.format.GML3.prototype.readSegment_=function(a,b){return ol.xml.pushParseAndPop([null],this.SEGMENTS_PARSERS_,a,b,this)};ol.format.GML3.prototype.readPolygonPatch_=function(a,b){return ol.xml.pushParseAndPop([null],this.FLAT_LINEAR_RINGS_PARSERS_,a,b,this)};
ol.format.GML3.prototype.readLineStringSegment_=function(a,b){return ol.xml.pushParseAndPop([null],this.GEOMETRY_FLAT_COORDINATES_PARSERS_,a,b,this)};ol.format.GML3.prototype.interiorParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,this.RING_PARSERS,a,b,this))&&b[b.length-1].push(a)};ol.format.GML3.prototype.exteriorParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,this.RING_PARSERS,a,b,this))&&(b[b.length-1][0]=a)};
ol.format.GML3.prototype.readSurface_=function(a,b){if((a=ol.xml.pushParseAndPop([null],this.SURFACE_PARSERS_,a,b,this))&&a[0]){b=new ol.geom.Polygon(null);var c=a[0],d=[c.length],e;var f=1;for(e=a.length;f<e;++f)ol.array.extend(c,a[f]),d.push(c.length);b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,c,d);return b}};
ol.format.GML3.prototype.readCurve_=function(a,b){if(a=ol.xml.pushParseAndPop([null],this.CURVE_PARSERS_,a,b,this))return b=new ol.geom.LineString(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b};ol.format.GML3.prototype.readEnvelope_=function(a,b){a=ol.xml.pushParseAndPop([null],this.ENVELOPE_PARSERS_,a,b,this);return ol.extent.createOrUpdate(a[1][0],a[1][1],a[2][0],a[2][1])};
ol.format.GML3.prototype.readFlatPos_=function(a,b){var c=ol.xml.getAllTextContent(a,!1),d=/^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;a=[];for(var e;e=d.exec(c);)a.push(parseFloat(e[1])),c=c.substr(e[0].length);if(""===c){b=b[0].srsName;c="enu";b&&(c=ol.proj.get(b).getAxisOrientation());if("neu"===c)for(b=0,c=a.length;b<c;b+=3)d=a[b],a[b]=a[b+1],a[b+1]=d;b=a.length;2==b&&a.push(0);if(0!==b)return a}};
ol.format.GML3.prototype.readFlatPosList_=function(a,b){var c=ol.xml.getAllTextContent(a,!1).replace(/^\s*|\s*$/g,"");b=b[0];var d=b.srsName,e=b.srsDimension;b="enu";d&&(b=ol.proj.get(d).getAxisOrientation());c=c.split(/\s+/);d=2;a.getAttribute("srsDimension")?d=ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("srsDimension")):a.getAttribute("dimension")?d=ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("dimension")):a.parentNode.getAttribute("srsDimension")?d=ol.format.XSD.readNonNegativeIntegerString(a.parentNode.getAttribute("srsDimension")):
e&&(d=ol.format.XSD.readNonNegativeIntegerString(e));for(var f,g=[],h=0,k=c.length;h<k;h+=d)a=parseFloat(c[h]),e=parseFloat(c[h+1]),f=3===d?parseFloat(c[h+2]):0,"en"===b.substr(0,2)?g.push(a,e,f):g.push(e,a,f);return g};ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_={"http://www.opengis.net/gml":{pos:ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPos_),posList:ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPosList_)}};
ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS_={"http://www.opengis.net/gml":{interior:ol.format.GML3.prototype.interiorParser_,exterior:ol.format.GML3.prototype.exteriorParser_}};
ol.format.GML3.prototype.GEOMETRY_PARSERS_={"http://www.opengis.net/gml":{Point:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint),MultiPoint:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPoint),LineString:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLineString),MultiLineString:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiLineString),LinearRing:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLinearRing),Polygon:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon),
MultiPolygon:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPolygon),Surface:ol.xml.makeReplacer(ol.format.GML3.prototype.readSurface_),MultiSurface:ol.xml.makeReplacer(ol.format.GML3.prototype.readMultiSurface_),Curve:ol.xml.makeReplacer(ol.format.GML3.prototype.readCurve_),MultiCurve:ol.xml.makeReplacer(ol.format.GML3.prototype.readMultiCurve_),Envelope:ol.xml.makeReplacer(ol.format.GML3.prototype.readEnvelope_)}};
ol.format.GML3.prototype.MULTICURVE_PARSERS_={"http://www.opengis.net/gml":{curveMember:ol.xml.makeArrayPusher(ol.format.GML3.prototype.curveMemberParser_),curveMembers:ol.xml.makeArrayPusher(ol.format.GML3.prototype.curveMemberParser_)}};ol.format.GML3.prototype.MULTISURFACE_PARSERS_={"http://www.opengis.net/gml":{surfaceMember:ol.xml.makeArrayPusher(ol.format.GML3.prototype.surfaceMemberParser_),surfaceMembers:ol.xml.makeArrayPusher(ol.format.GML3.prototype.surfaceMemberParser_)}};
ol.format.GML3.prototype.CURVEMEMBER_PARSERS_={"http://www.opengis.net/gml":{LineString:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readLineString),Curve:ol.xml.makeArrayPusher(ol.format.GML3.prototype.readCurve_)}};ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_={"http://www.opengis.net/gml":{Polygon:ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readPolygon),Surface:ol.xml.makeArrayPusher(ol.format.GML3.prototype.readSurface_)}};ol.format.GML3.prototype.SURFACE_PARSERS_={"http://www.opengis.net/gml":{patches:ol.xml.makeReplacer(ol.format.GML3.prototype.readPatch_)}};
ol.format.GML3.prototype.CURVE_PARSERS_={"http://www.opengis.net/gml":{segments:ol.xml.makeReplacer(ol.format.GML3.prototype.readSegment_)}};ol.format.GML3.prototype.ENVELOPE_PARSERS_={"http://www.opengis.net/gml":{lowerCorner:ol.xml.makeArrayPusher(ol.format.GML3.prototype.readFlatPosList_),upperCorner:ol.xml.makeArrayPusher(ol.format.GML3.prototype.readFlatPosList_)}};ol.format.GML3.prototype.PATCHES_PARSERS_={"http://www.opengis.net/gml":{PolygonPatch:ol.xml.makeReplacer(ol.format.GML3.prototype.readPolygonPatch_)}};
ol.format.GML3.prototype.SEGMENTS_PARSERS_={"http://www.opengis.net/gml":{LineStringSegment:ol.xml.makeReplacer(ol.format.GML3.prototype.readLineStringSegment_)}};ol.format.GML3.prototype.writePos_=function(a,b,c){var d=c[c.length-1];c=d.hasZ;a.setAttribute("srsDimension",c?3:2);var e=d.srsName;d="enu";e&&(d=ol.proj.get(e).getAxisOrientation());b=b.getCoordinates();d="en"===d.substr(0,2)?b[0]+" "+b[1]:b[1]+" "+b[0];c&&(d+=" "+(b[2]||0));ol.format.XSD.writeStringTextNode(a,d)};
ol.format.GML3.prototype.getCoords_=function(a,b,c){var d="enu";b&&(d=ol.proj.get(b).getAxisOrientation());b="en"===d.substr(0,2)?a[0]+" "+a[1]:a[1]+" "+a[0];c&&(b+=" "+(a[2]||0));return b};ol.format.GML3.prototype.writePosList_=function(a,b,c){var d=c[c.length-1];c=d.hasZ;a.setAttribute("srsDimension",c?3:2);d=d.srsName;b=b.getCoordinates();for(var e=b.length,f=Array(e),g,h=0;h<e;++h)g=b[h],f[h]=this.getCoords_(g,d,c);ol.format.XSD.writeStringTextNode(a,f.join(" "))};
ol.format.GML3.prototype.writePoint_=function(a,b,c){var d=c[c.length-1].srsName;d&&a.setAttribute("srsName",d);d=ol.xml.createElementNS(a.namespaceURI,"pos");a.appendChild(d);this.writePos_(d,b,c)};ol.format.GML3.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),upperCorner:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};
ol.format.GML3.prototype.writeEnvelope=function(a,b,c){var d=c[c.length-1].srsName;d&&a.setAttribute("srsName",d);ol.xml.pushSerializeAndPop({node:a},ol.format.GML3.ENVELOPE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b[0]+" "+b[1],b[2]+" "+b[3]],c,["lowerCorner","upperCorner"],this)};ol.format.GML3.prototype.writeLinearRing_=function(a,b,c){var d=c[c.length-1].srsName;d&&a.setAttribute("srsName",d);d=ol.xml.createElementNS(a.namespaceURI,"posList");a.appendChild(d);this.writePosList_(d,b,c)};
ol.format.GML3.prototype.RING_NODE_FACTORY_=function(a,b,c){a=b[b.length-1];b=a.node;c=a.exteriorWritten;void 0===c&&(a.exteriorWritten=!0);return ol.xml.createElementNS(b.namespaceURI,void 0!==c?"interior":"exterior")};
ol.format.GML3.prototype.writeSurfaceOrPolygon_=function(a,b,c){var d=c[c.length-1],e=d.hasZ;d=d.srsName;"PolygonPatch"!==a.nodeName&&d&&a.setAttribute("srsName",d);"Polygon"===a.nodeName||"PolygonPatch"===a.nodeName?(b=b.getLinearRings(),ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:d},ol.format.GML3.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,b,c,void 0,this)):"Surface"===a.nodeName&&(e=ol.xml.createElementNS(a.namespaceURI,"patches"),a.appendChild(e),this.writeSurfacePatches_(e,b,c))};
ol.format.GML3.prototype.writeCurveOrLineString_=function(a,b,c){var d=c[c.length-1].srsName;"LineStringSegment"!==a.nodeName&&d&&a.setAttribute("srsName",d);"LineString"===a.nodeName||"LineStringSegment"===a.nodeName?(d=ol.xml.createElementNS(a.namespaceURI,"posList"),a.appendChild(d),this.writePosList_(d,b,c)):"Curve"===a.nodeName&&(d=ol.xml.createElementNS(a.namespaceURI,"segments"),a.appendChild(d),this.writeCurveSegments_(d,b,c))};
ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_=function(a,b,c){var d=c[c.length-1],e=d.hasZ,f=d.srsName;d=d.surface;f&&a.setAttribute("srsName",f);b=b.getPolygons();ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:f,surface:d},ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,b,c,void 0,this)};
ol.format.GML3.prototype.writeMultiPoint_=function(a,b,c){var d=c[c.length-1],e=d.srsName;d=d.hasZ;e&&a.setAttribute("srsName",e);b=b.getPoints();ol.xml.pushSerializeAndPop({node:a,hasZ:d,srsName:e},ol.format.GML3.POINTMEMBER_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("pointMember"),b,c,void 0,this)};
ol.format.GML3.prototype.writeMultiCurveOrLineString_=function(a,b,c){var d=c[c.length-1],e=d.hasZ,f=d.srsName;d=d.curve;f&&a.setAttribute("srsName",f);b=b.getLineStrings();ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:f,curve:d},ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,b,c,void 0,this)};ol.format.GML3.prototype.writeRing_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"LinearRing");a.appendChild(d);this.writeLinearRing_(d,b,c)};
ol.format.GML3.prototype.writeSurfaceOrPolygonMember_=function(a,b,c){var d=this.GEOMETRY_NODE_FACTORY_(b,c);d&&(a.appendChild(d),this.writeSurfaceOrPolygon_(d,b,c))};ol.format.GML3.prototype.writePointMember_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"Point");a.appendChild(d);this.writePoint_(d,b,c)};ol.format.GML3.prototype.writeLineStringOrCurveMember_=function(a,b,c){var d=this.GEOMETRY_NODE_FACTORY_(b,c);d&&(a.appendChild(d),this.writeCurveOrLineString_(d,b,c))};
ol.format.GML3.prototype.writeSurfacePatches_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"PolygonPatch");a.appendChild(d);this.writeSurfaceOrPolygon_(d,b,c)};ol.format.GML3.prototype.writeCurveSegments_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"LineStringSegment");a.appendChild(d);this.writeCurveOrLineString_(d,b,c)};
ol.format.GML3.prototype.writeGeometryElement=function(a,b,c){var d=c[c.length-1],e=ol.obj.assign({},d);e.node=a;a=Array.isArray(b)?d.dataProjection?ol.proj.transformExtent(b,d.featureProjection,d.dataProjection):b:ol.format.Feature.transformWithOptions(b,!0,d);ol.xml.pushSerializeAndPop(e,ol.format.GML3.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[a],c,void 0,this)};
ol.format.GML3.prototype.writeFeatureElement=function(a,b,c){var d=b.getId();d&&a.setAttribute("fid",d);d=c[c.length-1];var e=d.featureNS,f=b.getGeometryName();d.serializers||(d.serializers={},d.serializers[e]={});var g=b.getProperties();b=[];var h=[];for(l in g){var k=g[l];null!==k&&(b.push(l),h.push(k),l==f||k instanceof ol.geom.Geometry?l in d.serializers[e]||(d.serializers[e][l]=ol.xml.makeChildAppender(this.writeGeometryElement,this)):l in d.serializers[e]||(d.serializers[e][l]=ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)))}var l=
ol.obj.assign({},d);l.node=a;ol.xml.pushSerializeAndPop(l,d.serializers,ol.xml.makeSimpleNodeFactory(void 0,e),h,c,b)};ol.format.GML3.prototype.writeFeatureMembers_=function(a,b,c){var d=c[c.length-1],e=d.featureType,f=d.featureNS,g={};g[f]={};g[f][e]=ol.xml.makeChildAppender(this.writeFeatureElement,this);d=ol.obj.assign({},d);d.node=a;ol.xml.pushSerializeAndPop(d,g,ol.xml.makeSimpleNodeFactory(e,f),b,c)};
ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygonMember_),polygonMember:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygonMember_)}};ol.format.GML3.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:ol.xml.makeChildAppender(ol.format.GML3.prototype.writePointMember_)}};
ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLineStringOrCurveMember_),curveMember:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLineStringOrCurveMember_)}};ol.format.GML3.RING_SERIALIZERS_={"http://www.opengis.net/gml":{exterior:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_),interior:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_)}};
ol.format.GML3.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeCurveOrLineString_),MultiCurve:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiCurveOrLineString_),Point:ol.xml.makeChildAppender(ol.format.GML3.prototype.writePoint_),MultiPoint:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiPoint_),LineString:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeCurveOrLineString_),MultiLineString:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiCurveOrLineString_),
LinearRing:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLinearRing_),Polygon:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygon_),MultiPolygon:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_),Surface:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygon_),MultiSurface:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_),Envelope:ol.xml.makeChildAppender(ol.format.GML3.prototype.writeEnvelope)}};
ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"};ol.format.GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(a,b,c){return ol.xml.createElementNS("http://www.opengis.net/gml",ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_[b[b.length-1].node.nodeName])};
ol.format.GML3.prototype.GEOMETRY_NODE_FACTORY_=function(a,b,c){var d=b[b.length-1];b=d.multiSurface;c=d.surface;var e=d.curve;d=d.multiCurve;Array.isArray(a)?a="Envelope":(a=a.getType(),"MultiPolygon"===a&&!0===b?a="MultiSurface":"Polygon"===a&&!0===c?a="Surface":"LineString"===a&&!0===e?a="Curve":"MultiLineString"===a&&!0===d&&(a="MultiCurve"));return ol.xml.createElementNS("http://www.opengis.net/gml",a)};
ol.format.GML3.prototype.writeGeometryNode=function(a,b){b=this.adaptOptions(b);var c=ol.xml.createElementNS("http://www.opengis.net/gml","geom"),d={node:c,hasZ:this.hasZ,srsName:this.srsName,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_};b&&ol.obj.assign(d,b);this.writeGeometryElement(c,a,[d]);return c};
ol.format.GML3.prototype.writeFeaturesNode=function(a,b){b=this.adaptOptions(b);var c=ol.xml.createElementNS("http://www.opengis.net/gml","featureMembers");ol.xml.setAttributeNS(c,"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",this.schemaLocation);var d={srsName:this.srsName,hasZ:this.hasZ,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_,featureNS:this.featureNS,featureType:this.featureType};b&&ol.obj.assign(d,b);this.writeFeatureMembers_(c,
a,[d]);return c};ol.format.GML=ol.format.GML3;ol.format.GML2=function(a){a=a?a:{};ol.format.GMLBase.call(this,a);this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS].featureMember=ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);this.schemaLocation=a.schemaLocation?a.schemaLocation:ol.format.GML2.schemaLocation_};ol.inherits(ol.format.GML2,ol.format.GMLBase);ol.format.GML2.schemaLocation_=ol.format.GMLBase.GMLNS+" http://schemas.opengis.net/gml/2.1.2/feature.xsd";
ol.format.GML2.prototype.readFlatCoordinates_=function(a,b){a=ol.xml.getAllTextContent(a,!1).replace(/^\s*|\s*$/g,"");var c=b[0].srsName;b="enu";c&&(c=ol.proj.get(c))&&(b=c.getAxisOrientation());a=a.trim().split(/\s+/);for(var d,e,f=[],g=0,h=a.length;g<h;g++)e=a[g].split(/,+/),c=parseFloat(e[0]),d=parseFloat(e[1]),e=3===e.length?parseFloat(e[2]):0,"en"===b.substr(0,2)?f.push(c,d,e):f.push(d,c,e);return f};
ol.format.GML2.prototype.readBox_=function(a,b){a=ol.xml.pushParseAndPop([null],this.BOX_PARSERS_,a,b,this);return ol.extent.createOrUpdate(a[1][0],a[1][1],a[1][3],a[1][4])};ol.format.GML2.prototype.innerBoundaryIsParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,this.RING_PARSERS,a,b,this))&&b[b.length-1].push(a)};ol.format.GML2.prototype.outerBoundaryIsParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,this.RING_PARSERS,a,b,this))&&(b[b.length-1][0]=a)};
ol.format.GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_={"http://www.opengis.net/gml":{coordinates:ol.xml.makeReplacer(ol.format.GML2.prototype.readFlatCoordinates_)}};ol.format.GML2.prototype.FLAT_LINEAR_RINGS_PARSERS_={"http://www.opengis.net/gml":{innerBoundaryIs:ol.format.GML2.prototype.innerBoundaryIsParser_,outerBoundaryIs:ol.format.GML2.prototype.outerBoundaryIsParser_}};ol.format.GML2.prototype.BOX_PARSERS_={"http://www.opengis.net/gml":{coordinates:ol.xml.makeArrayPusher(ol.format.GML2.prototype.readFlatCoordinates_)}};
ol.format.GML2.prototype.GEOMETRY_PARSERS_={"http://www.opengis.net/gml":{Point:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint),MultiPoint:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPoint),LineString:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLineString),MultiLineString:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiLineString),LinearRing:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLinearRing),Polygon:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon),
MultiPolygon:ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPolygon),Box:ol.xml.makeReplacer(ol.format.GML2.prototype.readBox_)}};ol.format.GML2.prototype.GEOMETRY_NODE_FACTORY_=function(a,b,c){var d=b[b.length-1];b=d.multiSurface;c=d.surface;d=d.multiCurve;Array.isArray(a)?a="Envelope":(a=a.getType(),"MultiPolygon"===a&&!0===b?a="MultiSurface":"Polygon"===a&&!0===c?a="Surface":"MultiLineString"===a&&!0===d&&(a="MultiCurve"));return ol.xml.createElementNS("http://www.opengis.net/gml",a)};
ol.format.GML2.prototype.writeFeatureElement=function(a,b,c){var d=b.getId();d&&a.setAttribute("fid",d);d=c[c.length-1];var e=d.featureNS,f=b.getGeometryName();d.serializers||(d.serializers={},d.serializers[e]={});var g=b.getProperties();b=[];var h=[];for(l in g){var k=g[l];null!==k&&(b.push(l),h.push(k),l==f||k instanceof ol.geom.Geometry?l in d.serializers[e]||(d.serializers[e][l]=ol.xml.makeChildAppender(this.writeGeometryElement,this)):l in d.serializers[e]||(d.serializers[e][l]=ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)))}var l=
ol.obj.assign({},d);l.node=a;ol.xml.pushSerializeAndPop(l,d.serializers,ol.xml.makeSimpleNodeFactory(void 0,e),h,c,b)};ol.format.GML2.prototype.writeGeometryElement=function(a,b,c){var d=c[c.length-1],e=ol.obj.assign({},d);e.node=a;a=Array.isArray(b)?d.dataProjection?ol.proj.transformExtent(b,d.featureProjection,d.dataProjection):b:ol.format.Feature.transformWithOptions(b,!0,d);ol.xml.pushSerializeAndPop(e,ol.format.GML2.GEOMETRY_SERIALIZERS_,this.GEOMETRY_NODE_FACTORY_,[a],c,void 0,this)};
ol.format.GML2.prototype.writeCurveOrLineString_=function(a,b,c){var d=c[c.length-1].srsName;"LineStringSegment"!==a.nodeName&&d&&a.setAttribute("srsName",d);"LineString"===a.nodeName||"LineStringSegment"===a.nodeName?(d=this.createCoordinatesNode_(a.namespaceURI),a.appendChild(d),this.writeCoordinates_(d,b,c)):"Curve"===a.nodeName&&(d=ol.xml.createElementNS(a.namespaceURI,"segments"),a.appendChild(d),this.writeCurveSegments_(d,b,c))};
ol.format.GML2.prototype.createCoordinatesNode_=function(a){a=ol.xml.createElementNS(a,"coordinates");a.setAttribute("decimal",".");a.setAttribute("cs",",");a.setAttribute("ts"," ");return a};ol.format.GML2.prototype.writeCoordinates_=function(a,b,c){var d=c[c.length-1];c=d.hasZ;d=d.srsName;b=b.getCoordinates();for(var e=b.length,f=Array(e),g,h=0;h<e;++h)g=b[h],f[h]=this.getCoords_(g,d,c);ol.format.XSD.writeStringTextNode(a,f.join(" "))};
ol.format.GML2.prototype.writeCurveSegments_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"LineStringSegment");a.appendChild(d);this.writeCurveOrLineString_(d,b,c)};
ol.format.GML2.prototype.writeSurfaceOrPolygon_=function(a,b,c){var d=c[c.length-1],e=d.hasZ;d=d.srsName;"PolygonPatch"!==a.nodeName&&d&&a.setAttribute("srsName",d);"Polygon"===a.nodeName||"PolygonPatch"===a.nodeName?(b=b.getLinearRings(),ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:d},ol.format.GML2.RING_SERIALIZERS_,this.RING_NODE_FACTORY_,b,c,void 0,this)):"Surface"===a.nodeName&&(e=ol.xml.createElementNS(a.namespaceURI,"patches"),a.appendChild(e),this.writeSurfacePatches_(e,b,c))};
ol.format.GML2.prototype.RING_NODE_FACTORY_=function(a,b,c){a=b[b.length-1];b=a.node;c=a.exteriorWritten;void 0===c&&(a.exteriorWritten=!0);return ol.xml.createElementNS(b.namespaceURI,void 0!==c?"innerBoundaryIs":"outerBoundaryIs")};ol.format.GML2.prototype.writeSurfacePatches_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"PolygonPatch");a.appendChild(d);this.writeSurfaceOrPolygon_(d,b,c)};
ol.format.GML2.prototype.writeRing_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"LinearRing");a.appendChild(d);this.writeLinearRing_(d,b,c)};ol.format.GML2.prototype.getCoords_=function(a,b,c){var d="enu";b&&(d=ol.proj.get(b).getAxisOrientation());b="en"===d.substr(0,2)?a[0]+","+a[1]:a[1]+","+a[0];c&&(b+=","+(a[2]||0));return b};
ol.format.GML2.prototype.writeMultiCurveOrLineString_=function(a,b,c){var d=c[c.length-1],e=d.hasZ,f=d.srsName;d=d.curve;f&&a.setAttribute("srsName",f);b=b.getLineStrings();ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:f,curve:d},ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,b,c,void 0,this)};
ol.format.GML2.prototype.writePoint_=function(a,b,c){var d=c[c.length-1];c=d.hasZ;var e=d.srsName;e&&a.setAttribute("srsName",e);d=this.createCoordinatesNode_(a.namespaceURI);a.appendChild(d);a=b.getCoordinates();a=this.getCoords_(a,e,c);ol.format.XSD.writeStringTextNode(d,a)};
ol.format.GML2.prototype.writeMultiPoint_=function(a,b,c){var d=c[c.length-1],e=d.hasZ;(d=d.srsName)&&a.setAttribute("srsName",d);b=b.getPoints();ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:d},ol.format.GML2.POINTMEMBER_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("pointMember"),b,c,void 0,this)};ol.format.GML2.prototype.writePointMember_=function(a,b,c){var d=ol.xml.createElementNS(a.namespaceURI,"Point");a.appendChild(d);this.writePoint_(d,b,c)};
ol.format.GML2.prototype.writeLineStringOrCurveMember_=function(a,b,c){var d=this.GEOMETRY_NODE_FACTORY_(b,c);d&&(a.appendChild(d),this.writeCurveOrLineString_(d,b,c))};ol.format.GML2.prototype.writeLinearRing_=function(a,b,c){var d=c[c.length-1].srsName;d&&a.setAttribute("srsName",d);d=this.createCoordinatesNode_(a.namespaceURI);a.appendChild(d);this.writeCoordinates_(d,b,c)};
ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_=function(a,b,c){var d=c[c.length-1],e=d.hasZ,f=d.srsName;d=d.surface;f&&a.setAttribute("srsName",f);b=b.getPolygons();ol.xml.pushSerializeAndPop({node:a,hasZ:e,srsName:f,surface:d},ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_,this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,b,c,void 0,this)};
ol.format.GML2.prototype.writeSurfaceOrPolygonMember_=function(a,b,c){var d=this.GEOMETRY_NODE_FACTORY_(b,c);d&&(a.appendChild(d),this.writeSurfaceOrPolygon_(d,b,c))};ol.format.GML2.prototype.writeEnvelope=function(a,b,c){var d=c[c.length-1].srsName;d&&a.setAttribute("srsName",d);ol.xml.pushSerializeAndPop({node:a},ol.format.GML2.ENVELOPE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b[0]+" "+b[1],b[2]+" "+b[3]],c,["lowerCorner","upperCorner"],this)};
ol.format.GML2.GEOMETRY_SERIALIZERS_={"http://www.opengis.net/gml":{Curve:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeCurveOrLineString_),MultiCurve:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiCurveOrLineString_),Point:ol.xml.makeChildAppender(ol.format.GML2.prototype.writePoint_),MultiPoint:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiPoint_),LineString:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeCurveOrLineString_),MultiLineString:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiCurveOrLineString_),
LinearRing:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLinearRing_),Polygon:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygon_),MultiPolygon:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_),Surface:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygon_),MultiSurface:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_),Envelope:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeEnvelope)}};
ol.format.GML2.RING_SERIALIZERS_={"http://www.opengis.net/gml":{outerBoundaryIs:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_),innerBoundaryIs:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_)}};ol.format.GML2.POINTMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{pointMember:ol.xml.makeChildAppender(ol.format.GML2.prototype.writePointMember_)}};
ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{lineStringMember:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLineStringOrCurveMember_),curveMember:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLineStringOrCurveMember_)}};ol.format.GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_=function(a,b,c){return ol.xml.createElementNS("http://www.opengis.net/gml",ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_[b[b.length-1].node.nodeName])};
ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_={MultiLineString:"lineStringMember",MultiCurve:"curveMember",MultiPolygon:"polygonMember",MultiSurface:"surfaceMember"};ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_={"http://www.opengis.net/gml":{surfaceMember:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygonMember_),polygonMember:ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygonMember_)}};
ol.format.GML2.ENVELOPE_SERIALIZERS_={"http://www.opengis.net/gml":{lowerCorner:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),upperCorner:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};ol.format.GPX=function(a){a=a?a:{};ol.format.XMLFeature.call(this);this.defaultDataProjection=ol.proj.get("EPSG:4326");this.readExtensions_=a.readExtensions};ol.inherits(ol.format.GPX,ol.format.XMLFeature);ol.format.GPX.NAMESPACE_URIS_=[null,"http://www.topografix.com/GPX/1/0","http://www.topografix.com/GPX/1/1"];ol.format.GPX.SCHEMA_LOCATION_="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
ol.format.GPX.appendCoordinate_=function(a,b,c,d){a.push(parseFloat(c.getAttribute("lon")),parseFloat(c.getAttribute("lat")));"ele"in d?(a.push(d.ele),delete d.ele,b.hasZ=!0):a.push(0);"time"in d?(a.push(d.time),delete d.time,b.hasM=!0):a.push(0);return a};
ol.format.GPX.applyLayoutOptions_=function(a,b,c){var d=ol.geom.GeometryLayout.XY,e=2;a.hasZ&&a.hasM?(d=ol.geom.GeometryLayout.XYZM,e=4):a.hasZ?(d=ol.geom.GeometryLayout.XYZ,e=3):a.hasM&&(d=ol.geom.GeometryLayout.XYM,e=3);if(4!==e){var f;var g=0;for(f=b.length/4;g<f;g++)b[g*e]=b[4*g],b[g*e+1]=b[4*g+1],a.hasZ&&(b[g*e+2]=b[4*g+2]),a.hasM&&(b[g*e+2]=b[4*g+3]);b.length=b.length/4*e;if(c)for(g=0,f=c.length;g<f;g++)c[g]=c[g]/4*e}return d};
ol.format.GPX.parseLink_=function(a,b){var c=b[b.length-1],d=a.getAttribute("href");null!==d&&(c.link=d);ol.xml.parseNode(ol.format.GPX.LINK_PARSERS_,a,b)};ol.format.GPX.parseExtensions_=function(a,b){b[b.length-1].extensionsNode_=a};ol.format.GPX.parseRtePt_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.GPX.RTEPT_PARSERS_,a,b);c&&(b=b[b.length-1],ol.format.GPX.appendCoordinate_(b.flatCoordinates,b.layoutOptions,a,c))};
ol.format.GPX.parseTrkPt_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.GPX.TRKPT_PARSERS_,a,b);c&&(b=b[b.length-1],ol.format.GPX.appendCoordinate_(b.flatCoordinates,b.layoutOptions,a,c))};ol.format.GPX.parseTrkSeg_=function(a,b){var c=b[b.length-1];ol.xml.parseNode(ol.format.GPX.TRKSEG_PARSERS_,a,b);c.ends.push(c.flatCoordinates.length)};
ol.format.GPX.readRte_=function(a,b){var c=b[0];if(a=ol.xml.pushParseAndPop({flatCoordinates:[],layoutOptions:{}},ol.format.GPX.RTE_PARSERS_,a,b)){b=a.flatCoordinates;delete a.flatCoordinates;var d=a.layoutOptions;delete a.layoutOptions;d=ol.format.GPX.applyLayoutOptions_(d,b);var e=new ol.geom.LineString(null);e.setFlatCoordinates(d,b);ol.format.Feature.transformWithOptions(e,!1,c);c=new ol.Feature(e);c.setProperties(a);return c}};
ol.format.GPX.readTrk_=function(a,b){var c=b[0];if(a=ol.xml.pushParseAndPop({flatCoordinates:[],ends:[],layoutOptions:{}},ol.format.GPX.TRK_PARSERS_,a,b)){b=a.flatCoordinates;delete a.flatCoordinates;var d=a.ends;delete a.ends;var e=a.layoutOptions;delete a.layoutOptions;e=ol.format.GPX.applyLayoutOptions_(e,b,d);var f=new ol.geom.MultiLineString(null);f.setFlatCoordinates(e,b,d);ol.format.Feature.transformWithOptions(f,!1,c);c=new ol.Feature(f);c.setProperties(a);return c}};
ol.format.GPX.readWpt_=function(a,b){var c=b[0];if(b=ol.xml.pushParseAndPop({},ol.format.GPX.WPT_PARSERS_,a,b)){var d={};a=ol.format.GPX.appendCoordinate_([],d,a,b);d=ol.format.GPX.applyLayoutOptions_(d,a);a=new ol.geom.Point(a,d);ol.format.Feature.transformWithOptions(a,!1,c);c=new ol.Feature(a);c.setProperties(b);return c}};ol.format.GPX.FEATURE_READER_={rte:ol.format.GPX.readRte_,trk:ol.format.GPX.readTrk_,wpt:ol.format.GPX.readWpt_};
ol.format.GPX.GPX_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{rte:ol.xml.makeArrayPusher(ol.format.GPX.readRte_),trk:ol.xml.makeArrayPusher(ol.format.GPX.readTrk_),wpt:ol.xml.makeArrayPusher(ol.format.GPX.readWpt_)});ol.format.GPX.LINK_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{text:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString,"linkText"),type:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString,"linkType")});
ol.format.GPX.RTE_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),cmt:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),desc:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),src:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),link:ol.format.GPX.parseLink_,number:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),extensions:ol.format.GPX.parseExtensions_,type:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
rtept:ol.format.GPX.parseRtePt_});ol.format.GPX.RTEPT_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{ele:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),time:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)});
ol.format.GPX.TRK_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),cmt:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),desc:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),src:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),link:ol.format.GPX.parseLink_,number:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),type:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
extensions:ol.format.GPX.parseExtensions_,trkseg:ol.format.GPX.parseTrkSeg_});ol.format.GPX.TRKSEG_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{trkpt:ol.format.GPX.parseTrkPt_});ol.format.GPX.TRKPT_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{ele:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),time:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)});
ol.format.GPX.WPT_PARSERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{ele:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),time:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime),magvar:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),geoidheight:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),cmt:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),desc:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
src:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),link:ol.format.GPX.parseLink_,sym:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),type:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),fix:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),sat:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),hdop:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),vdop:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),pdop:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
ageofdgpsdata:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),dgpsid:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),extensions:ol.format.GPX.parseExtensions_});ol.format.GPX.prototype.handleReadExtensions_=function(a){a||(a=[]);for(var b=0,c=a.length;b<c;++b){var d=a[b];if(this.readExtensions_){var e=d.get("extensionsNode_")||null;this.readExtensions_(d,e)}d.set("extensionsNode_",void 0)}};
ol.format.GPX.prototype.readFeatureFromNode=function(a,b){if(!ol.array.includes(ol.format.GPX.NAMESPACE_URIS_,a.namespaceURI))return null;var c=ol.format.GPX.FEATURE_READER_[a.localName];if(!c)return null;a=c(a,[this.getReadOptions(a,b)]);if(!a)return null;this.handleReadExtensions_([a]);return a};
ol.format.GPX.prototype.readFeaturesFromNode=function(a,b){return ol.array.includes(ol.format.GPX.NAMESPACE_URIS_,a.namespaceURI)?"gpx"==a.localName&&(a=ol.xml.pushParseAndPop([],ol.format.GPX.GPX_PARSERS_,a,[this.getReadOptions(a,b)]))?(this.handleReadExtensions_(a),a):[]:[]};
ol.format.GPX.writeLink_=function(a,b,c){a.setAttribute("href",b);b=c[c.length-1].properties;ol.xml.pushSerializeAndPop({node:a},ol.format.GPX.LINK_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b.linkText,b.linkType],c,ol.format.GPX.LINK_SEQUENCE_)};
ol.format.GPX.writeWptType_=function(a,b,c){var d=c[c.length-1],e=d.node.namespaceURI,f=d.properties;ol.xml.setAttributeNS(a,null,"lat",b[1]);ol.xml.setAttributeNS(a,null,"lon",b[0]);switch(d.geometryLayout){case ol.geom.GeometryLayout.XYZM:0!==b[3]&&(f.time=b[3]);case ol.geom.GeometryLayout.XYZ:0!==b[2]&&(f.ele=b[2]);break;case ol.geom.GeometryLayout.XYM:0!==b[2]&&(f.time=b[2])}b="rtept"==a.nodeName?ol.format.GPX.RTEPT_TYPE_SEQUENCE_[e]:ol.format.GPX.WPT_TYPE_SEQUENCE_[e];d=ol.xml.makeSequence(f,
b);ol.xml.pushSerializeAndPop({node:a,properties:f},ol.format.GPX.WPT_TYPE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,d,c,b)};
ol.format.GPX.writeRte_=function(a,b,c){var d=c[0],e=b.getProperties();a={node:a,properties:e};if(b=b.getGeometry())b=ol.format.Feature.transformWithOptions(b,!0,d),a.geometryLayout=b.getLayout(),e.rtept=b.getCoordinates();d=ol.format.GPX.RTE_SEQUENCE_[c[c.length-1].node.namespaceURI];e=ol.xml.makeSequence(e,d);ol.xml.pushSerializeAndPop(a,ol.format.GPX.RTE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,e,c,d)};
ol.format.GPX.writeTrk_=function(a,b,c){var d=c[0],e=b.getProperties();a={node:a,properties:e};if(b=b.getGeometry())b=ol.format.Feature.transformWithOptions(b,!0,d),e.trkseg=b.getLineStrings();d=ol.format.GPX.TRK_SEQUENCE_[c[c.length-1].node.namespaceURI];e=ol.xml.makeSequence(e,d);ol.xml.pushSerializeAndPop(a,ol.format.GPX.TRK_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,e,c,d)};
ol.format.GPX.writeTrkSeg_=function(a,b,c){a={node:a,geometryLayout:b.getLayout(),properties:{}};ol.xml.pushSerializeAndPop(a,ol.format.GPX.TRKSEG_SERIALIZERS_,ol.format.GPX.TRKSEG_NODE_FACTORY_,b.getCoordinates(),c)};ol.format.GPX.writeWpt_=function(a,b,c){var d=c[0],e=c[c.length-1];e.properties=b.getProperties();if(b=b.getGeometry())b=ol.format.Feature.transformWithOptions(b,!0,d),e.geometryLayout=b.getLayout(),ol.format.GPX.writeWptType_(a,b.getCoordinates(),c)};
ol.format.GPX.LINK_SEQUENCE_=["text","type"];ol.format.GPX.LINK_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{text:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),type:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)});ol.format.GPX.RTE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,"name cmt desc src link number type rtept".split(" "));
ol.format.GPX.RTE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{name:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),cmt:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),desc:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),src:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),link:ol.xml.makeChildAppender(ol.format.GPX.writeLink_),number:ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode),type:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
rtept:ol.xml.makeArraySerializer(ol.xml.makeChildAppender(ol.format.GPX.writeWptType_))});ol.format.GPX.RTEPT_TYPE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,["ele","time"]);ol.format.GPX.TRK_SEQUENCE_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,"name cmt desc src link number type trkseg".split(" "));
ol.format.GPX.TRK_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{name:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),cmt:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),desc:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),src:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),link:ol.xml.makeChildAppender(ol.format.GPX.writeLink_),number:ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode),type:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
trkseg:ol.xml.makeArraySerializer(ol.xml.makeChildAppender(ol.format.GPX.writeTrkSeg_))});ol.format.GPX.TRKSEG_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("trkpt");ol.format.GPX.TRKSEG_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{trkpt:ol.xml.makeChildAppender(ol.format.GPX.writeWptType_)});ol.format.GPX.WPT_TYPE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,"ele time magvar geoidheight name cmt desc src link sym type fix sat hdop vdop pdop ageofdgpsdata dgpsid".split(" "));
ol.format.GPX.WPT_TYPE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{ele:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),time:ol.xml.makeChildAppender(ol.format.XSD.writeDateTimeTextNode),magvar:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),geoidheight:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),name:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),cmt:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),desc:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
src:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),link:ol.xml.makeChildAppender(ol.format.GPX.writeLink_),sym:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),type:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),fix:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),sat:ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode),hdop:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),vdop:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
pdop:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),ageofdgpsdata:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),dgpsid:ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode)});ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_={Point:"wpt",LineString:"rte",MultiLineString:"trk"};
ol.format.GPX.GPX_NODE_FACTORY_=function(a,b,c){if(a=a.getGeometry())if(a=ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_[a.getType()])return ol.xml.createElementNS(b[b.length-1].node.namespaceURI,a)};ol.format.GPX.GPX_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_,{rte:ol.xml.makeChildAppender(ol.format.GPX.writeRte_),trk:ol.xml.makeChildAppender(ol.format.GPX.writeTrk_),wpt:ol.xml.makeChildAppender(ol.format.GPX.writeWpt_)});
ol.format.GPX.prototype.writeFeaturesNode=function(a,b){b=this.adaptOptions(b);var c=ol.xml.createElementNS("http://www.topografix.com/GPX/1/1","gpx");ol.xml.setAttributeNS(c,"http://www.w3.org/2000/xmlns/","xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance");ol.xml.setAttributeNS(c,"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",ol.format.GPX.SCHEMA_LOCATION_);c.setAttribute("version","1.1");c.setAttribute("creator","OpenLayers");ol.xml.pushSerializeAndPop({node:c},ol.format.GPX.GPX_SERIALIZERS_,
ol.format.GPX.GPX_NODE_FACTORY_,a,[b]);return c};ol.geom.GeometryCollection=function(a){ol.geom.Geometry.call(this);this.geometries_=a?a:null;this.listenGeometriesChange_()};ol.inherits(ol.geom.GeometryCollection,ol.geom.Geometry);ol.geom.GeometryCollection.cloneGeometries_=function(a){var b=[],c;var d=0;for(c=a.length;d<c;++d)b.push(a[d].clone());return b};
ol.geom.GeometryCollection.prototype.unlistenGeometriesChange_=function(){var a;if(this.geometries_){var b=0;for(a=this.geometries_.length;b<a;++b)ol.events.unlisten(this.geometries_[b],ol.events.EventType.CHANGE,this.changed,this)}};ol.geom.GeometryCollection.prototype.listenGeometriesChange_=function(){var a;if(this.geometries_){var b=0;for(a=this.geometries_.length;b<a;++b)ol.events.listen(this.geometries_[b],ol.events.EventType.CHANGE,this.changed,this)}};
ol.geom.GeometryCollection.prototype.clone=function(){var a=new ol.geom.GeometryCollection(null);a.setGeometries(this.geometries_);return a};ol.geom.GeometryCollection.prototype.closestPointXY=function(a,b,c,d){if(d<ol.extent.closestSquaredDistanceXY(this.getExtent(),a,b))return d;var e=this.geometries_,f;var g=0;for(f=e.length;g<f;++g)d=e[g].closestPointXY(a,b,c,d);return d};
ol.geom.GeometryCollection.prototype.containsXY=function(a,b){var c=this.geometries_,d;var e=0;for(d=c.length;e<d;++e)if(c[e].containsXY(a,b))return!0;return!1};ol.geom.GeometryCollection.prototype.computeExtent=function(a){ol.extent.createOrUpdateEmpty(a);for(var b=this.geometries_,c=0,d=b.length;c<d;++c)ol.extent.extend(a,b[c].getExtent());return a};ol.geom.GeometryCollection.prototype.getGeometries=function(){return ol.geom.GeometryCollection.cloneGeometries_(this.geometries_)};
ol.geom.GeometryCollection.prototype.getGeometriesArray=function(){return this.geometries_};
ol.geom.GeometryCollection.prototype.getSimplifiedGeometry=function(a){this.simplifiedGeometryRevision!=this.getRevision()&&(ol.obj.clear(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision());if(0>a||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&a<this.simplifiedGeometryMaxMinSquaredTolerance)return this;var b=a.toString();if(this.simplifiedGeometryCache.hasOwnProperty(b))return this.simplifiedGeometryCache[b];var c=
[],d=this.geometries_,e=!1,f;var g=0;for(f=d.length;g<f;++g){var h=d[g],k=h.getSimplifiedGeometry(a);c.push(k);k!==h&&(e=!0)}if(e)return a=new ol.geom.GeometryCollection(null),a.setGeometriesArray(c),this.simplifiedGeometryCache[b]=a;this.simplifiedGeometryMaxMinSquaredTolerance=a;return this};ol.geom.GeometryCollection.prototype.getType=function(){return ol.geom.GeometryType.GEOMETRY_COLLECTION};
ol.geom.GeometryCollection.prototype.intersectsExtent=function(a){var b=this.geometries_,c;var d=0;for(c=b.length;d<c;++d)if(b[d].intersectsExtent(a))return!0;return!1};ol.geom.GeometryCollection.prototype.isEmpty=function(){return 0===this.geometries_.length};ol.geom.GeometryCollection.prototype.rotate=function(a,b){for(var c=this.geometries_,d=0,e=c.length;d<e;++d)c[d].rotate(a,b);this.changed()};
ol.geom.GeometryCollection.prototype.scale=function(a,b,c){c||(c=ol.extent.getCenter(this.getExtent()));for(var d=this.geometries_,e=0,f=d.length;e<f;++e)d[e].scale(a,b,c);this.changed()};ol.geom.GeometryCollection.prototype.setGeometries=function(a){this.setGeometriesArray(ol.geom.GeometryCollection.cloneGeometries_(a))};ol.geom.GeometryCollection.prototype.setGeometriesArray=function(a){this.unlistenGeometriesChange_();this.geometries_=a;this.listenGeometriesChange_();this.changed()};
ol.geom.GeometryCollection.prototype.applyTransform=function(a){var b=this.geometries_,c;var d=0;for(c=b.length;d<c;++d)b[d].applyTransform(a);this.changed()};ol.geom.GeometryCollection.prototype.translate=function(a,b){var c=this.geometries_,d;var e=0;for(d=c.length;e<d;++e)c[e].translate(a,b);this.changed()};ol.geom.GeometryCollection.prototype.disposeInternal=function(){this.unlistenGeometriesChange_();ol.geom.Geometry.prototype.disposeInternal.call(this)};ol.format.GeoJSON=function(a){a=a?a:{};ol.format.JSONFeature.call(this);this.defaultDataProjection=ol.proj.get(a.defaultDataProjection?a.defaultDataProjection:"EPSG:4326");a.featureProjection&&(this.defaultFeatureProjection=ol.proj.get(a.featureProjection));this.geometryName_=a.geometryName;this.extractGeometryName_=a.extractGeometryName};ol.inherits(ol.format.GeoJSON,ol.format.JSONFeature);
ol.format.GeoJSON.readGeometry_=function(a,b){return a?ol.format.Feature.transformWithOptions((0,ol.format.GeoJSON.GEOMETRY_READERS_[a.type])(a),!1,b):null};ol.format.GeoJSON.readGeometryCollectionGeometry_=function(a,b){a=a.geometries.map(function(a){return ol.format.GeoJSON.readGeometry_(a,b)});return new ol.geom.GeometryCollection(a)};ol.format.GeoJSON.readPointGeometry_=function(a){return new ol.geom.Point(a.coordinates)};ol.format.GeoJSON.readLineStringGeometry_=function(a){return new ol.geom.LineString(a.coordinates)};
ol.format.GeoJSON.readMultiLineStringGeometry_=function(a){return new ol.geom.MultiLineString(a.coordinates)};ol.format.GeoJSON.readMultiPointGeometry_=function(a){return new ol.geom.MultiPoint(a.coordinates)};ol.format.GeoJSON.readMultiPolygonGeometry_=function(a){return new ol.geom.MultiPolygon(a.coordinates)};ol.format.GeoJSON.readPolygonGeometry_=function(a){return new ol.geom.Polygon(a.coordinates)};
ol.format.GeoJSON.writeGeometry_=function(a,b){return(0,ol.format.GeoJSON.GEOMETRY_WRITERS_[a.getType()])(ol.format.Feature.transformWithOptions(a,!0,b),b)};ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_=function(a){return{type:"GeometryCollection",geometries:[]}};
ol.format.GeoJSON.writeGeometryCollectionGeometry_=function(a,b){return{type:"GeometryCollection",geometries:a.getGeometriesArray().map(function(a){var c=ol.obj.assign({},b);delete c.featureProjection;return ol.format.GeoJSON.writeGeometry_(a,c)})}};ol.format.GeoJSON.writeLineStringGeometry_=function(a,b){return{type:"LineString",coordinates:a.getCoordinates()}};ol.format.GeoJSON.writeMultiLineStringGeometry_=function(a,b){return{type:"MultiLineString",coordinates:a.getCoordinates()}};
ol.format.GeoJSON.writeMultiPointGeometry_=function(a,b){return{type:"MultiPoint",coordinates:a.getCoordinates()}};ol.format.GeoJSON.writeMultiPolygonGeometry_=function(a,b){if(b)var c=b.rightHanded;return{type:"MultiPolygon",coordinates:a.getCoordinates(c)}};ol.format.GeoJSON.writePointGeometry_=function(a,b){return{type:"Point",coordinates:a.getCoordinates()}};ol.format.GeoJSON.writePolygonGeometry_=function(a,b){if(b)var c=b.rightHanded;return{type:"Polygon",coordinates:a.getCoordinates(c)}};
ol.format.GeoJSON.GEOMETRY_READERS_={Point:ol.format.GeoJSON.readPointGeometry_,LineString:ol.format.GeoJSON.readLineStringGeometry_,Polygon:ol.format.GeoJSON.readPolygonGeometry_,MultiPoint:ol.format.GeoJSON.readMultiPointGeometry_,MultiLineString:ol.format.GeoJSON.readMultiLineStringGeometry_,MultiPolygon:ol.format.GeoJSON.readMultiPolygonGeometry_,GeometryCollection:ol.format.GeoJSON.readGeometryCollectionGeometry_};
ol.format.GeoJSON.GEOMETRY_WRITERS_={Point:ol.format.GeoJSON.writePointGeometry_,LineString:ol.format.GeoJSON.writeLineStringGeometry_,Polygon:ol.format.GeoJSON.writePolygonGeometry_,MultiPoint:ol.format.GeoJSON.writeMultiPointGeometry_,MultiLineString:ol.format.GeoJSON.writeMultiLineStringGeometry_,MultiPolygon:ol.format.GeoJSON.writeMultiPolygonGeometry_,GeometryCollection:ol.format.GeoJSON.writeGeometryCollectionGeometry_,Circle:ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_};
ol.format.GeoJSON.prototype.readFeatureFromObject=function(a,b){a="Feature"===a.type?a:{type:"Feature",geometry:a};b=ol.format.GeoJSON.readGeometry_(a.geometry,b);var c=new ol.Feature;this.geometryName_?c.setGeometryName(this.geometryName_):this.extractGeometryName_&&void 0!==a.geometry_name&&c.setGeometryName(a.geometry_name);c.setGeometry(b);void 0!==a.id&&c.setId(a.id);a.properties&&c.setProperties(a.properties);return c};
ol.format.GeoJSON.prototype.readFeaturesFromObject=function(a,b){if("FeatureCollection"===a.type){var c=[];a=a.features;var d;var e=0;for(d=a.length;e<d;++e)c.push(this.readFeatureFromObject(a[e],b))}else c=[this.readFeatureFromObject(a,b)];return c};ol.format.GeoJSON.prototype.readGeometryFromObject=function(a,b){return ol.format.GeoJSON.readGeometry_(a,b)};
ol.format.GeoJSON.prototype.readProjectionFromObject=function(a){a=a.crs;var b;a?"name"==a.type?b=ol.proj.get(a.properties.name):ol.asserts.assert(!1,36):b=this.defaultDataProjection;return b};
ol.format.GeoJSON.prototype.writeFeatureObject=function(a,b){b=this.adaptOptions(b);var c={type:"Feature"},d=a.getId();void 0!==d&&(c.id=d);d=a.getGeometry();c.geometry=d?ol.format.GeoJSON.writeGeometry_(d,b):null;b=a.getProperties();delete b[a.getGeometryName()];ol.obj.isEmpty(b)?c.properties=null:c.properties=b;return c};
ol.format.GeoJSON.prototype.writeFeaturesObject=function(a,b){b=this.adaptOptions(b);var c=[],d;var e=0;for(d=a.length;e<d;++e)c.push(this.writeFeatureObject(a[e],b));return{type:"FeatureCollection",features:c}};ol.format.GeoJSON.prototype.writeGeometryObject=function(a,b){return ol.format.GeoJSON.writeGeometry_(a,this.adaptOptions(b))};ol.format.IGCZ={BAROMETRIC:"barometric",GPS:"gps",NONE:"none"};ol.format.TextFeature=function(){ol.format.Feature.call(this)};ol.inherits(ol.format.TextFeature,ol.format.Feature);ol.format.TextFeature.prototype.getText_=function(a){return"string"===typeof a?a:""};ol.format.TextFeature.prototype.getType=function(){return ol.format.FormatType.TEXT};ol.format.TextFeature.prototype.readFeature=function(a,b){return this.readFeatureFromText(this.getText_(a),this.adaptOptions(b))};ol.format.TextFeature.prototype.readFeatureFromText=function(a,b){};
ol.format.TextFeature.prototype.readFeatures=function(a,b){return this.readFeaturesFromText(this.getText_(a),this.adaptOptions(b))};ol.format.TextFeature.prototype.readFeaturesFromText=function(a,b){};ol.format.TextFeature.prototype.readGeometry=function(a,b){return this.readGeometryFromText(this.getText_(a),this.adaptOptions(b))};ol.format.TextFeature.prototype.readGeometryFromText=function(a,b){};ol.format.TextFeature.prototype.readProjection=function(a){return this.readProjectionFromText(this.getText_(a))};
ol.format.TextFeature.prototype.readProjectionFromText=function(a){return this.defaultDataProjection};ol.format.TextFeature.prototype.writeFeature=function(a,b){return this.writeFeatureText(a,this.adaptOptions(b))};ol.format.TextFeature.prototype.writeFeatureText=function(a,b){};ol.format.TextFeature.prototype.writeFeatures=function(a,b){return this.writeFeaturesText(a,this.adaptOptions(b))};ol.format.TextFeature.prototype.writeFeaturesText=function(a,b){};
ol.format.TextFeature.prototype.writeGeometry=function(a,b){return this.writeGeometryText(a,this.adaptOptions(b))};ol.format.TextFeature.prototype.writeGeometryText=function(a,b){};ol.format.IGC=function(a){a=a?a:{};ol.format.TextFeature.call(this);this.defaultDataProjection=ol.proj.get("EPSG:4326");this.altitudeMode_=a.altitudeMode?a.altitudeMode:ol.format.IGCZ.NONE};ol.inherits(ol.format.IGC,ol.format.TextFeature);ol.format.IGC.B_RECORD_RE_=/^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;ol.format.IGC.H_RECORD_RE_=/^H.([A-Z]{3}).*?:(.*)/;ol.format.IGC.HFDTE_RECORD_RE_=/^HFDTE(\d{2})(\d{2})(\d{2})/;ol.format.IGC.NEWLINE_RE_=/\r\n|\r|\n/;
ol.format.IGC.prototype.readFeatureFromText=function(a,b){var c=this.altitudeMode_,d=a.split(ol.format.IGC.NEWLINE_RE_);a={};var e=[],f=2E3,g=0,h=1,k=-1,l;var m=0;for(l=d.length;m<l;++m){var n=d[m],p;if("B"==n.charAt(0)){if(p=ol.format.IGC.B_RECORD_RE_.exec(n)){n=parseInt(p[1],10);var q=parseInt(p[2],10),r=parseInt(p[3],10),u=parseInt(p[4],10)+parseInt(p[5],10)/6E4;"S"==p[6]&&(u=-u);var t=parseInt(p[7],10)+parseInt(p[8],10)/6E4;"W"==p[9]&&(t=-t);e.push(t,u);c!=ol.format.IGCZ.NONE&&(p=c==ol.format.IGCZ.GPS?
parseInt(p[11],10):c==ol.format.IGCZ.BAROMETRIC?parseInt(p[12],10):0,e.push(p));p=Date.UTC(f,g,h,n,q,r);p<k&&(p=Date.UTC(f,g,h+1,n,q,r));e.push(p/1E3);k=p}}else"H"==n.charAt(0)&&((p=ol.format.IGC.HFDTE_RECORD_RE_.exec(n))?(h=parseInt(p[1],10),g=parseInt(p[2],10)-1,f=2E3+parseInt(p[3],10)):(p=ol.format.IGC.H_RECORD_RE_.exec(n))&&(a[p[1]]=p[2].trim()))}if(0===e.length)return null;d=new ol.geom.LineString(null);d.setFlatCoordinates(c==ol.format.IGCZ.NONE?ol.geom.GeometryLayout.XYM:ol.geom.GeometryLayout.XYZM,
e);b=new ol.Feature(ol.format.Feature.transformWithOptions(d,!1,b));b.setProperties(a);return b};ol.format.IGC.prototype.readFeaturesFromText=function(a,b){return(a=this.readFeatureFromText(a,b))?[a]:[]};ol.format.IGC.prototype.writeFeatureText=function(a,b){};ol.format.IGC.prototype.writeFeaturesText=function(a,b){};ol.format.IGC.prototype.writeGeometryText=function(a,b){};ol.format.IGC.prototype.readGeometryFromText=function(a,b){};ol.style.IconAnchorUnits={FRACTION:"fraction",PIXELS:"pixels"};ol.style.IconImage=function(a,b,c,d,e,f){ol.events.EventTarget.call(this);this.hitDetectionImage_=null;this.image_=a?a:new Image;null!==d&&(this.image_.crossOrigin=d);this.canvas_=f?document.createElement("CANVAS"):null;this.color_=f;this.imageListenerKeys_=null;this.imageState_=e;this.size_=c;this.src_=b;this.tainting_=!1;this.imageState_==ol.ImageState.LOADED&&this.determineTainting_()};ol.inherits(ol.style.IconImage,ol.events.EventTarget);
ol.style.IconImage.get=function(a,b,c,d,e,f){var g=ol.style.iconImageCache,h=g.get(b,d,f);h||(h=new ol.style.IconImage(a,b,c,d,e,f),g.set(b,d,f,h));return h};ol.style.IconImage.prototype.determineTainting_=function(){var a=ol.dom.createCanvasContext2D(1,1);try{a.drawImage(this.image_,0,0),a.getImageData(0,0,1,1)}catch(b){this.tainting_=!0}};ol.style.IconImage.prototype.dispatchChangeEvent_=function(){this.dispatchEvent(ol.events.EventType.CHANGE)};
ol.style.IconImage.prototype.handleImageError_=function(){this.imageState_=ol.ImageState.ERROR;this.unlistenImage_();this.dispatchChangeEvent_()};ol.style.IconImage.prototype.handleImageLoad_=function(){this.imageState_=ol.ImageState.LOADED;this.size_&&(this.image_.width=this.size_[0],this.image_.height=this.size_[1]);this.size_=[this.image_.width,this.image_.height];this.unlistenImage_();this.determineTainting_();this.replaceColor_();this.dispatchChangeEvent_()};
ol.style.IconImage.prototype.getImage=function(a){return this.canvas_?this.canvas_:this.image_};ol.style.IconImage.prototype.getImageState=function(){return this.imageState_};ol.style.IconImage.prototype.getHitDetectionImage=function(a){if(!this.hitDetectionImage_)if(this.tainting_){a=this.size_[0];var b=this.size_[1],c=ol.dom.createCanvasContext2D(a,b);c.fillRect(0,0,a,b);this.hitDetectionImage_=c.canvas}else this.hitDetectionImage_=this.image_;return this.hitDetectionImage_};
ol.style.IconImage.prototype.getSize=function(){return this.size_};ol.style.IconImage.prototype.getSrc=function(){return this.src_};ol.style.IconImage.prototype.load=function(){if(this.imageState_==ol.ImageState.IDLE){this.imageState_=ol.ImageState.LOADING;this.imageListenerKeys_=[ol.events.listenOnce(this.image_,ol.events.EventType.ERROR,this.handleImageError_,this),ol.events.listenOnce(this.image_,ol.events.EventType.LOAD,this.handleImageLoad_,this)];try{this.image_.src=this.src_}catch(a){this.handleImageError_()}}};
ol.style.IconImage.prototype.replaceColor_=function(){if(!this.tainting_&&null!==this.color_){this.canvas_.width=this.image_.width;this.canvas_.height=this.image_.height;var a=this.canvas_.getContext("2d");a.drawImage(this.image_,0,0);for(var b=a.getImageData(0,0,this.image_.width,this.image_.height),c=b.data,d=this.color_[0]/255,e=this.color_[1]/255,f=this.color_[2]/255,g=0,h=c.length;g<h;g+=4)c[g]*=d,c[g+1]*=e,c[g+2]*=f;a.putImageData(b,0,0)}};
ol.style.IconImage.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(ol.events.unlistenByKey);this.imageListenerKeys_=null};ol.style.IconOrigin={BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",TOP_LEFT:"top-left",TOP_RIGHT:"top-right"};ol.style.Icon=function(a){a=a||{};this.anchor_=void 0!==a.anchor?a.anchor:[.5,.5];this.normalizedAnchor_=null;this.anchorOrigin_=void 0!==a.anchorOrigin?a.anchorOrigin:ol.style.IconOrigin.TOP_LEFT;this.anchorXUnits_=void 0!==a.anchorXUnits?a.anchorXUnits:ol.style.IconAnchorUnits.FRACTION;this.anchorYUnits_=void 0!==a.anchorYUnits?a.anchorYUnits:ol.style.IconAnchorUnits.FRACTION;this.crossOrigin_=void 0!==a.crossOrigin?a.crossOrigin:null;var b=void 0!==a.img?a.img:null,c=void 0!==a.imgSize?a.imgSize:
null,d=a.src;ol.asserts.assert(!(void 0!==d&&b),4);ol.asserts.assert(!b||b&&c,5);void 0!==d&&0!==d.length||!b||(d=b.src||ol.getUid(b).toString());ol.asserts.assert(void 0!==d&&0<d.length,6);var e=void 0!==a.src?ol.ImageState.IDLE:ol.ImageState.LOADED;this.color_=void 0!==a.color?ol.color.asArray(a.color):null;this.iconImage_=ol.style.IconImage.get(b,d,c,this.crossOrigin_,e,this.color_);this.offset_=void 0!==a.offset?a.offset:[0,0];this.offsetOrigin_=void 0!==a.offsetOrigin?a.offsetOrigin:ol.style.IconOrigin.TOP_LEFT;
this.origin_=null;this.size_=void 0!==a.size?a.size:null;ol.style.Image.call(this,{opacity:void 0!==a.opacity?a.opacity:1,rotation:void 0!==a.rotation?a.rotation:0,scale:void 0!==a.scale?a.scale:1,snapToPixel:void 0!==a.snapToPixel?a.snapToPixel:!0,rotateWithView:void 0!==a.rotateWithView?a.rotateWithView:!1})};ol.inherits(ol.style.Icon,ol.style.Image);
ol.style.Icon.prototype.clone=function(){return new ol.style.Icon({anchor:this.anchor_.slice(),anchorOrigin:this.anchorOrigin_,anchorXUnits:this.anchorXUnits_,anchorYUnits:this.anchorYUnits_,crossOrigin:this.crossOrigin_,color:this.color_&&this.color_.slice?this.color_.slice():this.color_||void 0,src:this.getSrc(),offset:this.offset_.slice(),offsetOrigin:this.offsetOrigin_,size:null!==this.size_?this.size_.slice():void 0,opacity:this.getOpacity(),scale:this.getScale(),snapToPixel:this.getSnapToPixel(),
rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})};
ol.style.Icon.prototype.getAnchor=function(){if(this.normalizedAnchor_)return this.normalizedAnchor_;var a=this.anchor_,b=this.getSize();if(this.anchorXUnits_==ol.style.IconAnchorUnits.FRACTION||this.anchorYUnits_==ol.style.IconAnchorUnits.FRACTION){if(!b)return null;a=this.anchor_.slice();this.anchorXUnits_==ol.style.IconAnchorUnits.FRACTION&&(a[0]*=b[0]);this.anchorYUnits_==ol.style.IconAnchorUnits.FRACTION&&(a[1]*=b[1])}if(this.anchorOrigin_!=ol.style.IconOrigin.TOP_LEFT){if(!b)return null;a===
this.anchor_&&(a=this.anchor_.slice());if(this.anchorOrigin_==ol.style.IconOrigin.TOP_RIGHT||this.anchorOrigin_==ol.style.IconOrigin.BOTTOM_RIGHT)a[0]=-a[0]+b[0];if(this.anchorOrigin_==ol.style.IconOrigin.BOTTOM_LEFT||this.anchorOrigin_==ol.style.IconOrigin.BOTTOM_RIGHT)a[1]=-a[1]+b[1]}return this.normalizedAnchor_=a};ol.style.Icon.prototype.getColor=function(){return this.color_};ol.style.Icon.prototype.getImage=function(a){return this.iconImage_.getImage(a)};
ol.style.Icon.prototype.getImageSize=function(){return this.iconImage_.getSize()};ol.style.Icon.prototype.getHitDetectionImageSize=function(){return this.getImageSize()};ol.style.Icon.prototype.getImageState=function(){return this.iconImage_.getImageState()};ol.style.Icon.prototype.getHitDetectionImage=function(a){return this.iconImage_.getHitDetectionImage(a)};
ol.style.Icon.prototype.getOrigin=function(){if(this.origin_)return this.origin_;var a=this.offset_;if(this.offsetOrigin_!=ol.style.IconOrigin.TOP_LEFT){var b=this.getSize(),c=this.iconImage_.getSize();if(!b||!c)return null;a=a.slice();if(this.offsetOrigin_==ol.style.IconOrigin.TOP_RIGHT||this.offsetOrigin_==ol.style.IconOrigin.BOTTOM_RIGHT)a[0]=c[0]-b[0]-a[0];if(this.offsetOrigin_==ol.style.IconOrigin.BOTTOM_LEFT||this.offsetOrigin_==ol.style.IconOrigin.BOTTOM_RIGHT)a[1]=c[1]-b[1]-a[1]}return this.origin_=
a};ol.style.Icon.prototype.getSrc=function(){return this.iconImage_.getSrc()};ol.style.Icon.prototype.getSize=function(){return this.size_?this.size_:this.iconImage_.getSize()};ol.style.Icon.prototype.listenImageChange=function(a,b){return ol.events.listen(this.iconImage_,ol.events.EventType.CHANGE,a,b)};ol.style.Icon.prototype.load=function(){this.iconImage_.load()};ol.style.Icon.prototype.unlistenImageChange=function(a,b){ol.events.unlisten(this.iconImage_,ol.events.EventType.CHANGE,a,b)};ol.format.KML=function(a){a=a?a:{};ol.format.XMLFeature.call(this);ol.format.KML.DEFAULT_STYLE_ARRAY_||ol.format.KML.createStyleDefaults_();this.defaultDataProjection=ol.proj.get("EPSG:4326");this.defaultStyle_=a.defaultStyle?a.defaultStyle:ol.format.KML.DEFAULT_STYLE_ARRAY_;this.extractStyles_=void 0!==a.extractStyles?a.extractStyles:!0;this.writeStyles_=void 0!==a.writeStyles?a.writeStyles:!0;this.sharedStyles_={};this.showPointNames_=void 0!==a.showPointNames?a.showPointNames:!0};
ol.inherits(ol.format.KML,ol.format.XMLFeature);ol.format.KML.GX_NAMESPACE_URIS_=["http://www.google.com/kml/ext/2.2"];ol.format.KML.NAMESPACE_URIS_=[null,"http://earth.google.com/kml/2.0","http://earth.google.com/kml/2.1","http://earth.google.com/kml/2.2","http://www.opengis.net/kml/2.2"];ol.format.KML.SCHEMA_LOCATION_="http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
ol.format.KML.createStyleDefaults_=function(){ol.format.KML.DEFAULT_COLOR_=[255,255,255,1];ol.format.KML.DEFAULT_FILL_STYLE_=new ol.style.Fill({color:ol.format.KML.DEFAULT_COLOR_});ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_=[20,2];ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_=ol.style.IconAnchorUnits.PIXELS;ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_=ol.style.IconAnchorUnits.PIXELS;ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_=[64,64];ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_="https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_=.5;ol.format.KML.DEFAULT_IMAGE_STYLE_=new ol.style.Icon({anchor:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_,anchorOrigin:ol.style.IconOrigin.BOTTOM_LEFT,anchorXUnits:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_,anchorYUnits:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_,crossOrigin:"anonymous",rotation:0,scale:ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_,size:ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_,src:ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_});ol.format.KML.DEFAULT_NO_IMAGE_STYLE_=
"NO_IMAGE";ol.format.KML.DEFAULT_STROKE_STYLE_=new ol.style.Stroke({color:ol.format.KML.DEFAULT_COLOR_,width:1});ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_=new ol.style.Stroke({color:[51,51,51,1],width:2});ol.format.KML.DEFAULT_TEXT_STYLE_=new ol.style.Text({font:"bold 16px Helvetica",fill:ol.format.KML.DEFAULT_FILL_STYLE_,stroke:ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_,scale:.8});ol.format.KML.DEFAULT_STYLE_=new ol.style.Style({fill:ol.format.KML.DEFAULT_FILL_STYLE_,image:ol.format.KML.DEFAULT_IMAGE_STYLE_,
text:ol.format.KML.DEFAULT_TEXT_STYLE_,stroke:ol.format.KML.DEFAULT_STROKE_STYLE_,zIndex:0});ol.format.KML.DEFAULT_STYLE_ARRAY_=[ol.format.KML.DEFAULT_STYLE_];return ol.format.KML.DEFAULT_STYLE_ARRAY_};ol.format.KML.ICON_ANCHOR_UNITS_MAP_={fraction:ol.style.IconAnchorUnits.FRACTION,pixels:ol.style.IconAnchorUnits.PIXELS,insetPixels:ol.style.IconAnchorUnits.PIXELS};
ol.format.KML.createNameStyleFunction_=function(a,b){var c=[0,0],d="start";if(a.getImage()){var e=a.getImage().getImageSize();null===e&&(e=ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_);2==e.length&&(d=a.getImage().getScale(),c[0]=d*e[0]/2,c[1]=-d*e[1]/2,d="left")}null!==a.getText()?(e=a.getText(),a=e.clone(),a.setFont(e.getFont()||ol.format.KML.DEFAULT_TEXT_STYLE_.getFont()),a.setScale(e.getScale()||ol.format.KML.DEFAULT_TEXT_STYLE_.getScale()),a.setFill(e.getFill()||ol.format.KML.DEFAULT_TEXT_STYLE_.getFill()),
a.setStroke(e.getStroke()||ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_)):a=ol.format.KML.DEFAULT_TEXT_STYLE_.clone();a.setText(b);a.setOffsetX(c[0]);a.setOffsetY(c[1]);a.setTextAlign(d);return new ol.style.Style({text:a})};
ol.format.KML.createFeatureStyleFunction_=function(a,b,c,d,e){return function(f){var g=e,h="";g&&this.getGeometry()&&(g=this.getGeometry().getType()===ol.geom.GeometryType.POINT);g&&(h=this.get("name"),g=g&&h);return a?g?(g=ol.format.KML.createNameStyleFunction_(a[0],h),a.concat(g)):a:b?(f=ol.format.KML.findStyle_(b,c,d),g?(g=ol.format.KML.createNameStyleFunction_(f[0],h),f.concat(g)):f):g?(g=ol.format.KML.createNameStyleFunction_(c[0],h),c.concat(g)):c}};
ol.format.KML.findStyle_=function(a,b,c){return Array.isArray(a)?a:"string"===typeof a?(!(a in c)&&"#"+a in c&&(a="#"+a),ol.format.KML.findStyle_(c[a],b,c)):b};ol.format.KML.readColor_=function(a){a=ol.xml.getAllTextContent(a,!1);if(a=/^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(a))return a=a[1],[parseInt(a.substr(6,2),16),parseInt(a.substr(4,2),16),parseInt(a.substr(2,2),16),parseInt(a.substr(0,2),16)/255]};
ol.format.KML.readFlatCoordinates_=function(a){a=ol.xml.getAllTextContent(a,!1);for(var b=[],c=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i,d;d=c.exec(a);){var e=parseFloat(d[1]),f=parseFloat(d[2]),g=d[3]?parseFloat(d[3]):0;b.push(e,f,g);a=a.substr(d[0].length)}if(""===a)return b};
ol.format.KML.readURI_=function(a){var b=ol.xml.getAllTextContent(a,!1).trim();a=a.baseURI;a&&"about:blank"!=a||(a=window.location.href);return a?(new URL(b,a)).href:b};
ol.format.KML.readVec2_=function(a){var b=a.getAttribute("xunits"),c=a.getAttribute("yunits");var d="insetPixels"!==b?"insetPixels"!==c?ol.style.IconOrigin.BOTTOM_LEFT:ol.style.IconOrigin.TOP_LEFT:"insetPixels"!==c?ol.style.IconOrigin.BOTTOM_RIGHT:ol.style.IconOrigin.TOP_RIGHT;return{x:parseFloat(a.getAttribute("x")),xunits:ol.format.KML.ICON_ANCHOR_UNITS_MAP_[b],y:parseFloat(a.getAttribute("y")),yunits:ol.format.KML.ICON_ANCHOR_UNITS_MAP_[c],origin:d}};ol.format.KML.readScale_=function(a){return ol.format.XSD.readDecimal(a)};
ol.format.KML.readStyleMapValue_=function(a,b){return ol.xml.pushParseAndPop(void 0,ol.format.KML.STYLE_MAP_PARSERS_,a,b)};
ol.format.KML.IconStyleParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.ICON_STYLE_PARSERS_,a,b)){b=b[b.length-1];var c="Icon"in a?a.Icon:{},d=!("Icon"in a)||0<Object.keys(c).length,e=c.href;if(e)var f=e;else d&&(f=ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_);e=ol.style.IconOrigin.BOTTOM_LEFT;var g=a.hotSpot;if(g){var h=[g.x,g.y];var k=g.xunits;var l=g.yunits;e=g.origin}else f===ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_?(h=ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_,k=ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_,
l=ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_):/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(f)&&(h=[.5,0],l=k=ol.style.IconAnchorUnits.FRACTION);var m;g=c.x;var n=c.y;void 0!==g&&void 0!==n&&(m=[g,n]);var p;g=c.w;c=c.h;void 0!==g&&void 0!==c&&(p=[g,c]);var q;c=a.heading;void 0!==c&&(q=ol.math.toRadians(c));a=a.scale;d?(f==ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_&&(p=ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_,void 0===a&&(a=ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_)),f=new ol.style.Icon({anchor:h,
anchorOrigin:e,anchorXUnits:k,anchorYUnits:l,crossOrigin:"anonymous",offset:m,offsetOrigin:ol.style.IconOrigin.BOTTOM_LEFT,rotation:q,scale:a,size:p,src:f}),b.imageStyle=f):b.imageStyle=ol.format.KML.DEFAULT_NO_IMAGE_STYLE_}};ol.format.KML.LabelStyleParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.LABEL_STYLE_PARSERS_,a,b))b=b[b.length-1],a=new ol.style.Text({fill:new ol.style.Fill({color:"color"in a?a.color:ol.format.KML.DEFAULT_COLOR_}),scale:a.scale}),b.textStyle=a};
ol.format.KML.LineStyleParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.LINE_STYLE_PARSERS_,a,b))b=b[b.length-1],a=new ol.style.Stroke({color:"color"in a?a.color:ol.format.KML.DEFAULT_COLOR_,width:"width"in a?a.width:1}),b.strokeStyle=a};
ol.format.KML.PolyStyleParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.POLY_STYLE_PARSERS_,a,b)){b=b[b.length-1];var c=new ol.style.Fill({color:"color"in a?a.color:ol.format.KML.DEFAULT_COLOR_});b.fillStyle=c;c=a.fill;void 0!==c&&(b.fill=c);a=a.outline;void 0!==a&&(b.outline=a)}};ol.format.KML.readFlatLinearRing_=function(a,b){return ol.xml.pushParseAndPop(null,ol.format.KML.FLAT_LINEAR_RING_PARSERS_,a,b)};
ol.format.KML.gxCoordParser_=function(a,b){b=b[b.length-1].flatCoordinates;a=ol.xml.getAllTextContent(a,!1);var c=/^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(a);if(c){a=parseFloat(c[1]);var d=parseFloat(c[2]);c=parseFloat(c[3]);b.push(a,d,c,0)}else b.push(0,0,0,0)};
ol.format.KML.readGxMultiTrack_=function(a,b){if(a=ol.xml.pushParseAndPop([],ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_,a,b))return b=new ol.geom.MultiLineString(null),b.setLineStrings(a),b};
ol.format.KML.readGxTrack_=function(a,b){if(b=ol.xml.pushParseAndPop({flatCoordinates:[],whens:[]},ol.format.KML.GX_TRACK_PARSERS_,a,b)){a=b.flatCoordinates;b=b.whens;var c;var d=0;for(c=Math.min(a.length,b.length);d<c;++d)a[4*d+3]=b[d];b=new ol.geom.LineString(null);b.setFlatCoordinates(ol.geom.GeometryLayout.XYZM,a);return b}};ol.format.KML.readIcon_=function(a,b){return(a=ol.xml.pushParseAndPop({},ol.format.KML.ICON_PARSERS_,a,b))?a:null};
ol.format.KML.readFlatCoordinatesFromNode_=function(a,b){return ol.xml.pushParseAndPop(null,ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_,a,b)};ol.format.KML.readLineString_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_,a,b);if(a=ol.format.KML.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.LineString(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b.setProperties(c),b};
ol.format.KML.readLinearRing_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_,a,b);if(a=ol.format.KML.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.Polygon(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a,[a.length]),b.setProperties(c),b};
ol.format.KML.readMultiGeometry_=function(a,b){a=ol.xml.pushParseAndPop([],ol.format.KML.MULTI_GEOMETRY_PARSERS_,a,b);if(!a)return null;if(0===a.length)return new ol.geom.GeometryCollection(a);var c=!0,d=a[0].getType(),e;var f=1;for(e=a.length;f<e;++f)if(b=a[f],b.getType()!=d){c=!1;break}if(c)if(d==ol.geom.GeometryType.POINT){var g=a[0];c=g.getLayout();d=g.getFlatCoordinates();f=1;for(e=a.length;f<e;++f)b=a[f],ol.array.extend(d,b.getFlatCoordinates());g=new ol.geom.MultiPoint(null);g.setFlatCoordinates(c,
d);ol.format.KML.setCommonGeometryProperties_(g,a)}else d==ol.geom.GeometryType.LINE_STRING?(g=new ol.geom.MultiLineString(null),g.setLineStrings(a),ol.format.KML.setCommonGeometryProperties_(g,a)):d==ol.geom.GeometryType.POLYGON?(g=new ol.geom.MultiPolygon(null),g.setPolygons(a),ol.format.KML.setCommonGeometryProperties_(g,a)):d==ol.geom.GeometryType.GEOMETRY_COLLECTION?g=new ol.geom.GeometryCollection(a):ol.asserts.assert(!1,37);else g=new ol.geom.GeometryCollection(a);return g};
ol.format.KML.readPoint_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_,a,b);if(a=ol.format.KML.readFlatCoordinatesFromNode_(a,b))return b=new ol.geom.Point(null),b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,a),b.setProperties(c),b};
ol.format.KML.readPolygon_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_,a,b);if((a=ol.xml.pushParseAndPop([null],ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_,a,b))&&a[0]){b=new ol.geom.Polygon(null);var d=a[0],e=[d.length],f;var g=1;for(f=a.length;g<f;++g)ol.array.extend(d,a[g]),e.push(d.length);b.setFlatCoordinates(ol.geom.GeometryLayout.XYZ,d,e);b.setProperties(c);return b}};
ol.format.KML.readStyle_=function(a,b){b=ol.xml.pushParseAndPop({},ol.format.KML.STYLE_PARSERS_,a,b);if(!b)return null;a="fillStyle"in b?b.fillStyle:ol.format.KML.DEFAULT_FILL_STYLE_;var c=b.fill;void 0===c||c||(a=null);c="imageStyle"in b?b.imageStyle:ol.format.KML.DEFAULT_IMAGE_STYLE_;c==ol.format.KML.DEFAULT_NO_IMAGE_STYLE_&&(c=void 0);var d="textStyle"in b?b.textStyle:ol.format.KML.DEFAULT_TEXT_STYLE_,e="strokeStyle"in b?b.strokeStyle:ol.format.KML.DEFAULT_STROKE_STYLE_;b=b.outline;void 0===b||
b||(e=null);return[new ol.style.Style({fill:a,image:c,stroke:e,text:d,zIndex:void 0})]};ol.format.KML.setCommonGeometryProperties_=function(a,b){var c=b.length,d=Array(b.length),e=Array(b.length),f=Array(b.length),g,h,k;var l=h=k=!1;for(g=0;g<c;++g){var m=b[g];d[g]=m.get("extrude");e[g]=m.get("tessellate");f[g]=m.get("altitudeMode");l=l||void 0!==d[g];h=h||void 0!==e[g];k=k||f[g]}l&&a.set("extrude",d);h&&a.set("tessellate",e);k&&a.set("altitudeMode",f)};
ol.format.KML.DataParser_=function(a,b){var c=a.getAttribute("name");ol.xml.parseNode(ol.format.KML.DATA_PARSERS_,a,b);a=b[b.length-1];null!==c?a[c]=a.value:null!==a.displayName&&(a[a.displayName]=a.value);delete a.value};ol.format.KML.ExtendedDataParser_=function(a,b){ol.xml.parseNode(ol.format.KML.EXTENDED_DATA_PARSERS_,a,b)};ol.format.KML.RegionParser_=function(a,b){ol.xml.parseNode(ol.format.KML.REGION_PARSERS_,a,b)};
ol.format.KML.PairDataParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.PAIR_PARSERS_,a,b)){var c=a.key;c&&"normal"==c&&((c=a.styleUrl)&&(b[b.length-1]=c),(a=a.Style)&&(b[b.length-1]=a))}};ol.format.KML.PlacemarkStyleMapParser_=function(a,b){if(a=ol.format.KML.readStyleMapValue_(a,b))b=b[b.length-1],Array.isArray(a)?b.Style=a:"string"===typeof a?b.styleUrl=a:ol.asserts.assert(!1,38)};
ol.format.KML.SchemaDataParser_=function(a,b){ol.xml.parseNode(ol.format.KML.SCHEMA_DATA_PARSERS_,a,b)};ol.format.KML.SimpleDataParser_=function(a,b){var c=a.getAttribute("name");null!==c&&(a=ol.format.XSD.readString(a),b[b.length-1][c]=a)};
ol.format.KML.LatLonAltBoxParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.LAT_LON_ALT_BOX_PARSERS_,a,b)){b=b[b.length-1];var c=[parseFloat(a.west),parseFloat(a.south),parseFloat(a.east),parseFloat(a.north)];b.extent=c;b.altitudeMode=a.altitudeMode;b.minAltitude=parseFloat(a.minAltitude);b.maxAltitude=parseFloat(a.maxAltitude)}};
ol.format.KML.LodParser_=function(a,b){if(a=ol.xml.pushParseAndPop({},ol.format.KML.LOD_PARSERS_,a,b))b=b[b.length-1],b.minLodPixels=parseFloat(a.minLodPixels),b.maxLodPixels=parseFloat(a.maxLodPixels),b.minFadeExtent=parseFloat(a.minFadeExtent),b.maxFadeExtent=parseFloat(a.maxFadeExtent)};ol.format.KML.innerBoundaryIsParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,ol.format.KML.INNER_BOUNDARY_IS_PARSERS_,a,b))&&b[b.length-1].push(a)};
ol.format.KML.outerBoundaryIsParser_=function(a,b){(a=ol.xml.pushParseAndPop(void 0,ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_,a,b))&&(b[b.length-1][0]=a)};ol.format.KML.LinkParser_=function(a,b){ol.xml.parseNode(ol.format.KML.LINK_PARSERS_,a,b)};ol.format.KML.whenParser_=function(a,b){b=b[b.length-1].whens;a=ol.xml.getAllTextContent(a,!1);a=Date.parse(a);b.push(isNaN(a)?0:a)};
ol.format.KML.DATA_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{displayName:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),value:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});ol.format.KML.EXTENDED_DATA_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Data:ol.format.KML.DataParser_,SchemaData:ol.format.KML.SchemaDataParser_});
ol.format.KML.REGION_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LatLonAltBox:ol.format.KML.LatLonAltBoxParser_,Lod:ol.format.KML.LodParser_});
ol.format.KML.LAT_LON_ALT_BOX_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{altitudeMode:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),minAltitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),maxAltitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),north:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),south:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),east:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),west:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.LOD_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{minLodPixels:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),maxLodPixels:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),minFadeExtent:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),maxFadeExtent:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{extrude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),tessellate:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),altitudeMode:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});ol.format.KML.FLAT_LINEAR_RING_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{coordinates:ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)});
ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{innerBoundaryIs:ol.format.KML.innerBoundaryIsParser_,outerBoundaryIs:ol.format.KML.outerBoundaryIsParser_});ol.format.KML.GX_TRACK_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{when:ol.format.KML.whenParser_},ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,{coord:ol.format.KML.gxCoordParser_}));
ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{coordinates:ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)});
ol.format.KML.ICON_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{href:ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)},ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,{x:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),y:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),w:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),h:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)}));
ol.format.KML.ICON_STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Icon:ol.xml.makeObjectPropertySetter(ol.format.KML.readIcon_),heading:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),hotSpot:ol.xml.makeObjectPropertySetter(ol.format.KML.readVec2_),scale:ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)});ol.format.KML.INNER_BOUNDARY_IS_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LinearRing:ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)});
ol.format.KML.LABEL_STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),scale:ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)});ol.format.KML.LINE_STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),width:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.MULTI_GEOMETRY_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LineString:ol.xml.makeArrayPusher(ol.format.KML.readLineString_),LinearRing:ol.xml.makeArrayPusher(ol.format.KML.readLinearRing_),MultiGeometry:ol.xml.makeArrayPusher(ol.format.KML.readMultiGeometry_),Point:ol.xml.makeArrayPusher(ol.format.KML.readPoint_),Polygon:ol.xml.makeArrayPusher(ol.format.KML.readPolygon_)});
ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,{Track:ol.xml.makeArrayPusher(ol.format.KML.readGxTrack_)});
ol.format.KML.NETWORK_LINK_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{ExtendedData:ol.format.KML.ExtendedDataParser_,Region:ol.format.KML.RegionParser_,Link:ol.format.KML.LinkParser_,address:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),description:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),open:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),phoneNumber:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
visibility:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)});ol.format.KML.LINK_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{href:ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)});ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LinearRing:ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)});
ol.format.KML.PAIR_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Style:ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_),key:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),styleUrl:ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)});
ol.format.KML.PLACEMARK_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{ExtendedData:ol.format.KML.ExtendedDataParser_,Region:ol.format.KML.RegionParser_,MultiGeometry:ol.xml.makeObjectPropertySetter(ol.format.KML.readMultiGeometry_,"geometry"),LineString:ol.xml.makeObjectPropertySetter(ol.format.KML.readLineString_,"geometry"),LinearRing:ol.xml.makeObjectPropertySetter(ol.format.KML.readLinearRing_,"geometry"),Point:ol.xml.makeObjectPropertySetter(ol.format.KML.readPoint_,"geometry"),
Polygon:ol.xml.makeObjectPropertySetter(ol.format.KML.readPolygon_,"geometry"),Style:ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_),StyleMap:ol.format.KML.PlacemarkStyleMapParser_,address:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),description:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),open:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),phoneNumber:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
styleUrl:ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_),visibility:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)},ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,{MultiTrack:ol.xml.makeObjectPropertySetter(ol.format.KML.readGxMultiTrack_,"geometry"),Track:ol.xml.makeObjectPropertySetter(ol.format.KML.readGxTrack_,"geometry")}));
ol.format.KML.POLY_STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),fill:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),outline:ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)});ol.format.KML.SCHEMA_DATA_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{SimpleData:ol.format.KML.SimpleDataParser_});
ol.format.KML.STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{IconStyle:ol.format.KML.IconStyleParser_,LabelStyle:ol.format.KML.LabelStyleParser_,LineStyle:ol.format.KML.LineStyleParser_,PolyStyle:ol.format.KML.PolyStyleParser_});ol.format.KML.STYLE_MAP_PARSERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Pair:ol.format.KML.PairDataParser_});
ol.format.KML.prototype.readDocumentOrFolder_=function(a,b){var c=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Document:ol.xml.makeArrayExtender(this.readDocumentOrFolder_,this),Folder:ol.xml.makeArrayExtender(this.readDocumentOrFolder_,this),Placemark:ol.xml.makeArrayPusher(this.readPlacemark_,this),Style:this.readSharedStyle_.bind(this),StyleMap:this.readSharedStyleMap_.bind(this)});if(a=ol.xml.pushParseAndPop([],c,a,b,this))return a};
ol.format.KML.prototype.readPlacemark_=function(a,b){var c=ol.xml.pushParseAndPop({geometry:null},ol.format.KML.PLACEMARK_PARSERS_,a,b);if(c){var d=new ol.Feature;a=a.getAttribute("id");null!==a&&d.setId(a);b=b[0];(a=c.geometry)&&ol.format.Feature.transformWithOptions(a,!1,b);d.setGeometry(a);delete c.geometry;this.extractStyles_&&(b=ol.format.KML.createFeatureStyleFunction_(c.Style,c.styleUrl,this.defaultStyle_,this.sharedStyles_,this.showPointNames_),d.setStyle(b));delete c.Style;d.setProperties(c);
return d}};ol.format.KML.prototype.readSharedStyle_=function(a,b){var c=a.getAttribute("id");null!==c&&(b=ol.format.KML.readStyle_(a,b))&&(a=a.baseURI,a&&"about:blank"!=a||(a=window.location.href),c=a?(new URL("#"+c,a)).href:"#"+c,this.sharedStyles_[c]=b)};
ol.format.KML.prototype.readSharedStyleMap_=function(a,b){var c=a.getAttribute("id");null!==c&&(b=ol.format.KML.readStyleMapValue_(a,b))&&(a=a.baseURI,a&&"about:blank"!=a||(a=window.location.href),c=a?(new URL("#"+c,a)).href:"#"+c,this.sharedStyles_[c]=b)};ol.format.KML.prototype.readFeatureFromNode=function(a,b){return ol.array.includes(ol.format.KML.NAMESPACE_URIS_,a.namespaceURI)?(a=this.readPlacemark_(a,[this.getReadOptions(a,b)]))?a:null:null};
ol.format.KML.prototype.readFeaturesFromNode=function(a,b){if(!ol.array.includes(ol.format.KML.NAMESPACE_URIS_,a.namespaceURI))return[];var c=a.localName;if("Document"==c||"Folder"==c)return(c=this.readDocumentOrFolder_(a,[this.getReadOptions(a,b)]))?c:[];if("Placemark"==c)return(b=this.readPlacemark_(a,[this.getReadOptions(a,b)]))?[b]:[];if("kml"==c){c=[];for(a=a.firstElementChild;a;a=a.nextElementSibling){var d=this.readFeaturesFromNode(a,b);d&&ol.array.extend(c,d)}return c}return[]};
ol.format.KML.prototype.readName=function(a){if(ol.xml.isDocument(a))return this.readNameFromDocument(a);if(ol.xml.isNode(a))return this.readNameFromNode(a);if("string"===typeof a)return a=ol.xml.parse(a),this.readNameFromDocument(a)};ol.format.KML.prototype.readNameFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE){var b=this.readNameFromNode(a);if(b)return b}};
ol.format.KML.prototype.readNameFromNode=function(a){var b;for(b=a.firstElementChild;b;b=b.nextElementSibling)if(ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)&&"name"==b.localName)return ol.format.XSD.readString(b);for(b=a.firstElementChild;b;b=b.nextElementSibling)if(a=b.localName,ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)&&("Document"==a||"Folder"==a||"Placemark"==a||"kml"==a)&&(a=this.readNameFromNode(b)))return a};
ol.format.KML.prototype.readNetworkLinks=function(a){var b=[];ol.xml.isDocument(a)?ol.array.extend(b,this.readNetworkLinksFromDocument(a)):ol.xml.isNode(a)?ol.array.extend(b,this.readNetworkLinksFromNode(a)):"string"===typeof a&&(a=ol.xml.parse(a),ol.array.extend(b,this.readNetworkLinksFromDocument(a)));return b};
ol.format.KML.prototype.readNetworkLinksFromDocument=function(a){var b=[];for(a=a.firstChild;a;a=a.nextSibling)a.nodeType==Node.ELEMENT_NODE&&ol.array.extend(b,this.readNetworkLinksFromNode(a));return b};
ol.format.KML.prototype.readNetworkLinksFromNode=function(a){var b,c=[];for(b=a.firstElementChild;b;b=b.nextElementSibling)if(ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)&&"NetworkLink"==b.localName){var d=ol.xml.pushParseAndPop({},ol.format.KML.NETWORK_LINK_PARSERS_,b,[]);c.push(d)}for(b=a.firstElementChild;b;b=b.nextElementSibling)a=b.localName,!ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)||"Document"!=a&&"Folder"!=a&&"kml"!=a||ol.array.extend(c,this.readNetworkLinksFromNode(b));
return c};ol.format.KML.prototype.readRegion=function(a){var b=[];ol.xml.isDocument(a)?ol.array.extend(b,this.readRegionFromDocument(a)):ol.xml.isNode(a)?ol.array.extend(b,this.readRegionFromNode(a)):"string"===typeof a&&(a=ol.xml.parse(a),ol.array.extend(b,this.readRegionFromDocument(a)));return b};ol.format.KML.prototype.readRegionFromDocument=function(a){var b=[];for(a=a.firstChild;a;a=a.nextSibling)a.nodeType==Node.ELEMENT_NODE&&ol.array.extend(b,this.readRegionFromNode(a));return b};
ol.format.KML.prototype.readRegionFromNode=function(a){var b,c=[];for(b=a.firstElementChild;b;b=b.nextElementSibling)if(ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)&&"Region"==b.localName){var d=ol.xml.pushParseAndPop({},ol.format.KML.REGION_PARSERS_,b,[]);c.push(d)}for(b=a.firstElementChild;b;b=b.nextElementSibling)a=b.localName,!ol.array.includes(ol.format.KML.NAMESPACE_URIS_,b.namespaceURI)||"Document"!=a&&"Folder"!=a&&"kml"!=a||ol.array.extend(c,this.readRegionFromNode(b));
return c};ol.format.KML.writeColorTextNode_=function(a,b){b=ol.color.asArray(b);b=[255*(4==b.length?b[3]:1),b[2],b[1],b[0]];var c;for(c=0;4>c;++c){var d=parseInt(b[c],10).toString(16);b[c]=1==d.length?"0"+d:d}ol.format.XSD.writeStringTextNode(a,b.join(""))};
ol.format.KML.writeCoordinatesTextNode_=function(a,b,c){c=c[c.length-1];var d=c.layout;c=c.stride;var e;d==ol.geom.GeometryLayout.XY||d==ol.geom.GeometryLayout.XYM?e=2:d==ol.geom.GeometryLayout.XYZ||d==ol.geom.GeometryLayout.XYZM?e=3:ol.asserts.assert(!1,34);var f,g=b.length,h="";if(0<g){h+=b[0];for(d=1;d<e;++d)h+=","+b[d];for(f=c;f<g;f+=c)for(h+=" "+b[f],d=1;d<e;++d)h+=","+b[f+d]}ol.format.XSD.writeStringTextNode(a,h)};
ol.format.KML.writeDataNode_=function(a,b,c){a.setAttribute("name",b.name);a={node:a};b=b.value;"object"==typeof b?(null!==b&&b.displayName&&ol.xml.pushSerializeAndPop(a,ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b.displayName],c,["displayName"]),null!==b&&b.value&&ol.xml.pushSerializeAndPop(a,ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b.value],c,["value"])):ol.xml.pushSerializeAndPop(a,ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,
ol.xml.OBJECT_PROPERTY_NODE_FACTORY,[b],c,["value"])};ol.format.KML.writeDataNodeName_=function(a,b){ol.format.XSD.writeCDATASection(a,b)};ol.format.KML.writeDataNodeValue_=function(a,b){ol.format.XSD.writeStringTextNode(a,b)};ol.format.KML.writeDocument_=function(a,b,c){ol.xml.pushSerializeAndPop({node:a},ol.format.KML.DOCUMENT_SERIALIZERS_,ol.format.KML.DOCUMENT_NODE_FACTORY_,b,c,void 0,this)};
ol.format.KML.writeExtendedData_=function(a,b,c){a={node:a};var d=b.names;b=b.values;for(var e=d.length,f=0;f<e;f++)ol.xml.pushSerializeAndPop(a,ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,ol.format.KML.DATA_NODE_FACTORY_,[{name:d[f],value:b[f]}],c)};
ol.format.KML.writeIcon_=function(a,b,c){a={node:a};var d=ol.format.KML.ICON_SEQUENCE_[c[c.length-1].node.namespaceURI],e=ol.xml.makeSequence(b,d);ol.xml.pushSerializeAndPop(a,ol.format.KML.ICON_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,e,c,d);d=ol.format.KML.ICON_SEQUENCE_[ol.format.KML.GX_NAMESPACE_URIS_[0]];e=ol.xml.makeSequence(b,d);ol.xml.pushSerializeAndPop(a,ol.format.KML.ICON_SERIALIZERS_,ol.format.KML.GX_NODE_FACTORY_,e,c,d)};
ol.format.KML.writeIconStyle_=function(a,b,c){a={node:a};var d={},e=b.getSrc(),f=b.getSize(),g=b.getImageSize();e={href:e};if(f){e.w=f[0];e.h=f[1];var h=b.getAnchor(),k=b.getOrigin();k&&g&&0!==k[0]&&k[1]!==f[1]&&(e.x=k[0],e.y=g[1]-(k[1]+f[1]));!h||h[0]===f[0]/2&&h[1]===f[1]/2||(d.hotSpot={x:h[0],xunits:ol.style.IconAnchorUnits.PIXELS,y:f[1]-h[1],yunits:ol.style.IconAnchorUnits.PIXELS})}d.Icon=e;f=b.getScale();1!==f&&(d.scale=f);b=b.getRotation();0!==b&&(d.heading=b);b=ol.format.KML.ICON_STYLE_SEQUENCE_[c[c.length-
1].node.namespaceURI];d=ol.xml.makeSequence(d,b);ol.xml.pushSerializeAndPop(a,ol.format.KML.ICON_STYLE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,d,c,b)};
ol.format.KML.writeLabelStyle_=function(a,b,c){a={node:a};var d={},e=b.getFill();e&&(d.color=e.getColor());(b=b.getScale())&&1!==b&&(d.scale=b);b=ol.format.KML.LABEL_STYLE_SEQUENCE_[c[c.length-1].node.namespaceURI];d=ol.xml.makeSequence(d,b);ol.xml.pushSerializeAndPop(a,ol.format.KML.LABEL_STYLE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,d,c,b)};
ol.format.KML.writeLineStyle_=function(a,b,c){a={node:a};var d={color:b.getColor(),width:b.getWidth()};b=ol.format.KML.LINE_STYLE_SEQUENCE_[c[c.length-1].node.namespaceURI];d=ol.xml.makeSequence(d,b);ol.xml.pushSerializeAndPop(a,ol.format.KML.LINE_STYLE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,d,c,b)};
ol.format.KML.writeMultiGeometry_=function(a,b,c){a={node:a};var d=b.getType();if(d==ol.geom.GeometryType.GEOMETRY_COLLECTION){var e=b.getGeometries();var f=ol.format.KML.GEOMETRY_NODE_FACTORY_}else d==ol.geom.GeometryType.MULTI_POINT?(e=b.getPoints(),f=ol.format.KML.POINT_NODE_FACTORY_):d==ol.geom.GeometryType.MULTI_LINE_STRING?(e=b.getLineStrings(),f=ol.format.KML.LINE_STRING_NODE_FACTORY_):d==ol.geom.GeometryType.MULTI_POLYGON?(e=b.getPolygons(),f=ol.format.KML.POLYGON_NODE_FACTORY_):ol.asserts.assert(!1,
39);ol.xml.pushSerializeAndPop(a,ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_,f,e,c)};ol.format.KML.writeBoundaryIs_=function(a,b,c){ol.xml.pushSerializeAndPop({node:a},ol.format.KML.BOUNDARY_IS_SERIALIZERS_,ol.format.KML.LINEAR_RING_NODE_FACTORY_,[b],c)};
ol.format.KML.writePlacemark_=function(a,b,c){var d={node:a};b.getId()&&a.setAttribute("id",b.getId());a=b.getProperties();var e={address:1,description:1,name:1,open:1,phoneNumber:1,styleUrl:1,visibility:1};e[b.getGeometryName()]=1;var f=Object.keys(a||{}).sort().filter(function(a){return!e[a]});if(0<f.length){var g=ol.xml.makeSequence(a,f);ol.xml.pushSerializeAndPop(d,ol.format.KML.PLACEMARK_SERIALIZERS_,ol.format.KML.EXTENDEDDATA_NODE_FACTORY_,[{names:f,values:g}],c)}if(f=b.getStyleFunction())if(f=
f.call(b,0))f=Array.isArray(f)?f[0]:f,this.writeStyles_&&(a.Style=f),(f=f.getText())&&(a.name=f.getText());f=ol.format.KML.PLACEMARK_SEQUENCE_[c[c.length-1].node.namespaceURI];a=ol.xml.makeSequence(a,f);ol.xml.pushSerializeAndPop(d,ol.format.KML.PLACEMARK_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,a,c,f);a=c[0];(b=b.getGeometry())&&(b=ol.format.Feature.transformWithOptions(b,!0,a));ol.xml.pushSerializeAndPop(d,ol.format.KML.PLACEMARK_SERIALIZERS_,ol.format.KML.GEOMETRY_NODE_FACTORY_,[b],c)};
ol.format.KML.writePrimitiveGeometry_=function(a,b,c){var d=b.getFlatCoordinates();a={node:a};a.layout=b.getLayout();a.stride=b.getStride();b=b.getProperties();b.coordinates=d;d=ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_[c[c.length-1].node.namespaceURI];b=ol.xml.makeSequence(b,d);ol.xml.pushSerializeAndPop(a,ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,b,c,d)};
ol.format.KML.writePolygon_=function(a,b,c){b=b.getLinearRings();var d=b.shift();a={node:a};ol.xml.pushSerializeAndPop(a,ol.format.KML.POLYGON_SERIALIZERS_,ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_,b,c);ol.xml.pushSerializeAndPop(a,ol.format.KML.POLYGON_SERIALIZERS_,ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_,[d],c)};ol.format.KML.writePolyStyle_=function(a,b,c){ol.xml.pushSerializeAndPop({node:a},ol.format.KML.POLY_STYLE_SERIALIZERS_,ol.format.KML.COLOR_NODE_FACTORY_,[b.getColor()],c)};
ol.format.KML.writeScaleTextNode_=function(a,b){ol.format.XSD.writeDecimalTextNode(a,Math.round(1E6*b)/1E6)};
ol.format.KML.writeStyle_=function(a,b,c){a={node:a};var d={},e=b.getFill(),f=b.getStroke(),g=b.getImage();b=b.getText();g instanceof ol.style.Icon&&(d.IconStyle=g);b&&(d.LabelStyle=b);f&&(d.LineStyle=f);e&&(d.PolyStyle=e);b=ol.format.KML.STYLE_SEQUENCE_[c[c.length-1].node.namespaceURI];d=ol.xml.makeSequence(d,b);ol.xml.pushSerializeAndPop(a,ol.format.KML.STYLE_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,d,c,b)};
ol.format.KML.writeVec2_=function(a,b){a.setAttribute("x",b.x);a.setAttribute("y",b.y);a.setAttribute("xunits",b.xunits);a.setAttribute("yunits",b.yunits)};ol.format.KML.KML_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["Document","Placemark"]);ol.format.KML.KML_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Document:ol.xml.makeChildAppender(ol.format.KML.writeDocument_),Placemark:ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)});
ol.format.KML.DOCUMENT_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Placemark:ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)});ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Data:ol.xml.makeChildAppender(ol.format.KML.writeDataNode_),value:ol.xml.makeChildAppender(ol.format.KML.writeDataNodeValue_),displayName:ol.xml.makeChildAppender(ol.format.KML.writeDataNodeName_)});
ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_={Point:"Point",LineString:"LineString",LinearRing:"LinearRing",Polygon:"Polygon",MultiPoint:"MultiGeometry",MultiLineString:"MultiGeometry",MultiPolygon:"MultiGeometry",GeometryCollection:"MultiGeometry"};ol.format.KML.ICON_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["href"],ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,["x","y","w","h"]));
ol.format.KML.ICON_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{href:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)},ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_,{x:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),y:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),w:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),h:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)}));
ol.format.KML.ICON_STYLE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["scale","heading","Icon","hotSpot"]);ol.format.KML.ICON_STYLE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{Icon:ol.xml.makeChildAppender(ol.format.KML.writeIcon_),heading:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),hotSpot:ol.xml.makeChildAppender(ol.format.KML.writeVec2_),scale:ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)});
ol.format.KML.LABEL_STYLE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["color","scale"]);ol.format.KML.LABEL_STYLE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_),scale:ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)});ol.format.KML.LINE_STYLE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["color","width"]);
ol.format.KML.LINE_STYLE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_),width:ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)});ol.format.KML.BOUNDARY_IS_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LinearRing:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_)});
ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{LineString:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_),Point:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_),Polygon:ol.xml.makeChildAppender(ol.format.KML.writePolygon_),GeometryCollection:ol.xml.makeChildAppender(ol.format.KML.writeMultiGeometry_)});ol.format.KML.PLACEMARK_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,"name open visibility address phoneNumber description styleUrl Style".split(" "));
ol.format.KML.PLACEMARK_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{ExtendedData:ol.xml.makeChildAppender(ol.format.KML.writeExtendedData_),MultiGeometry:ol.xml.makeChildAppender(ol.format.KML.writeMultiGeometry_),LineString:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_),LinearRing:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_),Point:ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_),Polygon:ol.xml.makeChildAppender(ol.format.KML.writePolygon_),
Style:ol.xml.makeChildAppender(ol.format.KML.writeStyle_),address:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),description:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),name:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),open:ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),phoneNumber:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),styleUrl:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),visibility:ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode)});
ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["extrude","tessellate","altitudeMode","coordinates"]);ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{extrude:ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),tessellate:ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),altitudeMode:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),coordinates:ol.xml.makeChildAppender(ol.format.KML.writeCoordinatesTextNode_)});
ol.format.KML.POLYGON_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{outerBoundaryIs:ol.xml.makeChildAppender(ol.format.KML.writeBoundaryIs_),innerBoundaryIs:ol.xml.makeChildAppender(ol.format.KML.writeBoundaryIs_)});ol.format.KML.POLY_STYLE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{color:ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_)});
ol.format.KML.STYLE_SEQUENCE_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,["IconStyle","LabelStyle","LineStyle","PolyStyle"]);ol.format.KML.STYLE_SERIALIZERS_=ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_,{IconStyle:ol.xml.makeChildAppender(ol.format.KML.writeIconStyle_),LabelStyle:ol.xml.makeChildAppender(ol.format.KML.writeLabelStyle_),LineStyle:ol.xml.makeChildAppender(ol.format.KML.writeLineStyle_),PolyStyle:ol.xml.makeChildAppender(ol.format.KML.writePolyStyle_)});
ol.format.KML.GX_NODE_FACTORY_=function(a,b,c){return ol.xml.createElementNS(ol.format.KML.GX_NAMESPACE_URIS_[0],"gx:"+c)};ol.format.KML.DOCUMENT_NODE_FACTORY_=function(a,b,c){return ol.xml.createElementNS(b[b.length-1].node.namespaceURI,"Placemark")};ol.format.KML.GEOMETRY_NODE_FACTORY_=function(a,b,c){if(a)return ol.xml.createElementNS(b[b.length-1].node.namespaceURI,ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_[a.getType()])};ol.format.KML.COLOR_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("color");
ol.format.KML.DATA_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("Data");ol.format.KML.EXTENDEDDATA_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("ExtendedData");ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("innerBoundaryIs");ol.format.KML.POINT_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("Point");ol.format.KML.LINE_STRING_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("LineString");ol.format.KML.LINEAR_RING_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("LinearRing");
ol.format.KML.POLYGON_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("Polygon");ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_=ol.xml.makeSimpleNodeFactory("outerBoundaryIs");
ol.format.KML.prototype.writeFeaturesNode=function(a,b){b=this.adaptOptions(b);var c=ol.xml.createElementNS(ol.format.KML.NAMESPACE_URIS_[4],"kml");ol.xml.setAttributeNS(c,"http://www.w3.org/2000/xmlns/","xmlns:gx",ol.format.KML.GX_NAMESPACE_URIS_[0]);ol.xml.setAttributeNS(c,"http://www.w3.org/2000/xmlns/","xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance");ol.xml.setAttributeNS(c,"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",ol.format.KML.SCHEMA_LOCATION_);var d={node:c},
e={};1<a.length?e.Document=a:1==a.length&&(e.Placemark=a[0]);a=ol.format.KML.KML_SEQUENCE_[c.namespaceURI];e=ol.xml.makeSequence(e,a);ol.xml.pushSerializeAndPop(d,ol.format.KML.KML_SERIALIZERS_,ol.xml.OBJECT_PROPERTY_NODE_FACTORY,e,[b],a,this);return c};ol.ext.PBF=function(){};
(function(){(function(a){function b(a){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(a)?a:new Uint8Array(a||0);this.type=this.pos=0;this.length=this.buf.length}function c(a,b,c){var d=c.buf;var f=d[c.pos++];var g=(f&112)>>4;if(128>f)return e(a,g,b);f=d[c.pos++];g|=(f&127)<<3;if(128>f)return e(a,g,b);f=d[c.pos++];g|=(f&127)<<10;if(128>f)return e(a,g,b);f=d[c.pos++];g|=(f&127)<<17;if(128>f)return e(a,g,b);f=d[c.pos++];g|=(f&127)<<24;if(128>f)return e(a,g,b);f=d[c.pos++];if(128>f)return e(a,g|(f&1)<<
31,b);throw Error("Expected varint not more than 10 bytes");}function d(a){return a.type===b.Bytes?a.readVarint()+a.pos:a.pos+1}function e(a,b,c){return c?4294967296*b+(a>>>0):4294967296*(b>>>0)+(a>>>0)}function f(a,b,c){b=16383>=b?1:2097151>=b?2:268435455>=b?3:Math.ceil(Math.log(b)/(7*Math.LN2));c.realloc(b);for(var d=c.pos-1;d>=a;d--)c.buf[d+b]=c.buf[d]}function g(a,b){for(var c=0;c<a.length;c++)b.writeVarint(a[c])}function h(a,b){for(var c=0;c<a.length;c++)b.writeSVarint(a[c])}function k(a,b){for(var c=
0;c<a.length;c++)b.writeFloat(a[c])}function l(a,b){for(var c=0;c<a.length;c++)b.writeDouble(a[c])}function m(a,b){for(var c=0;c<a.length;c++)b.writeBoolean(a[c])}function n(a,b){for(var c=0;c<a.length;c++)b.writeFixed32(a[c])}function p(a,b){for(var c=0;c<a.length;c++)b.writeSFixed32(a[c])}function q(a,b){for(var c=0;c<a.length;c++)b.writeFixed64(a[c])}function r(a,b){for(var c=0;c<a.length;c++)b.writeSFixed64(a[c])}function u(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16)+16777216*a[b+3]}function t(a,b,
c){a[c]=b;a[c+1]=b>>>8;a[c+2]=b>>>16;a[c+3]=b>>>24}function v(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16)+(a[b+3]<<24)}var w={read:function(a,b,c,d,e){var f=8*e-d-1;var g=(1<<f)-1,h=g>>1,k=-7;e=c?e-1:0;var l=c?-1:1,m=a[b+e];e+=l;c=m&(1<<-k)-1;m>>=-k;for(k+=f;0<k;c=256*c+a[b+e],e+=l,k-=8);f=c&(1<<-k)-1;c>>=-k;for(k+=d;0<k;f=256*f+a[b+e],e+=l,k-=8);if(0===c)c=1-h;else{if(c===g)return f?NaN:Infinity*(m?-1:1);f+=Math.pow(2,d);c-=h}return(m?-1:1)*f*Math.pow(2,c-d)},write:function(a,b,c,d,e,f){var g,h=8*f-e-
1,k=(1<<h)-1,l=k>>1,m=23===e?Math.pow(2,-24)-Math.pow(2,-77):0;f=d?0:f-1;var n=d?1:-1,p=0>b||0===b&&0>1/b?1:0;b=Math.abs(b);isNaN(b)||Infinity===b?(b=isNaN(b)?1:0,d=k):(d=Math.floor(Math.log(b)/Math.LN2),1>b*(g=Math.pow(2,-d))&&(d--,g*=2),b=1<=d+l?b+m/g:b+m*Math.pow(2,1-l),2<=b*g&&(d++,g/=2),d+l>=k?(b=0,d=k):1<=d+l?(b=(b*g-1)*Math.pow(2,e),d+=l):(b=b*Math.pow(2,l-1)*Math.pow(2,e),d=0));for(;8<=e;a[c+f]=b&255,f+=n,b/=256,e-=8);d=d<<e|b;for(h+=e;0<h;a[c+f]=d&255,f+=n,d/=256,h-=8);a[c+f-n]|=128*p}};
b.Varint=0;b.Fixed64=1;b.Bytes=2;b.Fixed32=5;var y=1/4294967296;b.prototype={destroy:function(){this.buf=null},readFields:function(a,b,c){for(c=c||this.length;this.pos<c;){var d=this.readVarint(),e=d>>3,f=this.pos;this.type=d&7;a(e,b,this);this.pos===f&&this.skip(d)}return b},readMessage:function(a,b){return this.readFields(a,b,this.readVarint()+this.pos)},readFixed32:function(){var a=u(this.buf,this.pos);this.pos+=4;return a},readSFixed32:function(){var a=v(this.buf,this.pos);this.pos+=4;return a},
readFixed64:function(){var a=u(this.buf,this.pos)+4294967296*u(this.buf,this.pos+4);this.pos+=8;return a},readSFixed64:function(){var a=u(this.buf,this.pos)+4294967296*v(this.buf,this.pos+4);this.pos+=8;return a},readFloat:function(){var a=w.read(this.buf,this.pos,!0,23,4);this.pos+=4;return a},readDouble:function(){var a=w.read(this.buf,this.pos,!0,52,8);this.pos+=8;return a},readVarint:function(a){var b=this.buf;var d=b[this.pos++];var e=d&127;if(128>d)return e;d=b[this.pos++];e|=(d&127)<<7;if(128>
d)return e;d=b[this.pos++];e|=(d&127)<<14;if(128>d)return e;d=b[this.pos++];e|=(d&127)<<21;if(128>d)return e;d=b[this.pos];return c(e|(d&15)<<28,a,this)},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var a=this.readVarint();return 1===a%2?(a+1)/-2:a/2},readBoolean:function(){return!!this.readVarint()},readString:function(){for(var a=this.readVarint()+this.pos,b=this.buf,c="",d=this.pos;d<a;){var e=b[d],f=null,g=239<e?4:223<e?3:191<e?2:1;if(d+g>a)break;if(1===g)128>e&&
(f=e);else if(2===g){var h=b[d+1];128===(h&192)&&(f=(e&31)<<6|h&63,127>=f&&(f=null))}else if(3===g){h=b[d+1];var k=b[d+2];128===(h&192)&&128===(k&192)&&(f=(e&15)<<12|(h&63)<<6|k&63,2047>=f||55296<=f&&57343>=f)&&(f=null)}else if(4===g){h=b[d+1];k=b[d+2];var l=b[d+3];128===(h&192)&&128===(k&192)&&128===(l&192)&&(f=(e&15)<<18|(h&63)<<12|(k&63)<<6|l&63,65535>=f||1114112<=f)&&(f=null)}null===f?(f=65533,g=1):65535<f&&(f-=65536,c+=String.fromCharCode(f>>>10&1023|55296),f=56320|f&1023);c+=String.fromCharCode(f);
d+=g}this.pos=a;return c},readBytes:function(){var a=this.readVarint()+this.pos,b=this.buf.subarray(this.pos,a);this.pos=a;return b},readPackedVarint:function(a,b){var c=d(this);for(a=a||[];this.pos<c;)a.push(this.readVarint(b));return a},readPackedSVarint:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readSVarint());return a},readPackedBoolean:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readBoolean());return a},readPackedFloat:function(a){var b=d(this);for(a=a||[];this.pos<
b;)a.push(this.readFloat());return a},readPackedDouble:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readDouble());return a},readPackedFixed32:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readFixed32());return a},readPackedSFixed32:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readSFixed32());return a},readPackedFixed64:function(a){var b=d(this);for(a=a||[];this.pos<b;)a.push(this.readFixed64());return a},readPackedSFixed64:function(a){var b=d(this);
for(a=a||[];this.pos<b;)a.push(this.readSFixed64());return a},skip:function(a){a&=7;if(a===b.Varint)for(;127<this.buf[this.pos++];);else if(a===b.Bytes)this.pos=this.readVarint()+this.pos;else if(a===b.Fixed32)this.pos+=4;else if(a===b.Fixed64)this.pos+=8;else throw Error("Unimplemented type: "+a);},writeTag:function(a,b){this.writeVarint(a<<3|b)},realloc:function(a){for(var b=this.length||16;b<this.pos+a;)b*=2;b!==this.length&&(a=new Uint8Array(b),a.set(this.buf),this.buf=a,this.length=b)},finish:function(){this.length=
this.pos;this.pos=0;return this.buf.subarray(0,this.length)},writeFixed32:function(a){this.realloc(4);t(this.buf,a,this.pos);this.pos+=4},writeSFixed32:function(a){this.realloc(4);t(this.buf,a,this.pos);this.pos+=4},writeFixed64:function(a){this.realloc(8);t(this.buf,a&-1,this.pos);t(this.buf,Math.floor(a*y),this.pos+4);this.pos+=8},writeSFixed64:function(a){this.realloc(8);t(this.buf,a&-1,this.pos);t(this.buf,Math.floor(a*y),this.pos+4);this.pos+=8},writeVarint:function(a){a=+a||0;if(268435455<a||
0>a){if(0<=a){var b=a%4294967296|0;var c=a/4294967296|0}else b=~(-a%4294967296),c=~(-a/4294967296),b^4294967295?b=b+1|0:(b=0,c=c+1|0);if(1.8446744073709552E19<=a||-1.8446744073709552E19>a)throw Error("Given varint doesn't fit into 10 bytes");this.realloc(10);a=b;this.buf[this.pos++]=a&127|128;a>>>=7;this.buf[this.pos++]=a&127|128;a>>>=7;this.buf[this.pos++]=a&127|128;a>>>=7;this.buf[this.pos++]=a&127|128;this.buf[this.pos]=a>>>7&127;this.buf[this.pos++]|=(c&7)<<4|((c>>>=3)?128:0);c&&(this.buf[this.pos++]=
c&127|((c>>>=7)?128:0),c&&(this.buf[this.pos++]=c&127|((c>>>=7)?128:0),c&&(this.buf[this.pos++]=c&127|((c>>>=7)?128:0),c&&(this.buf[this.pos++]=c&127|((c>>>=7)?128:0),c&&(this.buf[this.pos++]=c&127)))))}else this.realloc(4),this.buf[this.pos++]=a&127|(127<a?128:0),127>=a||(this.buf[this.pos++]=(a>>>=7)&127|(127<a?128:0),127>=a||(this.buf[this.pos++]=(a>>>=7)&127|(127<a?128:0),127>=a||(this.buf[this.pos++]=a>>>7&127)))},writeSVarint:function(a){this.writeVarint(0>a?2*-a-1:2*a)},writeBoolean:function(a){this.writeVarint(!!a)},
writeString:function(a){a=String(a);this.realloc(4*a.length);this.pos++;for(var b=this.pos,c=this.buf,d=this.pos,e=0,g,h;e<a.length;e++){g=a.charCodeAt(e);if(55295<g&&57344>g)if(h)if(56320>g){c[d++]=239;c[d++]=191;c[d++]=189;h=g;continue}else g=h-55296<<10|g-56320|65536,h=null;else{56319<g||e+1===a.length?(c[d++]=239,c[d++]=191,c[d++]=189):h=g;continue}else h&&(c[d++]=239,c[d++]=191,c[d++]=189,h=null);128>g?c[d++]=g:(2048>g?c[d++]=g>>6|192:(65536>g?c[d++]=g>>12|224:(c[d++]=g>>18|240,c[d++]=g>>12&
63|128),c[d++]=g>>6&63|128),c[d++]=g&63|128)}this.pos=d;c=this.pos-b;128<=c&&f(b,c,this);this.pos=b-1;this.writeVarint(c);this.pos+=c},writeFloat:function(a){this.realloc(4);w.write(this.buf,a,this.pos,!0,23,4);this.pos+=4},writeDouble:function(a){this.realloc(8);w.write(this.buf,a,this.pos,!0,52,8);this.pos+=8},writeBytes:function(a){var b=a.length;this.writeVarint(b);this.realloc(b);for(var c=0;c<b;c++)this.buf[this.pos++]=a[c]},writeRawMessage:function(a,b){this.pos++;var c=this.pos;a(b,this);
a=this.pos-c;128<=a&&f(c,a,this);this.pos=c-1;this.writeVarint(a);this.pos+=a},writeMessage:function(a,c,d){this.writeTag(a,b.Bytes);this.writeRawMessage(c,d)},writePackedVarint:function(a,b){this.writeMessage(a,g,b)},writePackedSVarint:function(a,b){this.writeMessage(a,h,b)},writePackedBoolean:function(a,b){this.writeMessage(a,m,b)},writePackedFloat:function(a,b){this.writeMessage(a,k,b)},writePackedDouble:function(a,b){this.writeMessage(a,l,b)},writePackedFixed32:function(a,b){this.writeMessage(a,
n,b)},writePackedSFixed32:function(a,b){this.writeMessage(a,p,b)},writePackedFixed64:function(a,b){this.writeMessage(a,q,b)},writePackedSFixed64:function(a,b){this.writeMessage(a,r,b)},writeBytesField:function(a,c){this.writeTag(a,b.Bytes);this.writeBytes(c)},writeFixed32Field:function(a,c){this.writeTag(a,b.Fixed32);this.writeFixed32(c)},writeSFixed32Field:function(a,c){this.writeTag(a,b.Fixed32);this.writeSFixed32(c)},writeFixed64Field:function(a,c){this.writeTag(a,b.Fixed64);this.writeFixed64(c)},
writeSFixed64Field:function(a,c){this.writeTag(a,b.Fixed64);this.writeSFixed64(c)},writeVarintField:function(a,c){this.writeTag(a,b.Varint);this.writeVarint(c)},writeSVarintField:function(a,c){this.writeTag(a,b.Varint);this.writeSVarint(c)},writeStringField:function(a,c){this.writeTag(a,b.Bytes);this.writeString(c)},writeFloatField:function(a,c){this.writeTag(a,b.Fixed32);this.writeFloat(c)},writeDoubleField:function(a,c){this.writeTag(a,b.Fixed64);this.writeDouble(c)},writeBooleanField:function(a,
b){this.writeVarintField(a,!!b)}};a["default"]=b})(this.PBF=this.PBF||{})}).call(ol.ext);ol.ext.PBF=ol.ext.PBF.default;ol.render.Feature=function(a,b,c,d,e){this.id_=e;this.type_=a;this.flatCoordinates_=b;this.flatMidpoints_=this.flatInteriorPoints_=null;this.ends_=c;this.properties_=d;this.tmpTransform_=ol.transform.create()};ol.render.Feature.prototype.get=function(a){return this.properties_[a]};ol.render.Feature.prototype.getEnds=ol.render.Feature.prototype.getEndss=function(){return this.ends_};
ol.render.Feature.prototype.getExtent=function(){this.extent_||(this.extent_=this.type_===ol.geom.GeometryType.POINT?ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates_):ol.extent.createOrUpdateFromFlatCoordinates(this.flatCoordinates_,0,this.flatCoordinates_.length,2));return this.extent_};
ol.render.Feature.prototype.getFlatInteriorPoint=function(){if(!this.flatInteriorPoints_){var a=ol.extent.getCenter(this.getExtent());this.flatInteriorPoints_=ol.geom.flat.interiorpoint.linearRings(this.flatCoordinates_,0,this.ends_,2,a,0)}return this.flatInteriorPoints_};
ol.render.Feature.prototype.getFlatInteriorPoints=function(){if(!this.flatInteriorPoints_){var a=ol.geom.flat.center.linearRingss(this.flatCoordinates_,0,this.ends_,2);this.flatInteriorPoints_=ol.geom.flat.interiorpoint.linearRingss(this.flatCoordinates_,0,this.ends_,2,a)}return this.flatInteriorPoints_};ol.render.Feature.prototype.getFlatMidpoint=function(){this.flatMidpoints_||(this.flatMidpoints_=ol.geom.flat.interpolate.lineString(this.flatCoordinates_,0,this.flatCoordinates_.length,2,.5));return this.flatMidpoints_};
ol.render.Feature.prototype.getFlatMidpoints=function(){if(!this.flatMidpoints_){this.flatMidpoints_=[];for(var a=this.flatCoordinates_,b=0,c=this.ends_,d=0,e=c.length;d<e;++d){var f=c[d];b=ol.geom.flat.interpolate.lineString(a,b,f,2,.5);ol.array.extend(this.flatMidpoints_,b);b=f}}return this.flatMidpoints_};ol.render.Feature.prototype.getId=function(){return this.id_};ol.render.Feature.prototype.getOrientedFlatCoordinates=function(){return this.flatCoordinates_};
ol.render.Feature.prototype.getFlatCoordinates=ol.render.Feature.prototype.getOrientedFlatCoordinates;ol.render.Feature.prototype.getGeometry=function(){return this};ol.render.Feature.prototype.getProperties=function(){return this.properties_};ol.render.Feature.prototype.getSimplifiedGeometry=ol.render.Feature.prototype.getGeometry;ol.render.Feature.prototype.getStride=function(){return 2};ol.render.Feature.prototype.getStyleFunction=ol.nullFunction;ol.render.Feature.prototype.getType=function(){return this.type_};
ol.render.Feature.prototype.transform=function(a,b){b=a.getExtent();a=a.getWorldExtent();b=ol.extent.getHeight(a)/ol.extent.getHeight(b);var c=this.tmpTransform_;ol.transform.compose(c,a[0],a[3],b,-b,0,0,0);ol.geom.flat.transform.transform2D(this.flatCoordinates_,0,this.flatCoordinates_.length,2,c,this.flatCoordinates_)};ol.format.MVT=function(a){ol.format.Feature.call(this);a=a?a:{};this.defaultDataProjection=new ol.proj.Projection({code:"EPSG:3857",units:ol.proj.Units.TILE_PIXELS});this.featureClass_=a.featureClass?a.featureClass:ol.render.Feature;this.geometryName_=a.geometryName;this.layerName_=a.layerName?a.layerName:"layer";this.layers_=a.layers?a.layers:null;this.extent_=null};ol.inherits(ol.format.MVT,ol.format.Feature);
ol.format.MVT.pbfReaders_={layers:function(a,b,c){if(3===a){a={keys:[],values:[],features:[]};var d=c.readVarint()+c.pos;c.readFields(ol.format.MVT.pbfReaders_.layer,a,d);a.length=a.features.length;a.length&&(b[a.name]=a)}},layer:function(a,b,c){if(15===a)b.version=c.readVarint();else if(1===a)b.name=c.readString();else if(5===a)b.extent=c.readVarint();else if(2===a)b.features.push(c.pos);else if(3===a)b.keys.push(c.readString());else if(4===a){a=null;for(var d=c.readVarint()+c.pos;c.pos<d;)a=c.readVarint()>>
3,a=1===a?c.readString():2===a?c.readFloat():3===a?c.readDouble():4===a?c.readVarint64():5===a?c.readVarint():6===a?c.readSVarint():7===a?c.readBoolean():null;b.values.push(a)}},feature:function(a,b,c){if(1==a)b.id=c.readVarint();else if(2==a)for(a=c.readVarint()+c.pos;c.pos<a;){var d=b.layer.keys[c.readVarint()],e=b.layer.values[c.readVarint()];b.properties[d]=e}else 3==a?b.type=c.readVarint():4==a&&(b.geometry=c.pos)}};
ol.format.MVT.readRawFeature_=function(a,b,c){a.pos=b.features[c];c=a.readVarint()+a.pos;b={layer:b,type:0,properties:{}};a.readFields(ol.format.MVT.pbfReaders_.feature,b,c);return b};
ol.format.MVT.readRawGeometry_=function(a,b,c,d){a.pos=b.geometry;b=a.readVarint()+a.pos;for(var e=1,f=0,g=0,h=0,k=0,l=0;a.pos<b;)f||(f=a.readVarint(),e=f&7,f>>=3),f--,1===e||2===e?(g+=a.readSVarint(),h+=a.readSVarint(),1===e&&k>l&&(d.push(k),l=k),c.push(g,h),k+=2):7===e?k>l&&(c.push(c[l],c[l+1]),k+=2):ol.asserts.assert(!1,59);k>l&&d.push(k)};
ol.format.MVT.getGeometryType_=function(a,b){if(1===a)var c=1===b?ol.geom.GeometryType.POINT:ol.geom.GeometryType.MULTI_POINT;else 2===a?c=1===b?ol.geom.GeometryType.LINE_STRING:ol.geom.GeometryType.MULTI_LINE_STRING:3===a&&(c=ol.geom.GeometryType.POLYGON);return c};
ol.format.MVT.prototype.createFeature_=function(a,b,c){var d=b.type;if(0===d)return null;var e=b.id,f=b.properties;f[this.layerName_]=b.layer.name;var g=[];var h=[];ol.format.MVT.readRawGeometry_(a,b,g,h);a=ol.format.MVT.getGeometryType_(d,h.length);if(this.featureClass_===ol.render.Feature)g=new this.featureClass_(a,g,h,f,e);else{if(a==ol.geom.GeometryType.POLYGON){a=[];for(var k=d=b=0,l=h.length;k<l;++k){var m=h[k];ol.geom.flat.orient.linearRingIsClockwise(g,b,m,2)||(a.push(h.slice(d,k)),d=k);b=
m}1<a.length?(h=a,a=new ol.geom.MultiPolygon(null)):a=new ol.geom.Polygon(null)}else a=a===ol.geom.GeometryType.POINT?new ol.geom.Point(null):a===ol.geom.GeometryType.LINE_STRING?new ol.geom.LineString(null):a===ol.geom.GeometryType.POLYGON?new ol.geom.Polygon(null):a===ol.geom.GeometryType.MULTI_POINT?new ol.geom.MultiPoint(null):a===ol.geom.GeometryType.MULTI_LINE_STRING?new ol.geom.MultiLineString(null):null;a.setFlatCoordinates(ol.geom.GeometryLayout.XY,g,h);g=new this.featureClass_;this.geometryName_&&
g.setGeometryName(this.geometryName_);c=ol.format.Feature.transformWithOptions(a,!1,this.adaptOptions(c));g.setGeometry(c);g.setId(e);g.setProperties(f)}return g};ol.format.MVT.prototype.getLastExtent=function(){return this.extent_};ol.format.MVT.prototype.getType=function(){return ol.format.FormatType.ARRAY_BUFFER};
ol.format.MVT.prototype.readFeatures=function(a,b){b=this.layers_;a=new ol.ext.PBF(a);var c=a.readFields(ol.format.MVT.pbfReaders_.layers,{}),d=[],e;for(e in c)if(!b||-1!=b.indexOf(e)){var f=c[e];for(var g,h=0,k=f.length;h<k;++h)g=ol.format.MVT.readRawFeature_(a,f,h),d.push(this.createFeature_(a,g));this.extent_=f?[0,0,f.extent,f.extent]:null}return d};ol.format.MVT.prototype.readProjection=function(a){return this.defaultDataProjection};ol.format.MVT.prototype.setLayers=function(a){this.layers_=a};
ol.format.MVT.prototype.readFeature=function(){};ol.format.MVT.prototype.readGeometry=function(){};ol.format.MVT.prototype.writeFeature=function(){};ol.format.MVT.prototype.writeGeometry=function(){};ol.format.MVT.prototype.writeFeatures=function(){};ol.format.OSMXML=function(){ol.format.XMLFeature.call(this);this.defaultDataProjection=ol.proj.get("EPSG:4326")};ol.inherits(ol.format.OSMXML,ol.format.XMLFeature);
ol.format.OSMXML.readNode_=function(a,b){var c=b[0],d=b[b.length-1],e=a.getAttribute("id"),f=[parseFloat(a.getAttribute("lon")),parseFloat(a.getAttribute("lat"))];d.nodes[e]=f;a=ol.xml.pushParseAndPop({tags:{}},ol.format.OSMXML.NODE_PARSERS_,a,b);ol.obj.isEmpty(a.tags)||(f=new ol.geom.Point(f),ol.format.Feature.transformWithOptions(f,!1,c),c=new ol.Feature(f),c.setId(e),c.setProperties(a.tags),d.features.push(c))};
ol.format.OSMXML.readWay_=function(a,b){var c=a.getAttribute("id");a=ol.xml.pushParseAndPop({id:c,ndrefs:[],tags:{}},ol.format.OSMXML.WAY_PARSERS_,a,b);b[b.length-1].ways.push(a)};ol.format.OSMXML.readNd_=function(a,b){b[b.length-1].ndrefs.push(a.getAttribute("ref"))};ol.format.OSMXML.readTag_=function(a,b){b[b.length-1].tags[a.getAttribute("k")]=a.getAttribute("v")};ol.format.OSMXML.NAMESPACE_URIS_=[null];
ol.format.OSMXML.WAY_PARSERS_=ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_,{nd:ol.format.OSMXML.readNd_,tag:ol.format.OSMXML.readTag_});ol.format.OSMXML.PARSERS_=ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_,{node:ol.format.OSMXML.readNode_,way:ol.format.OSMXML.readWay_});ol.format.OSMXML.NODE_PARSERS_=ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_,{tag:ol.format.OSMXML.readTag_});
ol.format.OSMXML.prototype.readFeaturesFromNode=function(a,b){b=this.getReadOptions(a,b);if("osm"==a.localName){a=ol.xml.pushParseAndPop({nodes:{},ways:[],features:[]},ol.format.OSMXML.PARSERS_,a,[b]);for(var c=0;c<a.ways.length;c++){for(var d=a.ways[c],e=[],f=0,g=d.ndrefs.length;f<g;f++)ol.array.extend(e,a.nodes[d.ndrefs[f]]);d.ndrefs[0]==d.ndrefs[d.ndrefs.length-1]?(f=new ol.geom.Polygon(null),f.setFlatCoordinates(ol.geom.GeometryLayout.XY,e,[e.length])):(f=new ol.geom.LineString(null),f.setFlatCoordinates(ol.geom.GeometryLayout.XY,
e));ol.format.Feature.transformWithOptions(f,!1,b);e=new ol.Feature(f);e.setId(d.id);e.setProperties(d.tags);a.features.push(e)}if(a.features)return a.features}return[]};ol.format.OSMXML.prototype.writeFeatureNode=function(a,b){};ol.format.OSMXML.prototype.writeFeaturesNode=function(a,b){};ol.format.OSMXML.prototype.writeGeometryNode=function(a,b){};ol.geom.flat.flip={};ol.geom.flat.flip.flipXY=function(a,b,c,d,e,f){void 0!==e?f=void 0!==f?f:0:(e=[],f=0);for(;b<c;){var g=a[b++];e[f++]=a[b++];e[f++]=g;for(g=2;g<d;++g)e[f++]=a[b++]}e.length=f;return e};ol.format.Polyline=function(a){a=a?a:{};ol.format.TextFeature.call(this);this.defaultDataProjection=ol.proj.get("EPSG:4326");this.factor_=a.factor?a.factor:1E5;this.geometryLayout_=a.geometryLayout?a.geometryLayout:ol.geom.GeometryLayout.XY};ol.inherits(ol.format.Polyline,ol.format.TextFeature);
ol.format.Polyline.encodeDeltas=function(a,b,c){var d,e=Array(b);for(d=0;d<b;++d)e[d]=0;var f;var g=0;for(f=a.length;g<f;)for(d=0;d<b;++d,++g){var h=a[g],k=h-e[d];e[d]=h;a[g]=k}return ol.format.Polyline.encodeFloats(a,c?c:1E5)};ol.format.Polyline.decodeDeltas=function(a,b,c){var d,e=Array(b);for(d=0;d<b;++d)e[d]=0;a=ol.format.Polyline.decodeFloats(a,c?c:1E5);var f;c=0;for(f=a.length;c<f;)for(d=0;d<b;++d,++c)e[d]+=a[c],a[c]=e[d];return a};
ol.format.Polyline.encodeFloats=function(a,b){b=b?b:1E5;var c;var d=0;for(c=a.length;d<c;++d)a[d]=Math.round(a[d]*b);return ol.format.Polyline.encodeSignedIntegers(a)};ol.format.Polyline.decodeFloats=function(a,b){b=b?b:1E5;a=ol.format.Polyline.decodeSignedIntegers(a);var c;var d=0;for(c=a.length;d<c;++d)a[d]/=b;return a};ol.format.Polyline.encodeSignedIntegers=function(a){var b;var c=0;for(b=a.length;c<b;++c){var d=a[c];a[c]=0>d?~(d<<1):d<<1}return ol.format.Polyline.encodeUnsignedIntegers(a)};
ol.format.Polyline.decodeSignedIntegers=function(a){a=ol.format.Polyline.decodeUnsignedIntegers(a);var b;var c=0;for(b=a.length;c<b;++c){var d=a[c];a[c]=d&1?~(d>>1):d>>1}return a};ol.format.Polyline.encodeUnsignedIntegers=function(a){var b="",c;var d=0;for(c=a.length;d<c;++d)b+=ol.format.Polyline.encodeUnsignedInteger(a[d]);return b};
ol.format.Polyline.decodeUnsignedIntegers=function(a){var b=[],c=0,d=0,e;var f=0;for(e=a.length;f<e;++f){var g=a.charCodeAt(f)-63;c|=(g&31)<<d;32>g?(b.push(c),d=c=0):d+=5}return b};ol.format.Polyline.encodeUnsignedInteger=function(a){for(var b,c="";32<=a;)b=(32|a&31)+63,c+=String.fromCharCode(b),a>>=5;return c+=String.fromCharCode(a+63)};ol.format.Polyline.prototype.readFeatureFromText=function(a,b){a=this.readGeometryFromText(a,b);return new ol.Feature(a)};
ol.format.Polyline.prototype.readFeaturesFromText=function(a,b){return[this.readFeatureFromText(a,b)]};ol.format.Polyline.prototype.readGeometryFromText=function(a,b){var c=ol.geom.SimpleGeometry.getStrideForLayout(this.geometryLayout_);a=ol.format.Polyline.decodeDeltas(a,c,this.factor_);ol.geom.flat.flip.flipXY(a,0,a.length,c,a);c=ol.geom.flat.inflate.coordinates(a,0,a.length,c);return ol.format.Feature.transformWithOptions(new ol.geom.LineString(c,this.geometryLayout_),!1,this.adaptOptions(b))};
ol.format.Polyline.prototype.writeFeatureText=function(a,b){if(a=a.getGeometry())return this.writeGeometryText(a,b);ol.asserts.assert(!1,40);return""};ol.format.Polyline.prototype.writeFeaturesText=function(a,b){return this.writeFeatureText(a[0],b)};
ol.format.Polyline.prototype.writeGeometryText=function(a,b){a=ol.format.Feature.transformWithOptions(a,!0,this.adaptOptions(b));b=a.getFlatCoordinates();a=a.getStride();ol.geom.flat.flip.flipXY(b,0,b.length,a,b);return ol.format.Polyline.encodeDeltas(b,a,this.factor_)};ol.format.TopoJSON=function(a){a=a?a:{};ol.format.JSONFeature.call(this);this.layerName_=a.layerName;this.layers_=a.layers?a.layers:null;this.defaultDataProjection=ol.proj.get(a.defaultDataProjection?a.defaultDataProjection:"EPSG:4326")};ol.inherits(ol.format.TopoJSON,ol.format.JSONFeature);
ol.format.TopoJSON.concatenateArcs_=function(a,b){var c=[],d;var e=0;for(d=a.length;e<d;++e){var f=a[e];0<e&&c.pop();f=0<=f?b[f]:b[~f].slice().reverse();c.push.apply(c,f)}a=0;for(b=c.length;a<b;++a)c[a]=c[a].slice();return c};ol.format.TopoJSON.readPointGeometry_=function(a,b,c){a=a.coordinates;b&&c&&ol.format.TopoJSON.transformVertex_(a,b,c);return new ol.geom.Point(a)};
ol.format.TopoJSON.readMultiPointGeometry_=function(a,b,c){a=a.coordinates;var d;if(b&&c){var e=0;for(d=a.length;e<d;++e)ol.format.TopoJSON.transformVertex_(a[e],b,c)}return new ol.geom.MultiPoint(a)};ol.format.TopoJSON.readLineStringGeometry_=function(a,b){a=ol.format.TopoJSON.concatenateArcs_(a.arcs,b);return new ol.geom.LineString(a)};
ol.format.TopoJSON.readMultiLineStringGeometry_=function(a,b){var c=[],d;var e=0;for(d=a.arcs.length;e<d;++e)c[e]=ol.format.TopoJSON.concatenateArcs_(a.arcs[e],b);return new ol.geom.MultiLineString(c)};ol.format.TopoJSON.readPolygonGeometry_=function(a,b){var c=[],d;var e=0;for(d=a.arcs.length;e<d;++e)c[e]=ol.format.TopoJSON.concatenateArcs_(a.arcs[e],b);return new ol.geom.Polygon(c)};
ol.format.TopoJSON.readMultiPolygonGeometry_=function(a,b){var c=[],d,e;var f=0;for(e=a.arcs.length;f<e;++f){var g=a.arcs[f];var h=[];var k=0;for(d=g.length;k<d;++k)h[k]=ol.format.TopoJSON.concatenateArcs_(g[k],b);c[f]=h}return new ol.geom.MultiPolygon(c)};ol.format.TopoJSON.readFeaturesFromGeometryCollection_=function(a,b,c,d,e,f,g){a=a.geometries;var h=[],k;var l=0;for(k=a.length;l<k;++l)h[l]=ol.format.TopoJSON.readFeatureFromGeometry_(a[l],b,c,d,e,f,g);return h};
ol.format.TopoJSON.readFeatureFromGeometry_=function(a,b,c,d,e,f,g){var h=a.type,k=ol.format.TopoJSON.GEOMETRY_READERS_[h];c="Point"===h||"MultiPoint"===h?k(a,c,d):k(a,b);b=new ol.Feature;b.setGeometry(ol.format.Feature.transformWithOptions(c,!1,g));void 0!==a.id&&b.setId(a.id);a=a.properties;e&&(a||(a={}),a[e]=f);a&&b.setProperties(a);return b};
ol.format.TopoJSON.prototype.readFeaturesFromObject=function(a,b){if("Topology"==a.type){var c=null,d=null;if(a.transform){var e=a.transform;c=e.scale;d=e.translate}var f=a.arcs;e&&ol.format.TopoJSON.transformArcs_(f,c,d);e=[];a=a.objects;var g=this.layerName_,h;for(h in a)if(!this.layers_||-1!=this.layers_.indexOf(h))if("GeometryCollection"===a[h].type){var k=a[h];e.push.apply(e,ol.format.TopoJSON.readFeaturesFromGeometryCollection_(k,f,c,d,g,h,b))}else k=a[h],e.push(ol.format.TopoJSON.readFeatureFromGeometry_(k,
f,c,d,g,h,b));return e}return[]};ol.format.TopoJSON.transformArcs_=function(a,b,c){var d;var e=0;for(d=a.length;e<d;++e)ol.format.TopoJSON.transformArc_(a[e],b,c)};ol.format.TopoJSON.transformArc_=function(a,b,c){var d=0,e=0,f;var g=0;for(f=a.length;g<f;++g){var h=a[g];d+=h[0];e+=h[1];h[0]=d;h[1]=e;ol.format.TopoJSON.transformVertex_(h,b,c)}};ol.format.TopoJSON.transformVertex_=function(a,b,c){a[0]=a[0]*b[0]+c[0];a[1]=a[1]*b[1]+c[1]};ol.format.TopoJSON.prototype.readProjectionFromObject=function(a){return this.defaultDataProjection};
ol.format.TopoJSON.GEOMETRY_READERS_={Point:ol.format.TopoJSON.readPointGeometry_,LineString:ol.format.TopoJSON.readLineStringGeometry_,Polygon:ol.format.TopoJSON.readPolygonGeometry_,MultiPoint:ol.format.TopoJSON.readMultiPointGeometry_,MultiLineString:ol.format.TopoJSON.readMultiLineStringGeometry_,MultiPolygon:ol.format.TopoJSON.readMultiPolygonGeometry_};ol.format.TopoJSON.prototype.writeFeatureObject=function(a,b){};ol.format.TopoJSON.prototype.writeFeaturesObject=function(a,b){};
ol.format.TopoJSON.prototype.writeGeometryObject=function(a,b){};ol.format.TopoJSON.prototype.readGeometryFromObject=function(){};ol.format.TopoJSON.prototype.readFeatureFromObject=function(){};ol.format.filter={};ol.format.filter.Filter=function(a){this.tagName_=a};ol.format.filter.Filter.prototype.getTagName=function(){return this.tagName_};ol.format.filter.LogicalNary=function(a,b){ol.format.filter.Filter.call(this,a);this.conditions=Array.prototype.slice.call(arguments,1);ol.asserts.assert(2<=this.conditions.length,57)};ol.inherits(ol.format.filter.LogicalNary,ol.format.filter.Filter);ol.format.filter.And=function(a){var b=["And"].concat(Array.prototype.slice.call(arguments));ol.format.filter.LogicalNary.apply(this,b)};ol.inherits(ol.format.filter.And,ol.format.filter.LogicalNary);ol.format.filter.Bbox=function(a,b,c){ol.format.filter.Filter.call(this,"BBOX");this.geometryName=a;this.extent=b;this.srsName=c};ol.inherits(ol.format.filter.Bbox,ol.format.filter.Filter);ol.format.filter.Spatial=function(a,b,c,d){ol.format.filter.Filter.call(this,a);this.geometryName=b||"the_geom";this.geometry=c;this.srsName=d};ol.inherits(ol.format.filter.Spatial,ol.format.filter.Filter);ol.format.filter.Contains=function(a,b,c){ol.format.filter.Spatial.call(this,"Contains",a,b,c)};ol.inherits(ol.format.filter.Contains,ol.format.filter.Spatial);ol.format.filter.Comparison=function(a,b){ol.format.filter.Filter.call(this,a);this.propertyName=b};ol.inherits(ol.format.filter.Comparison,ol.format.filter.Filter);ol.format.filter.During=function(a,b,c){ol.format.filter.Comparison.call(this,"During",a);this.begin=b;this.end=c};ol.inherits(ol.format.filter.During,ol.format.filter.Comparison);ol.format.filter.ComparisonBinary=function(a,b,c,d){ol.format.filter.Comparison.call(this,a,b);this.expression=c;this.matchCase=d};ol.inherits(ol.format.filter.ComparisonBinary,ol.format.filter.Comparison);ol.format.filter.EqualTo=function(a,b,c){ol.format.filter.ComparisonBinary.call(this,"PropertyIsEqualTo",a,b,c)};ol.inherits(ol.format.filter.EqualTo,ol.format.filter.ComparisonBinary);ol.format.filter.GreaterThan=function(a,b){ol.format.filter.ComparisonBinary.call(this,"PropertyIsGreaterThan",a,b)};ol.inherits(ol.format.filter.GreaterThan,ol.format.filter.ComparisonBinary);ol.format.filter.GreaterThanOrEqualTo=function(a,b){ol.format.filter.ComparisonBinary.call(this,"PropertyIsGreaterThanOrEqualTo",a,b)};ol.inherits(ol.format.filter.GreaterThanOrEqualTo,ol.format.filter.ComparisonBinary);ol.format.filter.Intersects=function(a,b,c){ol.format.filter.Spatial.call(this,"Intersects",a,b,c)};ol.inherits(ol.format.filter.Intersects,ol.format.filter.Spatial);ol.format.filter.IsBetween=function(a,b,c){ol.format.filter.Comparison.call(this,"PropertyIsBetween",a);this.lowerBoundary=b;this.upperBoundary=c};ol.inherits(ol.format.filter.IsBetween,ol.format.filter.Comparison);ol.format.filter.IsLike=function(a,b,c,d,e,f){ol.format.filter.Comparison.call(this,"PropertyIsLike",a);this.pattern=b;this.wildCard=void 0!==c?c:"*";this.singleChar=void 0!==d?d:".";this.escapeChar=void 0!==e?e:"!";this.matchCase=f};ol.inherits(ol.format.filter.IsLike,ol.format.filter.Comparison);ol.format.filter.IsNull=function(a){ol.format.filter.Comparison.call(this,"PropertyIsNull",a)};ol.inherits(ol.format.filter.IsNull,ol.format.filter.Comparison);ol.format.filter.LessThan=function(a,b){ol.format.filter.ComparisonBinary.call(this,"PropertyIsLessThan",a,b)};ol.inherits(ol.format.filter.LessThan,ol.format.filter.ComparisonBinary);ol.format.filter.LessThanOrEqualTo=function(a,b){ol.format.filter.ComparisonBinary.call(this,"PropertyIsLessThanOrEqualTo",a,b)};ol.inherits(ol.format.filter.LessThanOrEqualTo,ol.format.filter.ComparisonBinary);ol.format.filter.Not=function(a){ol.format.filter.Filter.call(this,"Not");this.condition=a};ol.inherits(ol.format.filter.Not,ol.format.filter.Filter);ol.format.filter.NotEqualTo=function(a,b,c){ol.format.filter.ComparisonBinary.call(this,"PropertyIsNotEqualTo",a,b,c)};ol.inherits(ol.format.filter.NotEqualTo,ol.format.filter.ComparisonBinary);ol.format.filter.Or=function(a){var b=["Or"].concat(Array.prototype.slice.call(arguments));ol.format.filter.LogicalNary.apply(this,b)};ol.inherits(ol.format.filter.Or,ol.format.filter.LogicalNary);ol.format.filter.Within=function(a,b,c){ol.format.filter.Spatial.call(this,"Within",a,b,c)};ol.inherits(ol.format.filter.Within,ol.format.filter.Spatial);ol.format.filter.and=function(a){var b=[null].concat(Array.prototype.slice.call(arguments));return new (Function.prototype.bind.apply(ol.format.filter.And,b))};ol.format.filter.or=function(a){var b=[null].concat(Array.prototype.slice.call(arguments));return new (Function.prototype.bind.apply(ol.format.filter.Or,b))};ol.format.filter.not=function(a){return new ol.format.filter.Not(a)};ol.format.filter.bbox=function(a,b,c){return new ol.format.filter.Bbox(a,b,c)};
ol.format.filter.contains=function(a,b,c){return new ol.format.filter.Contains(a,b,c)};ol.format.filter.intersects=function(a,b,c){return new ol.format.filter.Intersects(a,b,c)};ol.format.filter.within=function(a,b,c){return new ol.format.filter.Within(a,b,c)};ol.format.filter.equalTo=function(a,b,c){return new ol.format.filter.EqualTo(a,b,c)};ol.format.filter.notEqualTo=function(a,b,c){return new ol.format.filter.NotEqualTo(a,b,c)};
ol.format.filter.lessThan=function(a,b){return new ol.format.filter.LessThan(a,b)};ol.format.filter.lessThanOrEqualTo=function(a,b){return new ol.format.filter.LessThanOrEqualTo(a,b)};ol.format.filter.greaterThan=function(a,b){return new ol.format.filter.GreaterThan(a,b)};ol.format.filter.greaterThanOrEqualTo=function(a,b){return new ol.format.filter.GreaterThanOrEqualTo(a,b)};ol.format.filter.isNull=function(a){return new ol.format.filter.IsNull(a)};
ol.format.filter.between=function(a,b,c){return new ol.format.filter.IsBetween(a,b,c)};ol.format.filter.like=function(a,b,c,d,e,f){return new ol.format.filter.IsLike(a,b,c,d,e,f)};ol.format.filter.during=function(a,b,c){return new ol.format.filter.During(a,b,c)};ol.format.WFS=function(a){a=a?a:{};this.featureType_=a.featureType;this.featureNS_=a.featureNS;this.gmlFormat_=a.gmlFormat?a.gmlFormat:new ol.format.GML3;this.schemaLocation_=a.schemaLocation?a.schemaLocation:ol.format.WFS.SCHEMA_LOCATIONS[ol.format.WFS.DEFAULT_VERSION];ol.format.XMLFeature.call(this)};ol.inherits(ol.format.WFS,ol.format.XMLFeature);ol.format.WFS.FEATURE_PREFIX="feature";ol.format.WFS.XMLNS="http://www.w3.org/2000/xmlns/";ol.format.WFS.OGCNS="http://www.opengis.net/ogc";
ol.format.WFS.WFSNS="http://www.opengis.net/wfs";ol.format.WFS.FESNS="http://www.opengis.net/fes";ol.format.WFS.SCHEMA_LOCATIONS={"1.1.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd","1.0.0":"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"};ol.format.WFS.DEFAULT_VERSION="1.1.0";ol.format.WFS.prototype.getFeatureType=function(){return this.featureType_};ol.format.WFS.prototype.setFeatureType=function(a){this.featureType_=a};
ol.format.WFS.prototype.readFeaturesFromNode=function(a,b){var c={featureType:this.featureType_,featureNS:this.featureNS_};ol.obj.assign(c,this.getReadOptions(a,b?b:{}));b=[c];this.gmlFormat_.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS].featureMember=ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);(a=ol.xml.pushParseAndPop([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,a,b,this.gmlFormat_))||(a=[]);return a};
ol.format.WFS.prototype.readTransactionResponse=function(a){if(ol.xml.isDocument(a))return this.readTransactionResponseFromDocument(a);if(ol.xml.isNode(a))return this.readTransactionResponseFromNode(a);if("string"===typeof a)return a=ol.xml.parse(a),this.readTransactionResponseFromDocument(a)};
ol.format.WFS.prototype.readFeatureCollectionMetadata=function(a){if(ol.xml.isDocument(a))return this.readFeatureCollectionMetadataFromDocument(a);if(ol.xml.isNode(a))return this.readFeatureCollectionMetadataFromNode(a);if("string"===typeof a)return a=ol.xml.parse(a),this.readFeatureCollectionMetadataFromDocument(a)};ol.format.WFS.prototype.readFeatureCollectionMetadataFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readFeatureCollectionMetadataFromNode(a)};
ol.format.WFS.FEATURE_COLLECTION_PARSERS_={"http://www.opengis.net/gml":{boundedBy:ol.xml.makeObjectPropertySetter(ol.format.GMLBase.prototype.readGeometryElement,"bounds")}};ol.format.WFS.prototype.readFeatureCollectionMetadataFromNode=function(a){var b={},c=ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("numberOfFeatures"));b.numberOfFeatures=c;return ol.xml.pushParseAndPop(b,ol.format.WFS.FEATURE_COLLECTION_PARSERS_,a,[],this.gmlFormat_)};
ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_={"http://www.opengis.net/wfs":{totalInserted:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),totalUpdated:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),totalDeleted:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)}};ol.format.WFS.readTransactionSummary_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_,a,b)};
ol.format.WFS.OGC_FID_PARSERS_={"http://www.opengis.net/ogc":{FeatureId:ol.xml.makeArrayPusher(function(a,b){return a.getAttribute("fid")})}};ol.format.WFS.fidParser_=function(a,b){ol.xml.parseNode(ol.format.WFS.OGC_FID_PARSERS_,a,b)};ol.format.WFS.INSERT_RESULTS_PARSERS_={"http://www.opengis.net/wfs":{Feature:ol.format.WFS.fidParser_}};ol.format.WFS.readInsertResults_=function(a,b){return ol.xml.pushParseAndPop([],ol.format.WFS.INSERT_RESULTS_PARSERS_,a,b)};
ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_={"http://www.opengis.net/wfs":{TransactionSummary:ol.xml.makeObjectPropertySetter(ol.format.WFS.readTransactionSummary_,"transactionSummary"),InsertResults:ol.xml.makeObjectPropertySetter(ol.format.WFS.readInsertResults_,"insertIds")}};ol.format.WFS.prototype.readTransactionResponseFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readTransactionResponseFromNode(a)};
ol.format.WFS.prototype.readTransactionResponseFromNode=function(a){return ol.xml.pushParseAndPop({},ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_,a,[])};ol.format.WFS.QUERY_SERIALIZERS_={"http://www.opengis.net/wfs":{PropertyName:ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};
ol.format.WFS.writeFeature_=function(a,b,c){var d=c[c.length-1],e=d.gmlVersion;d=ol.xml.createElementNS(d.featureNS,d.featureType);a.appendChild(d);2===e?ol.format.GML2.prototype.writeFeatureElement(d,b,c):ol.format.GML3.prototype.writeFeatureElement(d,b,c)};ol.format.WFS.writeOgcFidFilter_=function(a,b,c){c=ol.xml.createElementNS(ol.format.WFS.OGCNS,"Filter");var d=ol.xml.createElementNS(ol.format.WFS.OGCNS,"FeatureId");c.appendChild(d);d.setAttribute("fid",b);a.appendChild(c)};
ol.format.WFS.getTypeName_=function(a,b){a=a?a:ol.format.WFS.FEATURE_PREFIX;a+=":";return 0===b.indexOf(a)?b:a+b};ol.format.WFS.writeDelete_=function(a,b,c){var d=c[c.length-1];ol.asserts.assert(void 0!==b.getId(),26);var e=d.featurePrefix,f=d.featureNS;d=ol.format.WFS.getTypeName_(e,d.featureType);a.setAttribute("typeName",d);ol.xml.setAttributeNS(a,ol.format.WFS.XMLNS,"xmlns:"+e,f);b=b.getId();void 0!==b&&ol.format.WFS.writeOgcFidFilter_(a,b,c)};
ol.format.WFS.writeUpdate_=function(a,b,c){var d=c[c.length-1];ol.asserts.assert(void 0!==b.getId(),27);var e=d.featurePrefix,f=d.featureNS,g=ol.format.WFS.getTypeName_(e,d.featureType),h=b.getGeometryName();a.setAttribute("typeName",g);ol.xml.setAttributeNS(a,ol.format.WFS.XMLNS,"xmlns:"+e,f);e=b.getId();if(void 0!==e){f=b.getKeys();g=[];for(var k=0,l=f.length;k<l;k++){var m=b.get(f[k]);if(void 0!==m){var n=f[k];m instanceof ol.geom.Geometry&&(n=h);g.push({name:n,value:m})}}ol.xml.pushSerializeAndPop({gmlVersion:d.gmlVersion,
node:a,hasZ:d.hasZ,srsName:d.srsName},ol.format.WFS.TRANSACTION_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Property"),g,c);ol.format.WFS.writeOgcFidFilter_(a,e,c)}};
ol.format.WFS.writeProperty_=function(a,b,c){var d=ol.xml.createElementNS(ol.format.WFS.WFSNS,"Name"),e=c[c.length-1].gmlVersion;a.appendChild(d);ol.format.XSD.writeStringTextNode(d,b.name);void 0!==b.value&&null!==b.value&&(d=ol.xml.createElementNS(ol.format.WFS.WFSNS,"Value"),a.appendChild(d),b.value instanceof ol.geom.Geometry?2===e?ol.format.GML2.prototype.writeGeometryElement(d,b.value,c):ol.format.GML3.prototype.writeGeometryElement(d,b.value,c):ol.format.XSD.writeStringTextNode(d,b.value))};
ol.format.WFS.writeNative_=function(a,b,c){b.vendorId&&a.setAttribute("vendorId",b.vendorId);void 0!==b.safeToIgnore&&a.setAttribute("safeToIgnore",b.safeToIgnore);void 0!==b.value&&ol.format.XSD.writeStringTextNode(a,b.value)};
ol.format.WFS.TRANSACTION_SERIALIZERS_={"http://www.opengis.net/wfs":{Insert:ol.xml.makeChildAppender(ol.format.WFS.writeFeature_),Update:ol.xml.makeChildAppender(ol.format.WFS.writeUpdate_),Delete:ol.xml.makeChildAppender(ol.format.WFS.writeDelete_),Property:ol.xml.makeChildAppender(ol.format.WFS.writeProperty_),Native:ol.xml.makeChildAppender(ol.format.WFS.writeNative_)}};
ol.format.WFS.writeQuery_=function(a,b,c){var d=c[c.length-1],e=d.featurePrefix,f=d.featureNS,g=d.propertyNames,h=d.srsName;b=e?ol.format.WFS.getTypeName_(e,b):b;a.setAttribute("typeName",b);h&&a.setAttribute("srsName",h);f&&ol.xml.setAttributeNS(a,ol.format.WFS.XMLNS,"xmlns:"+e,f);e=ol.obj.assign({},d);e.node=a;ol.xml.pushSerializeAndPop(e,ol.format.WFS.QUERY_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("PropertyName"),g,c);if(d=d.filter)g=ol.xml.createElementNS(ol.format.WFS.OGCNS,"Filter"),a.appendChild(g),
ol.format.WFS.writeFilterCondition_(g,d,c)};ol.format.WFS.writeFilterCondition_=function(a,b,c){ol.xml.pushSerializeAndPop({node:a},ol.format.WFS.GETFEATURE_SERIALIZERS_,ol.xml.makeSimpleNodeFactory(b.getTagName()),[b],c)};ol.format.WFS.writeBboxFilter_=function(a,b,c){c[c.length-1].srsName=b.srsName;ol.format.WFS.writeOgcPropertyName_(a,b.geometryName);ol.format.GML3.prototype.writeGeometryElement(a,b.extent,c)};
ol.format.WFS.writeContainsFilter_=function(a,b,c){c[c.length-1].srsName=b.srsName;ol.format.WFS.writeOgcPropertyName_(a,b.geometryName);ol.format.GML3.prototype.writeGeometryElement(a,b.geometry,c)};ol.format.WFS.writeIntersectsFilter_=function(a,b,c){c[c.length-1].srsName=b.srsName;ol.format.WFS.writeOgcPropertyName_(a,b.geometryName);ol.format.GML3.prototype.writeGeometryElement(a,b.geometry,c)};
ol.format.WFS.writeWithinFilter_=function(a,b,c){c[c.length-1].srsName=b.srsName;ol.format.WFS.writeOgcPropertyName_(a,b.geometryName);ol.format.GML3.prototype.writeGeometryElement(a,b.geometry,c)};
ol.format.WFS.writeDuringFilter_=function(a,b,c){c=ol.xml.createElementNS(ol.format.WFS.FESNS,"ValueReference");ol.format.XSD.writeStringTextNode(c,b.propertyName);a.appendChild(c);c=ol.xml.createElementNS(ol.format.GMLBase.GMLNS,"TimePeriod");a.appendChild(c);a=ol.xml.createElementNS(ol.format.GMLBase.GMLNS,"begin");c.appendChild(a);ol.format.WFS.writeTimeInstant_(a,b.begin);a=ol.xml.createElementNS(ol.format.GMLBase.GMLNS,"end");c.appendChild(a);ol.format.WFS.writeTimeInstant_(a,b.end)};
ol.format.WFS.writeLogicalFilter_=function(a,b,c){a={node:a};b=b.conditions;for(var d=0,e=b.length;d<e;++d){var f=b[d];ol.xml.pushSerializeAndPop(a,ol.format.WFS.GETFEATURE_SERIALIZERS_,ol.xml.makeSimpleNodeFactory(f.getTagName()),[f],c)}};ol.format.WFS.writeNotFilter_=function(a,b,c){b=b.condition;ol.xml.pushSerializeAndPop({node:a},ol.format.WFS.GETFEATURE_SERIALIZERS_,ol.xml.makeSimpleNodeFactory(b.getTagName()),[b],c)};
ol.format.WFS.writeComparisonFilter_=function(a,b,c){void 0!==b.matchCase&&a.setAttribute("matchCase",b.matchCase.toString());ol.format.WFS.writeOgcPropertyName_(a,b.propertyName);ol.format.WFS.writeOgcLiteral_(a,""+b.expression)};ol.format.WFS.writeIsNullFilter_=function(a,b,c){ol.format.WFS.writeOgcPropertyName_(a,b.propertyName)};
ol.format.WFS.writeIsBetweenFilter_=function(a,b,c){ol.format.WFS.writeOgcPropertyName_(a,b.propertyName);c=ol.xml.createElementNS(ol.format.WFS.OGCNS,"LowerBoundary");a.appendChild(c);ol.format.WFS.writeOgcLiteral_(c,""+b.lowerBoundary);c=ol.xml.createElementNS(ol.format.WFS.OGCNS,"UpperBoundary");a.appendChild(c);ol.format.WFS.writeOgcLiteral_(c,""+b.upperBoundary)};
ol.format.WFS.writeIsLikeFilter_=function(a,b,c){a.setAttribute("wildCard",b.wildCard);a.setAttribute("singleChar",b.singleChar);a.setAttribute("escapeChar",b.escapeChar);void 0!==b.matchCase&&a.setAttribute("matchCase",b.matchCase.toString());ol.format.WFS.writeOgcPropertyName_(a,b.propertyName);ol.format.WFS.writeOgcLiteral_(a,""+b.pattern)};ol.format.WFS.writeOgcExpression_=function(a,b,c){a=ol.xml.createElementNS(ol.format.WFS.OGCNS,a);ol.format.XSD.writeStringTextNode(a,c);b.appendChild(a)};
ol.format.WFS.writeOgcPropertyName_=function(a,b){ol.format.WFS.writeOgcExpression_("PropertyName",a,b)};ol.format.WFS.writeOgcLiteral_=function(a,b){ol.format.WFS.writeOgcExpression_("Literal",a,b)};ol.format.WFS.writeTimeInstant_=function(a,b){var c=ol.xml.createElementNS(ol.format.GMLBase.GMLNS,"TimeInstant");a.appendChild(c);a=ol.xml.createElementNS(ol.format.GMLBase.GMLNS,"timePosition");c.appendChild(a);ol.format.XSD.writeStringTextNode(a,b)};
ol.format.WFS.GETFEATURE_SERIALIZERS_={"http://www.opengis.net/wfs":{Query:ol.xml.makeChildAppender(ol.format.WFS.writeQuery_)},"http://www.opengis.net/ogc":{During:ol.xml.makeChildAppender(ol.format.WFS.writeDuringFilter_),And:ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_),Or:ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_),Not:ol.xml.makeChildAppender(ol.format.WFS.writeNotFilter_),BBOX:ol.xml.makeChildAppender(ol.format.WFS.writeBboxFilter_),Contains:ol.xml.makeChildAppender(ol.format.WFS.writeContainsFilter_),
Intersects:ol.xml.makeChildAppender(ol.format.WFS.writeIntersectsFilter_),Within:ol.xml.makeChildAppender(ol.format.WFS.writeWithinFilter_),PropertyIsEqualTo:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),PropertyIsNotEqualTo:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),PropertyIsLessThan:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),PropertyIsLessThanOrEqualTo:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),PropertyIsGreaterThan:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),
PropertyIsGreaterThanOrEqualTo:ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),PropertyIsNull:ol.xml.makeChildAppender(ol.format.WFS.writeIsNullFilter_),PropertyIsBetween:ol.xml.makeChildAppender(ol.format.WFS.writeIsBetweenFilter_),PropertyIsLike:ol.xml.makeChildAppender(ol.format.WFS.writeIsLikeFilter_)}};ol.format.WFS.writeFilter=function(a){var b=ol.xml.createElementNS(ol.format.WFS.OGCNS,"Filter");ol.format.WFS.writeFilterCondition_(b,a,[]);return b};
ol.format.WFS.writeGetFeature_=function(a,b,c){var d=ol.obj.assign({},c[c.length-1]);d.node=a;ol.xml.pushSerializeAndPop(d,ol.format.WFS.GETFEATURE_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Query"),b,c)};
ol.format.WFS.prototype.writeGetFeature=function(a){var b=ol.xml.createElementNS(ol.format.WFS.WFSNS,"GetFeature");b.setAttribute("service","WFS");b.setAttribute("version","1.1.0");if(a){a.handle&&b.setAttribute("handle",a.handle);a.outputFormat&&b.setAttribute("outputFormat",a.outputFormat);void 0!==a.maxFeatures&&b.setAttribute("maxFeatures",a.maxFeatures);a.resultType&&b.setAttribute("resultType",a.resultType);void 0!==a.startIndex&&b.setAttribute("startIndex",a.startIndex);void 0!==a.count&&b.setAttribute("count",
a.count);var c=a.filter;if(a.bbox){ol.asserts.assert(a.geometryName,12);var d=ol.format.filter.bbox(a.geometryName,a.bbox,a.srsName);c=c?ol.format.filter.and(c,d):d}}ol.xml.setAttributeNS(b,"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",this.schemaLocation_);c={node:b,srsName:a.srsName,featureNS:a.featureNS?a.featureNS:this.featureNS_,featurePrefix:a.featurePrefix,geometryName:a.geometryName,filter:c,propertyNames:a.propertyNames?a.propertyNames:[]};ol.asserts.assert(Array.isArray(a.featureTypes),
11);ol.format.WFS.writeGetFeature_(b,a.featureTypes,[c]);return b};
ol.format.WFS.prototype.writeTransaction=function(a,b,c,d){var e=[],f=ol.xml.createElementNS(ol.format.WFS.WFSNS,"Transaction"),g=d.version?d.version:ol.format.WFS.DEFAULT_VERSION,h="1.0.0"===g?2:3;f.setAttribute("service","WFS");f.setAttribute("version",g);if(d){var k=d.gmlOptions?d.gmlOptions:{};d.handle&&f.setAttribute("handle",d.handle)}ol.xml.setAttributeNS(f,"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",ol.format.WFS.SCHEMA_LOCATIONS[g]);var l=d.featurePrefix?d.featurePrefix:
ol.format.WFS.FEATURE_PREFIX;a&&(g={node:f,featureNS:d.featureNS,featureType:d.featureType,featurePrefix:l,gmlVersion:h,hasZ:d.hasZ,srsName:d.srsName},ol.obj.assign(g,k),ol.xml.pushSerializeAndPop(g,ol.format.WFS.TRANSACTION_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Insert"),a,e));b&&(g={node:f,featureNS:d.featureNS,featureType:d.featureType,featurePrefix:l,gmlVersion:h,hasZ:d.hasZ,srsName:d.srsName},ol.obj.assign(g,k),ol.xml.pushSerializeAndPop(g,ol.format.WFS.TRANSACTION_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Update"),
b,e));c&&ol.xml.pushSerializeAndPop({node:f,featureNS:d.featureNS,featureType:d.featureType,featurePrefix:l,gmlVersion:h,srsName:d.srsName},ol.format.WFS.TRANSACTION_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Delete"),c,e);d.nativeElements&&ol.xml.pushSerializeAndPop({node:f,featureNS:d.featureNS,featureType:d.featureType,featurePrefix:l,gmlVersion:h,srsName:d.srsName},ol.format.WFS.TRANSACTION_SERIALIZERS_,ol.xml.makeSimpleNodeFactory("Native"),d.nativeElements,e);return f};
ol.format.WFS.prototype.readProjectionFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readProjectionFromNode(a);return null};
ol.format.WFS.prototype.readProjectionFromNode=function(a){if(a.firstElementChild&&a.firstElementChild.firstElementChild)for(a=a.firstElementChild.firstElementChild,a=a.firstElementChild;a;a=a.nextElementSibling)if(0!==a.childNodes.length&&(1!==a.childNodes.length||3!==a.firstChild.nodeType)){var b=[{}];this.gmlFormat_.readGeometryElement(a,b);return ol.proj.get(b.pop().srsName)}return null};ol.format.WKT=function(a){a=a?a:{};ol.format.TextFeature.call(this);this.splitCollection_=void 0!==a.splitCollection?a.splitCollection:!1};ol.inherits(ol.format.WKT,ol.format.TextFeature);ol.format.WKT.EMPTY="EMPTY";ol.format.WKT.Z="Z";ol.format.WKT.M="M";ol.format.WKT.ZM="ZM";ol.format.WKT.encodePointGeometry_=function(a){a=a.getCoordinates();return 0===a.length?"":a.join(" ")};
ol.format.WKT.encodeMultiPointGeometry_=function(a){var b=[];a=a.getPoints();for(var c=0,d=a.length;c<d;++c)b.push("("+ol.format.WKT.encodePointGeometry_(a[c])+")");return b.join(",")};ol.format.WKT.encodeGeometryCollectionGeometry_=function(a){var b=[];a=a.getGeometries();for(var c=0,d=a.length;c<d;++c)b.push(ol.format.WKT.encode_(a[c]));return b.join(",")};ol.format.WKT.encodeLineStringGeometry_=function(a){a=a.getCoordinates();for(var b=[],c=0,d=a.length;c<d;++c)b.push(a[c].join(" "));return b.join(",")};
ol.format.WKT.encodeMultiLineStringGeometry_=function(a){var b=[];a=a.getLineStrings();for(var c=0,d=a.length;c<d;++c)b.push("("+ol.format.WKT.encodeLineStringGeometry_(a[c])+")");return b.join(",")};ol.format.WKT.encodePolygonGeometry_=function(a){var b=[];a=a.getLinearRings();for(var c=0,d=a.length;c<d;++c)b.push("("+ol.format.WKT.encodeLineStringGeometry_(a[c])+")");return b.join(",")};
ol.format.WKT.encodeMultiPolygonGeometry_=function(a){var b=[];a=a.getPolygons();for(var c=0,d=a.length;c<d;++c)b.push("("+ol.format.WKT.encodePolygonGeometry_(a[c])+")");return b.join(",")};ol.format.WKT.encodeGeometryLayout_=function(a){a=a.getLayout();var b="";if(a===ol.geom.GeometryLayout.XYZ||a===ol.geom.GeometryLayout.XYZM)b+=ol.format.WKT.Z;if(a===ol.geom.GeometryLayout.XYM||a===ol.geom.GeometryLayout.XYZM)b+=ol.format.WKT.M;return b};
ol.format.WKT.encode_=function(a){var b=a.getType(),c=(0,ol.format.WKT.GeometryEncoder_[b])(a);b=b.toUpperCase();a instanceof ol.geom.SimpleGeometry&&(a=ol.format.WKT.encodeGeometryLayout_(a),0<a.length&&(b+=" "+a));return 0===c.length?b+" "+ol.format.WKT.EMPTY:b+"("+c+")"};
ol.format.WKT.GeometryEncoder_={Point:ol.format.WKT.encodePointGeometry_,LineString:ol.format.WKT.encodeLineStringGeometry_,Polygon:ol.format.WKT.encodePolygonGeometry_,MultiPoint:ol.format.WKT.encodeMultiPointGeometry_,MultiLineString:ol.format.WKT.encodeMultiLineStringGeometry_,MultiPolygon:ol.format.WKT.encodeMultiPolygonGeometry_,GeometryCollection:ol.format.WKT.encodeGeometryCollectionGeometry_};ol.format.WKT.prototype.parse_=function(a){a=new ol.format.WKT.Lexer(a);return(new ol.format.WKT.Parser(a)).parse()};
ol.format.WKT.prototype.readFeatureFromText=function(a,b){return(a=this.readGeometryFromText(a,b))?(b=new ol.Feature,b.setGeometry(a),b):null};ol.format.WKT.prototype.readFeaturesFromText=function(a,b){a=this.readGeometryFromText(a,b);a=this.splitCollection_&&a.getType()==ol.geom.GeometryType.GEOMETRY_COLLECTION?a.getGeometriesArray():[a];for(var c=[],d=0,e=a.length;d<e;++d)b=new ol.Feature,b.setGeometry(a[d]),c.push(b);return c};
ol.format.WKT.prototype.readGeometryFromText=function(a,b){return(a=this.parse_(a))?ol.format.Feature.transformWithOptions(a,!1,b):null};ol.format.WKT.prototype.writeFeatureText=function(a,b){return(a=a.getGeometry())?this.writeGeometryText(a,b):""};ol.format.WKT.prototype.writeFeaturesText=function(a,b){if(1==a.length)return this.writeFeatureText(a[0],b);for(var c=[],d=0,e=a.length;d<e;++d)c.push(a[d].getGeometry());a=new ol.geom.GeometryCollection(c);return this.writeGeometryText(a,b)};
ol.format.WKT.prototype.writeGeometryText=function(a,b){return ol.format.WKT.encode_(ol.format.Feature.transformWithOptions(a,!0,b))};ol.format.WKT.TokenType_={TEXT:1,LEFT_PAREN:2,RIGHT_PAREN:3,NUMBER:4,COMMA:5,EOF:6};ol.format.WKT.Lexer=function(a){this.wkt=a;this.index_=-1};ol.format.WKT.Lexer.prototype.isAlpha_=function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a};ol.format.WKT.Lexer.prototype.isNumeric_=function(a,b){return"0"<=a&&"9">=a||"."==a&&!(void 0!==b&&b)};
ol.format.WKT.Lexer.prototype.isWhiteSpace_=function(a){return" "==a||"\t"==a||"\r"==a||"\n"==a};ol.format.WKT.Lexer.prototype.nextChar_=function(){return this.wkt.charAt(++this.index_)};
ol.format.WKT.Lexer.prototype.nextToken=function(){var a=this.nextChar_(),b={position:this.index_,value:a};if("("==a)b.type=ol.format.WKT.TokenType_.LEFT_PAREN;else if(","==a)b.type=ol.format.WKT.TokenType_.COMMA;else if(")"==a)b.type=ol.format.WKT.TokenType_.RIGHT_PAREN;else if(this.isNumeric_(a)||"-"==a)b.type=ol.format.WKT.TokenType_.NUMBER,b.value=this.readNumber_();else if(this.isAlpha_(a))b.type=ol.format.WKT.TokenType_.TEXT,b.value=this.readText_();else{if(this.isWhiteSpace_(a))return this.nextToken();
if(""===a)b.type=ol.format.WKT.TokenType_.EOF;else throw Error("Unexpected character: "+a);}return b};ol.format.WKT.Lexer.prototype.readNumber_=function(){var a=this.index_,b=!1,c=!1;do{if("."==d)b=!0;else if("e"==d||"E"==d)c=!0;var d=this.nextChar_()}while(this.isNumeric_(d,b)||!c&&("e"==d||"E"==d)||c&&("-"==d||"+"==d));return parseFloat(this.wkt.substring(a,this.index_--))};
ol.format.WKT.Lexer.prototype.readText_=function(){var a=this.index_;do var b=this.nextChar_();while(this.isAlpha_(b));return this.wkt.substring(a,this.index_--).toUpperCase()};ol.format.WKT.Parser=function(a){this.lexer_=a;this.layout_=ol.geom.GeometryLayout.XY};ol.format.WKT.Parser.prototype.consume_=function(){this.token_=this.lexer_.nextToken()};ol.format.WKT.Parser.prototype.isTokenType=function(a){return this.token_.type==a};
ol.format.WKT.Parser.prototype.match=function(a){(a=this.isTokenType(a))&&this.consume_();return a};ol.format.WKT.Parser.prototype.parse=function(){this.consume_();return this.parseGeometry_()};
ol.format.WKT.Parser.prototype.parseGeometryLayout_=function(){var a=ol.geom.GeometryLayout.XY,b=this.token_;this.isTokenType(ol.format.WKT.TokenType_.TEXT)&&(b=b.value,b===ol.format.WKT.Z?a=ol.geom.GeometryLayout.XYZ:b===ol.format.WKT.M?a=ol.geom.GeometryLayout.XYM:b===ol.format.WKT.ZM&&(a=ol.geom.GeometryLayout.XYZM),a!==ol.geom.GeometryLayout.XY&&this.consume_());return a};
ol.format.WKT.Parser.prototype.parseGeometry_=function(){var a=this.token_;if(this.match(ol.format.WKT.TokenType_.TEXT)){var b=a.value;this.layout_=this.parseGeometryLayout_();if(b==ol.geom.GeometryType.GEOMETRY_COLLECTION.toUpperCase())return a=this.parseGeometryCollectionText_(),new ol.geom.GeometryCollection(a);var c=ol.format.WKT.Parser.GeometryParser_[b];a=ol.format.WKT.Parser.GeometryConstructor_[b];if(!c||!a)throw Error("Invalid geometry type: "+b);b=c.call(this);return new a(b,this.layout_)}throw Error(this.formatErrorMessage_());
};ol.format.WKT.Parser.prototype.parseGeometryCollectionText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=[];do a.push(this.parseGeometry_());while(this.match(ol.format.WKT.TokenType_.COMMA));if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parsePointText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.parsePoint_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return null;throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parseLineStringText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.parsePointList_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parsePolygonText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.parseLineStringTextList_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parseMultiPointText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.token_.type==ol.format.WKT.TokenType_.LEFT_PAREN?this.parsePointTextList_():this.parsePointList_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parseMultiLineStringText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.parseLineStringTextList_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parseMultiPolygonText_=function(){if(this.match(ol.format.WKT.TokenType_.LEFT_PAREN)){var a=this.parsePolygonTextList_();if(this.match(ol.format.WKT.TokenType_.RIGHT_PAREN))return a}else if(this.isEmptyGeometry_())return[];throw Error(this.formatErrorMessage_());};
ol.format.WKT.Parser.prototype.parsePoint_=function(){for(var a=[],b=this.layout_.length,c=0;c<b;++c){var d=this.token_;if(this.match(ol.format.WKT.TokenType_.NUMBER))a.push(d.value);else break}if(a.length==b)return a;throw Error(this.formatErrorMessage_());};ol.format.WKT.Parser.prototype.parsePointList_=function(){for(var a=[this.parsePoint_()];this.match(ol.format.WKT.TokenType_.COMMA);)a.push(this.parsePoint_());return a};
ol.format.WKT.Parser.prototype.parsePointTextList_=function(){for(var a=[this.parsePointText_()];this.match(ol.format.WKT.TokenType_.COMMA);)a.push(this.parsePointText_());return a};ol.format.WKT.Parser.prototype.parseLineStringTextList_=function(){for(var a=[this.parseLineStringText_()];this.match(ol.format.WKT.TokenType_.COMMA);)a.push(this.parseLineStringText_());return a};
ol.format.WKT.Parser.prototype.parsePolygonTextList_=function(){for(var a=[this.parsePolygonText_()];this.match(ol.format.WKT.TokenType_.COMMA);)a.push(this.parsePolygonText_());return a};ol.format.WKT.Parser.prototype.isEmptyGeometry_=function(){var a=this.isTokenType(ol.format.WKT.TokenType_.TEXT)&&this.token_.value==ol.format.WKT.EMPTY;a&&this.consume_();return a};
ol.format.WKT.Parser.prototype.formatErrorMessage_=function(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"};ol.format.WKT.Parser.GeometryConstructor_={POINT:ol.geom.Point,LINESTRING:ol.geom.LineString,POLYGON:ol.geom.Polygon,MULTIPOINT:ol.geom.MultiPoint,MULTILINESTRING:ol.geom.MultiLineString,MULTIPOLYGON:ol.geom.MultiPolygon};
ol.format.WKT.Parser.GeometryParser_={POINT:ol.format.WKT.Parser.prototype.parsePointText_,LINESTRING:ol.format.WKT.Parser.prototype.parseLineStringText_,POLYGON:ol.format.WKT.Parser.prototype.parsePolygonText_,MULTIPOINT:ol.format.WKT.Parser.prototype.parseMultiPointText_,MULTILINESTRING:ol.format.WKT.Parser.prototype.parseMultiLineStringText_,MULTIPOLYGON:ol.format.WKT.Parser.prototype.parseMultiPolygonText_};ol.format.XLink={};ol.format.XLink.NAMESPACE_URI="http://www.w3.org/1999/xlink";ol.format.XLink.readHref=function(a){return a.getAttributeNS(ol.format.XLink.NAMESPACE_URI,"href")};ol.format.XML=function(){};ol.format.XML.prototype.read=function(a){return ol.xml.isDocument(a)?this.readFromDocument(a):ol.xml.isNode(a)?this.readFromNode(a):"string"===typeof a?(a=ol.xml.parse(a),this.readFromDocument(a)):null};ol.format.XML.prototype.readFromDocument=function(a){};ol.format.XML.prototype.readFromNode=function(a){};ol.format.WMSCapabilities=function(){ol.format.XML.call(this);this.version=void 0};ol.inherits(ol.format.WMSCapabilities,ol.format.XML);ol.format.WMSCapabilities.prototype.readFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readFromNode(a);return null};
ol.format.WMSCapabilities.prototype.readFromNode=function(a){this.version=a.getAttribute("version").trim();return(a=ol.xml.pushParseAndPop({version:this.version},ol.format.WMSCapabilities.PARSERS_,a,[]))?a:null};ol.format.WMSCapabilities.readAttribution_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_,a,b)};
ol.format.WMSCapabilities.readBoundingBox_=function(a,b){b=[ol.format.XSD.readDecimalString(a.getAttribute("minx")),ol.format.XSD.readDecimalString(a.getAttribute("miny")),ol.format.XSD.readDecimalString(a.getAttribute("maxx")),ol.format.XSD.readDecimalString(a.getAttribute("maxy"))];var c=[ol.format.XSD.readDecimalString(a.getAttribute("resx")),ol.format.XSD.readDecimalString(a.getAttribute("resy"))];return{crs:a.getAttribute("CRS"),extent:b,res:c}};
ol.format.WMSCapabilities.readEXGeographicBoundingBox_=function(a,b){var c=ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_,a,b);if(c){a=c.westBoundLongitude;b=c.southBoundLatitude;var d=c.eastBoundLongitude;c=c.northBoundLatitude;if(void 0!==a&&void 0!==b&&void 0!==d&&void 0!==c)return[a,b,d,c]}};ol.format.WMSCapabilities.readCapability_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.CAPABILITY_PARSERS_,a,b)};
ol.format.WMSCapabilities.readService_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.SERVICE_PARSERS_,a,b)};ol.format.WMSCapabilities.readContactInformation_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_,a,b)};ol.format.WMSCapabilities.readContactPersonPrimary_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_,a,b)};
ol.format.WMSCapabilities.readContactAddress_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_,a,b)};ol.format.WMSCapabilities.readException_=function(a,b){return ol.xml.pushParseAndPop([],ol.format.WMSCapabilities.EXCEPTION_PARSERS_,a,b)};ol.format.WMSCapabilities.readCapabilityLayer_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.LAYER_PARSERS_,a,b)};
ol.format.WMSCapabilities.readLayer_=function(a,b){var c=b[b.length-1],d=ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.LAYER_PARSERS_,a,b);if(d)return b=ol.format.XSD.readBooleanString(a.getAttribute("queryable")),void 0===b&&(b=c.queryable),d.queryable=void 0!==b?b:!1,b=ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("cascaded")),void 0===b&&(b=c.cascaded),d.cascaded=b,b=ol.format.XSD.readBooleanString(a.getAttribute("opaque")),void 0===b&&(b=c.opaque),d.opaque=void 0!==b?b:!1,b=
ol.format.XSD.readBooleanString(a.getAttribute("noSubsets")),void 0===b&&(b=c.noSubsets),d.noSubsets=void 0!==b?b:!1,(b=ol.format.XSD.readDecimalString(a.getAttribute("fixedWidth")))||(b=c.fixedWidth),d.fixedWidth=b,(a=ol.format.XSD.readDecimalString(a.getAttribute("fixedHeight")))||(a=c.fixedHeight),d.fixedHeight=a,["Style","CRS","AuthorityURL"].forEach(function(a){a in c&&(d[a]=(d[a]||[]).concat(c[a]))}),"EX_GeographicBoundingBox BoundingBox Dimension Attribution MinScaleDenominator MaxScaleDenominator".split(" ").forEach(function(a){a in
d||(d[a]=c[a])}),d};ol.format.WMSCapabilities.readDimension_=function(a,b){return{name:a.getAttribute("name"),units:a.getAttribute("units"),unitSymbol:a.getAttribute("unitSymbol"),"default":a.getAttribute("default"),multipleValues:ol.format.XSD.readBooleanString(a.getAttribute("multipleValues")),nearestValue:ol.format.XSD.readBooleanString(a.getAttribute("nearestValue")),current:ol.format.XSD.readBooleanString(a.getAttribute("current")),values:ol.format.XSD.readString(a)}};
ol.format.WMSCapabilities.readFormatOnlineresource_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_,a,b)};ol.format.WMSCapabilities.readRequest_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.REQUEST_PARSERS_,a,b)};ol.format.WMSCapabilities.readDCPType_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.DCPTYPE_PARSERS_,a,b)};
ol.format.WMSCapabilities.readHTTP_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.HTTP_PARSERS_,a,b)};ol.format.WMSCapabilities.readOperationType_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_,a,b)};
ol.format.WMSCapabilities.readSizedFormatOnlineresource_=function(a,b){if(b=ol.format.WMSCapabilities.readFormatOnlineresource_(a,b))return a=[ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("width")),ol.format.XSD.readNonNegativeIntegerString(a.getAttribute("height"))],b.size=a,b};ol.format.WMSCapabilities.readAuthorityURL_=function(a,b){if(b=ol.format.WMSCapabilities.readFormatOnlineresource_(a,b))return b.name=a.getAttribute("name"),b};
ol.format.WMSCapabilities.readMetadataURL_=function(a,b){if(b=ol.format.WMSCapabilities.readFormatOnlineresource_(a,b))return b.type=a.getAttribute("type"),b};ol.format.WMSCapabilities.readStyle_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMSCapabilities.STYLE_PARSERS_,a,b)};ol.format.WMSCapabilities.readKeywordList_=function(a,b){return ol.xml.pushParseAndPop([],ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_,a,b)};ol.format.WMSCapabilities.NAMESPACE_URIS_=[null,"http://www.opengis.net/wms"];
ol.format.WMSCapabilities.PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Service:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readService_),Capability:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readCapability_)});
ol.format.WMSCapabilities.CAPABILITY_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Request:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readRequest_),Exception:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readException_),Layer:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readCapabilityLayer_)});
ol.format.WMSCapabilities.SERVICE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Abstract:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),KeywordList:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readKeywordList_),OnlineResource:ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref),ContactInformation:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactInformation_),
Fees:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),AccessConstraints:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),LayerLimit:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MaxWidth:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MaxHeight:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)});
ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{ContactPersonPrimary:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactPersonPrimary_),ContactPosition:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ContactAddress:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactAddress_),ContactVoiceTelephone:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ContactFacsimileTelephone:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
ContactElectronicMailAddress:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{ContactPerson:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ContactOrganization:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{AddressType:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Address:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),City:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),StateOrProvince:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),PostCode:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Country:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.WMSCapabilities.EXCEPTION_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Format:ol.xml.makeArrayPusher(ol.format.XSD.readString)});
ol.format.WMSCapabilities.LAYER_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Abstract:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),KeywordList:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readKeywordList_),CRS:ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),EX_GeographicBoundingBox:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readEXGeographicBoundingBox_),
BoundingBox:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readBoundingBox_),Dimension:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readDimension_),Attribution:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readAttribution_),AuthorityURL:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readAuthorityURL_),Identifier:ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),MetadataURL:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readMetadataURL_),
DataURL:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readFormatOnlineresource_),FeatureListURL:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readFormatOnlineresource_),Style:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readStyle_),MinScaleDenominator:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),MaxScaleDenominator:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),Layer:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readLayer_)});
ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),OnlineResource:ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref),LogoURL:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readSizedFormatOnlineresource_)});
ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{westBoundLongitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),eastBoundLongitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),southBoundLatitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),northBoundLatitude:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.WMSCapabilities.REQUEST_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{GetCapabilities:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_),GetMap:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_),GetFeatureInfo:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_)});
ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Format:ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),DCPType:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readDCPType_)});ol.format.WMSCapabilities.DCPTYPE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{HTTP:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readHTTP_)});
ol.format.WMSCapabilities.HTTP_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Get:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_),Post:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_)});
ol.format.WMSCapabilities.STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Name:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Abstract:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),LegendURL:ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readSizedFormatOnlineresource_),StyleSheetURL:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_),StyleURL:ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_)});
ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Format:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),OnlineResource:ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref)});ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_=ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_,{Keyword:ol.xml.makeArrayPusher(ol.format.XSD.readString)});ol.format.WMSGetFeatureInfo=function(a){a=a?a:{};this.featureNS_="http://mapserver.gis.umn.edu/mapserver";this.gmlFormat_=new ol.format.GML2;this.layers_=a.layers?a.layers:null;ol.format.XMLFeature.call(this)};ol.inherits(ol.format.WMSGetFeatureInfo,ol.format.XMLFeature);ol.format.WMSGetFeatureInfo.featureIdentifier_="_feature";ol.format.WMSGetFeatureInfo.layerIdentifier_="_layer";ol.format.WMSGetFeatureInfo.prototype.getLayers=function(){return this.layers_};
ol.format.WMSGetFeatureInfo.prototype.setLayers=function(a){this.layers_=a};
ol.format.WMSGetFeatureInfo.prototype.readFeatures_=function(a,b){a.setAttribute("namespaceURI",this.featureNS_);var c=a.localName,d=[];if(0===a.childNodes.length)return d;if("msGMLOutput"==c)for(var e=0,f=a.childNodes.length;e<f;e++){var g=a.childNodes[e];if(g.nodeType===Node.ELEMENT_NODE){var h=b[0],k=g.localName.replace(ol.format.WMSGetFeatureInfo.layerIdentifier_,"");if(!this.layers_||ol.array.includes(this.layers_,k)){k+=ol.format.WMSGetFeatureInfo.featureIdentifier_;h.featureType=k;h.featureNS=
this.featureNS_;var l={};l[k]=ol.xml.makeArrayPusher(this.gmlFormat_.readFeatureElement,this.gmlFormat_);h=ol.xml.makeStructureNS([h.featureNS,null],l);g.setAttribute("namespaceURI",this.featureNS_);(g=ol.xml.pushParseAndPop([],h,g,b,this.gmlFormat_))&&ol.array.extend(d,g)}}}"FeatureCollection"==c&&(a=ol.xml.pushParseAndPop([],this.gmlFormat_.FEATURE_COLLECTION_PARSERS,a,[{}],this.gmlFormat_))&&(d=a);return d};
ol.format.WMSGetFeatureInfo.prototype.readFeaturesFromNode=function(a,b){var c={};b&&ol.obj.assign(c,this.getReadOptions(a,b));return this.readFeatures_(a,[c])};ol.format.WMSGetFeatureInfo.prototype.writeFeatureNode=function(a,b){};ol.format.WMSGetFeatureInfo.prototype.writeFeaturesNode=function(a,b){};ol.format.WMSGetFeatureInfo.prototype.writeGeometryNode=function(a,b){};ol.format.OWS=function(){ol.format.XML.call(this)};ol.inherits(ol.format.OWS,ol.format.XML);ol.format.OWS.prototype.readFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readFromNode(a);return null};ol.format.OWS.prototype.readFromNode=function(a){return(a=ol.xml.pushParseAndPop({},ol.format.OWS.PARSERS_,a,[]))?a:null};ol.format.OWS.readAddress_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.ADDRESS_PARSERS_,a,b)};
ol.format.OWS.readAllowedValues_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.ALLOWED_VALUES_PARSERS_,a,b)};ol.format.OWS.readConstraint_=function(a,b){var c=a.getAttribute("name");if(c)return ol.xml.pushParseAndPop({name:c},ol.format.OWS.CONSTRAINT_PARSERS_,a,b)};ol.format.OWS.readContactInfo_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.CONTACT_INFO_PARSERS_,a,b)};ol.format.OWS.readDcp_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.DCP_PARSERS_,a,b)};
ol.format.OWS.readGet_=function(a,b){var c=ol.format.XLink.readHref(a);if(c)return ol.xml.pushParseAndPop({href:c},ol.format.OWS.REQUEST_METHOD_PARSERS_,a,b)};ol.format.OWS.readHttp_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.HTTP_PARSERS_,a,b)};ol.format.OWS.readOperation_=function(a,b){var c=a.getAttribute("name");(a=ol.xml.pushParseAndPop({},ol.format.OWS.OPERATION_PARSERS_,a,b))&&(b[b.length-1][c]=a)};
ol.format.OWS.readOperationsMetadata_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.OPERATIONS_METADATA_PARSERS_,a,b)};ol.format.OWS.readPhone_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.PHONE_PARSERS_,a,b)};ol.format.OWS.readServiceIdentification_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_,a,b)};
ol.format.OWS.readServiceContact_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.SERVICE_CONTACT_PARSERS_,a,b)};ol.format.OWS.readServiceProvider_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.OWS.SERVICE_PROVIDER_PARSERS_,a,b)};ol.format.OWS.readValue_=function(a,b){return ol.format.XSD.readString(a)};ol.format.OWS.NAMESPACE_URIS_=[null,"http://www.opengis.net/ows/1.1"];
ol.format.OWS.PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{ServiceIdentification:ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceIdentification_),ServiceProvider:ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceProvider_),OperationsMetadata:ol.xml.makeObjectPropertySetter(ol.format.OWS.readOperationsMetadata_)});
ol.format.OWS.ADDRESS_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{DeliveryPoint:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),City:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),AdministrativeArea:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),PostalCode:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Country:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ElectronicMailAddress:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.OWS.ALLOWED_VALUES_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Value:ol.xml.makeObjectPropertyPusher(ol.format.OWS.readValue_)});ol.format.OWS.CONSTRAINT_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{AllowedValues:ol.xml.makeObjectPropertySetter(ol.format.OWS.readAllowedValues_)});ol.format.OWS.CONTACT_INFO_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Phone:ol.xml.makeObjectPropertySetter(ol.format.OWS.readPhone_),Address:ol.xml.makeObjectPropertySetter(ol.format.OWS.readAddress_)});
ol.format.OWS.DCP_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{HTTP:ol.xml.makeObjectPropertySetter(ol.format.OWS.readHttp_)});ol.format.OWS.HTTP_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Get:ol.xml.makeObjectPropertyPusher(ol.format.OWS.readGet_),Post:void 0});ol.format.OWS.OPERATION_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{DCP:ol.xml.makeObjectPropertySetter(ol.format.OWS.readDcp_)});
ol.format.OWS.OPERATIONS_METADATA_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Operation:ol.format.OWS.readOperation_});ol.format.OWS.PHONE_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Voice:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Facsimile:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});ol.format.OWS.REQUEST_METHOD_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Constraint:ol.xml.makeObjectPropertyPusher(ol.format.OWS.readConstraint_)});
ol.format.OWS.SERVICE_CONTACT_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{IndividualName:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),PositionName:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ContactInfo:ol.xml.makeObjectPropertySetter(ol.format.OWS.readContactInfo_)});
ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{Abstract:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),AccessConstraints:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Fees:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ServiceTypeVersion:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ServiceType:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.OWS.SERVICE_PROVIDER_PARSERS_=ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_,{ProviderName:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),ProviderSite:ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref),ServiceContact:ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceContact_)});ol.format.WMTSCapabilities=function(){ol.format.XML.call(this);this.owsParser_=new ol.format.OWS};ol.inherits(ol.format.WMTSCapabilities,ol.format.XML);ol.format.WMTSCapabilities.prototype.readFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==Node.ELEMENT_NODE)return this.readFromNode(a);return null};
ol.format.WMTSCapabilities.prototype.readFromNode=function(a){var b=a.getAttribute("version").trim(),c=this.owsParser_.readFromNode(a);if(!c)return null;c.version=b;return(c=ol.xml.pushParseAndPop(c,ol.format.WMTSCapabilities.PARSERS_,a,[]))?c:null};ol.format.WMTSCapabilities.readContents_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.CONTENTS_PARSERS_,a,b)};
ol.format.WMTSCapabilities.readLayer_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.LAYER_PARSERS_,a,b)};ol.format.WMTSCapabilities.readTileMatrixSet_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.TMS_PARSERS_,a,b)};ol.format.WMTSCapabilities.readStyle_=function(a,b){if(b=ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.STYLE_PARSERS_,a,b))return a="true"===a.getAttribute("isDefault"),b.isDefault=a,b};
ol.format.WMTSCapabilities.readTileMatrixSetLink_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_,a,b)};ol.format.WMTSCapabilities.readDimensions_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.DIMENSION_PARSERS_,a,b)};
ol.format.WMTSCapabilities.readResourceUrl_=function(a,b){b=a.getAttribute("format");var c=a.getAttribute("template");a=a.getAttribute("resourceType");var d={};b&&(d.format=b);c&&(d.template=c);a&&(d.resourceType=a);return d};ol.format.WMTSCapabilities.readWgs84BoundingBox_=function(a,b){a=ol.xml.pushParseAndPop([],ol.format.WMTSCapabilities.WGS84_BBOX_READERS_,a,b);if(2==a.length)return ol.extent.boundingExtent(a)};
ol.format.WMTSCapabilities.readLegendUrl_=function(a,b){b={};b.format=a.getAttribute("format");b.href=ol.format.XLink.readHref(a);return b};ol.format.WMTSCapabilities.readCoordinates_=function(a,b){if((b=ol.format.XSD.readString(a).split(" "))&&2==b.length&&(a=+b[0],b=+b[1],!isNaN(a)&&!isNaN(b)))return[a,b]};ol.format.WMTSCapabilities.readTileMatrix_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.TM_PARSERS_,a,b)};
ol.format.WMTSCapabilities.readTileMatrixLimitsList_=function(a,b){return ol.xml.pushParseAndPop([],ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_,a,b)};ol.format.WMTSCapabilities.readTileMatrixLimits_=function(a,b){return ol.xml.pushParseAndPop({},ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_,a,b)};ol.format.WMTSCapabilities.NAMESPACE_URIS_=[null,"http://www.opengis.net/wmts/1.0"];ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_=[null,"http://www.opengis.net/ows/1.1"];
ol.format.WMTSCapabilities.PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{Contents:ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readContents_)});ol.format.WMTSCapabilities.CONTENTS_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{Layer:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readLayer_),TileMatrixSet:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrixSet_)});
ol.format.WMTSCapabilities.LAYER_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{Style:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readStyle_),Format:ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),TileMatrixSetLink:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrixSetLink_),Dimension:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readDimensions_),ResourceURL:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readResourceUrl_)},
ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Abstract:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),WGS84BoundingBox:ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readWgs84BoundingBox_),Identifier:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.STYLE_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{LegendURL:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readLegendUrl_)},ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{Title:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Identifier:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{TileMatrixSet:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),TileMatrixSetLimits:ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readTileMatrixLimitsList_)});ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{TileMatrixLimits:ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readTileMatrixLimits_)});
ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{TileMatrix:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),MinTileRow:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MaxTileRow:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MinTileCol:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MaxTileCol:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)});
ol.format.WMTSCapabilities.DIMENSION_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{Default:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Value:ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString)},ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{Identifier:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.WGS84_BBOX_READERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{LowerCorner:ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readCoordinates_),UpperCorner:ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readCoordinates_)});
ol.format.WMTSCapabilities.TMS_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{WellKnownScaleSet:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),TileMatrix:ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrix_)},ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{SupportedCRS:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),Identifier:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.TM_PARSERS_=ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_,{TopLeftCorner:ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readCoordinates_),ScaleDenominator:ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),TileWidth:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),TileHeight:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),MatrixWidth:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),
MatrixHeight:ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)},ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_,{Identifier:ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));ol.geom.Circle=function(a,b,c){ol.geom.SimpleGeometry.call(this);this.setCenterAndRadius(a,b?b:0,c)};ol.inherits(ol.geom.Circle,ol.geom.SimpleGeometry);ol.geom.Circle.prototype.clone=function(){var a=new ol.geom.Circle(null);a.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return a};
ol.geom.Circle.prototype.closestPointXY=function(a,b,c,d){var e=this.flatCoordinates;a-=e[0];var f=b-e[1];b=a*a+f*f;if(b<d){0===b?d=0:(d=this.getRadius()/Math.sqrt(b),c[0]=e[0]+d*a,c[1]=e[1]+d*f,d=2);for(;d<this.stride;++d)c[d]=e[d];c.length=this.stride;return b}return d};ol.geom.Circle.prototype.containsXY=function(a,b){var c=this.flatCoordinates;a-=c[0];b-=c[1];return a*a+b*b<=this.getRadiusSquared_()};ol.geom.Circle.prototype.getCenter=function(){return this.flatCoordinates.slice(0,this.stride)};
ol.geom.Circle.prototype.computeExtent=function(a){var b=this.flatCoordinates,c=b[this.stride]-b[0];return ol.extent.createOrUpdate(b[0]-c,b[1]-c,b[0]+c,b[1]+c,a)};ol.geom.Circle.prototype.getRadius=function(){return Math.sqrt(this.getRadiusSquared_())};ol.geom.Circle.prototype.getRadiusSquared_=function(){var a=this.flatCoordinates[this.stride]-this.flatCoordinates[0],b=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return a*a+b*b};ol.geom.Circle.prototype.getType=function(){return ol.geom.GeometryType.CIRCLE};
ol.geom.Circle.prototype.intersectsExtent=function(a){var b=this.getExtent();return ol.extent.intersects(a,b)?(b=this.getCenter(),a[0]<=b[0]&&a[2]>=b[0]||a[1]<=b[1]&&a[3]>=b[1]?!0:ol.extent.forEachCorner(a,this.intersectsCoordinate,this)):!1};ol.geom.Circle.prototype.setCenter=function(a){var b=this.stride,c=this.flatCoordinates[b]-this.flatCoordinates[0],d=a.slice();d[b]=d[0]+c;for(c=1;c<b;++c)d[b+c]=a[c];this.setFlatCoordinates(this.layout,d)};
ol.geom.Circle.prototype.setCenterAndRadius=function(a,b,c){if(a){this.setLayout(c,a,0);this.flatCoordinates||(this.flatCoordinates=[]);c=this.flatCoordinates;a=ol.geom.flat.deflate.coordinate(c,0,a,this.stride);c[a++]=c[0]+b;var d;b=1;for(d=this.stride;b<d;++b)c[a++]=c[b];c.length=a;this.changed()}else this.setFlatCoordinates(ol.geom.GeometryLayout.XY,null)};ol.geom.Circle.prototype.getCoordinates=function(){};ol.geom.Circle.prototype.setCoordinates=function(a,b){};
ol.geom.Circle.prototype.setFlatCoordinates=function(a,b){this.setFlatCoordinatesInternal(a,b);this.changed()};ol.geom.Circle.prototype.setRadius=function(a){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+a;this.changed()};ol.interaction.DragAndDrop=function(a){a=a?a:{};ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.DragAndDrop.handleEvent});this.formatConstructors_=a.formatConstructors?a.formatConstructors:[];this.projection_=a.projection?ol.proj.get(a.projection):null;this.dropListenKeys_=null;this.source_=a.source||null;this.target=a.target?a.target:null};ol.inherits(ol.interaction.DragAndDrop,ol.interaction.Interaction);
ol.interaction.DragAndDrop.handleDrop_=function(a){a=a.dataTransfer.files;var b;var c=0;for(b=a.length;c<b;++c){var d=a.item(c);var e=new FileReader;e.addEventListener(ol.events.EventType.LOAD,this.handleResult_.bind(this,d));e.readAsText(d)}};ol.interaction.DragAndDrop.handleStop_=function(a){a.stopPropagation();a.preventDefault();a.dataTransfer.dropEffect="copy"};
ol.interaction.DragAndDrop.prototype.handleResult_=function(a,b){b=b.target.result;var c=this.getMap(),d=this.projection_;d||(d=c.getView().getProjection());c=this.formatConstructors_;var e=[],f;var g=0;for(f=c.length;g<f&&!(e=new c[g],(e=this.tryReadFeatures_(e,b,{featureProjection:d}))&&0<e.length);++g);this.source_&&(this.source_.clear(),this.source_.addFeatures(e));this.dispatchEvent(new ol.interaction.DragAndDrop.Event(ol.interaction.DragAndDrop.EventType_.ADD_FEATURES,a,e,d))};
ol.interaction.DragAndDrop.handleEvent=ol.functions.TRUE;
ol.interaction.DragAndDrop.prototype.registerListeners_=function(){var a=this.getMap();a&&(a=this.target?this.target:a.getViewport(),this.dropListenKeys_=[ol.events.listen(a,ol.events.EventType.DROP,ol.interaction.DragAndDrop.handleDrop_,this),ol.events.listen(a,ol.events.EventType.DRAGENTER,ol.interaction.DragAndDrop.handleStop_,this),ol.events.listen(a,ol.events.EventType.DRAGOVER,ol.interaction.DragAndDrop.handleStop_,this),ol.events.listen(a,ol.events.EventType.DROP,ol.interaction.DragAndDrop.handleStop_,
this)])};ol.interaction.DragAndDrop.prototype.setActive=function(a){ol.interaction.Interaction.prototype.setActive.call(this,a);a?this.registerListeners_():this.unregisterListeners_()};ol.interaction.DragAndDrop.prototype.setMap=function(a){this.unregisterListeners_();ol.interaction.Interaction.prototype.setMap.call(this,a);this.getActive()&&this.registerListeners_()};ol.interaction.DragAndDrop.prototype.tryReadFeatures_=function(a,b,c){try{return a.readFeatures(b,c)}catch(d){return null}};
ol.interaction.DragAndDrop.prototype.unregisterListeners_=function(){this.dropListenKeys_&&(this.dropListenKeys_.forEach(ol.events.unlistenByKey),this.dropListenKeys_=null)};ol.interaction.DragAndDrop.EventType_={ADD_FEATURES:"addfeatures"};ol.interaction.DragAndDrop.Event=function(a,b,c,d){ol.events.Event.call(this,a);this.features=c;this.file=b;this.projection=d};ol.inherits(ol.interaction.DragAndDrop.Event,ol.events.Event);ol.interaction.DragRotateAndZoom=function(a){a=a?a:{};ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.DragRotateAndZoom.handleDownEvent_,handleDragEvent:ol.interaction.DragRotateAndZoom.handleDragEvent_,handleUpEvent:ol.interaction.DragRotateAndZoom.handleUpEvent_});this.condition_=a.condition?a.condition:ol.events.condition.shiftKeyOnly;this.lastMagnitude_=this.lastAngle_=void 0;this.lastScaleDelta_=0;this.duration_=void 0!==a.duration?a.duration:400};
ol.inherits(ol.interaction.DragRotateAndZoom,ol.interaction.Pointer);
ol.interaction.DragRotateAndZoom.handleDragEvent_=function(a){if(ol.events.condition.mouseOnly(a)){var b=a.map,c=b.getSize(),d=a.pixel;a=d[0]-c[0]/2;d=c[1]/2-d[1];c=Math.atan2(d,a);a=Math.sqrt(a*a+d*d);b=b.getView();b.getConstraints().rotation!==ol.RotationConstraint.disable&&void 0!==this.lastAngle_&&(d=c-this.lastAngle_,ol.interaction.Interaction.rotateWithoutConstraints(b,b.getRotation()-d));this.lastAngle_=c;void 0!==this.lastMagnitude_&&(c=this.lastMagnitude_*(b.getResolution()/a),ol.interaction.Interaction.zoomWithoutConstraints(b,
c));void 0!==this.lastMagnitude_&&(this.lastScaleDelta_=this.lastMagnitude_/a);this.lastMagnitude_=a}};ol.interaction.DragRotateAndZoom.handleUpEvent_=function(a){if(!ol.events.condition.mouseOnly(a))return!0;a=a.map.getView();a.setHint(ol.ViewHint.INTERACTING,-1);var b=this.lastScaleDelta_-1;ol.interaction.Interaction.rotate(a,a.getRotation());ol.interaction.Interaction.zoom(a,a.getResolution(),void 0,this.duration_,b);this.lastScaleDelta_=0;return!1};
ol.interaction.DragRotateAndZoom.handleDownEvent_=function(a){return ol.events.condition.mouseOnly(a)&&this.condition_(a)?(a.map.getView().setHint(ol.ViewHint.INTERACTING,1),this.lastMagnitude_=this.lastAngle_=void 0,!0):!1};ol.interaction.DrawEventType={DRAWSTART:"drawstart",DRAWEND:"drawend"};ol.layer.Vector=function(a){a=a?a:{};var b=ol.obj.assign({},a);delete b.style;delete b.renderBuffer;delete b.updateWhileAnimating;delete b.updateWhileInteracting;ol.layer.Layer.call(this,b);this.declutter_=void 0!==a.declutter?a.declutter:!1;this.renderBuffer_=void 0!==a.renderBuffer?a.renderBuffer:100;this.style_=null;this.styleFunction_=void 0;this.setStyle(a.style);this.updateWhileAnimating_=void 0!==a.updateWhileAnimating?a.updateWhileAnimating:!1;this.updateWhileInteracting_=void 0!==a.updateWhileInteracting?
a.updateWhileInteracting:!1;this.renderMode_=a.renderMode||ol.layer.VectorRenderType.VECTOR;this.type=ol.LayerType.VECTOR};ol.inherits(ol.layer.Vector,ol.layer.Layer);ol.layer.Vector.prototype.getDeclutter=function(){return this.declutter_};ol.layer.Vector.prototype.setDeclutter=function(a){this.declutter_=a};ol.layer.Vector.prototype.getRenderBuffer=function(){return this.renderBuffer_};ol.layer.Vector.prototype.getRenderOrder=function(){return this.get(ol.layer.Vector.Property_.RENDER_ORDER)};
ol.layer.Vector.prototype.getStyle=function(){return this.style_};ol.layer.Vector.prototype.getStyleFunction=function(){return this.styleFunction_};ol.layer.Vector.prototype.getUpdateWhileAnimating=function(){return this.updateWhileAnimating_};ol.layer.Vector.prototype.getUpdateWhileInteracting=function(){return this.updateWhileInteracting_};ol.layer.Vector.prototype.setRenderOrder=function(a){this.set(ol.layer.Vector.Property_.RENDER_ORDER,a)};
ol.layer.Vector.prototype.setStyle=function(a){this.style_=void 0!==a?a:ol.style.Style.defaultFunction;this.styleFunction_=null===a?void 0:ol.style.Style.createFunction(this.style_);this.changed()};ol.layer.Vector.prototype.getRenderMode=function(){return this.renderMode_};ol.layer.Vector.Property_={RENDER_ORDER:"renderOrder"};ol.loadingstrategy={};ol.loadingstrategy.all=function(a,b){return[[-Infinity,-Infinity,Infinity,Infinity]]};ol.loadingstrategy.bbox=function(a,b){return[a]};ol.loadingstrategy.tile=function(a){return function(b,c){c=a.getZForResolution(c);b=a.getTileRangeForExtentAndZ(b,c);var d=[];c=[c,0,0];for(c[1]=b.minX;c[1]<=b.maxX;++c[1])for(c[2]=b.minY;c[2]<=b.maxY;++c[2])d.push(a.getTileCoordExtent(c));return d}};ol.source.Source=function(a){ol.Object.call(this);this.projection_=ol.proj.get(a.projection);this.attributions_=null;this.attributions2_=this.adaptAttributions_(a.attributions);this.logo_=a.logo;this.state_=void 0!==a.state?a.state:ol.source.State.READY;this.wrapX_=void 0!==a.wrapX?a.wrapX:!1};ol.inherits(ol.source.Source,ol.Object);
ol.source.Source.prototype.adaptAttributions_=function(a){if(!a)return null;if(a instanceof ol.Attribution)return this.attributions_=[a],function(b){return[a.getHTML()]};if(Array.isArray(a)){if(a[0]instanceof ol.Attribution){this.attributions_=a;var b=a.map(function(a){return a.getHTML()});return function(a){return b}}this.attributions_=a.map(function(a){return new ol.Attribution({html:a})});return function(b){return a}}if("function"===typeof a)return a;this.attributions_=[new ol.Attribution({html:a})];
return function(b){return[a]}};ol.source.Source.prototype.forEachFeatureAtCoordinate=ol.nullFunction;ol.source.Source.prototype.getAttributions=function(){return this.attributions_};ol.source.Source.prototype.getAttributions2=function(){return this.attributions2_};ol.source.Source.prototype.getLogo=function(){return this.logo_};ol.source.Source.prototype.getProjection=function(){return this.projection_};ol.source.Source.prototype.getResolutions=function(){};ol.source.Source.prototype.getState=function(){return this.state_};
ol.source.Source.prototype.getWrapX=function(){return this.wrapX_};ol.source.Source.prototype.refresh=function(){this.changed()};ol.source.Source.prototype.setAttributions=function(a){this.attributions2_=this.adaptAttributions_(a);this.changed()};ol.source.Source.prototype.setLogo=function(a){this.logo_=a};ol.source.Source.prototype.setState=function(a){this.state_=a;this.changed()};ol.source.VectorEventType={ADDFEATURE:"addfeature",CHANGEFEATURE:"changefeature",CLEAR:"clear",REMOVEFEATURE:"removefeature"};ol.source.Vector=function(a){a=a||{};ol.source.Source.call(this,{attributions:a.attributions,logo:a.logo,projection:void 0,state:ol.source.State.READY,wrapX:void 0!==a.wrapX?a.wrapX:!0});this.loader_=ol.nullFunction;this.format_=a.format;this.overlaps_=void 0==a.overlaps?!0:a.overlaps;this.url_=a.url;void 0!==a.loader?this.loader_=a.loader:void 0!==this.url_&&(ol.asserts.assert(this.format_,7),this.loader_=ol.featureloader.xhr(this.url_,this.format_));this.strategy_=void 0!==a.strategy?a.strategy:
ol.loadingstrategy.all;var b=void 0!==a.useSpatialIndex?a.useSpatialIndex:!0;this.featuresRtree_=b?new ol.structs.RBush:null;this.loadedExtentsRtree_=new ol.structs.RBush;this.nullGeometryFeatures_={};this.idIndex_={};this.undefIdIndex_={};this.featureChangeKeys_={};this.featuresCollection_=null;if(a.features instanceof ol.Collection){var c=a.features;var d=c.getArray()}else Array.isArray(a.features)&&(d=a.features);b||void 0!==c||(c=new ol.Collection(d));void 0!==d&&this.addFeaturesInternal(d);void 0!==
c&&this.bindFeaturesCollection_(c)};ol.inherits(ol.source.Vector,ol.source.Source);ol.source.Vector.prototype.addFeature=function(a){this.addFeatureInternal(a);this.changed()};
ol.source.Vector.prototype.addFeatureInternal=function(a){var b=ol.getUid(a).toString();if(this.addToIndex_(b,a)){this.setupChangeEvents_(b,a);var c=a.getGeometry();c?(b=c.getExtent(),this.featuresRtree_&&this.featuresRtree_.insert(b,a)):this.nullGeometryFeatures_[b]=a;this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.ADDFEATURE,a))}};
ol.source.Vector.prototype.setupChangeEvents_=function(a,b){this.featureChangeKeys_[a]=[ol.events.listen(b,ol.events.EventType.CHANGE,this.handleFeatureChange_,this),ol.events.listen(b,ol.ObjectEventType.PROPERTYCHANGE,this.handleFeatureChange_,this)]};ol.source.Vector.prototype.addToIndex_=function(a,b){var c=!0,d=b.getId();void 0!==d?d.toString()in this.idIndex_?c=!1:this.idIndex_[d.toString()]=b:(ol.asserts.assert(!(a in this.undefIdIndex_),30),this.undefIdIndex_[a]=b);return c};
ol.source.Vector.prototype.addFeatures=function(a){this.addFeaturesInternal(a);this.changed()};
ol.source.Vector.prototype.addFeaturesInternal=function(a){var b,c=[],d=[],e=[];var f=0;for(b=a.length;f<b;f++){var g=a[f];var h=ol.getUid(g).toString();this.addToIndex_(h,g)&&d.push(g)}f=0;for(b=d.length;f<b;f++)g=d[f],h=ol.getUid(g).toString(),this.setupChangeEvents_(h,g),(a=g.getGeometry())?(h=a.getExtent(),c.push(h),e.push(g)):this.nullGeometryFeatures_[h]=g;this.featuresRtree_&&this.featuresRtree_.load(c,e);f=0;for(b=d.length;f<b;f++)this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.ADDFEATURE,
d[f]))};
ol.source.Vector.prototype.bindFeaturesCollection_=function(a){var b=!1;ol.events.listen(this,ol.source.VectorEventType.ADDFEATURE,function(c){b||(b=!0,a.push(c.feature),b=!1)});ol.events.listen(this,ol.source.VectorEventType.REMOVEFEATURE,function(c){b||(b=!0,a.remove(c.feature),b=!1)});ol.events.listen(a,ol.CollectionEventType.ADD,function(a){b||(b=!0,this.addFeature(a.element),b=!1)},this);ol.events.listen(a,ol.CollectionEventType.REMOVE,function(a){b||(b=!0,this.removeFeature(a.element),b=!1)},
this);this.featuresCollection_=a};
ol.source.Vector.prototype.clear=function(a){if(a){for(var b in this.featureChangeKeys_)this.featureChangeKeys_[b].forEach(ol.events.unlistenByKey);this.featuresCollection_||(this.featureChangeKeys_={},this.idIndex_={},this.undefIdIndex_={})}else if(this.featuresRtree_){this.featuresRtree_.forEach(this.removeFeatureInternal,this);for(var c in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[c])}this.featuresCollection_&&this.featuresCollection_.clear();this.featuresRtree_&&
this.featuresRtree_.clear();this.loadedExtentsRtree_.clear();this.nullGeometryFeatures_={};a=new ol.source.Vector.Event(ol.source.VectorEventType.CLEAR);this.dispatchEvent(a);this.changed()};ol.source.Vector.prototype.forEachFeature=function(a,b){if(this.featuresRtree_)return this.featuresRtree_.forEach(a,b);if(this.featuresCollection_)return this.featuresCollection_.forEach(a,b)};
ol.source.Vector.prototype.forEachFeatureAtCoordinateDirect=function(a,b,c){return this.forEachFeatureInExtent([a[0],a[1],a[0],a[1]],function(d){if(d.getGeometry().intersectsCoordinate(a))return b.call(c,d)})};ol.source.Vector.prototype.forEachFeatureInExtent=function(a,b,c){if(this.featuresRtree_)return this.featuresRtree_.forEachInExtent(a,b,c);if(this.featuresCollection_)return this.featuresCollection_.forEach(b,c)};
ol.source.Vector.prototype.forEachFeatureIntersectingExtent=function(a,b,c){return this.forEachFeatureInExtent(a,function(d){if(d.getGeometry().intersectsExtent(a)&&(d=b.call(c,d)))return d})};ol.source.Vector.prototype.getFeaturesCollection=function(){return this.featuresCollection_};
ol.source.Vector.prototype.getFeatures=function(){if(this.featuresCollection_)var a=this.featuresCollection_.getArray();else this.featuresRtree_&&(a=this.featuresRtree_.getAll(),ol.obj.isEmpty(this.nullGeometryFeatures_)||ol.array.extend(a,ol.obj.getValues(this.nullGeometryFeatures_)));return a};ol.source.Vector.prototype.getFeaturesAtCoordinate=function(a){var b=[];this.forEachFeatureAtCoordinateDirect(a,function(a){b.push(a)});return b};ol.source.Vector.prototype.getFeaturesInExtent=function(a){return this.featuresRtree_.getInExtent(a)};
ol.source.Vector.prototype.getClosestFeatureToCoordinate=function(a,b){var c=a[0],d=a[1],e=null,f=[NaN,NaN],g=Infinity,h=[-Infinity,-Infinity,Infinity,Infinity],k=b?b:ol.functions.TRUE;this.featuresRtree_.forEachInExtent(h,function(a){if(k(a)){var b=a.getGeometry(),l=g;g=b.closestPointXY(c,d,f,g);g<l&&(e=a,a=Math.sqrt(g),h[0]=c-a,h[1]=d-a,h[2]=c+a,h[3]=d+a)}});return e};ol.source.Vector.prototype.getExtent=function(a){return this.featuresRtree_.getExtent(a)};
ol.source.Vector.prototype.getFeatureById=function(a){a=this.idIndex_[a.toString()];return void 0!==a?a:null};ol.source.Vector.prototype.getFormat=function(){return this.format_};ol.source.Vector.prototype.getOverlaps=function(){return this.overlaps_};ol.source.Vector.prototype.getResolutions=function(){};ol.source.Vector.prototype.getUrl=function(){return this.url_};
ol.source.Vector.prototype.handleFeatureChange_=function(a){a=a.target;var b=ol.getUid(a).toString(),c=a.getGeometry();c?(c=c.getExtent(),b in this.nullGeometryFeatures_?(delete this.nullGeometryFeatures_[b],this.featuresRtree_&&this.featuresRtree_.insert(c,a)):this.featuresRtree_&&this.featuresRtree_.update(c,a)):b in this.nullGeometryFeatures_||(this.featuresRtree_&&this.featuresRtree_.remove(a),this.nullGeometryFeatures_[b]=a);c=a.getId();void 0!==c?(c=c.toString(),b in this.undefIdIndex_?(delete this.undefIdIndex_[b],
this.idIndex_[c]=a):this.idIndex_[c]!==a&&(this.removeFromIdIndex_(a),this.idIndex_[c]=a)):b in this.undefIdIndex_||(this.removeFromIdIndex_(a),this.undefIdIndex_[b]=a);this.changed();this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.CHANGEFEATURE,a))};ol.source.Vector.prototype.isEmpty=function(){return this.featuresRtree_.isEmpty()&&ol.obj.isEmpty(this.nullGeometryFeatures_)};
ol.source.Vector.prototype.loadFeatures=function(a,b,c){var d=this.loadedExtentsRtree_;a=this.strategy_(a,b);var e;var f=0;for(e=a.length;f<e;++f){var g=a[f];d.forEachInExtent(g,function(a){return ol.extent.containsExtent(a.extent,g)})||(this.loader_.call(this,g,b,c),d.insert(g,{extent:g.slice()}))}};ol.source.Vector.prototype.removeLoadedExtent=function(a){var b=this.loadedExtentsRtree_,c;b.forEachInExtent(a,function(b){if(ol.extent.equals(b.extent,a))return c=b,!0});c&&b.remove(c)};
ol.source.Vector.prototype.removeFeature=function(a){var b=ol.getUid(a).toString();b in this.nullGeometryFeatures_?delete this.nullGeometryFeatures_[b]:this.featuresRtree_&&this.featuresRtree_.remove(a);this.removeFeatureInternal(a);this.changed()};
ol.source.Vector.prototype.removeFeatureInternal=function(a){var b=ol.getUid(a).toString();this.featureChangeKeys_[b].forEach(ol.events.unlistenByKey);delete this.featureChangeKeys_[b];var c=a.getId();void 0!==c?delete this.idIndex_[c.toString()]:delete this.undefIdIndex_[b];this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.REMOVEFEATURE,a))};
ol.source.Vector.prototype.removeFromIdIndex_=function(a){var b=!1,c;for(c in this.idIndex_)if(this.idIndex_[c]===a){delete this.idIndex_[c];b=!0;break}return b};ol.source.Vector.prototype.setLoader=function(a){this.loader_=a};ol.source.Vector.Event=function(a,b){ol.events.Event.call(this,a);this.feature=b};ol.inherits(ol.source.Vector.Event,ol.events.Event);ol.interaction.Draw=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.Draw.handleDownEvent_,handleEvent:ol.interaction.Draw.handleEvent,handleUpEvent:ol.interaction.Draw.handleUpEvent_});this.shouldHandle_=!1;this.downPx_=null;this.freehand_=!1;this.source_=a.source?a.source:null;this.features_=a.features?a.features:null;this.snapTolerance_=a.snapTolerance?a.snapTolerance:12;this.type_=a.type;this.mode_=ol.interaction.Draw.getMode_(this.type_);this.stopClick_=!!a.stopClick;
this.minPoints_=a.minPoints?a.minPoints:this.mode_===ol.interaction.Draw.Mode_.POLYGON?3:2;this.maxPoints_=a.maxPoints?a.maxPoints:Infinity;this.finishCondition_=a.finishCondition?a.finishCondition:ol.functions.TRUE;var b=a.geometryFunction;if(!b)if(this.type_===ol.geom.GeometryType.CIRCLE)b=function(a,b){b=b?b:new ol.geom.Circle([NaN,NaN]);var c=ol.coordinate.squaredDistance(a[0],a[1]);b.setCenterAndRadius(a[0],Math.sqrt(c));return b};else{var c=this.mode_;if(c===ol.interaction.Draw.Mode_.POINT)var d=
ol.geom.Point;else c===ol.interaction.Draw.Mode_.LINE_STRING?d=ol.geom.LineString:c===ol.interaction.Draw.Mode_.POLYGON&&(d=ol.geom.Polygon);b=function(a,b){b?c===ol.interaction.Draw.Mode_.POLYGON?a[0].length?b.setCoordinates([a[0].concat([a[0][0]])]):b.setCoordinates([]):b.setCoordinates(a):b=new d(a);return b}}this.geometryFunction_=b;this.sketchLineCoords_=this.sketchLine_=this.sketchCoords_=this.sketchPoint_=this.sketchFeature_=this.finishCoordinate_=null;this.squaredClickTolerance_=a.clickTolerance?
a.clickTolerance*a.clickTolerance:36;this.overlay_=new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:!1,wrapX:a.wrapX?a.wrapX:!1}),style:a.style?a.style:ol.interaction.Draw.getDefaultStyleFunction()});this.geometryName_=a.geometryName;this.condition_=a.condition?a.condition:ol.events.condition.noModifierKeys;this.freehandCondition_=a.freehand?ol.events.condition.always:a.freehandCondition?a.freehandCondition:ol.events.condition.shiftKeyOnly;ol.events.listen(this,ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE),
this.updateState_,this)};ol.inherits(ol.interaction.Draw,ol.interaction.Pointer);ol.interaction.Draw.getDefaultStyleFunction=function(){var a=ol.style.Style.createDefaultEditing();return function(b,c){return a[b.getGeometry().getType()]}};ol.interaction.Draw.prototype.setMap=function(a){ol.interaction.Pointer.prototype.setMap.call(this,a);this.updateState_()};
ol.interaction.Draw.handleEvent=function(a){this.freehand_=this.mode_!==ol.interaction.Draw.Mode_.POINT&&this.freehandCondition_(a);var b=!0;this.freehand_&&a.type===ol.MapBrowserEventType.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(a),b=!1):this.freehand_&&a.type===ol.MapBrowserEventType.POINTERDOWN?b=!1:a.type===ol.MapBrowserEventType.POINTERMOVE?b=this.handlePointerMove_(a):a.type===ol.MapBrowserEventType.DBLCLICK&&(b=!1);return ol.interaction.Pointer.handleEvent.call(this,a)&&
b};ol.interaction.Draw.handleDownEvent_=function(a){this.shouldHandle_=!this.freehand_;return this.freehand_?(this.downPx_=a.pixel,this.finishCoordinate_||this.startDrawing_(a),!0):this.condition_(a)?(this.downPx_=a.pixel,!0):!1};
ol.interaction.Draw.handleUpEvent_=function(a){var b=!0;this.handlePointerMove_(a);var c=this.mode_===ol.interaction.Draw.Mode_.CIRCLE;this.shouldHandle_?(this.finishCoordinate_?this.freehand_||c?this.finishDrawing():this.atFinish_(a)?this.finishCondition_(a)&&this.finishDrawing():this.addToDrawing_(a):(this.startDrawing_(a),this.mode_===ol.interaction.Draw.Mode_.POINT&&this.finishDrawing()),b=!1):this.freehand_&&(this.finishCoordinate_=null,this.abortDrawing_());!b&&this.stopClick_&&a.stopPropagation();
return b};ol.interaction.Draw.prototype.handlePointerMove_=function(a){if(this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){var b=this.downPx_,c=a.pixel,d=b[0]-c[0];b=b[1]-c[1];d=d*d+b*b;this.shouldHandle_=this.freehand_?d>this.squaredClickTolerance_:d<=this.squaredClickTolerance_}this.finishCoordinate_?this.modifyDrawing_(a):this.createOrUpdateSketchPoint_(a);return!0};
ol.interaction.Draw.prototype.atFinish_=function(a){var b=!1;if(this.sketchFeature_){var c=!1,d=[this.finishCoordinate_];this.mode_===ol.interaction.Draw.Mode_.LINE_STRING?c=this.sketchCoords_.length>this.minPoints_:this.mode_===ol.interaction.Draw.Mode_.POLYGON&&(c=this.sketchCoords_[0].length>this.minPoints_,d=[this.sketchCoords_[0][0],this.sketchCoords_[0][this.sketchCoords_[0].length-2]]);if(c){c=a.map;for(var e=0,f=d.length;e<f;e++){var g=d[e],h=c.getPixelFromCoordinate(g),k=a.pixel;b=k[0]-h[0];
h=k[1]-h[1];if(b=Math.sqrt(b*b+h*h)<=(this.freehand_?1:this.snapTolerance_)){this.finishCoordinate_=g;break}}}}return b};ol.interaction.Draw.prototype.createOrUpdateSketchPoint_=function(a){a=a.coordinate.slice();this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(a):(this.sketchPoint_=new ol.Feature(new ol.geom.Point(a)),this.updateSketchFeatures_())};
ol.interaction.Draw.prototype.startDrawing_=function(a){this.finishCoordinate_=a=a.coordinate;this.mode_===ol.interaction.Draw.Mode_.POINT?this.sketchCoords_=a.slice():this.mode_===ol.interaction.Draw.Mode_.POLYGON?(this.sketchCoords_=[[a.slice(),a.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):(this.sketchCoords_=[a.slice(),a.slice()],this.mode_===ol.interaction.Draw.Mode_.CIRCLE&&(this.sketchLineCoords_=this.sketchCoords_));this.sketchLineCoords_&&(this.sketchLine_=new ol.Feature(new ol.geom.LineString(this.sketchLineCoords_)));
a=this.geometryFunction_(this.sketchCoords_);this.sketchFeature_=new ol.Feature;this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_);this.sketchFeature_.setGeometry(a);this.updateSketchFeatures_();this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWSTART,this.sketchFeature_))};
ol.interaction.Draw.prototype.modifyDrawing_=function(a){var b=a.coordinate,c=this.sketchFeature_.getGeometry();if(this.mode_===ol.interaction.Draw.Mode_.POINT)var d=this.sketchCoords_;else this.mode_===ol.interaction.Draw.Mode_.POLYGON?(d=this.sketchCoords_[0],d=d[d.length-1],this.atFinish_(a)&&(b=this.finishCoordinate_.slice())):(d=this.sketchCoords_,d=d[d.length-1]);d[0]=b[0];d[1]=b[1];this.geometryFunction_(this.sketchCoords_,c);this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(b);
c instanceof ol.geom.Polygon&&this.mode_!==ol.interaction.Draw.Mode_.POLYGON?(this.sketchLine_||(this.sketchLine_=new ol.Feature(new ol.geom.LineString(null))),b=c.getLinearRing(0),a=this.sketchLine_.getGeometry(),a.setFlatCoordinates(b.getLayout(),b.getFlatCoordinates())):this.sketchLineCoords_&&(a=this.sketchLine_.getGeometry(),a.setCoordinates(this.sketchLineCoords_));this.updateSketchFeatures_()};
ol.interaction.Draw.prototype.addToDrawing_=function(a){a=a.coordinate;var b=this.sketchFeature_.getGeometry(),c;if(this.mode_===ol.interaction.Draw.Mode_.LINE_STRING){this.finishCoordinate_=a.slice();var d=this.sketchCoords_;d.length>=this.maxPoints_&&(this.freehand_?d.pop():c=!0);d.push(a.slice());this.geometryFunction_(d,b)}else this.mode_===ol.interaction.Draw.Mode_.POLYGON&&(d=this.sketchCoords_[0],d.length>=this.maxPoints_&&(this.freehand_?d.pop():c=!0),d.push(a.slice()),c&&(this.finishCoordinate_=
d[0]),this.geometryFunction_(this.sketchCoords_,b));this.updateSketchFeatures_();c&&this.finishDrawing()};
ol.interaction.Draw.prototype.removeLastPoint=function(){if(this.sketchFeature_){var a=this.sketchFeature_.getGeometry();if(this.mode_===ol.interaction.Draw.Mode_.LINE_STRING){var b=this.sketchCoords_;b.splice(-2,1);this.geometryFunction_(b,a);2<=b.length&&(this.finishCoordinate_=b[b.length-2].slice())}else if(this.mode_===ol.interaction.Draw.Mode_.POLYGON){b=this.sketchCoords_[0];b.splice(-2,1);var c=this.sketchLine_.getGeometry();c.setCoordinates(b);this.geometryFunction_(this.sketchCoords_,a)}0===
b.length&&(this.finishCoordinate_=null);this.updateSketchFeatures_()}};
ol.interaction.Draw.prototype.finishDrawing=function(){var a=this.abortDrawing_(),b=this.sketchCoords_,c=a.getGeometry();this.mode_===ol.interaction.Draw.Mode_.LINE_STRING?(b.pop(),this.geometryFunction_(b,c)):this.mode_===ol.interaction.Draw.Mode_.POLYGON&&(b[0].pop(),this.geometryFunction_(b,c),b=c.getCoordinates());this.type_===ol.geom.GeometryType.MULTI_POINT?a.setGeometry(new ol.geom.MultiPoint([b])):this.type_===ol.geom.GeometryType.MULTI_LINE_STRING?a.setGeometry(new ol.geom.MultiLineString([b])):
this.type_===ol.geom.GeometryType.MULTI_POLYGON&&a.setGeometry(new ol.geom.MultiPolygon([b]));this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWEND,a));this.features_&&this.features_.push(a);this.source_&&this.source_.addFeature(a)};ol.interaction.Draw.prototype.abortDrawing_=function(){this.finishCoordinate_=null;var a=this.sketchFeature_;a&&(this.sketchLine_=this.sketchPoint_=this.sketchFeature_=null,this.overlay_.getSource().clear(!0));return a};
ol.interaction.Draw.prototype.extend=function(a){var b=a.getGeometry();this.sketchFeature_=a;this.sketchCoords_=b.getCoordinates();a=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=a.slice();this.sketchCoords_.push(a.slice());this.updateSketchFeatures_();this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWSTART,this.sketchFeature_))};ol.interaction.Draw.prototype.shouldStopEvent=ol.functions.FALSE;
ol.interaction.Draw.prototype.updateSketchFeatures_=function(){var a=[];this.sketchFeature_&&a.push(this.sketchFeature_);this.sketchLine_&&a.push(this.sketchLine_);this.sketchPoint_&&a.push(this.sketchPoint_);var b=this.overlay_.getSource();b.clear(!0);b.addFeatures(a)};ol.interaction.Draw.prototype.updateState_=function(){var a=this.getMap(),b=this.getActive();a&&b||this.abortDrawing_();this.overlay_.setMap(b?a:null)};
ol.interaction.Draw.createRegularPolygon=function(a,b){return function(c,d){var e=c[0];c=c[1];var f=Math.sqrt(ol.coordinate.squaredDistance(e,c));d=d?d:ol.geom.Polygon.fromCircle(new ol.geom.Circle(e),a);ol.geom.Polygon.makeRegular(d,e,f,b?b:Math.atan((c[1]-e[1])/(c[0]-e[0])));return d}};
ol.interaction.Draw.createBox=function(){return function(a,b){a=ol.extent.boundingExtent(a);b=b||new ol.geom.Polygon(null);b.setCoordinates([[ol.extent.getBottomLeft(a),ol.extent.getBottomRight(a),ol.extent.getTopRight(a),ol.extent.getTopLeft(a),ol.extent.getBottomLeft(a)]]);return b}};
ol.interaction.Draw.getMode_=function(a){if(a===ol.geom.GeometryType.POINT||a===ol.geom.GeometryType.MULTI_POINT)var b=ol.interaction.Draw.Mode_.POINT;else a===ol.geom.GeometryType.LINE_STRING||a===ol.geom.GeometryType.MULTI_LINE_STRING?b=ol.interaction.Draw.Mode_.LINE_STRING:a===ol.geom.GeometryType.POLYGON||a===ol.geom.GeometryType.MULTI_POLYGON?b=ol.interaction.Draw.Mode_.POLYGON:a===ol.geom.GeometryType.CIRCLE&&(b=ol.interaction.Draw.Mode_.CIRCLE);return b};
ol.interaction.Draw.Mode_={POINT:"Point",LINE_STRING:"LineString",POLYGON:"Polygon",CIRCLE:"Circle"};ol.interaction.Draw.Event=function(a,b){ol.events.Event.call(this,a);this.feature=b};ol.inherits(ol.interaction.Draw.Event,ol.events.Event);ol.interaction.ExtentEventType={EXTENTCHANGED:"extentchanged"};ol.interaction.Extent=function(a){var b=a||{};this.pointerHandler_=this.extent_=null;this.pixelTolerance_=void 0!==b.pixelTolerance?b.pixelTolerance:10;this.snappedToVertex_=!1;this.vertexFeature_=this.extentFeature_=null;a||(a={});ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.Extent.handleDownEvent_,handleDragEvent:ol.interaction.Extent.handleDragEvent_,handleEvent:ol.interaction.Extent.handleEvent_,handleUpEvent:ol.interaction.Extent.handleUpEvent_});this.extentOverlay_=new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:!1,
wrapX:!!a.wrapX}),style:a.boxStyle?a.boxStyle:ol.interaction.Extent.getDefaultExtentStyleFunction_(),updateWhileAnimating:!0,updateWhileInteracting:!0});this.vertexOverlay_=new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:!1,wrapX:!!a.wrapX}),style:a.pointerStyle?a.pointerStyle:ol.interaction.Extent.getDefaultPointerStyleFunction_(),updateWhileAnimating:!0,updateWhileInteracting:!0});a.extent&&this.setExtent(a.extent)};ol.inherits(ol.interaction.Extent,ol.interaction.Pointer);
ol.interaction.Extent.handleEvent_=function(a){if(!(a instanceof ol.MapBrowserPointerEvent))return!0;a.type!=ol.MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(a);ol.interaction.Pointer.handleEvent.call(this,a);return!1};
ol.interaction.Extent.handleDownEvent_=function(a){var b=a.pixel,c=a.map,d=this.getExtent();a=this.snapToVertex_(b,c);var e=function(a){var b=null,c=null;a[0]==d[0]?b=d[2]:a[0]==d[2]&&(b=d[0]);a[1]==d[1]?c=d[3]:a[1]==d[3]&&(c=d[1]);return null!==b&&null!==c?[b,c]:null};a&&d?(b=a[0]==d[0]||a[0]==d[2]?a[0]:null,c=a[1]==d[1]||a[1]==d[3]?a[1]:null,null!==b&&null!==c?this.pointerHandler_=ol.interaction.Extent.getPointHandler_(e(a)):null!==b?this.pointerHandler_=ol.interaction.Extent.getEdgeHandler_(e([b,
d[1]]),e([b,d[3]])):null!==c&&(this.pointerHandler_=ol.interaction.Extent.getEdgeHandler_(e([d[0],c]),e([d[2],c])))):(a=c.getCoordinateFromPixel(b),this.setExtent([a[0],a[1],a[0],a[1]]),this.pointerHandler_=ol.interaction.Extent.getPointHandler_(a));return!0};ol.interaction.Extent.handleDragEvent_=function(a){this.pointerHandler_&&(a=a.coordinate,this.setExtent(this.pointerHandler_(a)),this.createOrUpdatePointerFeature_(a));return!0};
ol.interaction.Extent.handleUpEvent_=function(a){this.pointerHandler_=null;(a=this.getExtent())&&0!==ol.extent.getArea(a)||this.setExtent(null);return!1};ol.interaction.Extent.getDefaultExtentStyleFunction_=function(){var a=ol.style.Style.createDefaultEditing();return function(b,c){return a[ol.geom.GeometryType.POLYGON]}};ol.interaction.Extent.getDefaultPointerStyleFunction_=function(){var a=ol.style.Style.createDefaultEditing();return function(b,c){return a[ol.geom.GeometryType.POINT]}};
ol.interaction.Extent.getPointHandler_=function(a){return function(b){return ol.extent.boundingExtent([a,b])}};ol.interaction.Extent.getEdgeHandler_=function(a,b){return a[0]==b[0]?function(c){return ol.extent.boundingExtent([a,[c[0],b[1]]])}:a[1]==b[1]?function(c){return ol.extent.boundingExtent([a,[b[0],c[1]]])}:null};ol.interaction.Extent.getSegments_=function(a){return[[[a[0],a[1]],[a[0],a[3]]],[[a[0],a[3]],[a[2],a[3]]],[[a[2],a[3]],[a[2],a[1]]],[[a[2],a[1]],[a[0],a[1]]]]};
ol.interaction.Extent.prototype.snapToVertex_=function(a,b){var c=b.getCoordinateFromPixel(a),d=function(a,b){return ol.coordinate.squaredDistanceToSegment(c,a)-ol.coordinate.squaredDistanceToSegment(c,b)},e=this.getExtent();if(e){e=ol.interaction.Extent.getSegments_(e);e.sort(d);d=e[0];e=ol.coordinate.closestOnSegment(c,d);var f=b.getPixelFromCoordinate(e);if(ol.coordinate.distance(a,f)<=this.pixelTolerance_)return a=b.getPixelFromCoordinate(d[0]),b=b.getPixelFromCoordinate(d[1]),a=ol.coordinate.squaredDistance(f,
a),b=ol.coordinate.squaredDistance(f,b),(this.snappedToVertex_=Math.sqrt(Math.min(a,b))<=this.pixelTolerance_)&&(e=a>b?d[1]:d[0]),e}return null};ol.interaction.Extent.prototype.handlePointerMove_=function(a){var b=a.pixel;a=a.map;var c=this.snapToVertex_(b,a);c||(c=a.getCoordinateFromPixel(b));this.createOrUpdatePointerFeature_(c)};
ol.interaction.Extent.prototype.createOrUpdateExtentFeature_=function(a){var b=this.extentFeature_;b?a?b.setGeometry(ol.geom.Polygon.fromExtent(a)):b.setGeometry(void 0):(this.extentFeature_=b=a?new ol.Feature(ol.geom.Polygon.fromExtent(a)):new ol.Feature({}),this.extentOverlay_.getSource().addFeature(b));return b};
ol.interaction.Extent.prototype.createOrUpdatePointerFeature_=function(a){var b=this.vertexFeature_;b?b.getGeometry().setCoordinates(a):(this.vertexFeature_=b=new ol.Feature(new ol.geom.Point(a)),this.vertexOverlay_.getSource().addFeature(b));return b};ol.interaction.Extent.prototype.setMap=function(a){this.extentOverlay_.setMap(a);this.vertexOverlay_.setMap(a);ol.interaction.Pointer.prototype.setMap.call(this,a)};ol.interaction.Extent.prototype.getExtent=function(){return this.extent_};
ol.interaction.Extent.prototype.setExtent=function(a){this.extent_=a?a:null;this.createOrUpdateExtentFeature_(a);this.dispatchEvent(new ol.interaction.Extent.Event(this.extent_))};ol.interaction.Extent.Event=function(a){ol.events.Event.call(this,ol.interaction.ExtentEventType.EXTENTCHANGED);this.extent=a};ol.inherits(ol.interaction.Extent.Event,ol.events.Event);ol.interaction.ModifyEventType={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};ol.interaction.Modify=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.Modify.handleDownEvent_,handleDragEvent:ol.interaction.Modify.handleDragEvent_,handleEvent:ol.interaction.Modify.handleEvent,handleUpEvent:ol.interaction.Modify.handleUpEvent_});this.condition_=a.condition?a.condition:ol.events.condition.primaryAction;this.defaultDeleteCondition_=function(a){return ol.events.condition.altKeyOnly(a)&&ol.events.condition.singleClick(a)};this.deleteCondition_=a.deleteCondition?
a.deleteCondition:this.defaultDeleteCondition_;this.insertVertexCondition_=a.insertVertexCondition?a.insertVertexCondition:ol.events.condition.always;this.vertexSegments_=this.vertexFeature_=null;this.lastPixel_=[0,0];this.modified_=this.ignoreNextSingleClick_=!1;this.rBush_=new ol.structs.RBush;this.pixelTolerance_=void 0!==a.pixelTolerance?a.pixelTolerance:10;this.changingFeature_=this.snappedToVertex_=!1;this.dragSegments_=[];this.overlay_=new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:!1,
wrapX:!!a.wrapX}),style:a.style?a.style:ol.interaction.Modify.getDefaultStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0});this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,Circle:this.writeCircleGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_};
this.source_=null;a.source?(this.source_=a.source,a=new ol.Collection(this.source_.getFeatures()),ol.events.listen(this.source_,ol.source.VectorEventType.ADDFEATURE,this.handleSourceAdd_,this),ol.events.listen(this.source_,ol.source.VectorEventType.REMOVEFEATURE,this.handleSourceRemove_,this)):a=a.features;if(!a)throw Error("The modify interaction requires features or a source");this.features_=a;this.features_.forEach(this.addFeature_,this);ol.events.listen(this.features_,ol.CollectionEventType.ADD,
this.handleFeatureAdd_,this);ol.events.listen(this.features_,ol.CollectionEventType.REMOVE,this.handleFeatureRemove_,this);this.lastPointerEvent_=null};ol.inherits(ol.interaction.Modify,ol.interaction.Pointer);ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX=0;ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX=1;
ol.interaction.Modify.prototype.addFeature_=function(a){var b=a.getGeometry();b&&b.getType()in this.SEGMENT_WRITERS_&&this.SEGMENT_WRITERS_[b.getType()].call(this,a,b);(b=this.getMap())&&b.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,b);ol.events.listen(a,ol.events.EventType.CHANGE,this.handleFeatureChange_,this)};
ol.interaction.Modify.prototype.willModifyFeatures_=function(a){this.modified_||(this.modified_=!0,this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYSTART,this.features_,a)))};
ol.interaction.Modify.prototype.removeFeature_=function(a){this.removeFeatureSegmentData_(a);this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);ol.events.unlisten(a,ol.events.EventType.CHANGE,this.handleFeatureChange_,this)};ol.interaction.Modify.prototype.removeFeatureSegmentData_=function(a){var b=this.rBush_,c=[];b.forEach(function(b){a===b.feature&&c.push(b)});for(var d=c.length-1;0<=d;--d)b.remove(c[d])};
ol.interaction.Modify.prototype.setActive=function(a){this.vertexFeature_&&!a&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);ol.interaction.Pointer.prototype.setActive.call(this,a)};ol.interaction.Modify.prototype.setMap=function(a){this.overlay_.setMap(a);ol.interaction.Pointer.prototype.setMap.call(this,a)};ol.interaction.Modify.prototype.handleSourceAdd_=function(a){a.feature&&this.features_.push(a.feature)};
ol.interaction.Modify.prototype.handleSourceRemove_=function(a){a.feature&&this.features_.remove(a.feature)};ol.interaction.Modify.prototype.handleFeatureAdd_=function(a){this.addFeature_(a.element)};ol.interaction.Modify.prototype.handleFeatureChange_=function(a){this.changingFeature_||(a=a.target,this.removeFeature_(a),this.addFeature_(a))};ol.interaction.Modify.prototype.handleFeatureRemove_=function(a){this.removeFeature_(a.element)};
ol.interaction.Modify.prototype.writePointGeometry_=function(a,b){var c=b.getCoordinates();a={feature:a,geometry:b,segment:[c,c]};this.rBush_.insert(b.getExtent(),a)};ol.interaction.Modify.prototype.writeMultiPointGeometry_=function(a,b){var c=b.getCoordinates(),d;var e=0;for(d=c.length;e<d;++e){var f=c[e];f={feature:a,geometry:b,depth:[e],index:e,segment:[f,f]};this.rBush_.insert(b.getExtent(),f)}};
ol.interaction.Modify.prototype.writeLineStringGeometry_=function(a,b){var c=b.getCoordinates(),d;var e=0;for(d=c.length-1;e<d;++e){var f=c.slice(e,e+2);var g={feature:a,geometry:b,index:e,segment:f};this.rBush_.insert(ol.extent.boundingExtent(f),g)}};
ol.interaction.Modify.prototype.writeMultiLineStringGeometry_=function(a,b){var c=b.getCoordinates(),d,e;var f=0;for(e=c.length;f<e;++f){var g=c[f];var h=0;for(d=g.length-1;h<d;++h){var k=g.slice(h,h+2);var l={feature:a,geometry:b,depth:[f],index:h,segment:k};this.rBush_.insert(ol.extent.boundingExtent(k),l)}}};
ol.interaction.Modify.prototype.writePolygonGeometry_=function(a,b){var c=b.getCoordinates(),d,e;var f=0;for(e=c.length;f<e;++f){var g=c[f];var h=0;for(d=g.length-1;h<d;++h){var k=g.slice(h,h+2);var l={feature:a,geometry:b,depth:[f],index:h,segment:k};this.rBush_.insert(ol.extent.boundingExtent(k),l)}}};
ol.interaction.Modify.prototype.writeMultiPolygonGeometry_=function(a,b){var c=b.getCoordinates(),d,e,f;var g=0;for(f=c.length;g<f;++g){var h=c[g];var k=0;for(e=h.length;k<e;++k){var l=h[k];var m=0;for(d=l.length-1;m<d;++m){var n=l.slice(m,m+2);var p={feature:a,geometry:b,depth:[k,g],index:m,segment:n};this.rBush_.insert(ol.extent.boundingExtent(n),p)}}}};
ol.interaction.Modify.prototype.writeCircleGeometry_=function(a,b){var c=b.getCenter(),d={feature:a,geometry:b,index:ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX,segment:[c,c]};a={feature:a,geometry:b,index:ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX,segment:[c,c]};d.featureSegments=a.featureSegments=[d,a];this.rBush_.insert(ol.extent.createOrUpdateFromCoordinate(c),d);this.rBush_.insert(b.getExtent(),a)};
ol.interaction.Modify.prototype.writeGeometryCollectionGeometry_=function(a,b){var c=b.getGeometriesArray();for(b=0;b<c.length;++b)this.SEGMENT_WRITERS_[c[b].getType()].call(this,a,c[b])};ol.interaction.Modify.prototype.createOrUpdateVertexFeature_=function(a){var b=this.vertexFeature_;b?b.getGeometry().setCoordinates(a):(this.vertexFeature_=b=new ol.Feature(new ol.geom.Point(a)),this.overlay_.getSource().addFeature(b));return b};
ol.interaction.Modify.compareIndexes_=function(a,b){return a.index-b.index};
ol.interaction.Modify.handleDownEvent_=function(a){if(!this.condition_(a))return!1;this.handlePointerAtPixel_(a.pixel,a.map);var b=a.map.getCoordinateFromPixel(a.pixel);this.dragSegments_.length=0;this.modified_=!1;var c=this.vertexFeature_;if(c){var d=[];c=c.getGeometry().getCoordinates();var e=ol.extent.boundingExtent([c]);e=this.rBush_.getInExtent(e);var f={};e.sort(ol.interaction.Modify.compareIndexes_);for(var g=0,h=e.length;g<h;++g){var k=e[g],l=k.segment,m=ol.getUid(k.feature),n=k.depth;n&&
(m+="-"+n.join("-"));f[m]||(f[m]=Array(2));if(k.geometry.getType()===ol.geom.GeometryType.CIRCLE&&k.index===ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX)l=ol.interaction.Modify.closestOnSegmentData_(b,k),ol.coordinate.equals(l,c)&&!f[m][0]&&(this.dragSegments_.push([k,0]),f[m][0]=k);else if(ol.coordinate.equals(l[0],c)&&!f[m][0])this.dragSegments_.push([k,0]),f[m][0]=k;else if(ol.coordinate.equals(l[1],c)&&!f[m][1]){if(k.geometry.getType()!==ol.geom.GeometryType.LINE_STRING&&k.geometry.getType()!==
ol.geom.GeometryType.MULTI_LINE_STRING||!f[m][0]||0!==f[m][0].index)this.dragSegments_.push([k,1]),f[m][1]=k}else this.insertVertexCondition_(a)&&ol.getUid(l)in this.vertexSegments_&&!f[m][0]&&!f[m][1]&&d.push([k,c])}d.length&&this.willModifyFeatures_(a);for(a=d.length-1;0<=a;--a)this.insertVertex_.apply(this,d[a])}return!!this.vertexFeature_};
ol.interaction.Modify.handleDragEvent_=function(a){this.ignoreNextSingleClick_=!1;this.willModifyFeatures_(a);a=a.coordinate;for(var b=0,c=this.dragSegments_.length;b<c;++b){var d=this.dragSegments_[b],e=d[0],f=e.depth,g=e.geometry,h=e.segment;for(d=d[1];a.length<g.getStride();)a.push(h[d][a.length]);switch(g.getType()){case ol.geom.GeometryType.POINT:var k=a;h[0]=h[1]=a;break;case ol.geom.GeometryType.MULTI_POINT:k=g.getCoordinates();k[e.index]=a;h[0]=h[1]=a;break;case ol.geom.GeometryType.LINE_STRING:k=
g.getCoordinates();k[e.index+d]=a;h[d]=a;break;case ol.geom.GeometryType.MULTI_LINE_STRING:k=g.getCoordinates();k[f[0]][e.index+d]=a;h[d]=a;break;case ol.geom.GeometryType.POLYGON:k=g.getCoordinates();k[f[0]][e.index+d]=a;h[d]=a;break;case ol.geom.GeometryType.MULTI_POLYGON:k=g.getCoordinates();k[f[1]][f[0]][e.index+d]=a;h[d]=a;break;case ol.geom.GeometryType.CIRCLE:h[0]=h[1]=a,e.index===ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX?(this.changingFeature_=!0,g.setCenter(a)):(this.changingFeature_=
!0,g.setRadius(ol.coordinate.distance(g.getCenter(),a))),this.changingFeature_=!1}k&&this.setGeometryCoordinates_(g,k)}this.createOrUpdateVertexFeature_(a)};
ol.interaction.Modify.handleUpEvent_=function(a){for(var b,c,d=this.dragSegments_.length-1;0<=d;--d)if(b=this.dragSegments_[d][0],c=b.geometry,c.getType()===ol.geom.GeometryType.CIRCLE){var e=c.getCenter(),f=b.featureSegments[0];b=b.featureSegments[1];f.segment[0]=f.segment[1]=e;b.segment[0]=b.segment[1]=e;this.rBush_.update(ol.extent.createOrUpdateFromCoordinate(e),f);this.rBush_.update(c.getExtent(),b)}else this.rBush_.update(ol.extent.boundingExtent(b.segment),b);this.modified_&&(this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYEND,
this.features_,a)),this.modified_=!1);return!1};
ol.interaction.Modify.handleEvent=function(a){if(!(a instanceof ol.MapBrowserPointerEvent))return!0;this.lastPointerEvent_=a;var b;a.map.getView().getInteracting()||a.type!=ol.MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(a);this.vertexFeature_&&this.deleteCondition_(a)&&(b=a.type==ol.MapBrowserEventType.SINGLECLICK&&this.ignoreNextSingleClick_?!0:this.removePoint());a.type==ol.MapBrowserEventType.SINGLECLICK&&(this.ignoreNextSingleClick_=!1);return ol.interaction.Pointer.handleEvent.call(this,
a)&&!b};ol.interaction.Modify.prototype.handlePointerMove_=function(a){this.lastPixel_=a.pixel;this.handlePointerAtPixel_(a.pixel,a.map)};
ol.interaction.Modify.prototype.handlePointerAtPixel_=function(a,b){var c=b.getCoordinateFromPixel(a),d=function(a,b){return ol.interaction.Modify.pointDistanceToSegmentDataSquared_(c,a)-ol.interaction.Modify.pointDistanceToSegmentDataSquared_(c,b)},e=ol.extent.buffer(ol.extent.createOrUpdateFromCoordinate(c),b.getView().getResolution()*this.pixelTolerance_);e=this.rBush_.getInExtent(e);if(0<e.length){e.sort(d);var f=e[0];d=f.segment;var g=ol.interaction.Modify.closestOnSegmentData_(c,f),h=b.getPixelFromCoordinate(g),
k=ol.coordinate.distance(a,h);if(k<=this.pixelTolerance_){a={};if(f.geometry.getType()===ol.geom.GeometryType.CIRCLE&&f.index===ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(g);else for(k=b.getPixelFromCoordinate(d[0]),f=b.getPixelFromCoordinate(d[1]),b=ol.coordinate.squaredDistance(h,k),h=ol.coordinate.squaredDistance(h,f),k=Math.sqrt(Math.min(b,h)),(this.snappedToVertex_=k<=this.pixelTolerance_)&&(g=b>h?d[1]:d[0]),this.createOrUpdateVertexFeature_(g),
b=1,h=e.length;b<h;++b)if(g=e[b].segment,ol.coordinate.equals(d[0],g[0])&&ol.coordinate.equals(d[1],g[1])||ol.coordinate.equals(d[0],g[1])&&ol.coordinate.equals(d[1],g[0]))a[ol.getUid(g)]=!0;else break;a[ol.getUid(d)]=!0;this.vertexSegments_=a;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)};
ol.interaction.Modify.pointDistanceToSegmentDataSquared_=function(a,b){var c=b.geometry;return c.getType()===ol.geom.GeometryType.CIRCLE&&b.index===ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX?(a=ol.coordinate.squaredDistance(c.getCenter(),a),c=Math.sqrt(a)-c.getRadius(),c*c):ol.coordinate.squaredDistanceToSegment(a,b.segment)};
ol.interaction.Modify.closestOnSegmentData_=function(a,b){var c=b.geometry;return c.getType()===ol.geom.GeometryType.CIRCLE&&b.index===ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX?c.getClosestPoint(a):ol.coordinate.closestOnSegment(a,b.segment)};
ol.interaction.Modify.prototype.insertVertex_=function(a,b){for(var c=a.segment,d=a.feature,e=a.geometry,f=a.depth,g=a.index,h;b.length<e.getStride();)b.push(0);switch(e.getType()){case ol.geom.GeometryType.MULTI_LINE_STRING:h=e.getCoordinates();h[f[0]].splice(g+1,0,b);break;case ol.geom.GeometryType.POLYGON:h=e.getCoordinates();h[f[0]].splice(g+1,0,b);break;case ol.geom.GeometryType.MULTI_POLYGON:h=e.getCoordinates();h[f[1]][f[0]].splice(g+1,0,b);break;case ol.geom.GeometryType.LINE_STRING:h=e.getCoordinates();
h.splice(g+1,0,b);break;default:return}this.setGeometryCoordinates_(e,h);h=this.rBush_;h.remove(a);this.updateSegmentIndices_(e,g,f,1);a={segment:[c[0],b],feature:d,geometry:e,depth:f,index:g};h.insert(ol.extent.boundingExtent(a.segment),a);this.dragSegments_.push([a,1]);b={segment:[b,c[1]],feature:d,geometry:e,depth:f,index:g+1};h.insert(ol.extent.boundingExtent(b.segment),b);this.dragSegments_.push([b,0]);this.ignoreNextSingleClick_=!0};
ol.interaction.Modify.prototype.removePoint=function(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=ol.MapBrowserEventType.POINTERDRAG){var a=this.lastPointerEvent_;this.willModifyFeatures_(a);this.removeVertex_();this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYEND,this.features_,a));this.modified_=!1;return!0}return!1};
ol.interaction.Modify.prototype.removeVertex_=function(){var a=this.dragSegments_,b={},c=!1,d,e;for(e=a.length-1;0<=e;--e){var f=a[e];var g=f[0];var h=ol.getUid(g.feature);g.depth&&(h+="-"+g.depth.join("-"));h in b||(b[h]={});0===f[1]?(b[h].right=g,b[h].index=g.index):1==f[1]&&(b[h].left=g,b[h].index=g.index+1)}for(h in b){var k=b[h].right;var l=b[h].left;e=b[h].index;var m=e-1;g=void 0!==l?l:k;0>m&&(m=0);f=g.geometry;var n=d=f.getCoordinates();c=!1;switch(f.getType()){case ol.geom.GeometryType.MULTI_LINE_STRING:2<
d[g.depth[0]].length&&(d[g.depth[0]].splice(e,1),c=!0);break;case ol.geom.GeometryType.LINE_STRING:2<d.length&&(d.splice(e,1),c=!0);break;case ol.geom.GeometryType.MULTI_POLYGON:n=n[g.depth[1]];case ol.geom.GeometryType.POLYGON:n=n[g.depth[0]],4<n.length&&(e==n.length-1&&(e=0),n.splice(e,1),c=!0,0===e&&(n.pop(),n.push(n[0]),m=n.length-1))}c&&(this.setGeometryCoordinates_(f,d),n=[],void 0!==l&&(this.rBush_.remove(l),n.push(l.segment[0])),void 0!==k&&(this.rBush_.remove(k),n.push(k.segment[1])),void 0!==
l&&void 0!==k&&(l={depth:g.depth,feature:g.feature,geometry:g.geometry,index:m,segment:n},this.rBush_.insert(ol.extent.boundingExtent(l.segment),l)),this.updateSegmentIndices_(f,e,g.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),a.length=0)}return c};ol.interaction.Modify.prototype.setGeometryCoordinates_=function(a,b){this.changingFeature_=!0;a.setCoordinates(b);this.changingFeature_=!1};
ol.interaction.Modify.prototype.updateSegmentIndices_=function(a,b,c,d){this.rBush_.forEachInExtent(a.getExtent(),function(e){e.geometry===a&&(void 0===c||void 0===e.depth||ol.array.equals(e.depth,c))&&e.index>b&&(e.index+=d)})};ol.interaction.Modify.getDefaultStyleFunction=function(){var a=ol.style.Style.createDefaultEditing();return function(b,c){return a[ol.geom.GeometryType.POINT]}};ol.interaction.Modify.Event=function(a,b,c){ol.events.Event.call(this,a);this.features=b;this.mapBrowserEvent=c};
ol.inherits(ol.interaction.Modify.Event,ol.events.Event);ol.interaction.Select=function(a){ol.interaction.Interaction.call(this,{handleEvent:ol.interaction.Select.handleEvent});a=a?a:{};this.condition_=a.condition?a.condition:ol.events.condition.singleClick;this.addCondition_=a.addCondition?a.addCondition:ol.events.condition.never;this.removeCondition_=a.removeCondition?a.removeCondition:ol.events.condition.never;this.toggleCondition_=a.toggleCondition?a.toggleCondition:ol.events.condition.shiftKeyOnly;this.multi_=a.multi?a.multi:!1;this.filter_=a.filter?
a.filter:ol.functions.TRUE;this.hitTolerance_=a.hitTolerance?a.hitTolerance:0;this.featureOverlay_=new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:!1,features:a.features,wrapX:a.wrapX}),style:a.style?a.style:ol.interaction.Select.getDefaultStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0});if(a.layers)if("function"===typeof a.layers)a=a.layers;else{var b=a.layers;a=function(a){return ol.array.includes(b,a)}}else a=ol.functions.TRUE;this.layerFilter_=a;this.featureLayerAssociation_=
{};a=this.featureOverlay_.getSource().getFeaturesCollection();ol.events.listen(a,ol.CollectionEventType.ADD,this.addFeature_,this);ol.events.listen(a,ol.CollectionEventType.REMOVE,this.removeFeature_,this)};ol.inherits(ol.interaction.Select,ol.interaction.Interaction);ol.interaction.Select.prototype.addFeatureLayerAssociation_=function(a,b){a=ol.getUid(a);this.featureLayerAssociation_[a]=b};ol.interaction.Select.prototype.getFeatures=function(){return this.featureOverlay_.getSource().getFeaturesCollection()};
ol.interaction.Select.prototype.getHitTolerance=function(){return this.hitTolerance_};ol.interaction.Select.prototype.getLayer=function(a){a=ol.getUid(a);return this.featureLayerAssociation_[a]};
ol.interaction.Select.handleEvent=function(a){if(!this.condition_(a))return!0;var b=this.addCondition_(a),c=this.removeCondition_(a),d=this.toggleCondition_(a),e=!b&&!c&&!d,f=a.map,g=this.featureOverlay_.getSource().getFeaturesCollection(),h=[],k=[];if(e){ol.obj.clear(this.featureLayerAssociation_);f.forEachFeatureAtPixel(a.pixel,function(a,b){if(this.filter_(a,b))return k.push(a),this.addFeatureLayerAssociation_(a,b),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});
for(e=g.getLength()-1;0<=e;--e){f=g.item(e);var l=k.indexOf(f);-1<l?k.splice(l,1):(g.remove(f),h.push(f))}0!==k.length&&g.extend(k)}else{f.forEachFeatureAtPixel(a.pixel,function(a,e){if(this.filter_(a,e))return!b&&!d||ol.array.includes(g.getArray(),a)?(c||d)&&ol.array.includes(g.getArray(),a)&&(h.push(a),this.removeFeatureLayerAssociation_(a)):(k.push(a),this.addFeatureLayerAssociation_(a,e)),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(e=h.length-
1;0<=e;--e)g.remove(h[e]);g.extend(k)}(0<k.length||0<h.length)&&this.dispatchEvent(new ol.interaction.Select.Event(ol.interaction.Select.EventType_.SELECT,k,h,a));return ol.events.condition.pointerMove(a)};ol.interaction.Select.prototype.setHitTolerance=function(a){this.hitTolerance_=a};
ol.interaction.Select.prototype.setMap=function(a){var b=this.getMap(),c=this.featureOverlay_.getSource().getFeaturesCollection();b&&c.forEach(b.unskipFeature,b);ol.interaction.Interaction.prototype.setMap.call(this,a);this.featureOverlay_.setMap(a);a&&c.forEach(a.skipFeature,a)};
ol.interaction.Select.getDefaultStyleFunction=function(){var a=ol.style.Style.createDefaultEditing();ol.array.extend(a[ol.geom.GeometryType.POLYGON],a[ol.geom.GeometryType.LINE_STRING]);ol.array.extend(a[ol.geom.GeometryType.GEOMETRY_COLLECTION],a[ol.geom.GeometryType.LINE_STRING]);return function(b,c){return b.getGeometry()?a[b.getGeometry().getType()]:null}};ol.interaction.Select.prototype.addFeature_=function(a){var b=this.getMap();b&&b.skipFeature(a.element)};
ol.interaction.Select.prototype.removeFeature_=function(a){var b=this.getMap();b&&b.unskipFeature(a.element)};ol.interaction.Select.prototype.removeFeatureLayerAssociation_=function(a){a=ol.getUid(a);delete this.featureLayerAssociation_[a]};ol.interaction.Select.Event=function(a,b,c,d){ol.events.Event.call(this,a);this.selected=b;this.deselected=c;this.mapBrowserEvent=d};ol.inherits(ol.interaction.Select.Event,ol.events.Event);ol.interaction.Select.EventType_={SELECT:"select"};ol.interaction.Snap=function(a){ol.interaction.Pointer.call(this,{handleEvent:ol.interaction.Snap.handleEvent_,handleDownEvent:ol.functions.TRUE,handleUpEvent:ol.interaction.Snap.handleUpEvent_});a=a?a:{};this.source_=a.source?a.source:null;this.vertex_=void 0!==a.vertex?a.vertex:!0;this.edge_=void 0!==a.edge?a.edge:!0;this.features_=a.features?a.features:null;this.featuresListenerKeys_=[];this.featureChangeListenerKeys_={};this.indexedFeaturesExtents_={};this.pendingFeatures_={};this.pixelCoordinate_=
null;this.pixelTolerance_=void 0!==a.pixelTolerance?a.pixelTolerance:10;this.sortByDistance_=ol.interaction.Snap.sortByDistance.bind(this);this.rBush_=new ol.structs.RBush;this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_,
Circle:this.writeCircleGeometry_}};ol.inherits(ol.interaction.Snap,ol.interaction.Pointer);ol.interaction.Snap.prototype.addFeature=function(a,b){b=void 0!==b?b:!0;var c=ol.getUid(a),d=a.getGeometry();if(d){var e=this.SEGMENT_WRITERS_[d.getType()];e&&(this.indexedFeaturesExtents_[c]=d.getExtent(ol.extent.createEmpty()),e.call(this,a,d))}b&&(this.featureChangeListenerKeys_[c]=ol.events.listen(a,ol.events.EventType.CHANGE,this.handleFeatureChange_,this))};
ol.interaction.Snap.prototype.forEachFeatureAdd_=function(a){this.addFeature(a)};ol.interaction.Snap.prototype.forEachFeatureRemove_=function(a){this.removeFeature(a)};ol.interaction.Snap.prototype.getFeatures_=function(){var a;this.features_?a=this.features_:this.source_&&(a=this.source_.getFeatures());return a};ol.interaction.Snap.prototype.handleFeatureAdd_=function(a){if(a instanceof ol.source.Vector.Event)var b=a.feature;else a instanceof ol.Collection.Event&&(b=a.element);this.addFeature(b)};
ol.interaction.Snap.prototype.handleFeatureRemove_=function(a){if(a instanceof ol.source.Vector.Event)var b=a.feature;else a instanceof ol.Collection.Event&&(b=a.element);this.removeFeature(b)};ol.interaction.Snap.prototype.handleFeatureChange_=function(a){a=a.target;if(this.handlingDownUpSequence){var b=ol.getUid(a);b in this.pendingFeatures_||(this.pendingFeatures_[b]=a)}else this.updateFeature_(a)};
ol.interaction.Snap.prototype.removeFeature=function(a,b){b=void 0!==b?b:!0;var c=ol.getUid(a),d=this.indexedFeaturesExtents_[c];if(d){var e=this.rBush_,f=[];e.forEachInExtent(d,function(b){a===b.feature&&f.push(b)});for(d=f.length-1;0<=d;--d)e.remove(f[d])}b&&(ol.events.unlistenByKey(this.featureChangeListenerKeys_[c]),delete this.featureChangeListenerKeys_[c])};
ol.interaction.Snap.prototype.setMap=function(a){var b=this.getMap(),c=this.featuresListenerKeys_,d=this.getFeatures_();b&&(c.forEach(ol.events.unlistenByKey),c.length=0,d.forEach(this.forEachFeatureRemove_,this));ol.interaction.Pointer.prototype.setMap.call(this,a);a&&(this.features_?c.push(ol.events.listen(this.features_,ol.CollectionEventType.ADD,this.handleFeatureAdd_,this),ol.events.listen(this.features_,ol.CollectionEventType.REMOVE,this.handleFeatureRemove_,this)):this.source_&&c.push(ol.events.listen(this.source_,
ol.source.VectorEventType.ADDFEATURE,this.handleFeatureAdd_,this),ol.events.listen(this.source_,ol.source.VectorEventType.REMOVEFEATURE,this.handleFeatureRemove_,this)),d.forEach(this.forEachFeatureAdd_,this))};ol.interaction.Snap.prototype.shouldStopEvent=ol.functions.FALSE;
ol.interaction.Snap.prototype.snapTo=function(a,b,c){var d=c.getCoordinateFromPixel([a[0]-this.pixelTolerance_,a[1]+this.pixelTolerance_]),e=c.getCoordinateFromPixel([a[0]+this.pixelTolerance_,a[1]-this.pixelTolerance_]);d=ol.extent.boundingExtent([d,e]);var f=this.rBush_.getInExtent(d);this.vertex_&&!this.edge_&&(f=f.filter(function(a){return a.feature.getGeometry().getType()!==ol.geom.GeometryType.CIRCLE}));var g=!1;d=!1;var h=e=null;if(0<f.length){this.pixelCoordinate_=b;f.sort(this.sortByDistance_);
var k=f[0].segment;g=f[0].feature.getGeometry().getType()===ol.geom.GeometryType.CIRCLE;if(this.vertex_&&!this.edge_){if(b=c.getPixelFromCoordinate(k[0]),g=c.getPixelFromCoordinate(k[1]),b=ol.coordinate.squaredDistance(a,b),a=ol.coordinate.squaredDistance(a,g),g=Math.sqrt(Math.min(b,a)),g=g<=this.pixelTolerance_)d=!0,e=b>a?k[1]:k[0],h=c.getPixelFromCoordinate(e)}else this.edge_&&(e=g?ol.coordinate.closestOnCircle(b,f[0].feature.getGeometry()):ol.coordinate.closestOnSegment(b,k),h=c.getPixelFromCoordinate(e),
ol.coordinate.distance(a,h)<=this.pixelTolerance_&&(d=!0,this.vertex_&&!g&&(b=c.getPixelFromCoordinate(k[0]),g=c.getPixelFromCoordinate(k[1]),b=ol.coordinate.squaredDistance(h,b),a=ol.coordinate.squaredDistance(h,g),g=Math.sqrt(Math.min(b,a)),g=g<=this.pixelTolerance_)))&&(e=b>a?k[1]:k[0],h=c.getPixelFromCoordinate(e));d&&(h=[Math.round(h[0]),Math.round(h[1])])}return{snapped:d,vertex:e,vertexPixel:h}};
ol.interaction.Snap.prototype.updateFeature_=function(a){this.removeFeature(a,!1);this.addFeature(a,!1)};ol.interaction.Snap.prototype.writeCircleGeometry_=function(a,b){b=ol.geom.Polygon.fromCircle(b).getCoordinates()[0];var c;var d=0;for(c=b.length-1;d<c;++d){var e=b.slice(d,d+2);var f={feature:a,segment:e};this.rBush_.insert(ol.extent.boundingExtent(e),f)}};
ol.interaction.Snap.prototype.writeGeometryCollectionGeometry_=function(a,b){var c=b.getGeometriesArray();for(b=0;b<c.length;++b){var d=this.SEGMENT_WRITERS_[c[b].getType()];d&&d.call(this,a,c[b])}};ol.interaction.Snap.prototype.writeLineStringGeometry_=function(a,b){b=b.getCoordinates();var c;var d=0;for(c=b.length-1;d<c;++d){var e=b.slice(d,d+2);var f={feature:a,segment:e};this.rBush_.insert(ol.extent.boundingExtent(e),f)}};
ol.interaction.Snap.prototype.writeMultiLineStringGeometry_=function(a,b){b=b.getCoordinates();var c,d;var e=0;for(d=b.length;e<d;++e){var f=b[e];var g=0;for(c=f.length-1;g<c;++g){var h=f.slice(g,g+2);var k={feature:a,segment:h};this.rBush_.insert(ol.extent.boundingExtent(h),k)}}};ol.interaction.Snap.prototype.writeMultiPointGeometry_=function(a,b){var c=b.getCoordinates(),d;var e=0;for(d=c.length;e<d;++e){var f=c[e];f={feature:a,segment:[f,f]};this.rBush_.insert(b.getExtent(),f)}};
ol.interaction.Snap.prototype.writeMultiPolygonGeometry_=function(a,b){b=b.getCoordinates();var c,d,e;var f=0;for(e=b.length;f<e;++f){var g=b[f];var h=0;for(d=g.length;h<d;++h){var k=g[h];var l=0;for(c=k.length-1;l<c;++l){var m=k.slice(l,l+2);var n={feature:a,segment:m};this.rBush_.insert(ol.extent.boundingExtent(m),n)}}}};ol.interaction.Snap.prototype.writePointGeometry_=function(a,b){var c=b.getCoordinates();a={feature:a,segment:[c,c]};this.rBush_.insert(b.getExtent(),a)};
ol.interaction.Snap.prototype.writePolygonGeometry_=function(a,b){b=b.getCoordinates();var c,d;var e=0;for(d=b.length;e<d;++e){var f=b[e];var g=0;for(c=f.length-1;g<c;++g){var h=f.slice(g,g+2);var k={feature:a,segment:h};this.rBush_.insert(ol.extent.boundingExtent(h),k)}}};ol.interaction.Snap.handleEvent_=function(a){var b=this.snapTo(a.pixel,a.coordinate,a.map);b.snapped&&(a.coordinate=b.vertex.slice(0,2),a.pixel=b.vertexPixel);return ol.interaction.Pointer.handleEvent.call(this,a)};
ol.interaction.Snap.handleUpEvent_=function(a){a=ol.obj.getValues(this.pendingFeatures_);a.length&&(a.forEach(this.updateFeature_,this),this.pendingFeatures_={});return!1};ol.interaction.Snap.sortByDistance=function(a,b){return ol.coordinate.squaredDistanceToSegment(this.pixelCoordinate_,a.segment)-ol.coordinate.squaredDistanceToSegment(this.pixelCoordinate_,b.segment)};ol.interaction.TranslateEventType={TRANSLATESTART:"translatestart",TRANSLATING:"translating",TRANSLATEEND:"translateend"};ol.interaction.Translate=function(a){ol.interaction.Pointer.call(this,{handleDownEvent:ol.interaction.Translate.handleDownEvent_,handleDragEvent:ol.interaction.Translate.handleDragEvent_,handleMoveEvent:ol.interaction.Translate.handleMoveEvent_,handleUpEvent:ol.interaction.Translate.handleUpEvent_});a=a?a:{};this.lastCoordinate_=null;this.features_=void 0!==a.features?a.features:null;if(a.layers)if("function"===typeof a.layers)var b=a.layers;else{var c=a.layers;b=function(a){return ol.array.includes(c,
a)}}else b=ol.functions.TRUE;this.layerFilter_=b;this.hitTolerance_=a.hitTolerance?a.hitTolerance:0;this.lastFeature_=null;ol.events.listen(this,ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE),this.handleActiveChanged_,this)};ol.inherits(ol.interaction.Translate,ol.interaction.Pointer);
ol.interaction.Translate.handleDownEvent_=function(a){this.lastFeature_=this.featuresAtPixel_(a.pixel,a.map);if(!this.lastCoordinate_&&this.lastFeature_){this.lastCoordinate_=a.coordinate;ol.interaction.Translate.handleMoveEvent_.call(this,a);var b=this.features_||new ol.Collection([this.lastFeature_]);this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATESTART,b,a.coordinate));return!0}return!1};
ol.interaction.Translate.handleUpEvent_=function(a){if(this.lastCoordinate_){this.lastCoordinate_=null;ol.interaction.Translate.handleMoveEvent_.call(this,a);var b=this.features_||new ol.Collection([this.lastFeature_]);this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATEEND,b,a.coordinate));return!0}return!1};
ol.interaction.Translate.handleDragEvent_=function(a){if(this.lastCoordinate_){a=a.coordinate;var b=a[0]-this.lastCoordinate_[0],c=a[1]-this.lastCoordinate_[1],d=this.features_||new ol.Collection([this.lastFeature_]);d.forEach(function(a){var d=a.getGeometry();d.translate(b,c);a.setGeometry(d)});this.lastCoordinate_=a;this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATING,d,a))}};
ol.interaction.Translate.handleMoveEvent_=function(a){var b=a.map.getViewport();this.featuresAtPixel_(a.pixel,a.map)?(b.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),b.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):b.classList.remove("ol-grab","ol-grabbing")};
ol.interaction.Translate.prototype.featuresAtPixel_=function(a,b){return b.forEachFeatureAtPixel(a,function(a){if(!this.features_||ol.array.includes(this.features_.getArray(),a))return a}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})};ol.interaction.Translate.prototype.getHitTolerance=function(){return this.hitTolerance_};ol.interaction.Translate.prototype.setHitTolerance=function(a){this.hitTolerance_=a};
ol.interaction.Translate.prototype.setMap=function(a){var b=this.getMap();ol.interaction.Pointer.prototype.setMap.call(this,a);this.updateState_(b)};ol.interaction.Translate.prototype.handleActiveChanged_=function(){this.updateState_(null)};ol.interaction.Translate.prototype.updateState_=function(a){var b=this.getMap(),c=this.getActive();b&&c||(b=b||a)&&b.getViewport().classList.remove("ol-grab","ol-grabbing")};
ol.interaction.Translate.Event=function(a,b,c){ol.events.Event.call(this,a);this.features=b;this.coordinate=c};ol.inherits(ol.interaction.Translate.Event,ol.events.Event);ol.layer.Heatmap=function(a){a=a?a:{};var b=ol.obj.assign({},a);delete b.gradient;delete b.radius;delete b.blur;delete b.shadow;delete b.weight;ol.layer.Vector.call(this,b);this.gradient_=null;this.shadow_=void 0!==a.shadow?a.shadow:250;this.circleImage_=void 0;this.styleCache_=null;ol.events.listen(this,ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.GRADIENT),this.handleGradientChanged_,this);this.setGradient(a.gradient?a.gradient:ol.layer.Heatmap.DEFAULT_GRADIENT);this.setBlur(void 0!==
a.blur?a.blur:15);this.setRadius(void 0!==a.radius?a.radius:8);ol.events.listen(this,ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.BLUR),this.handleStyleChanged_,this);ol.events.listen(this,ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.RADIUS),this.handleStyleChanged_,this);this.handleStyleChanged_();var c=a.weight?a.weight:"weight";var d="string"===typeof c?function(a){return a.get(c)}:c;this.setStyle(function(a,b){a=d(a);a=void 0!==a?ol.math.clamp(a,0,1):1;b=255*a|0;var c=this.styleCache_[b];
c||(c=[new ol.style.Style({image:new ol.style.Icon({opacity:a,src:this.circleImage_})})],this.styleCache_[b]=c);return c}.bind(this));this.setRenderOrder(null);ol.events.listen(this,ol.render.EventType.RENDER,this.handleRender_,this)};ol.inherits(ol.layer.Heatmap,ol.layer.Vector);ol.layer.Heatmap.DEFAULT_GRADIENT=["#00f","#0ff","#0f0","#ff0","#f00"];
ol.layer.Heatmap.createGradient_=function(a){for(var b=ol.dom.createCanvasContext2D(1,256),c=b.createLinearGradient(0,0,1,256),d=1/(a.length-1),e=0,f=a.length;e<f;++e)c.addColorStop(e*d,a[e]);b.fillStyle=c;b.fillRect(0,0,1,256);return b.getImageData(0,0,1,256).data};
ol.layer.Heatmap.prototype.createCircle_=function(){var a=this.getRadius(),b=this.getBlur(),c=a+b+1,d=2*c;d=ol.dom.createCanvasContext2D(d,d);d.shadowOffsetX=d.shadowOffsetY=this.shadow_;d.shadowBlur=b;d.shadowColor="#000";d.beginPath();b=c-this.shadow_;d.arc(b,b,a,0,2*Math.PI,!0);d.fill();return d.canvas.toDataURL()};ol.layer.Heatmap.prototype.getBlur=function(){return this.get(ol.layer.Heatmap.Property_.BLUR)};ol.layer.Heatmap.prototype.getGradient=function(){return this.get(ol.layer.Heatmap.Property_.GRADIENT)};
ol.layer.Heatmap.prototype.getRadius=function(){return this.get(ol.layer.Heatmap.Property_.RADIUS)};ol.layer.Heatmap.prototype.handleGradientChanged_=function(){this.gradient_=ol.layer.Heatmap.createGradient_(this.getGradient())};ol.layer.Heatmap.prototype.handleStyleChanged_=function(){this.circleImage_=this.createCircle_();this.styleCache_=Array(256);this.changed()};
ol.layer.Heatmap.prototype.handleRender_=function(a){a=a.context;var b=a.canvas;b=a.getImageData(0,0,b.width,b.height);var c=b.data,d,e;var f=0;for(d=c.length;f<d;f+=4)if(e=4*c[f+3])c[f]=this.gradient_[e],c[f+1]=this.gradient_[e+1],c[f+2]=this.gradient_[e+2];a.putImageData(b,0,0)};ol.layer.Heatmap.prototype.setBlur=function(a){this.set(ol.layer.Heatmap.Property_.BLUR,a)};ol.layer.Heatmap.prototype.setGradient=function(a){this.set(ol.layer.Heatmap.Property_.GRADIENT,a)};
ol.layer.Heatmap.prototype.setRadius=function(a){this.set(ol.layer.Heatmap.Property_.RADIUS,a)};ol.layer.Heatmap.Property_={BLUR:"blur",GRADIENT:"gradient",RADIUS:"radius"};ol.layer.Image=function(a){ol.layer.Layer.call(this,a?a:{});this.type=ol.LayerType.IMAGE};ol.inherits(ol.layer.Image,ol.layer.Layer);ol.layer.TileProperty={PRELOAD:"preload",USE_INTERIM_TILES_ON_ERROR:"useInterimTilesOnError"};ol.layer.Tile=function(a){a=a?a:{};var b=ol.obj.assign({},a);delete b.preload;delete b.useInterimTilesOnError;ol.layer.Layer.call(this,b);this.setPreload(void 0!==a.preload?a.preload:0);this.setUseInterimTilesOnError(void 0!==a.useInterimTilesOnError?a.useInterimTilesOnError:!0);this.type=ol.LayerType.TILE};ol.inherits(ol.layer.Tile,ol.layer.Layer);ol.layer.Tile.prototype.getPreload=function(){return this.get(ol.layer.TileProperty.PRELOAD)};
ol.layer.Tile.prototype.setPreload=function(a){this.set(ol.layer.TileProperty.PRELOAD,a)};ol.layer.Tile.prototype.getUseInterimTilesOnError=function(){return this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR)};ol.layer.Tile.prototype.setUseInterimTilesOnError=function(a){this.set(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR,a)};ol.layer.VectorTile=function(a){a=a?a:{};var b=a.renderMode||ol.layer.VectorTileRenderType.HYBRID;ol.asserts.assert(void 0==b||b==ol.layer.VectorTileRenderType.IMAGE||b==ol.layer.VectorTileRenderType.HYBRID||b==ol.layer.VectorTileRenderType.VECTOR,28);a.declutter&&b==ol.layer.VectorTileRenderType.IMAGE&&(b=ol.layer.VectorTileRenderType.HYBRID);a.renderMode=b;b=ol.obj.assign({},a);delete b.preload;delete b.useInterimTilesOnError;ol.layer.Vector.call(this,b);this.setPreload(a.preload?a.preload:0);this.setUseInterimTilesOnError(a.useInterimTilesOnError?
a.useInterimTilesOnError:!0);this.type=ol.LayerType.VECTOR_TILE};ol.inherits(ol.layer.VectorTile,ol.layer.Vector);ol.layer.VectorTile.prototype.getPreload=function(){return this.get(ol.layer.TileProperty.PRELOAD)};ol.layer.VectorTile.prototype.getUseInterimTilesOnError=function(){return this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR)};ol.layer.VectorTile.prototype.setPreload=function(a){this.set(ol.layer.TileProperty.PRELOAD,a)};
ol.layer.VectorTile.prototype.setUseInterimTilesOnError=function(a){this.set(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR,a)};ol.proj.common={};ol.proj.common.add=ol.proj.addCommon;ol.render.toContext=function(a,b){var c=a.canvas,d=b?b:{};b=d.pixelRatio||ol.has.DEVICE_PIXEL_RATIO;if(d=d.size)c.width=d[0]*b,c.height=d[1]*b,c.style.width=d[0]+"px",c.style.height=d[1]+"px";c=[0,0,c.width,c.height];d=ol.transform.scale(ol.transform.create(),b,b);return new ol.render.canvas.Immediate(a,b,c,d,0)};ol.TileUrlFunction={};ol.TileUrlFunction.createFromTemplate=function(a,b){var c=/\{z\}/g,d=/\{x\}/g,e=/\{y\}/g,f=/\{-y\}/g;return function(g,h,k){if(g)return a.replace(c,g[0].toString()).replace(d,g[1].toString()).replace(e,function(){return(-g[2]-1).toString()}).replace(f,function(){var a=b.getFullTileRange(g[0]);ol.asserts.assert(a,55);return(a.getHeight()+g[2]).toString()})}};
ol.TileUrlFunction.createFromTemplates=function(a,b){for(var c=a.length,d=Array(c),e=0;e<c;++e)d[e]=ol.TileUrlFunction.createFromTemplate(a[e],b);return ol.TileUrlFunction.createFromTileUrlFunctions(d)};ol.TileUrlFunction.createFromTileUrlFunctions=function(a){return 1===a.length?a[0]:function(b,c,d){if(b){var e=ol.tilecoord.hash(b);e=ol.math.modulo(e,a.length);return a[e](b,c,d)}}};ol.TileUrlFunction.nullTileUrlFunction=function(a,b,c){};
ol.TileUrlFunction.expandUrl=function(a){var b=[],c=/\{([a-z])-([a-z])\}/.exec(a);if(c){for(var d=c[1].charCodeAt(0),e=c[2].charCodeAt(0);d<=e;++d)b.push(a.replace(c[0],String.fromCharCode(d)));return b}if(c=c=/\{(\d+)-(\d+)\}/.exec(a)){e=parseInt(c[2],10);for(d=parseInt(c[1],10);d<=e;d++)b.push(a.replace(c[0],d.toString()));return b}b.push(a);return b};ol.net={};ol.net.jsonp=function(a,b,c,d){function e(){delete window[g];f.parentNode.removeChild(f)}var f=document.createElement("script"),g="olc_"+ol.getUid(b);f.async=!0;f.src=a+(-1==a.indexOf("?")?"?":"&")+(d||"callback")+"="+g;var h=setTimeout(function(){e();c&&c()},1E4);window[g]=function(a){clearTimeout(h);e();b(a)};document.getElementsByTagName("head")[0].appendChild(f)};ol.TileCache=function(a){ol.structs.LRUCache.call(this,a)};ol.inherits(ol.TileCache,ol.structs.LRUCache);ol.TileCache.prototype.expireCache=function(a){for(var b,c;this.canExpireCache()&&!(b=this.peekLast(),c=b.tileCoord[0].toString(),c in a&&a[c].contains(b.tileCoord));)this.pop().dispose()};
ol.TileCache.prototype.pruneExceptNewestZ=function(){if(0!==this.getCount()){var a=this.peekFirstKey(),b=ol.tilecoord.fromKey(a)[0];this.forEach(function(a){a.tileCoord[0]!==b&&(this.remove(ol.tilecoord.getKey(a.tileCoord)),a.dispose())},this)}};ol.reproj={};ol.reproj.calculateSourceResolution=function(a,b,c,d){var e=ol.proj.transform(c,b,a);c=ol.proj.getPointResolution(b,d,c);b=b.getMetersPerUnit();void 0!==b&&(c*=b);b=a.getMetersPerUnit();void 0!==b&&(c/=b);b=a.getExtent();if(!b||ol.extent.containsCoordinate(b,e))a=ol.proj.getPointResolution(a,c,e)/c,isFinite(a)&&0<a&&(c/=a);return c};ol.reproj.enlargeClipPoint_=function(a,b,c,d){a=c-a;b=d-b;var e=Math.sqrt(a*a+b*b);return[Math.round(c+a/e),Math.round(d+b/e)]};
ol.reproj.render=function(a,b,c,d,e,f,g,h,k,l,m){var n=ol.dom.createCanvasContext2D(Math.round(c*a),Math.round(c*b));if(0===k.length)return n.canvas;n.scale(c,c);var p=ol.extent.createEmpty();k.forEach(function(a,b,c){ol.extent.extend(p,a.extent)});a=ol.extent.getWidth(p);b=ol.extent.getHeight(p);var q=ol.dom.createCanvasContext2D(Math.round(c*a/d),Math.round(c*b/d)),r=c/d;k.forEach(function(a,b,c){b=a.extent[0]-p[0];c=-(a.extent[3]-p[3]);var d=ol.extent.getWidth(a.extent),e=ol.extent.getHeight(a.extent);
q.drawImage(a.image,l,l,a.image.width-2*l,a.image.height-2*l,b*r,c*r,d*r,e*r)});var u=ol.extent.getTopLeft(g);h.getTriangles().forEach(function(a,b,e){var g=a.source,h=a.target,k=g[1][0],l=g[1][1],m=g[2][0],r=g[2][1];a=(h[0][0]-u[0])/f;b=-(h[0][1]-u[1])/f;var t=(h[1][0]-u[0])/f,v=-(h[1][1]-u[1])/f;e=(h[2][0]-u[0])/f;var w=-(h[2][1]-u[1])/f;h=g[0][0];g=g[0][1];k-=h;l-=g;m-=h;r-=g;if(k=ol.math.solveLinearSystem([[k,l,0,0,t-a],[m,r,0,0,e-a],[0,0,k,l,v-b],[0,0,m,r,w-b]]))n.save(),n.beginPath(),m=(a+t+
e)/3,r=(b+v+w)/3,l=ol.reproj.enlargeClipPoint_(m,r,a,b),t=ol.reproj.enlargeClipPoint_(m,r,t,v),e=ol.reproj.enlargeClipPoint_(m,r,e,w),n.moveTo(t[0],t[1]),n.lineTo(l[0],l[1]),n.lineTo(e[0],e[1]),n.clip(),n.transform(k[0],k[2],k[1],k[3],a,b),n.translate(p[0]-h,p[3]-g),n.scale(d/c,-d/c),n.drawImage(q.canvas,0,0),n.restore()});m&&(n.save(),n.strokeStyle="black",n.lineWidth=1,h.getTriangles().forEach(function(a,b,c){var d=a.target;a=(d[0][0]-u[0])/f;b=-(d[0][1]-u[1])/f;c=(d[1][0]-u[0])/f;var e=-(d[1][1]-
u[1])/f,g=(d[2][0]-u[0])/f;d=-(d[2][1]-u[1])/f;n.beginPath();n.moveTo(c,e);n.lineTo(a,b);n.lineTo(g,d);n.closePath();n.stroke()}),n.restore());return n.canvas};ol.reproj.Triangulation=function(a,b,c,d,e){this.sourceProj_=a;this.targetProj_=b;var f={},g=ol.proj.getTransform(this.targetProj_,this.sourceProj_);this.transformInv_=function(a){var b=a[0]+"/"+a[1];f[b]||(f[b]=g(a));return f[b]};this.maxSourceExtent_=d;this.errorThresholdSquared_=e*e;this.triangles_=[];this.wrapsXInSource_=!1;this.canWrapXInSource_=this.sourceProj_.canWrapX()&&!!d&&!!this.sourceProj_.getExtent()&&ol.extent.getWidth(d)==ol.extent.getWidth(this.sourceProj_.getExtent());this.sourceWorldWidth_=
this.sourceProj_.getExtent()?ol.extent.getWidth(this.sourceProj_.getExtent()):null;this.targetWorldWidth_=this.targetProj_.getExtent()?ol.extent.getWidth(this.targetProj_.getExtent()):null;a=ol.extent.getTopLeft(c);b=ol.extent.getTopRight(c);d=ol.extent.getBottomRight(c);c=ol.extent.getBottomLeft(c);e=this.transformInv_(a);var h=this.transformInv_(b),k=this.transformInv_(d),l=this.transformInv_(c);this.addQuad_(a,b,d,c,e,h,k,l,ol.RASTER_REPROJECTION_MAX_SUBDIVISION);if(this.wrapsXInSource_){var m=
Infinity;this.triangles_.forEach(function(a,b,c){m=Math.min(m,a.source[0][0],a.source[1][0],a.source[2][0])});this.triangles_.forEach(function(a){if(Math.max(a.source[0][0],a.source[1][0],a.source[2][0])-m>this.sourceWorldWidth_/2){var b=[[a.source[0][0],a.source[0][1]],[a.source[1][0],a.source[1][1]],[a.source[2][0],a.source[2][1]]];b[0][0]-m>this.sourceWorldWidth_/2&&(b[0][0]-=this.sourceWorldWidth_);b[1][0]-m>this.sourceWorldWidth_/2&&(b[1][0]-=this.sourceWorldWidth_);b[2][0]-m>this.sourceWorldWidth_/
2&&(b[2][0]-=this.sourceWorldWidth_);Math.max(b[0][0],b[1][0],b[2][0])-Math.min(b[0][0],b[1][0],b[2][0])<this.sourceWorldWidth_/2&&(a.source=b)}},this)}f={}};ol.reproj.Triangulation.prototype.addTriangle_=function(a,b,c,d,e,f){this.triangles_.push({source:[d,e,f],target:[a,b,c]})};
ol.reproj.Triangulation.prototype.addQuad_=function(a,b,c,d,e,f,g,h,k){var l=ol.extent.boundingExtent([e,f,g,h]),m=this.sourceWorldWidth_?ol.extent.getWidth(l)/this.sourceWorldWidth_:null,n=this.sourceWorldWidth_,p=this.sourceProj_.canWrapX()&&.5<m&&1>m,q=!1;if(0<k){if(this.targetProj_.isGlobal()&&this.targetWorldWidth_){var r=ol.extent.boundingExtent([a,b,c,d]);r=ol.extent.getWidth(r)/this.targetWorldWidth_;q|=r>ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH}!p&&this.sourceProj_.isGlobal()&&m&&(q|=m>
ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH)}if(q||!this.maxSourceExtent_||ol.extent.intersects(l,this.maxSourceExtent_)){if(!(q||isFinite(e[0])&&isFinite(e[1])&&isFinite(f[0])&&isFinite(f[1])&&isFinite(g[0])&&isFinite(g[1])&&isFinite(h[0])&&isFinite(h[1])))if(0<k)q=!0;else return;if(0<k&&(q||(l=this.transformInv_([(a[0]+c[0])/2,(a[1]+c[1])/2]),n=p?(ol.math.modulo(e[0],n)+ol.math.modulo(g[0],n))/2-ol.math.modulo(l[0],n):(e[0]+g[0])/2-l[0],l=(e[1]+g[1])/2-l[1],q=n*n+l*l>this.errorThresholdSquared_),
q)){Math.abs(a[0]-c[0])<=Math.abs(a[1]-c[1])?(p=[(b[0]+c[0])/2,(b[1]+c[1])/2],n=this.transformInv_(p),l=[(d[0]+a[0])/2,(d[1]+a[1])/2],m=this.transformInv_(l),this.addQuad_(a,b,p,l,e,f,n,m,k-1),this.addQuad_(l,p,c,d,m,n,g,h,k-1)):(p=[(a[0]+b[0])/2,(a[1]+b[1])/2],n=this.transformInv_(p),l=[(c[0]+d[0])/2,(c[1]+d[1])/2],m=this.transformInv_(l),this.addQuad_(a,p,l,d,e,n,m,h,k-1),this.addQuad_(p,b,c,l,n,f,g,m,k-1));return}if(p){if(!this.canWrapXInSource_)return;this.wrapsXInSource_=!0}this.addTriangle_(a,
c,d,e,g,h);this.addTriangle_(a,b,c,e,f,g)}};ol.reproj.Triangulation.prototype.calculateSourceExtent=function(){var a=ol.extent.createEmpty();this.triangles_.forEach(function(b,c,d){b=b.source;ol.extent.extendCoordinate(a,b[0]);ol.extent.extendCoordinate(a,b[1]);ol.extent.extendCoordinate(a,b[2])});return a};ol.reproj.Triangulation.prototype.getTriangles=function(){return this.triangles_};ol.reproj.Tile=function(a,b,c,d,e,f,g,h,k,l,m){ol.Tile.call(this,e,ol.TileState.IDLE);this.renderEdges_=void 0!==m?m:!1;this.pixelRatio_=g;this.gutter_=h;this.canvas_=null;this.sourceTileGrid_=b;this.targetTileGrid_=d;this.wrappedTileCoord_=f?f:e;this.sourceTiles_=[];this.sourcesListenerKeys_=null;this.sourceZ_=0;f=d.getTileCoordExtent(this.wrappedTileCoord_);h=this.targetTileGrid_.getExtent();e=this.sourceTileGrid_.getExtent();f=h?ol.extent.getIntersection(f,h):f;if(0===ol.extent.getArea(f))this.state=
ol.TileState.EMPTY;else if((h=a.getExtent())&&(e=e?ol.extent.getIntersection(e,h):h),d=d.getResolution(this.wrappedTileCoord_[0]),h=ol.extent.getCenter(f),d=ol.reproj.calculateSourceResolution(a,c,h,d),!isFinite(d)||0>=d)this.state=ol.TileState.EMPTY;else if(this.triangulation_=new ol.reproj.Triangulation(a,c,f,e,d*(void 0!==l?l:ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD)),0===this.triangulation_.getTriangles().length)this.state=ol.TileState.EMPTY;else if(this.sourceZ_=b.getZForResolution(d),
c=this.triangulation_.calculateSourceExtent(),e&&(a.canWrapX()?(c[1]=ol.math.clamp(c[1],e[1],e[3]),c[3]=ol.math.clamp(c[3],e[1],e[3])):c=ol.extent.getIntersection(c,e)),ol.extent.getArea(c)){a=b.getTileRangeForExtentAndZ(c,this.sourceZ_);for(b=a.minX;b<=a.maxX;b++)for(c=a.minY;c<=a.maxY;c++)(l=k(this.sourceZ_,b,c,g))&&this.sourceTiles_.push(l);0===this.sourceTiles_.length&&(this.state=ol.TileState.EMPTY)}else this.state=ol.TileState.EMPTY};ol.inherits(ol.reproj.Tile,ol.Tile);
ol.reproj.Tile.prototype.disposeInternal=function(){this.state==ol.TileState.LOADING&&this.unlistenSources_();ol.Tile.prototype.disposeInternal.call(this)};ol.reproj.Tile.prototype.getImage=function(){return this.canvas_};
ol.reproj.Tile.prototype.reproject_=function(){var a=[];this.sourceTiles_.forEach(function(b,c,d){b&&b.getState()==ol.TileState.LOADED&&a.push({extent:this.sourceTileGrid_.getTileCoordExtent(b.tileCoord),image:b.getImage()})},this);this.sourceTiles_.length=0;if(0===a.length)this.state=ol.TileState.ERROR;else{var b=this.wrappedTileCoord_[0],c=this.targetTileGrid_.getTileSize(b),d="number"===typeof c?c:c[0];c="number"===typeof c?c:c[1];b=this.targetTileGrid_.getResolution(b);var e=this.sourceTileGrid_.getResolution(this.sourceZ_),
f=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=ol.reproj.render(d,c,this.pixelRatio_,e,this.sourceTileGrid_.getExtent(),b,f,this.triangulation_,a,this.gutter_,this.renderEdges_);this.state=ol.TileState.LOADED}this.changed()};
ol.reproj.Tile.prototype.load=function(){if(this.state==ol.TileState.IDLE){this.state=ol.TileState.LOADING;this.changed();var a=0;this.sourcesListenerKeys_=[];this.sourceTiles_.forEach(function(b,c,d){c=b.getState();if(c==ol.TileState.IDLE||c==ol.TileState.LOADING){a++;var e=ol.events.listen(b,ol.events.EventType.CHANGE,function(c){c=b.getState();if(c==ol.TileState.LOADED||c==ol.TileState.ERROR||c==ol.TileState.EMPTY)ol.events.unlistenByKey(e),a--,0===a&&(this.unlistenSources_(),this.reproject_())},
this);this.sourcesListenerKeys_.push(e)}},this);this.sourceTiles_.forEach(function(a,c,d){a.getState()==ol.TileState.IDLE&&a.load()});0===a&&setTimeout(this.reproject_.bind(this),0)}};ol.reproj.Tile.prototype.unlistenSources_=function(){this.sourcesListenerKeys_.forEach(ol.events.unlistenByKey);this.sourcesListenerKeys_=null};ol.source.Tile=function(a){ol.source.Source.call(this,{attributions:a.attributions,extent:a.extent,logo:a.logo,projection:a.projection,state:a.state,wrapX:a.wrapX});this.opaque_=void 0!==a.opaque?a.opaque:!1;this.tilePixelRatio_=void 0!==a.tilePixelRatio?a.tilePixelRatio:1;this.tileGrid=void 0!==a.tileGrid?a.tileGrid:null;this.tileCache=new ol.TileCache(a.cacheSize);this.tmpSize=[0,0];this.key_="";this.tileOptions={transition:a.transition}};ol.inherits(ol.source.Tile,ol.source.Source);
ol.source.Tile.prototype.canExpireCache=function(){return this.tileCache.canExpireCache()};ol.source.Tile.prototype.expireCache=function(a,b){(a=this.getTileCacheForProjection(a))&&a.expireCache(b)};
ol.source.Tile.prototype.forEachLoadedTile=function(a,b,c,d){a=this.getTileCacheForProjection(a);if(!a)return!1;for(var e=!0,f,g,h=c.minX;h<=c.maxX;++h)for(var k=c.minY;k<=c.maxY;++k)f=ol.tilecoord.getKeyZXY(b,h,k),g=!1,a.containsKey(f)&&(f=a.get(f),(g=f.getState()===ol.TileState.LOADED)&&(g=!1!==d(f))),g||(e=!1);return e};ol.source.Tile.prototype.getGutter=function(a){return 0};ol.source.Tile.prototype.getKey=function(){return this.key_};
ol.source.Tile.prototype.setKey=function(a){this.key_!==a&&(this.key_=a,this.changed())};ol.source.Tile.prototype.getOpaque=function(a){return this.opaque_};ol.source.Tile.prototype.getResolutions=function(){return this.tileGrid.getResolutions()};ol.source.Tile.prototype.getTile=function(a,b,c,d,e){};ol.source.Tile.prototype.getTileGrid=function(){return this.tileGrid};ol.source.Tile.prototype.getTileGridForProjection=function(a){return this.tileGrid?this.tileGrid:ol.tilegrid.getForProjection(a)};
ol.source.Tile.prototype.getTileCacheForProjection=function(a){var b=this.getProjection();return b&&!ol.proj.equivalent(b,a)?null:this.tileCache};ol.source.Tile.prototype.getTilePixelRatio=function(a){return this.tilePixelRatio_};ol.source.Tile.prototype.getTilePixelSize=function(a,b,c){c=this.getTileGridForProjection(c);b=this.getTilePixelRatio(b);a=ol.size.toSize(c.getTileSize(a),this.tmpSize);return 1==b?a:ol.size.scale(a,b,this.tmpSize)};
ol.source.Tile.prototype.getTileCoordForTileUrlFunction=function(a,b){b=void 0!==b?b:this.getProjection();var c=this.getTileGridForProjection(b);this.getWrapX()&&b.isGlobal()&&(a=ol.tilegrid.wrapX(c,a,b));return ol.tilecoord.withinExtentAndZ(a,c)?a:null};ol.source.Tile.prototype.refresh=function(){this.tileCache.clear();this.changed()};ol.source.Tile.prototype.useTile=ol.nullFunction;ol.source.Tile.Event=function(a,b){ol.events.Event.call(this,a);this.tile=b};ol.inherits(ol.source.Tile.Event,ol.events.Event);ol.source.TileEventType={TILELOADSTART:"tileloadstart",TILELOADEND:"tileloadend",TILELOADERROR:"tileloaderror"};ol.source.UrlTile=function(a){ol.source.Tile.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,extent:a.extent,logo:a.logo,opaque:a.opaque,projection:a.projection,state:a.state,tileGrid:a.tileGrid,tilePixelRatio:a.tilePixelRatio,wrapX:a.wrapX,transition:a.transition});this.tileLoadFunction=a.tileLoadFunction;this.tileUrlFunction=this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):ol.TileUrlFunction.nullTileUrlFunction;this.urls=null;a.urls?this.setUrls(a.urls):a.url&&this.setUrl(a.url);
a.tileUrlFunction&&this.setTileUrlFunction(a.tileUrlFunction);this.tileLoadingKeys_={}};ol.inherits(ol.source.UrlTile,ol.source.Tile);ol.source.UrlTile.prototype.getTileLoadFunction=function(){return this.tileLoadFunction};ol.source.UrlTile.prototype.getTileUrlFunction=function(){return this.tileUrlFunction};ol.source.UrlTile.prototype.getUrls=function(){return this.urls};
ol.source.UrlTile.prototype.handleTileChange=function(a){a=a.target;var b=ol.getUid(a),c=a.getState();if(c==ol.TileState.LOADING){this.tileLoadingKeys_[b]=!0;var d=ol.source.TileEventType.TILELOADSTART}else b in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[b],d=c==ol.TileState.ERROR?ol.source.TileEventType.TILELOADERROR:c==ol.TileState.LOADED||c==ol.TileState.ABORT?ol.source.TileEventType.TILELOADEND:void 0);void 0!=d&&this.dispatchEvent(new ol.source.Tile.Event(d,a))};
ol.source.UrlTile.prototype.setTileLoadFunction=function(a){this.tileCache.clear();this.tileLoadFunction=a;this.changed()};ol.source.UrlTile.prototype.setTileUrlFunction=function(a,b){this.tileUrlFunction=a;this.tileCache.pruneExceptNewestZ();"undefined"!==typeof b?this.setKey(b):this.changed()};
ol.source.UrlTile.prototype.setUrl=function(a){var b=this.urls=ol.TileUrlFunction.expandUrl(a);this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):ol.TileUrlFunction.createFromTemplates(b,this.tileGrid),a)};ol.source.UrlTile.prototype.setUrls=function(a){this.urls=a;var b=a.join("\n");this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):ol.TileUrlFunction.createFromTemplates(a,this.tileGrid),b)};
ol.source.UrlTile.prototype.useTile=function(a,b,c){a=ol.tilecoord.getKeyZXY(a,b,c);this.tileCache.containsKey(a)&&this.tileCache.get(a)};ol.source.TileImage=function(a){ol.source.UrlTile.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,extent:a.extent,logo:a.logo,opaque:a.opaque,projection:a.projection,state:a.state,tileGrid:a.tileGrid,tileLoadFunction:a.tileLoadFunction?a.tileLoadFunction:ol.source.TileImage.defaultTileLoadFunction,tilePixelRatio:a.tilePixelRatio,tileUrlFunction:a.tileUrlFunction,url:a.url,urls:a.urls,wrapX:a.wrapX,transition:a.transition});this.crossOrigin=void 0!==a.crossOrigin?a.crossOrigin:null;this.tileClass=
void 0!==a.tileClass?a.tileClass:ol.ImageTile;this.tileCacheForProjection={};this.tileGridForProjection={};this.reprojectionErrorThreshold_=a.reprojectionErrorThreshold;this.renderReprojectionEdges_=!1};ol.inherits(ol.source.TileImage,ol.source.UrlTile);
ol.source.TileImage.prototype.canExpireCache=function(){if(!ol.ENABLE_RASTER_REPROJECTION)return ol.source.UrlTile.prototype.canExpireCache.call(this);if(this.tileCache.canExpireCache())return!0;for(var a in this.tileCacheForProjection)if(this.tileCacheForProjection[a].canExpireCache())return!0;return!1};
ol.source.TileImage.prototype.expireCache=function(a,b){if(ol.ENABLE_RASTER_REPROJECTION){a=this.getTileCacheForProjection(a);this.tileCache.expireCache(this.tileCache==a?b:{});for(var c in this.tileCacheForProjection){var d=this.tileCacheForProjection[c];d.expireCache(d==a?b:{})}}else ol.source.UrlTile.prototype.expireCache.call(this,a,b)};
ol.source.TileImage.prototype.getGutter=function(a){return ol.ENABLE_RASTER_REPROJECTION&&this.getProjection()&&a&&!ol.proj.equivalent(this.getProjection(),a)?0:this.getGutterInternal()};ol.source.TileImage.prototype.getGutterInternal=function(){return 0};ol.source.TileImage.prototype.getOpaque=function(a){return ol.ENABLE_RASTER_REPROJECTION&&this.getProjection()&&a&&!ol.proj.equivalent(this.getProjection(),a)?!1:ol.source.UrlTile.prototype.getOpaque.call(this,a)};
ol.source.TileImage.prototype.getTileGridForProjection=function(a){if(!ol.ENABLE_RASTER_REPROJECTION)return ol.source.UrlTile.prototype.getTileGridForProjection.call(this,a);var b=this.getProjection();return!this.tileGrid||b&&!ol.proj.equivalent(b,a)?(b=ol.getUid(a).toString(),b in this.tileGridForProjection||(this.tileGridForProjection[b]=ol.tilegrid.getForProjection(a)),this.tileGridForProjection[b]):this.tileGrid};
ol.source.TileImage.prototype.getTileCacheForProjection=function(a){if(!ol.ENABLE_RASTER_REPROJECTION)return ol.source.UrlTile.prototype.getTileCacheForProjection.call(this,a);var b=this.getProjection();if(!b||ol.proj.equivalent(b,a))return this.tileCache;a=ol.getUid(a).toString();a in this.tileCacheForProjection||(this.tileCacheForProjection[a]=new ol.TileCache(this.tileCache.highWaterMark));return this.tileCacheForProjection[a]};
ol.source.TileImage.prototype.createTile_=function(a,b,c,d,e,f){a=[a,b,c];d=(b=this.getTileCoordForTileUrlFunction(a,e))?this.tileUrlFunction(b,d,e):void 0;d=new this.tileClass(a,void 0!==d?ol.TileState.IDLE:ol.TileState.EMPTY,void 0!==d?d:"",this.crossOrigin,this.tileLoadFunction,this.tileOptions);d.key=f;ol.events.listen(d,ol.events.EventType.CHANGE,this.handleTileChange,this);return d};
ol.source.TileImage.prototype.getTile=function(a,b,c,d,e){var f=this.getProjection();if(ol.ENABLE_RASTER_REPROJECTION&&f&&e&&!ol.proj.equivalent(f,e)){var g=this.getTileCacheForProjection(e);c=[a,b,c];var h;a=ol.tilecoord.getKey(c);g.containsKey(a)&&(h=g.get(a));b=this.getKey();if(h&&h.key==b)return h;var k=this.getTileGridForProjection(f),l=this.getTileGridForProjection(e),m=this.getTileCoordForTileUrlFunction(c,e);d=new ol.reproj.Tile(f,k,e,l,c,m,this.getTilePixelRatio(d),this.getGutterInternal(),
function(a,b,c,d){return this.getTileInternal(a,b,c,d,f)}.bind(this),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_);d.key=b;h?(d.interimTile=h,d.refreshInterimChain(),g.replace(a,d)):g.set(a,d);return d}return this.getTileInternal(a,b,c,d,f||e)};
ol.source.TileImage.prototype.getTileInternal=function(a,b,c,d,e){var f=ol.tilecoord.getKeyZXY(a,b,c),g=this.getKey();if(this.tileCache.containsKey(f)){var h=this.tileCache.get(f);if(h.key!=g){var k=h;h=this.createTile_(a,b,c,d,e,g);k.getState()==ol.TileState.IDLE?h.interimTile=k.interimTile:h.interimTile=k;h.refreshInterimChain();this.tileCache.replace(f,h)}}else h=this.createTile_(a,b,c,d,e,g),this.tileCache.set(f,h);return h};
ol.source.TileImage.prototype.setRenderReprojectionEdges=function(a){if(ol.ENABLE_RASTER_REPROJECTION&&this.renderReprojectionEdges_!=a){this.renderReprojectionEdges_=a;for(var b in this.tileCacheForProjection)this.tileCacheForProjection[b].clear();this.changed()}};ol.source.TileImage.prototype.setTileGridForProjection=function(a,b){ol.ENABLE_RASTER_REPROJECTION&&(a=ol.proj.get(a))&&(a=ol.getUid(a).toString(),a in this.tileGridForProjection||(this.tileGridForProjection[a]=b))};
ol.source.TileImage.defaultTileLoadFunction=function(a,b){a.getImage().src=b};ol.source.BingMaps=function(a){this.hidpi_=void 0!==a.hidpi?a.hidpi:!1;ol.source.TileImage.call(this,{cacheSize:a.cacheSize,crossOrigin:"anonymous",opaque:!0,projection:ol.proj.get("EPSG:3857"),reprojectionErrorThreshold:a.reprojectionErrorThreshold,state:ol.source.State.LOADING,tileLoadFunction:a.tileLoadFunction,tilePixelRatio:this.hidpi_?2:1,wrapX:void 0!==a.wrapX?a.wrapX:!0,transition:a.transition});this.culture_=void 0!==a.culture?a.culture:"en-us";this.maxZoom_=void 0!==a.maxZoom?a.maxZoom:
-1;this.apiKey_=a.key;this.imagerySet_=a.imagerySet;ol.net.jsonp("https://dev.virtualearth.net/REST/v1/Imagery/Metadata/"+this.imagerySet_+"?uriScheme=https&include=ImageryProviders&key="+this.apiKey_+"&c="+this.culture_,this.handleImageryMetadataResponse.bind(this),void 0,"jsonp")};ol.inherits(ol.source.BingMaps,ol.source.TileImage);ol.source.BingMaps.TOS_ATTRIBUTION='<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html">Terms of Use</a>';
ol.source.BingMaps.prototype.getApiKey=function(){return this.apiKey_};ol.source.BingMaps.prototype.getImagerySet=function(){return this.imagerySet_};
ol.source.BingMaps.prototype.handleImageryMetadataResponse=function(a){if(200!=a.statusCode||"OK"!=a.statusDescription||"ValidCredentials"!=a.authenticationResultCode||1!=a.resourceSets.length||1!=a.resourceSets[0].resources.length)this.setState(ol.source.State.ERROR);else{var b=a.brandLogoUri;-1==b.indexOf("https")&&(b=b.replace("http","https"));var c=a.resourceSets[0].resources[0];a=-1==this.maxZoom_?c.zoomMax:this.maxZoom_;var d=this.getProjection();d=ol.tilegrid.extentFromProjection(d);this.tileGrid=
ol.tilegrid.createXYZ({extent:d,minZoom:c.zoomMin,maxZoom:a,tileSize:(c.imageWidth==c.imageHeight?c.imageWidth:[c.imageWidth,c.imageHeight])/(this.hidpi_?2:1)});var e=this.culture_,f=this.hidpi_;this.tileUrlFunction=ol.TileUrlFunction.createFromTileUrlFunctions(c.imageUrlSubdomains.map(function(a){var b=[0,0,0],d=c.imageUrl.replace("{subdomain}",a).replace("{culture}",e);return function(a,c,e){if(a)return ol.tilecoord.createOrUpdate(a[0],a[1],-a[2]-1,b),a=d,f&&(a+="&dpi=d1&device=mobile"),a.replace("{quadkey}",
ol.tilecoord.quadKey(b))}}));if(c.imageryProviders){var g=ol.proj.getTransformFromProjections(ol.proj.get("EPSG:4326"),this.getProjection());this.setAttributions(function(a){var b=[],d=a.viewState.zoom;c.imageryProviders.map(function(c){for(var e=!1,f=c.coverageAreas,h=0,k=f.length;h<k;++h){var l=f[h];if(d>=l.zoomMin&&d<=l.zoomMax&&(l=l.bbox,l=ol.extent.applyTransform([l[1],l[0],l[3],l[2]],g),ol.extent.intersects(l,a.extent))){e=!0;break}}e&&b.push(c.attribution)});b.push(ol.source.BingMaps.TOS_ATTRIBUTION);
return b})}this.setLogo(b);this.setState(ol.source.State.READY)}};ol.source.XYZ=function(a){a=a||{};var b=void 0!==a.projection?a.projection:"EPSG:3857",c=void 0!==a.tileGrid?a.tileGrid:ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(b),maxZoom:a.maxZoom,minZoom:a.minZoom,tileSize:a.tileSize});ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,opaque:a.opaque,projection:b,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileGrid:c,tileLoadFunction:a.tileLoadFunction,tilePixelRatio:a.tilePixelRatio,
tileUrlFunction:a.tileUrlFunction,url:a.url,urls:a.urls,wrapX:void 0!==a.wrapX?a.wrapX:!0,transition:a.transition})};ol.inherits(ol.source.XYZ,ol.source.TileImage);ol.source.CartoDB=function(a){this.account_=a.account;this.mapId_=a.map||"";this.config_=a.config||{};this.templateCache_={};ol.source.XYZ.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,maxZoom:void 0!==a.maxZoom?a.maxZoom:18,minZoom:a.minZoom,projection:a.projection,state:ol.source.State.LOADING,wrapX:a.wrapX});this.initializeMap_()};ol.inherits(ol.source.CartoDB,ol.source.XYZ);ol.source.CartoDB.prototype.getConfig=function(){return this.config_};
ol.source.CartoDB.prototype.updateConfig=function(a){ol.obj.assign(this.config_,a);this.initializeMap_()};ol.source.CartoDB.prototype.setConfig=function(a){this.config_=a||{};this.initializeMap_()};
ol.source.CartoDB.prototype.initializeMap_=function(){var a=JSON.stringify(this.config_);if(this.templateCache_[a])this.applyTemplate_(this.templateCache_[a]);else{var b="https://"+this.account_+".carto.com/api/v1/map";this.mapId_&&(b+="/named/"+this.mapId_);var c=new XMLHttpRequest;c.addEventListener("load",this.handleInitResponse_.bind(this,a));c.addEventListener("error",this.handleInitError_.bind(this));c.open("POST",b);c.setRequestHeader("Content-type","application/json");c.send(JSON.stringify(this.config_))}};
ol.source.CartoDB.prototype.handleInitResponse_=function(a,b){b=b.target;if(!b.status||200<=b.status&&300>b.status){try{var c=JSON.parse(b.responseText)}catch(d){this.setState(ol.source.State.ERROR);return}this.applyTemplate_(c);this.templateCache_[a]=c;this.setState(ol.source.State.READY)}else this.setState(ol.source.State.ERROR)};ol.source.CartoDB.prototype.handleInitError_=function(a){this.setState(ol.source.State.ERROR)};
ol.source.CartoDB.prototype.applyTemplate_=function(a){this.setUrl("https://"+a.cdn_url.https+"/"+this.account_+"/api/v1/map/"+a.layergroupid+"/{z}/{x}/{y}.png")};ol.source.Cluster=function(a){ol.source.Vector.call(this,{attributions:a.attributions,extent:a.extent,logo:a.logo,projection:a.projection,wrapX:a.wrapX});this.resolution=void 0;this.distance=void 0!==a.distance?a.distance:20;this.features=[];this.geometryFunction=a.geometryFunction||function(a){a=a.getGeometry();ol.asserts.assert(a instanceof ol.geom.Point,10);return a};this.source=a.source;this.source.on(ol.events.EventType.CHANGE,ol.source.Cluster.prototype.refresh,this)};
ol.inherits(ol.source.Cluster,ol.source.Vector);ol.source.Cluster.prototype.getDistance=function(){return this.distance};ol.source.Cluster.prototype.getSource=function(){return this.source};ol.source.Cluster.prototype.loadFeatures=function(a,b,c){this.source.loadFeatures(a,b,c);b!==this.resolution&&(this.clear(),this.resolution=b,this.cluster(),this.addFeatures(this.features))};ol.source.Cluster.prototype.setDistance=function(a){this.distance=a;this.refresh()};
ol.source.Cluster.prototype.refresh=function(){this.clear();this.cluster();this.addFeatures(this.features);ol.source.Vector.prototype.refresh.call(this)};
ol.source.Cluster.prototype.cluster=function(){if(void 0!==this.resolution){this.features.length=0;for(var a=ol.extent.createEmpty(),b=this.distance*this.resolution,c=this.source.getFeatures(),d={},e=0,f=c.length;e<f;e++){var g=c[e];ol.getUid(g).toString()in d||!(g=this.geometryFunction(g))||(g=g.getCoordinates(),ol.extent.createOrUpdateFromCoordinate(g,a),ol.extent.buffer(a,b,a),g=this.source.getFeaturesInExtent(a),g=g.filter(function(a){a=ol.getUid(a).toString();return a in d?!1:d[a]=!0}),this.features.push(this.createCluster(g)))}}};
ol.source.Cluster.prototype.createCluster=function(a){for(var b=[0,0],c=a.length-1;0<=c;--c){var d=this.geometryFunction(a[c]);d?ol.coordinate.add(b,d.getCoordinates()):a.splice(c,1)}ol.coordinate.scale(b,1/a.length);b=new ol.Feature(new ol.geom.Point(b));b.set("features",a);return b};ol.reproj.Image=function(a,b,c,d,e,f){this.targetProj_=b;this.maxSourceExtent_=a.getExtent();var g=b.getExtent();g=g?ol.extent.getIntersection(c,g):c;var h=ol.extent.getCenter(g);h=ol.reproj.calculateSourceResolution(a,b,h,d);this.triangulation_=new ol.reproj.Triangulation(a,b,g,this.maxSourceExtent_,h*ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD);this.targetResolution_=d;this.targetExtent_=c;a=this.triangulation_.calculateSourceExtent();this.sourcePixelRatio_=(this.sourceImage_=f(a,h,e))?this.sourceImage_.getPixelRatio():
1;this.sourceListenerKey_=this.canvas_=null;e=ol.ImageState.LOADED;this.sourceImage_&&(e=ol.ImageState.IDLE);ol.ImageBase.call(this,c,d,this.sourcePixelRatio_,e)};ol.inherits(ol.reproj.Image,ol.ImageBase);ol.reproj.Image.prototype.disposeInternal=function(){this.state==ol.ImageState.LOADING&&this.unlistenSource_();ol.ImageBase.prototype.disposeInternal.call(this)};ol.reproj.Image.prototype.getImage=function(){return this.canvas_};ol.reproj.Image.prototype.getProjection=function(){return this.targetProj_};
ol.reproj.Image.prototype.reproject_=function(){var a=this.sourceImage_.getState();if(a==ol.ImageState.LOADED){var b=ol.extent.getWidth(this.targetExtent_)/this.targetResolution_,c=ol.extent.getHeight(this.targetExtent_)/this.targetResolution_;this.canvas_=ol.reproj.render(b,c,this.sourcePixelRatio_,this.sourceImage_.getResolution(),this.maxSourceExtent_,this.targetResolution_,this.targetExtent_,this.triangulation_,[{extent:this.sourceImage_.getExtent(),image:this.sourceImage_.getImage()}],0)}this.state=
a;this.changed()};ol.reproj.Image.prototype.load=function(){if(this.state==ol.ImageState.IDLE){this.state=ol.ImageState.LOADING;this.changed();var a=this.sourceImage_.getState();a==ol.ImageState.LOADED||a==ol.ImageState.ERROR?this.reproject_():(this.sourceListenerKey_=ol.events.listen(this.sourceImage_,ol.events.EventType.CHANGE,function(a){a=this.sourceImage_.getState();if(a==ol.ImageState.LOADED||a==ol.ImageState.ERROR)this.unlistenSource_(),this.reproject_()},this),this.sourceImage_.load())}};
ol.reproj.Image.prototype.unlistenSource_=function(){ol.events.unlistenByKey(this.sourceListenerKey_);this.sourceListenerKey_=null};ol.source.Image=function(a){ol.source.Source.call(this,{attributions:a.attributions,extent:a.extent,logo:a.logo,projection:a.projection,state:a.state});this.resolutions_=void 0!==a.resolutions?a.resolutions:null;this.reprojectedImage_=null;this.reprojectedRevision_=0};ol.inherits(ol.source.Image,ol.source.Source);ol.source.Image.prototype.getResolutions=function(){return this.resolutions_};
ol.source.Image.prototype.findNearestResolution=function(a){this.resolutions_&&(a=ol.array.linearFindNearest(this.resolutions_,a,0),a=this.resolutions_[a]);return a};
ol.source.Image.prototype.getImage=function(a,b,c,d){var e=this.getProjection();if(ol.ENABLE_RASTER_REPROJECTION&&e&&d&&!ol.proj.equivalent(e,d)){if(this.reprojectedImage_){if(this.reprojectedRevision_==this.getRevision()&&ol.proj.equivalent(this.reprojectedImage_.getProjection(),d)&&this.reprojectedImage_.getResolution()==b&&ol.extent.equals(this.reprojectedImage_.getExtent(),a))return this.reprojectedImage_;this.reprojectedImage_.dispose();this.reprojectedImage_=null}this.reprojectedImage_=new ol.reproj.Image(e,
d,a,b,c,function(a,b,c){return this.getImageInternal(a,b,c,e)}.bind(this));this.reprojectedRevision_=this.getRevision();return this.reprojectedImage_}e&&(d=e);return this.getImageInternal(a,b,c,d)};ol.source.Image.prototype.getImageInternal=function(a,b,c,d){};
ol.source.Image.prototype.handleImageChange=function(a){a=a.target;switch(a.getState()){case ol.ImageState.LOADING:this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADSTART,a));break;case ol.ImageState.LOADED:this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADEND,a));break;case ol.ImageState.ERROR:this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADERROR,a))}};
ol.source.Image.defaultImageLoadFunction=function(a,b){a.getImage().src=b};ol.source.Image.Event=function(a,b){ol.events.Event.call(this,a);this.image=b};ol.inherits(ol.source.Image.Event,ol.events.Event);ol.source.Image.EventType_={IMAGELOADSTART:"imageloadstart",IMAGELOADEND:"imageloadend",IMAGELOADERROR:"imageloaderror"};ol.uri={};ol.uri.appendParams=function(a,b){var c=[];Object.keys(b).forEach(function(a){null!==b[a]&&void 0!==b[a]&&c.push(a+"="+encodeURIComponent(b[a]))});var d=c.join("&");a=a.replace(/[?&]$/,"");a=-1===a.indexOf("?")?a+"?":a+"&";return a+d};ol.source.ImageArcGISRest=function(a){a=a||{};ol.source.Image.call(this,{attributions:a.attributions,logo:a.logo,projection:a.projection,resolutions:a.resolutions});this.crossOrigin_=void 0!==a.crossOrigin?a.crossOrigin:null;this.hidpi_=void 0!==a.hidpi?a.hidpi:!0;this.url_=a.url;this.imageLoadFunction_=void 0!==a.imageLoadFunction?a.imageLoadFunction:ol.source.Image.defaultImageLoadFunction;this.params_=a.params||{};this.image_=null;this.imageSize_=[0,0];this.renderedRevision_=0;this.ratio_=void 0!==
a.ratio?a.ratio:1.5};ol.inherits(ol.source.ImageArcGISRest,ol.source.Image);ol.source.ImageArcGISRest.prototype.getParams=function(){return this.params_};
ol.source.ImageArcGISRest.prototype.getImageInternal=function(a,b,c,d){if(void 0===this.url_)return null;b=this.findNearestResolution(b);c=this.hidpi_?c:1;var e=this.image_;if(e&&this.renderedRevision_==this.getRevision()&&e.getResolution()==b&&e.getPixelRatio()==c&&ol.extent.containsExtent(e.getExtent(),a))return e;e={F:"image",FORMAT:"PNG32",TRANSPARENT:!0};ol.obj.assign(e,this.params_);a=a.slice();var f=(a[0]+a[2])/2,g=(a[1]+a[3])/2;if(1!=this.ratio_){var h=this.ratio_*ol.extent.getWidth(a)/2,
k=this.ratio_*ol.extent.getHeight(a)/2;a[0]=f-h;a[1]=g-k;a[2]=f+h;a[3]=g+k}h=b/c;k=Math.ceil(ol.extent.getWidth(a)/h);var l=Math.ceil(ol.extent.getHeight(a)/h);a[0]=f-h*k/2;a[2]=f+h*k/2;a[1]=g-h*l/2;a[3]=g+h*l/2;this.imageSize_[0]=k;this.imageSize_[1]=l;d=this.getRequestUrl_(a,this.imageSize_,c,d,e);this.image_=new ol.Image(a,b,c,d,this.crossOrigin_,this.imageLoadFunction_);this.renderedRevision_=this.getRevision();ol.events.listen(this.image_,ol.events.EventType.CHANGE,this.handleImageChange,this);
return this.image_};ol.source.ImageArcGISRest.prototype.getImageLoadFunction=function(){return this.imageLoadFunction_};ol.source.ImageArcGISRest.prototype.getRequestUrl_=function(a,b,c,d,e){d=d.getCode().split(":").pop();e.SIZE=b[0]+","+b[1];e.BBOX=a.join(",");e.BBOXSR=d;e.IMAGESR=d;e.DPI=Math.round(90*c);a=this.url_;b=a.replace(/MapServer\/?$/,"MapServer/export").replace(/ImageServer\/?$/,"ImageServer/exportImage");b==a&&ol.asserts.assert(!1,50);return ol.uri.appendParams(b,e)};
ol.source.ImageArcGISRest.prototype.getUrl=function(){return this.url_};ol.source.ImageArcGISRest.prototype.setImageLoadFunction=function(a){this.image_=null;this.imageLoadFunction_=a;this.changed()};ol.source.ImageArcGISRest.prototype.setUrl=function(a){a!=this.url_&&(this.url_=a,this.image_=null,this.changed())};ol.source.ImageArcGISRest.prototype.updateParams=function(a){ol.obj.assign(this.params_,a);this.image_=null;this.changed()};ol.source.ImageCanvas=function(a){ol.source.Image.call(this,{attributions:a.attributions,logo:a.logo,projection:a.projection,resolutions:a.resolutions,state:a.state});this.canvasFunction_=a.canvasFunction;this.canvas_=null;this.renderedRevision_=0;this.ratio_=void 0!==a.ratio?a.ratio:1.5};ol.inherits(ol.source.ImageCanvas,ol.source.Image);
ol.source.ImageCanvas.prototype.getImageInternal=function(a,b,c,d){b=this.findNearestResolution(b);var e=this.canvas_;if(e&&this.renderedRevision_==this.getRevision()&&e.getResolution()==b&&e.getPixelRatio()==c&&ol.extent.containsExtent(e.getExtent(),a))return e;a=a.slice();ol.extent.scaleFromCenter(a,this.ratio_);var f=ol.extent.getWidth(a)/b,g=ol.extent.getHeight(a)/b;(d=this.canvasFunction_(a,b,c,[f*c,g*c],d))&&(e=new ol.ImageCanvas(a,b,c,d));this.canvas_=e;this.renderedRevision_=this.getRevision();
return e};ol.source.ImageMapGuide=function(a){ol.source.Image.call(this,{projection:a.projection,resolutions:a.resolutions});this.crossOrigin_=void 0!==a.crossOrigin?a.crossOrigin:null;this.displayDpi_=void 0!==a.displayDpi?a.displayDpi:96;this.params_=a.params||{};this.url_=a.url;this.imageLoadFunction_=void 0!==a.imageLoadFunction?a.imageLoadFunction:ol.source.Image.defaultImageLoadFunction;this.hidpi_=void 0!==a.hidpi?a.hidpi:!0;this.metersPerUnit_=void 0!==a.metersPerUnit?a.metersPerUnit:1;this.ratio_=
void 0!==a.ratio?a.ratio:1;this.useOverlay_=void 0!==a.useOverlay?a.useOverlay:!1;this.image_=null;this.renderedRevision_=0};ol.inherits(ol.source.ImageMapGuide,ol.source.Image);ol.source.ImageMapGuide.prototype.getParams=function(){return this.params_};
ol.source.ImageMapGuide.prototype.getImageInternal=function(a,b,c,d){b=this.findNearestResolution(b);c=this.hidpi_?c:1;var e=this.image_;if(e&&this.renderedRevision_==this.getRevision()&&e.getResolution()==b&&e.getPixelRatio()==c&&ol.extent.containsExtent(e.getExtent(),a))return e;1!=this.ratio_&&(a=a.slice(),ol.extent.scaleFromCenter(a,this.ratio_));e=ol.extent.getWidth(a)/b;var f=ol.extent.getHeight(a)/b;e=[e*c,f*c];void 0!==this.url_?(d=this.getUrl(this.url_,this.params_,a,e,d),e=new ol.Image(a,
b,c,d,this.crossOrigin_,this.imageLoadFunction_),ol.events.listen(e,ol.events.EventType.CHANGE,this.handleImageChange,this)):e=null;this.image_=e;this.renderedRevision_=this.getRevision();return e};ol.source.ImageMapGuide.prototype.getImageLoadFunction=function(){return this.imageLoadFunction_};ol.source.ImageMapGuide.getScale=function(a,b,c,d){var e=ol.extent.getWidth(a);a=ol.extent.getHeight(a);var f=b[0];b=b[1];d=.0254/d;return b*e>f*a?e*c/(f*d):a*c/(b*d)};
ol.source.ImageMapGuide.prototype.updateParams=function(a){ol.obj.assign(this.params_,a);this.changed()};
ol.source.ImageMapGuide.prototype.getUrl=function(a,b,c,d,e){e=ol.source.ImageMapGuide.getScale(c,d,this.metersPerUnit_,this.displayDpi_);c=ol.extent.getCenter(c);d={OPERATION:this.useOverlay_?"GETDYNAMICMAPOVERLAYIMAGE":"GETMAPIMAGE",VERSION:"2.0.0",LOCALE:"en",CLIENTAGENT:"ol.source.ImageMapGuide source",CLIP:"1",SETDISPLAYDPI:this.displayDpi_,SETDISPLAYWIDTH:Math.round(d[0]),SETDISPLAYHEIGHT:Math.round(d[1]),SETVIEWSCALE:e,SETVIEWCENTERX:c[0],SETVIEWCENTERY:c[1]};ol.obj.assign(d,b);return ol.uri.appendParams(a,
d)};ol.source.ImageMapGuide.prototype.setImageLoadFunction=function(a){this.image_=null;this.imageLoadFunction_=a;this.changed()};ol.source.ImageStatic=function(a){var b=a.imageExtent,c=void 0!==a.crossOrigin?a.crossOrigin:null,d=void 0!==a.imageLoadFunction?a.imageLoadFunction:ol.source.Image.defaultImageLoadFunction;ol.source.Image.call(this,{attributions:a.attributions,logo:a.logo,projection:ol.proj.get(a.projection)});this.image_=new ol.Image(b,void 0,1,a.url,c,d);this.imageSize_=a.imageSize?a.imageSize:null;ol.events.listen(this.image_,ol.events.EventType.CHANGE,this.handleImageChange,this)};
ol.inherits(ol.source.ImageStatic,ol.source.Image);ol.source.ImageStatic.prototype.getImageInternal=function(a,b,c,d){return ol.extent.intersects(a,this.image_.getExtent())?this.image_:null};
ol.source.ImageStatic.prototype.handleImageChange=function(a){if(this.image_.getState()==ol.ImageState.LOADED){var b=this.image_.getExtent(),c=this.image_.getImage();if(this.imageSize_){var d=this.imageSize_[0];var e=this.imageSize_[1]}else d=c.width,e=c.height;var f=ol.extent.getHeight(b)/e;b=Math.ceil(ol.extent.getWidth(b)/f);b!=d&&(b=ol.dom.createCanvasContext2D(b,e),f=b.canvas,b.drawImage(c,0,0,d,e,0,0,f.width,f.height),this.image_.setImage(f))}ol.source.Image.prototype.handleImageChange.call(this,
a)};ol.source.ImageVector=function(a){this.source_=a.source;this.transform_=ol.transform.create();this.canvasContext_=ol.dom.createCanvasContext2D();this.canvasSize_=[0,0];this.declutterTree_=ol.ext.rbush(9);this.renderBuffer_=void 0==a.renderBuffer?100:a.renderBuffer;this.replayGroup_=null;ol.source.ImageCanvas.call(this,{attributions:a.attributions,canvasFunction:this.canvasFunctionInternal_.bind(this),logo:a.logo,projection:a.projection,ratio:a.ratio,resolutions:a.resolutions,state:this.source_.getState()});
this.style_=null;this.styleFunction_=void 0;this.setStyle(a.style);ol.events.listen(this.source_,ol.events.EventType.CHANGE,this.handleSourceChange_,this)};ol.inherits(ol.source.ImageVector,ol.source.ImageCanvas);
ol.source.ImageVector.prototype.canvasFunctionInternal_=function(a,b,c,d,e){var f=new ol.render.canvas.ReplayGroup(ol.renderer.vector.getTolerance(b,c),a,b,c,this.source_.getOverlaps(),this.declutterTree_,this.renderBuffer_);this.source_.loadFeatures(a,b,e);var g=!1;this.source_.forEachFeatureInExtent(a,function(a){g=g||this.renderFeature_(a,b,c,f)},this);f.finish();if(g)return null;this.canvasSize_[0]!=d[0]||this.canvasSize_[1]!=d[1]?(this.canvasContext_.canvas.width=d[0],this.canvasContext_.canvas.height=
d[1],this.canvasSize_[0]=d[0],this.canvasSize_[1]=d[1]):this.canvasContext_.clearRect(0,0,d[0],d[1]);this.declutterTree_.clear();a=this.getTransform_(ol.extent.getCenter(a),b,c,d);f.replay(this.canvasContext_,a,0,{});this.replayGroup_=f;return this.canvasContext_.canvas};
ol.source.ImageVector.prototype.forEachFeatureAtCoordinate=function(a,b,c,d,e,f){if(this.replayGroup_){var g={};return this.replayGroup_.forEachFeatureAtCoordinate(a,b,0,d,e,function(a){var b=ol.getUid(a).toString();if(!(b in g))return g[b]=!0,f(a)},null)}};ol.source.ImageVector.prototype.getSource=function(){return this.source_};ol.source.ImageVector.prototype.getStyle=function(){return this.style_};ol.source.ImageVector.prototype.getStyleFunction=function(){return this.styleFunction_};
ol.source.ImageVector.prototype.getTransform_=function(a,b,c,d){b=c/b;return ol.transform.compose(this.transform_,d[0]/2,d[1]/2,b,-b,0,-a[0],-a[1])};ol.source.ImageVector.prototype.handleImageChange_=function(a){this.changed()};ol.source.ImageVector.prototype.handleSourceChange_=function(){this.setState(this.source_.getState())};
ol.source.ImageVector.prototype.renderFeature_=function(a,b,c,d){var e,f=a.getStyleFunction();f?e=f.call(a,b):this.styleFunction_&&(e=this.styleFunction_(a,b));if(!e)return!1;var g,h=!1;Array.isArray(e)||(e=[e]);f=0;for(g=e.length;f<g;++f)h=ol.renderer.vector.renderFeature(d,a,e[f],ol.renderer.vector.getSquaredTolerance(b,c),this.handleImageChange_,this)||h;return h};
ol.source.ImageVector.prototype.setStyle=function(a){this.style_=void 0!==a?a:ol.style.Style.defaultFunction;this.styleFunction_=a?ol.style.Style.createFunction(this.style_):void 0;this.changed()};ol.source.WMSServerType={CARMENTA_SERVER:"carmentaserver",GEOSERVER:"geoserver",MAPSERVER:"mapserver",QGIS:"qgis"};ol.source.ImageWMS=function(a){a=a||{};ol.source.Image.call(this,{attributions:a.attributions,logo:a.logo,projection:a.projection,resolutions:a.resolutions});this.crossOrigin_=void 0!==a.crossOrigin?a.crossOrigin:null;this.url_=a.url;this.imageLoadFunction_=void 0!==a.imageLoadFunction?a.imageLoadFunction:ol.source.Image.defaultImageLoadFunction;this.params_=a.params||{};this.v13_=!0;this.updateV13_();this.serverType_=a.serverType;this.hidpi_=void 0!==a.hidpi?a.hidpi:!0;this.image_=null;this.imageSize_=
[0,0];this.renderedRevision_=0;this.ratio_=void 0!==a.ratio?a.ratio:1.5};ol.inherits(ol.source.ImageWMS,ol.source.Image);ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_=[101,101];
ol.source.ImageWMS.prototype.getGetFeatureInfoUrl=function(a,b,c,d){if(void 0!==this.url_){c=ol.proj.get(c);var e=this.getProjection();e&&e!==c&&(b=ol.reproj.calculateSourceResolution(e,c,a,b),a=ol.proj.transform(a,c,e));var f=ol.extent.getForViewAndSize(a,b,0,ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_),g={SERVICE:"WMS",VERSION:ol.DEFAULT_WMS_VERSION,REQUEST:"GetFeatureInfo",FORMAT:"image/png",TRANSPARENT:!0,QUERY_LAYERS:this.params_.LAYERS};ol.obj.assign(g,this.params_,d);d=Math.floor((f[3]-a[1])/
b);g[this.v13_?"I":"X"]=Math.floor((a[0]-f[0])/b);g[this.v13_?"J":"Y"]=d;return this.getRequestUrl_(f,ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_,1,e||c,g)}};ol.source.ImageWMS.prototype.getParams=function(){return this.params_};
ol.source.ImageWMS.prototype.getImageInternal=function(a,b,c,d){if(void 0===this.url_)return null;b=this.findNearestResolution(b);1==c||this.hidpi_&&void 0!==this.serverType_||(c=1);var e=b/c,f=ol.extent.getCenter(a),g=Math.ceil(ol.extent.getWidth(a)/e),h=Math.ceil(ol.extent.getHeight(a)/e);g=ol.extent.getForViewAndSize(f,e,0,[g,h]);h=Math.ceil(this.ratio_*ol.extent.getWidth(a)/e);a=Math.ceil(this.ratio_*ol.extent.getHeight(a)/e);f=ol.extent.getForViewAndSize(f,e,0,[h,a]);if((a=this.image_)&&this.renderedRevision_==
this.getRevision()&&a.getResolution()==b&&a.getPixelRatio()==c&&ol.extent.containsExtent(a.getExtent(),g))return a;g={SERVICE:"WMS",VERSION:ol.DEFAULT_WMS_VERSION,REQUEST:"GetMap",FORMAT:"image/png",TRANSPARENT:!0};ol.obj.assign(g,this.params_);this.imageSize_[0]=Math.round(ol.extent.getWidth(f)/e);this.imageSize_[1]=Math.round(ol.extent.getHeight(f)/e);d=this.getRequestUrl_(f,this.imageSize_,c,d,g);this.image_=new ol.Image(f,b,c,d,this.crossOrigin_,this.imageLoadFunction_);this.renderedRevision_=
this.getRevision();ol.events.listen(this.image_,ol.events.EventType.CHANGE,this.handleImageChange,this);return this.image_};ol.source.ImageWMS.prototype.getImageLoadFunction=function(){return this.imageLoadFunction_};
ol.source.ImageWMS.prototype.getRequestUrl_=function(a,b,c,d,e){ol.asserts.assert(void 0!==this.url_,9);e[this.v13_?"CRS":"SRS"]=d.getCode();"STYLES"in this.params_||(e.STYLES="");if(1!=c)switch(this.serverType_){case ol.source.WMSServerType.GEOSERVER:c=90*c+.5|0;e.FORMAT_OPTIONS="FORMAT_OPTIONS"in e?e.FORMAT_OPTIONS+(";dpi:"+c):"dpi:"+c;break;case ol.source.WMSServerType.MAPSERVER:e.MAP_RESOLUTION=90*c;break;case ol.source.WMSServerType.CARMENTA_SERVER:case ol.source.WMSServerType.QGIS:e.DPI=90*
c;break;default:ol.asserts.assert(!1,8)}e.WIDTH=b[0];e.HEIGHT=b[1];b=d.getAxisOrientation();a=this.v13_&&"ne"==b.substr(0,2)?[a[1],a[0],a[3],a[2]]:a;e.BBOX=a.join(",");return ol.uri.appendParams(this.url_,e)};ol.source.ImageWMS.prototype.getUrl=function(){return this.url_};ol.source.ImageWMS.prototype.setImageLoadFunction=function(a){this.image_=null;this.imageLoadFunction_=a;this.changed()};ol.source.ImageWMS.prototype.setUrl=function(a){a!=this.url_&&(this.url_=a,this.image_=null,this.changed())};
ol.source.ImageWMS.prototype.updateParams=function(a){ol.obj.assign(this.params_,a);this.updateV13_();this.image_=null;this.changed()};ol.source.ImageWMS.prototype.updateV13_=function(){this.v13_=0<=ol.string.compareVersions(this.params_.VERSION||ol.DEFAULT_WMS_VERSION,"1.3")};ol.source.OSM=function(a){a=a||{};ol.source.XYZ.call(this,{attributions:void 0!==a.attributions?a.attributions:[ol.source.OSM.ATTRIBUTION],cacheSize:a.cacheSize,crossOrigin:void 0!==a.crossOrigin?a.crossOrigin:"anonymous",opaque:void 0!==a.opaque?a.opaque:!0,maxZoom:void 0!==a.maxZoom?a.maxZoom:19,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileLoadFunction:a.tileLoadFunction,url:void 0!==a.url?a.url:"https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png",wrapX:a.wrapX})};
ol.inherits(ol.source.OSM,ol.source.XYZ);ol.source.OSM.ATTRIBUTION='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors.';ol.ext.pixelworks={};ol.ext.pixelworks.Processor=function(){};
(function(){(function(a){function b(a){var b=!0;try{new ImageData(10,10)}catch(m){b=!1}return function(c){var d=c.buffers,e=c.meta,f=c.width,g=c.height,h=d.length,k=d[0].byteLength;if(c.imageOps){k=Array(h);for(c=0;c<h;++c){var l=c;var m=new Uint8ClampedArray(d[c]);var y=f,z=g;m=b?new ImageData(m,y,z):{data:m,width:y,height:z};k[l]=m}f=a(k,e).data}else{f=new Uint8ClampedArray(k);g=Array(h);l=Array(h);for(c=0;c<h;++c)g[c]=new Uint8ClampedArray(d[c]),l[c]=[0,0,0,0];for(d=0;d<k;d+=4){for(c=0;c<h;++c)m=
g[c],l[c][0]=m[d],l[c][1]=m[d+1],l[c][2]=m[d+2],l[c][3]=m[d+3];c=a(l,e);f[d]=c[0];f[d+1]=c[1];f[d+2]=c[2];f[d+3]=c[3]}}return f.buffer}}function c(a,c){var d=Object.keys(a.lib||{}).map(function(b){return"var "+b+" = "+a.lib[b].toString()+";"}).concat(["var __minion__ = ("+b.toString()+")(",a.operation.toString(),");",'self.addEventListener("message", function(event) {',"  var buffer = __minion__(event.data);","  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);","});"]);d=new Blob(d,
{type:"text/javascript"});d=URL.createObjectURL(d);d=new Worker(d);d.addEventListener("message",c);return d}function d(a,c){var d=b(a.operation);return{postMessage:function(a){setTimeout(function(){c({data:{buffer:d(a),meta:a.meta}})},0)}}}function e(a){this._imageOps=!!a.imageOps;var b=0===a.threads?0:this._imageOps?1:a.threads||1;var e=[];if(b)for(var f=0;f<b;++f)e[f]=c(a,this._onWorkerMessage.bind(this,f));else e[0]=d(a,this._onWorkerMessage.bind(this,0));this._workers=e;this._queue=[];this._maxQueueLength=
a.queue||Infinity;this._running=0;this._dataLookup={};this._job=null}var f=!0;try{new ImageData(10,10)}catch(k){f=!1}var g=document.createElement("canvas").getContext("2d"),h=function(a,b,c){if(f)return new ImageData(a,b,c);b=g.createImageData(b,c);b.data.set(a);return b};e.prototype.process=function(a,b,c){this._enqueue({inputs:a,meta:b,callback:c});this._dispatch()};e.prototype.destroy=function(){for(var a in this)this[a]=null;this._destroyed=!0};e.prototype._enqueue=function(a){for(this._queue.push(a);this._queue.length>
this._maxQueueLength;)this._queue.shift().callback(null,null)};e.prototype._dispatch=function(){if(0===this._running&&0<this._queue.length){var a=this._job=this._queue.shift(),b=a.inputs[0].width,c=a.inputs[0].height,d=a.inputs.map(function(a){return a.data.buffer}),e=this._workers.length;this._running=e;if(1===e)this._workers[0].postMessage({buffers:d,meta:a.meta,imageOps:this._imageOps,width:b,height:c},d);else for(var f=4*Math.ceil(a.inputs[0].data.length/4/e),g=0;g<e;++g){for(var h=g*f,t=[],v=
0,w=d.length;v<w;++v)t.push(d[g].slice(h,h+f));this._workers[g].postMessage({buffers:t,meta:a.meta,imageOps:this._imageOps,width:b,height:c},t)}}};e.prototype._onWorkerMessage=function(a,b){this._destroyed||(this._dataLookup[a]=b.data,--this._running,0===this._running&&this._resolveJob())};e.prototype._resolveJob=function(){var a=this._job,b=this._workers.length;if(1===b){var c=new Uint8ClampedArray(this._dataLookup[0].buffer);var d=this._dataLookup[0].meta}else{var e=a.inputs[0].data.length;c=new Uint8ClampedArray(e);
d=Array(e);e=4*Math.ceil(e/4/b);for(var f=0;f<b;++f){var g=f*e;c.set(new Uint8ClampedArray(this._dataLookup[f].buffer),g);d[f]=this._dataLookup[f].meta}}this._job=null;this._dataLookup={};a.callback(null,h(c,a.inputs[0].width,a.inputs[0].height),d);this._dispatch()};a["default"]={Processor:e};a.Processor=e})(this.pixelworks=this.pixelworks||{})}).call(ol.ext);ol.source.RasterOperationType={PIXEL:"pixel",IMAGE:"image"};ol.source.Raster=function(a){this.worker_=null;this.operationType_=void 0!==a.operationType?a.operationType:ol.source.RasterOperationType.PIXEL;this.threads_=void 0!==a.threads?a.threads:1;this.renderers_=ol.source.Raster.createRenderers_(a.sources);for(var b=0,c=this.renderers_.length;b<c;++b)ol.events.listen(this.renderers_[b],ol.events.EventType.CHANGE,this.changed,this);this.tileQueue_=new ol.TileQueue(function(){return 1},this.changed.bind(this));b=ol.source.Raster.getLayerStatesArray_(this.renderers_);
c={};for(var d=0,e=b.length;d<e;++d)c[ol.getUid(b[d].layer)]=b[d];this.renderedImageCanvas_=null;this.frameState_={animate:!1,coordinateToPixelTransform:ol.transform.create(),extent:null,focus:null,index:0,layerStates:c,layerStatesArray:b,logos:{},pixelRatio:1,pixelToCoordinateTransform:ol.transform.create(),postRenderFunctions:[],size:[0,0],skippedFeatureUids:{},tileQueue:this.tileQueue_,time:Date.now(),usedTiles:{},viewState:{rotation:0},viewHints:[],wantedTiles:{}};ol.source.Image.call(this,{});
void 0!==a.operation&&this.setOperation(a.operation,a.lib)};ol.inherits(ol.source.Raster,ol.source.Image);ol.source.Raster.prototype.setOperation=function(a,b){this.worker_=new ol.ext.pixelworks.Processor({operation:a,imageOps:this.operationType_===ol.source.RasterOperationType.IMAGE,queue:1,lib:b,threads:this.threads_});this.changed()};
ol.source.Raster.prototype.updateFrameState_=function(a,b,c){var d=ol.obj.assign({},this.frameState_);d.viewState=ol.obj.assign({},d.viewState);var e=ol.extent.getCenter(a);d.extent=a.slice();d.focus=e;d.size[0]=Math.round(ol.extent.getWidth(a)/b);d.size[1]=Math.round(ol.extent.getHeight(a)/b);d.time=Date.now();d.animate=!1;a=d.viewState;a.center=e;a.projection=c;a.resolution=b;return d};
ol.source.Raster.prototype.allSourcesReady_=function(){for(var a=!0,b,c=0,d=this.renderers_.length;c<d;++c)if(b=this.renderers_[c].getLayer().getSource(),b.getState()!==ol.source.State.READY){a=!1;break}return a};
ol.source.Raster.prototype.getImage=function(a,b,c,d){if(!this.allSourcesReady_())return null;this.requestedFrameState_=c=this.updateFrameState_(a,b,d);if(this.renderedImageCanvas_){d=this.renderedImageCanvas_.getResolution();var e=this.renderedImageCanvas_.getExtent();b===d&&ol.extent.equals(a,e)||(this.renderedImageCanvas_=null)}this.renderedImageCanvas_&&this.getRevision()===this.renderedRevision_||this.processSources_();c.tileQueue.loadMoreTiles(16,16);c.animate&&requestAnimationFrame(this.changed.bind(this));
return this.renderedImageCanvas_};ol.source.Raster.prototype.processSources_=function(){for(var a=this.requestedFrameState_,b=this.renderers_.length,c=Array(b),d=0;d<b;++d){var e=ol.source.Raster.getImageData_(this.renderers_[d],a,a.layerStatesArray[d]);if(e)c[d]=e;else return}b={};this.dispatchEvent(new ol.source.Raster.Event(ol.source.Raster.EventType_.BEFOREOPERATIONS,a,b));this.worker_.process(c,b,this.onWorkerComplete_.bind(this,a))};
ol.source.Raster.prototype.onWorkerComplete_=function(a,b,c,d){if(!b&&c){b=a.extent;var e=a.viewState.resolution;if(e===this.requestedFrameState_.viewState.resolution&&ol.extent.equals(b,this.requestedFrameState_.extent)){if(this.renderedImageCanvas_)var f=this.renderedImageCanvas_.getImage().getContext("2d");else{f=Math.round(ol.extent.getWidth(b)/e);var g=Math.round(ol.extent.getHeight(b)/e);f=ol.dom.createCanvasContext2D(f,g);this.renderedImageCanvas_=new ol.ImageCanvas(b,e,1,f.canvas)}f.putImageData(c,
0,0);this.changed();this.renderedRevision_=this.getRevision();this.dispatchEvent(new ol.source.Raster.Event(ol.source.Raster.EventType_.AFTEROPERATIONS,a,d))}}};
ol.source.Raster.getImageData_=function(a,b,c){if(!a.prepareFrame(b,c))return null;var d=b.size[0],e=b.size[1];if(ol.source.Raster.context_){var f=ol.source.Raster.context_.canvas;f.width!==d||f.height!==e?ol.source.Raster.context_=ol.dom.createCanvasContext2D(d,e):ol.source.Raster.context_.clearRect(0,0,d,e)}else ol.source.Raster.context_=ol.dom.createCanvasContext2D(d,e);a.composeFrame(b,c,ol.source.Raster.context_);return ol.source.Raster.context_.getImageData(0,0,d,e)};
ol.source.Raster.context_=null;ol.source.Raster.getLayerStatesArray_=function(a){return a.map(function(a){return a.getLayer().getLayerState()})};ol.source.Raster.createRenderers_=function(a){for(var b=a.length,c=Array(b),d=0;d<b;++d)c[d]=ol.source.Raster.createRenderer_(a[d]);return c};ol.source.Raster.createRenderer_=function(a){var b=null;a instanceof ol.source.Tile?b=ol.source.Raster.createTileRenderer_(a):a instanceof ol.source.Image&&(b=ol.source.Raster.createImageRenderer_(a));return b};
ol.source.Raster.createImageRenderer_=function(a){a=new ol.layer.Image({source:a});return new ol.renderer.canvas.ImageLayer(a)};ol.source.Raster.createTileRenderer_=function(a){a=new ol.layer.Tile({source:a});return new ol.renderer.canvas.TileLayer(a)};ol.source.Raster.Event=function(a,b,c){ol.events.Event.call(this,a);this.extent=b.extent;this.resolution=b.viewState.resolution/b.pixelRatio;this.data=c};ol.inherits(ol.source.Raster.Event,ol.events.Event);
ol.source.Raster.prototype.getImageInternal=function(){return null};ol.source.Raster.EventType_={BEFOREOPERATIONS:"beforeoperations",AFTEROPERATIONS:"afteroperations"};ol.source.Stamen=function(a){var b=a.layer.indexOf("-");b=-1==b?a.layer:a.layer.slice(0,b);b=ol.source.Stamen.ProviderConfig[b];var c=ol.source.Stamen.LayerConfig[a.layer];ol.source.XYZ.call(this,{attributions:ol.source.Stamen.ATTRIBUTIONS,cacheSize:a.cacheSize,crossOrigin:"anonymous",maxZoom:void 0!=a.maxZoom?a.maxZoom:b.maxZoom,minZoom:void 0!=a.minZoom?a.minZoom:b.minZoom,opaque:c.opaque,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileLoadFunction:a.tileLoadFunction,url:void 0!==a.url?
a.url:"https://stamen-tiles-{a-d}.a.ssl.fastly.net/"+a.layer+"/{z}/{x}/{y}."+c.extension,wrapX:a.wrapX})};ol.inherits(ol.source.Stamen,ol.source.XYZ);ol.source.Stamen.ATTRIBUTIONS=['Map tiles by <a href="https://stamen.com/">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.',ol.source.OSM.ATTRIBUTION];
ol.source.Stamen.LayerConfig={terrain:{extension:"jpg",opaque:!0},"terrain-background":{extension:"jpg",opaque:!0},"terrain-labels":{extension:"png",opaque:!1},"terrain-lines":{extension:"png",opaque:!1},"toner-background":{extension:"png",opaque:!0},toner:{extension:"png",opaque:!0},"toner-hybrid":{extension:"png",opaque:!1},"toner-labels":{extension:"png",opaque:!1},"toner-lines":{extension:"png",opaque:!1},"toner-lite":{extension:"png",opaque:!0},watercolor:{extension:"jpg",opaque:!0}};
ol.source.Stamen.ProviderConfig={terrain:{minZoom:4,maxZoom:18},toner:{minZoom:0,maxZoom:20},watercolor:{minZoom:1,maxZoom:16}};ol.source.TileArcGISRest=function(a){a=a||{};ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,projection:a.projection,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileGrid:a.tileGrid,tileLoadFunction:a.tileLoadFunction,url:a.url,urls:a.urls,wrapX:void 0!==a.wrapX?a.wrapX:!0,transition:a.transition});this.params_=a.params||{};this.tmpExtent_=ol.extent.createEmpty();this.setKey(this.getKeyForParams_())};
ol.inherits(ol.source.TileArcGISRest,ol.source.TileImage);ol.source.TileArcGISRest.prototype.getKeyForParams_=function(){var a=0,b=[],c;for(c in this.params_)b[a++]=c+"-"+this.params_[c];return b.join("/")};ol.source.TileArcGISRest.prototype.getParams=function(){return this.params_};
ol.source.TileArcGISRest.prototype.getRequestUrl_=function(a,b,c,d,e,f){var g=this.urls;if(g)return e=e.getCode().split(":").pop(),f.SIZE=b[0]+","+b[1],f.BBOX=c.join(","),f.BBOXSR=e,f.IMAGESR=e,f.DPI=Math.round(f.DPI?f.DPI*d:90*d),1==g.length?g=g[0]:(a=ol.math.modulo(ol.tilecoord.hash(a),g.length),g=g[a]),g=g.replace(/MapServer\/?$/,"MapServer/export").replace(/ImageServer\/?$/,"ImageServer/exportImage"),ol.uri.appendParams(g,f)};ol.source.TileArcGISRest.prototype.getTilePixelRatio=function(a){return a};
ol.source.TileArcGISRest.prototype.fixedTileUrlFunction=function(a,b,c){var d=this.getTileGrid();d||(d=this.getTileGridForProjection(c));if(!(d.getResolutions().length<=a[0])){var e=d.getTileCoordExtent(a,this.tmpExtent_);d=ol.size.toSize(d.getTileSize(a[0]),this.tmpSize);1!=b&&(d=ol.size.scale(d,b,this.tmpSize));var f={F:"image",FORMAT:"PNG32",TRANSPARENT:!0};ol.obj.assign(f,this.params_);return this.getRequestUrl_(a,d,e,b,c,f)}};
ol.source.TileArcGISRest.prototype.updateParams=function(a){ol.obj.assign(this.params_,a);this.setKey(this.getKeyForParams_())};ol.source.TileDebug=function(a){ol.source.Tile.call(this,{opaque:!1,projection:a.projection,tileGrid:a.tileGrid,wrapX:void 0!==a.wrapX?a.wrapX:!0})};ol.inherits(ol.source.TileDebug,ol.source.Tile);
ol.source.TileDebug.prototype.getTile=function(a,b,c){var d=ol.tilecoord.getKeyZXY(a,b,c);if(this.tileCache.containsKey(d))return this.tileCache.get(d);var e=ol.size.toSize(this.tileGrid.getTileSize(a));a=[a,b,c];b=(b=this.getTileCoordForTileUrlFunction(a))?this.getTileCoordForTileUrlFunction(b).toString():"";e=new ol.source.TileDebug.Tile_(a,e,b);this.tileCache.set(d,e);return e};
ol.source.TileDebug.Tile_=function(a,b,c){ol.Tile.call(this,a,ol.TileState.LOADED);this.tileSize_=b;this.text_=c;this.canvas_=null};ol.inherits(ol.source.TileDebug.Tile_,ol.Tile);
ol.source.TileDebug.Tile_.prototype.getImage=function(){if(this.canvas_)return this.canvas_;var a=this.tileSize_,b=ol.dom.createCanvasContext2D(a[0],a[1]);b.strokeStyle="black";b.strokeRect(.5,.5,a[0]+.5,a[1]+.5);b.fillStyle="black";b.textAlign="center";b.textBaseline="middle";b.font="24px sans-serif";b.fillText(this.text_,a[0]/2,a[1]/2);return this.canvas_=b.canvas};ol.source.TileDebug.Tile_.prototype.load=function(){};ol.source.TileJSON=function(a){this.tileJSON_=null;ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,projection:ol.proj.get("EPSG:3857"),reprojectionErrorThreshold:a.reprojectionErrorThreshold,state:ol.source.State.LOADING,tileLoadFunction:a.tileLoadFunction,wrapX:void 0!==a.wrapX?a.wrapX:!0,transition:a.transition});if(a.url)if(a.jsonp)ol.net.jsonp(a.url,this.handleTileJSONResponse.bind(this),this.handleTileJSONError.bind(this));else{var b=
new XMLHttpRequest;b.addEventListener("load",this.onXHRLoad_.bind(this));b.addEventListener("error",this.onXHRError_.bind(this));b.open("GET",a.url);b.send()}else a.tileJSON?this.handleTileJSONResponse(a.tileJSON):ol.asserts.assert(!1,51)};ol.inherits(ol.source.TileJSON,ol.source.TileImage);ol.source.TileJSON.prototype.onXHRLoad_=function(a){a=a.target;if(!a.status||200<=a.status&&300>a.status){try{var b=JSON.parse(a.responseText)}catch(c){this.handleTileJSONError();return}this.handleTileJSONResponse(b)}else this.handleTileJSONError()};
ol.source.TileJSON.prototype.onXHRError_=function(a){this.handleTileJSONError()};ol.source.TileJSON.prototype.getTileJSON=function(){return this.tileJSON_};
ol.source.TileJSON.prototype.handleTileJSONResponse=function(a){var b=ol.proj.get("EPSG:4326"),c=this.getProjection();if(void 0!==a.bounds){var d=ol.proj.getTransformFromProjections(b,c);d=ol.extent.applyTransform(a.bounds,d)}var e=a.minzoom||0,f=a.maxzoom||22;this.tileGrid=c=ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(c),maxZoom:f,minZoom:e});this.tileUrlFunction=ol.TileUrlFunction.createFromTemplates(a.tiles,c);if(void 0!==a.attribution&&!this.getAttributions2()){var g=void 0!==
d?d:b.getExtent();this.setAttributions(function(b){return ol.extent.intersects(g,b.extent)?[a.attribution]:null})}this.tileJSON_=a;this.setState(ol.source.State.READY)};ol.source.TileJSON.prototype.handleTileJSONError=function(){this.setState(ol.source.State.ERROR)};ol.source.TileUTFGrid=function(a){ol.source.Tile.call(this,{projection:ol.proj.get("EPSG:3857"),state:ol.source.State.LOADING});this.preemptive_=void 0!==a.preemptive?a.preemptive:!0;this.tileUrlFunction_=ol.TileUrlFunction.nullTileUrlFunction;this.template_=void 0;this.jsonp_=a.jsonp||!1;if(a.url)if(this.jsonp_)ol.net.jsonp(a.url,this.handleTileJSONResponse.bind(this),this.handleTileJSONError.bind(this));else{var b=new XMLHttpRequest;b.addEventListener("load",this.onXHRLoad_.bind(this));b.addEventListener("error",
this.onXHRError_.bind(this));b.open("GET",a.url);b.send()}else a.tileJSON?this.handleTileJSONResponse(a.tileJSON):ol.asserts.assert(!1,51)};ol.inherits(ol.source.TileUTFGrid,ol.source.Tile);ol.source.TileUTFGrid.prototype.onXHRLoad_=function(a){a=a.target;if(!a.status||200<=a.status&&300>a.status){try{var b=JSON.parse(a.responseText)}catch(c){this.handleTileJSONError();return}this.handleTileJSONResponse(b)}else this.handleTileJSONError()};ol.source.TileUTFGrid.prototype.onXHRError_=function(a){this.handleTileJSONError()};
ol.source.TileUTFGrid.prototype.getTemplate=function(){return this.template_};ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution=function(a,b,c,d,e){this.tileGrid?(b=this.tileGrid.getTileCoordForCoordAndResolution(a,b),this.getTile(b[0],b[1],b[2],1,this.getProjection()).forDataAtCoordinate(a,c,d,e)):!0===e?setTimeout(function(){c.call(d,null)},0):c.call(d,null)};ol.source.TileUTFGrid.prototype.handleTileJSONError=function(){this.setState(ol.source.State.ERROR)};
ol.source.TileUTFGrid.prototype.handleTileJSONResponse=function(a){var b=ol.proj.get("EPSG:4326"),c=this.getProjection();if(void 0!==a.bounds){var d=ol.proj.getTransformFromProjections(b,c);d=ol.extent.applyTransform(a.bounds,d)}var e=a.minzoom||0,f=a.maxzoom||22;this.tileGrid=c=ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(c),maxZoom:f,minZoom:e});this.template_=a.template;if(e=a.grids){this.tileUrlFunction_=ol.TileUrlFunction.createFromTemplates(e,c);if(void 0!==a.attribution){var g=
void 0!==d?d:b.getExtent();this.setAttributions(function(b){return ol.extent.intersects(g,b.extent)?[a.attribution]:null})}this.setState(ol.source.State.READY)}else this.setState(ol.source.State.ERROR)};
ol.source.TileUTFGrid.prototype.getTile=function(a,b,c,d,e){var f=ol.tilecoord.getKeyZXY(a,b,c);if(this.tileCache.containsKey(f))return this.tileCache.get(f);a=[a,b,c];b=this.getTileCoordForTileUrlFunction(a,e);d=this.tileUrlFunction_(b,d,e);d=new ol.source.TileUTFGrid.Tile_(a,void 0!==d?ol.TileState.IDLE:ol.TileState.EMPTY,void 0!==d?d:"",this.tileGrid.getTileCoordExtent(a),this.preemptive_,this.jsonp_);this.tileCache.set(f,d);return d};
ol.source.TileUTFGrid.prototype.useTile=function(a,b,c){a=ol.tilecoord.getKeyZXY(a,b,c);this.tileCache.containsKey(a)&&this.tileCache.get(a)};ol.source.TileUTFGrid.Tile_=function(a,b,c,d,e,f){ol.Tile.call(this,a,b);this.src_=c;this.extent_=d;this.preemptive_=e;this.data_=this.keys_=this.grid_=null;this.jsonp_=f};ol.inherits(ol.source.TileUTFGrid.Tile_,ol.Tile);ol.source.TileUTFGrid.Tile_.prototype.getImage=function(){return null};
ol.source.TileUTFGrid.Tile_.prototype.getData=function(a){if(!this.grid_||!this.keys_)return null;var b=this.grid_[Math.floor((1-(a[1]-this.extent_[1])/(this.extent_[3]-this.extent_[1]))*this.grid_.length)];if("string"!==typeof b)return null;a=b.charCodeAt(Math.floor((a[0]-this.extent_[0])/(this.extent_[2]-this.extent_[0])*b.length));93<=a&&a--;35<=a&&a--;a-=32;b=null;a in this.keys_&&(a=this.keys_[a],b=this.data_&&a in this.data_?this.data_[a]:a);return b};
ol.source.TileUTFGrid.Tile_.prototype.forDataAtCoordinate=function(a,b,c,d){this.state==ol.TileState.IDLE&&!0===d?(ol.events.listenOnce(this,ol.events.EventType.CHANGE,function(d){b.call(c,this.getData(a))},this),this.loadInternal_()):!0===d?setTimeout(function(){b.call(c,this.getData(a))}.bind(this),0):b.call(c,this.getData(a))};ol.source.TileUTFGrid.Tile_.prototype.getKey=function(){return this.src_};ol.source.TileUTFGrid.Tile_.prototype.handleError_=function(){this.state=ol.TileState.ERROR;this.changed()};
ol.source.TileUTFGrid.Tile_.prototype.handleLoad_=function(a){this.grid_=a.grid;this.keys_=a.keys;this.data_=a.data;this.state=ol.TileState.EMPTY;this.changed()};
ol.source.TileUTFGrid.Tile_.prototype.loadInternal_=function(){if(this.state==ol.TileState.IDLE)if(this.state=ol.TileState.LOADING,this.jsonp_)ol.net.jsonp(this.src_,this.handleLoad_.bind(this),this.handleError_.bind(this));else{var a=new XMLHttpRequest;a.addEventListener("load",this.onXHRLoad_.bind(this));a.addEventListener("error",this.onXHRError_.bind(this));a.open("GET",this.src_);a.send()}};
ol.source.TileUTFGrid.Tile_.prototype.onXHRLoad_=function(a){a=a.target;if(!a.status||200<=a.status&&300>a.status){try{var b=JSON.parse(a.responseText)}catch(c){this.handleError_();return}this.handleLoad_(b)}else this.handleError_()};ol.source.TileUTFGrid.Tile_.prototype.onXHRError_=function(a){this.handleError_()};ol.source.TileUTFGrid.Tile_.prototype.load=function(){this.preemptive_&&this.loadInternal_()};ol.source.TileWMS=function(a){a=a||{};var b=a.params||{};ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,opaque:!("TRANSPARENT"in b?b.TRANSPARENT:1),projection:a.projection,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileClass:a.tileClass,tileGrid:a.tileGrid,tileLoadFunction:a.tileLoadFunction,url:a.url,urls:a.urls,wrapX:void 0!==a.wrapX?a.wrapX:!0,transition:a.transition});this.gutter_=void 0!==a.gutter?a.gutter:0;
this.params_=b;this.v13_=!0;this.serverType_=a.serverType;this.hidpi_=void 0!==a.hidpi?a.hidpi:!0;this.tmpExtent_=ol.extent.createEmpty();this.updateV13_();this.setKey(this.getKeyForParams_())};ol.inherits(ol.source.TileWMS,ol.source.TileImage);
ol.source.TileWMS.prototype.getGetFeatureInfoUrl=function(a,b,c,d){c=ol.proj.get(c);var e=this.getProjection(),f=this.getTileGrid();f||(f=this.getTileGridForProjection(c));b=f.getTileCoordForCoordAndResolution(a,b);if(!(f.getResolutions().length<=b[0])){var g=f.getResolution(b[0]),h=f.getTileCoordExtent(b,this.tmpExtent_);f=ol.size.toSize(f.getTileSize(b[0]),this.tmpSize);var k=this.gutter_;0!==k&&(f=ol.size.buffer(f,k,this.tmpSize),h=ol.extent.buffer(h,g*k,h));e&&e!==c&&(g=ol.reproj.calculateSourceResolution(e,
c,a,g),h=ol.proj.transformExtent(h,c,e),a=ol.proj.transform(a,c,e));k={SERVICE:"WMS",VERSION:ol.DEFAULT_WMS_VERSION,REQUEST:"GetFeatureInfo",FORMAT:"image/png",TRANSPARENT:!0,QUERY_LAYERS:this.params_.LAYERS};ol.obj.assign(k,this.params_,d);d=Math.floor((h[3]-a[1])/g);k[this.v13_?"I":"X"]=Math.floor((a[0]-h[0])/g);k[this.v13_?"J":"Y"]=d;return this.getRequestUrl_(b,f,h,1,e||c,k)}};ol.source.TileWMS.prototype.getGutterInternal=function(){return this.gutter_};ol.source.TileWMS.prototype.getParams=function(){return this.params_};
ol.source.TileWMS.prototype.getRequestUrl_=function(a,b,c,d,e,f){var g=this.urls;if(g){f.WIDTH=b[0];f.HEIGHT=b[1];f[this.v13_?"CRS":"SRS"]=e.getCode();"STYLES"in this.params_||(f.STYLES="");if(1!=d)switch(this.serverType_){case ol.source.WMSServerType.GEOSERVER:b=90*d+.5|0;f.FORMAT_OPTIONS="FORMAT_OPTIONS"in f?f.FORMAT_OPTIONS+(";dpi:"+b):"dpi:"+b;break;case ol.source.WMSServerType.MAPSERVER:f.MAP_RESOLUTION=90*d;break;case ol.source.WMSServerType.CARMENTA_SERVER:case ol.source.WMSServerType.QGIS:f.DPI=
90*d;break;default:ol.asserts.assert(!1,52)}e=e.getAxisOrientation();this.v13_&&"ne"==e.substr(0,2)&&(e=c[0],c[0]=c[1],c[1]=e,e=c[2],c[2]=c[3],c[3]=e);f.BBOX=c.join(",");1==g.length?g=g[0]:(a=ol.math.modulo(ol.tilecoord.hash(a),g.length),g=g[a]);return ol.uri.appendParams(g,f)}};ol.source.TileWMS.prototype.getTilePixelRatio=function(a){return this.hidpi_&&void 0!==this.serverType_?a:1};
ol.source.TileWMS.prototype.getKeyForParams_=function(){var a=0,b=[],c;for(c in this.params_)b[a++]=c+"-"+this.params_[c];return b.join("/")};
ol.source.TileWMS.prototype.fixedTileUrlFunction=function(a,b,c){var d=this.getTileGrid();d||(d=this.getTileGridForProjection(c));if(!(d.getResolutions().length<=a[0])){1==b||this.hidpi_&&void 0!==this.serverType_||(b=1);var e=d.getResolution(a[0]),f=d.getTileCoordExtent(a,this.tmpExtent_);d=ol.size.toSize(d.getTileSize(a[0]),this.tmpSize);var g=this.gutter_;0!==g&&(d=ol.size.buffer(d,g,this.tmpSize),f=ol.extent.buffer(f,e*g,f));1!=b&&(d=ol.size.scale(d,b,this.tmpSize));e={SERVICE:"WMS",VERSION:ol.DEFAULT_WMS_VERSION,
REQUEST:"GetMap",FORMAT:"image/png",TRANSPARENT:!0};ol.obj.assign(e,this.params_);return this.getRequestUrl_(a,d,f,b,c,e)}};ol.source.TileWMS.prototype.updateParams=function(a){ol.obj.assign(this.params_,a);this.updateV13_();this.setKey(this.getKeyForParams_())};ol.source.TileWMS.prototype.updateV13_=function(){this.v13_=0<=ol.string.compareVersions(this.params_.VERSION||ol.DEFAULT_WMS_VERSION,"1.3")};ol.VectorImageTile=function(a,b,c,d,e,f,g,h,k,l,m,n,p,q,r){ol.Tile.call(this,a,b,r);this.context_={};this.replayState_={};this.sourceTiles_=l;this.tileKeys=[];this.sourceRevision_=c;this.wrappedTileCoord=f;this.loadListenerKeys_=[];this.sourceTileListenerKeys_=[];if(f){var u=k.getTileCoordExtent(f),t=k.getResolution(a[0]);a=h.getZForResolution(t);h.forEachTileCoord(u,a,function(a){var b=ol.extent.getIntersection(u,h.getTileCoordExtent(a)),c=h.getExtent();c&&(b=ol.extent.getIntersection(b,c));.5<=
ol.extent.getWidth(b)/t&&.5<=ol.extent.getHeight(b)/t&&(b=a.toString(),c=l[b],c||(c=g(a,m,n),c=l[b]=new p(a,void 0==c?ol.TileState.EMPTY:ol.TileState.IDLE,void 0==c?"":c,d,e),this.sourceTileListenerKeys_.push(ol.events.listen(c,ol.events.EventType.CHANGE,q))),c.consumers++,this.tileKeys.push(b))}.bind(this))}};ol.inherits(ol.VectorImageTile,ol.Tile);
ol.VectorImageTile.prototype.disposeInternal=function(){for(var a=0,b=this.tileKeys.length;a<b;++a){var c=this.tileKeys[a],d=this.getTile(c);d.consumers--;0==d.consumers&&(delete this.sourceTiles_[c],d.dispose())}this.tileKeys.length=0;this.sourceTiles_=null;this.loadListenerKeys_.forEach(ol.events.unlistenByKey);this.loadListenerKeys_.length=0;this.interimTile&&this.interimTile.dispose();this.state=ol.TileState.ABORT;this.changed();this.sourceTileListenerKeys_.forEach(ol.events.unlistenByKey);this.sourceTileListenerKeys_.length=
0;ol.Tile.prototype.disposeInternal.call(this)};ol.VectorImageTile.prototype.getContext=function(a){a=ol.getUid(a).toString();a in this.context_||(this.context_[a]=ol.dom.createCanvasContext2D());return this.context_[a]};ol.VectorImageTile.prototype.getImage=function(a){return-1==this.getReplayState(a).renderedTileRevision?null:this.getContext(a).canvas};
ol.VectorImageTile.prototype.getReplayState=function(a){a=ol.getUid(a).toString();a in this.replayState_||(this.replayState_[a]={dirty:!1,renderedRenderOrder:null,renderedRevision:-1,renderedTileRevision:-1});return this.replayState_[a]};ol.VectorImageTile.prototype.getKey=function(){return this.tileKeys.join("/")+"-"+this.sourceRevision_};ol.VectorImageTile.prototype.getTile=function(a){return this.sourceTiles_[a]};
ol.VectorImageTile.prototype.load=function(){var a=0,b={};this.state==ol.TileState.IDLE&&this.setState(ol.TileState.LOADING);this.state==ol.TileState.LOADING&&this.tileKeys.forEach(function(c){var d=this.getTile(c);d.state==ol.TileState.IDLE&&(d.setLoader(this.loader_),d.load());d.state==ol.TileState.LOADING&&(c=ol.events.listen(d,ol.events.EventType.CHANGE,function(c){c=d.getState();if(c==ol.TileState.LOADED||c==ol.TileState.ERROR){var e=ol.getUid(d);c==ol.TileState.ERROR?b[e]=!0:(--a,delete b[e]);
0==a-Object.keys(b).length&&this.finishLoading_()}}.bind(this)),this.loadListenerKeys_.push(c),++a)}.bind(this));0==a-Object.keys(b).length&&setTimeout(this.finishLoading_.bind(this),0)};
ol.VectorImageTile.prototype.finishLoading_=function(){for(var a=this.tileKeys.length,b=0,c=a-1;0<=c;--c){var d=this.getTile(this.tileKeys[c]).getState();d!=ol.TileState.LOADED&&--a;d==ol.TileState.EMPTY&&++b}a==this.tileKeys.length?(this.loadListenerKeys_.forEach(ol.events.unlistenByKey),this.loadListenerKeys_.length=0,this.setState(ol.TileState.LOADED)):this.setState(b==this.tileKeys.length?ol.TileState.EMPTY:ol.TileState.ERROR)};
ol.VectorImageTile.defaultLoadFunction=function(a,b){b=ol.featureloader.loadFeaturesXhr(b,a.getFormat(),a.onLoad.bind(a),a.onError.bind(a));a.setLoader(b)};ol.source.VectorTile=function(a){var b=a.projection||"EPSG:3857",c=a.extent||ol.tilegrid.extentFromProjection(b),d=a.tileGrid||ol.tilegrid.createXYZ({extent:c,maxZoom:a.maxZoom||22,minZoom:a.minZoom,tileSize:a.tileSize||512});ol.source.UrlTile.call(this,{attributions:a.attributions,cacheSize:void 0!==a.cacheSize?a.cacheSize:128,extent:c,logo:a.logo,opaque:!1,projection:b,state:a.state,tileGrid:d,tileLoadFunction:a.tileLoadFunction?a.tileLoadFunction:ol.VectorImageTile.defaultLoadFunction,tileUrlFunction:a.tileUrlFunction,
url:a.url,urls:a.urls,wrapX:void 0===a.wrapX?!0:a.wrapX,transition:a.transition});this.format_=a.format?a.format:null;this.sourceTiles_={};this.overlaps_=void 0==a.overlaps?!0:a.overlaps;this.tileClass=a.tileClass?a.tileClass:ol.VectorTile;this.tileGrids_={}};ol.inherits(ol.source.VectorTile,ol.source.UrlTile);ol.source.VectorTile.prototype.getOverlaps=function(){return this.overlaps_};ol.source.VectorTile.prototype.clear=function(){this.tileCache.clear();this.sourceTiles_={}};
ol.source.VectorTile.prototype.getTile=function(a,b,c,d,e){var f=ol.tilecoord.getKeyZXY(a,b,c);if(this.tileCache.containsKey(f))return this.tileCache.get(f);a=[a,b,c];b=this.getTileCoordForTileUrlFunction(a,e);d=new ol.VectorImageTile(a,null!==b?ol.TileState.IDLE:ol.TileState.EMPTY,this.getRevision(),this.format_,this.tileLoadFunction,b,this.tileUrlFunction,this.tileGrid,this.getTileGridForProjection(e),this.sourceTiles_,d,e,this.tileClass,this.handleTileChange.bind(this),this.tileOptions);this.tileCache.set(f,
d);return d};ol.source.VectorTile.prototype.getTileGridForProjection=function(a){var b=a.getCode(),c=this.tileGrids_[b];c||(c=this.tileGrid,c=this.tileGrids_[b]=ol.tilegrid.createForProjection(a,void 0,c?c.getTileSize(c.getMinZoom()):void 0));return c};ol.source.VectorTile.prototype.getTilePixelRatio=function(a){return a};ol.source.VectorTile.prototype.getTilePixelSize=function(a,b,c){a=ol.size.toSize(this.getTileGridForProjection(c).getTileSize(a));return[Math.round(a[0]*b),Math.round(a[1]*b)]};ol.source.WMTSRequestEncoding={KVP:"KVP",REST:"REST"};ol.tilegrid.WMTS=function(a){this.matrixIds_=a.matrixIds;ol.tilegrid.TileGrid.call(this,{extent:a.extent,origin:a.origin,origins:a.origins,resolutions:a.resolutions,tileSize:a.tileSize,tileSizes:a.tileSizes,sizes:a.sizes})};ol.inherits(ol.tilegrid.WMTS,ol.tilegrid.TileGrid);ol.tilegrid.WMTS.prototype.getMatrixId=function(a){return this.matrixIds_[a]};ol.tilegrid.WMTS.prototype.getMatrixIds=function(){return this.matrixIds_};
ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet=function(a,b,c){var d=[],e=[],f=[],g=[],h=[],k=void 0!==c?c:[];c=a.SupportedCRS;c=ol.proj.get(c.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||ol.proj.get(c);var l=c.getMetersPerUnit(),m="ne"==c.getAxisOrientation().substr(0,2);a.TileMatrix.sort(function(a,b){return b.ScaleDenominator-a.ScaleDenominator});a.TileMatrix.forEach(function(a,b,c){if(0<k.length?ol.array.find(k,function(b,c,d){return a.Identifier==b.TileMatrix}):1){e.push(a.Identifier);
b=2.8E-4*a.ScaleDenominator/l;c=a.TileWidth;var n=a.TileHeight;m?f.push([a.TopLeftCorner[1],a.TopLeftCorner[0]]):f.push(a.TopLeftCorner);d.push(b);g.push(c==n?c:[c,n]);h.push([a.MatrixWidth,-a.MatrixHeight])}});return new ol.tilegrid.WMTS({extent:b,origins:f,resolutions:d,matrixIds:e,tileSizes:g,sizes:h})};ol.source.WMTS=function(a){this.version_=void 0!==a.version?a.version:"1.0.0";this.format_=void 0!==a.format?a.format:"image/jpeg";this.dimensions_=void 0!==a.dimensions?a.dimensions:{};this.layer_=a.layer;this.matrixSet_=a.matrixSet;this.style_=a.style;var b=a.urls;void 0===b&&void 0!==a.url&&(b=ol.TileUrlFunction.expandUrl(a.url));var c=this.requestEncoding_=void 0!==a.requestEncoding?a.requestEncoding:ol.source.WMTSRequestEncoding.KVP,d=a.tileGrid,e={layer:this.layer_,style:this.style_,tilematrixset:this.matrixSet_};
c==ol.source.WMTSRequestEncoding.KVP&&ol.obj.assign(e,{Service:"WMTS",Request:"GetTile",Version:this.version_,Format:this.format_});var f=this.dimensions_;this.createFromWMTSTemplate_=function(a){a=c==ol.source.WMTSRequestEncoding.KVP?ol.uri.appendParams(a,e):a.replace(/\{(\w+?)\}/g,function(a,b){return b.toLowerCase()in e?e[b.toLowerCase()]:a});return function(b,e,g){if(b){var h={TileMatrix:d.getMatrixId(b[0]),TileCol:b[1],TileRow:-b[2]-1};ol.obj.assign(h,f);b=a;return b=c==ol.source.WMTSRequestEncoding.KVP?
ol.uri.appendParams(b,h):b.replace(/\{(\w+?)\}/g,function(a,b){return h[b]})}}};var g=b&&0<b.length?ol.TileUrlFunction.createFromTileUrlFunctions(b.map(this.createFromWMTSTemplate_)):ol.TileUrlFunction.nullTileUrlFunction;ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,projection:a.projection,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileClass:a.tileClass,tileGrid:d,tileLoadFunction:a.tileLoadFunction,tilePixelRatio:a.tilePixelRatio,
tileUrlFunction:g,urls:b,wrapX:void 0!==a.wrapX?a.wrapX:!1,transition:a.transition});this.setKey(this.getKeyForDimensions_())};ol.inherits(ol.source.WMTS,ol.source.TileImage);ol.source.WMTS.prototype.setUrls=function(a){this.urls=a;var b=a.join("\n");this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):ol.TileUrlFunction.createFromTileUrlFunctions(a.map(this.createFromWMTSTemplate_.bind(this))),b)};ol.source.WMTS.prototype.getDimensions=function(){return this.dimensions_};
ol.source.WMTS.prototype.getFormat=function(){return this.format_};ol.source.WMTS.prototype.getLayer=function(){return this.layer_};ol.source.WMTS.prototype.getMatrixSet=function(){return this.matrixSet_};ol.source.WMTS.prototype.getRequestEncoding=function(){return this.requestEncoding_};ol.source.WMTS.prototype.getStyle=function(){return this.style_};ol.source.WMTS.prototype.getVersion=function(){return this.version_};
ol.source.WMTS.prototype.getKeyForDimensions_=function(){var a=0,b=[],c;for(c in this.dimensions_)b[a++]=c+"-"+this.dimensions_[c];return b.join("/")};ol.source.WMTS.prototype.updateDimensions=function(a){ol.obj.assign(this.dimensions_,a);this.setKey(this.getKeyForDimensions_())};
ol.source.WMTS.optionsFromCapabilities=function(a,b){var c=ol.array.find(a.Contents.Layer,function(a,c,d){return a.Identifier==b.layer});if(null===c)return null;var d=a.Contents.TileMatrixSet;var e=1<c.TileMatrixSetLink.length?"projection"in b?ol.array.findIndex(c.TileMatrixSetLink,function(a,c,e){c=ol.array.find(d,function(b){return b.Identifier==a.TileMatrixSet}).SupportedCRS;e=ol.proj.get(c.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||ol.proj.get(c);var f=ol.proj.get(b.projection);return e&&
f?ol.proj.equivalent(e,f):c==b.projection}):ol.array.findIndex(c.TileMatrixSetLink,function(a,c,d){return a.TileMatrixSet==b.matrixSet}):0;0>e&&(e=0);var f=c.TileMatrixSetLink[e].TileMatrixSet;var g=c.TileMatrixSetLink[e].TileMatrixSetLimits;var h=c.Format[0];"format"in b&&(h=b.format);e=ol.array.findIndex(c.Style,function(a,c,d){return"style"in b?a.Title==b.style:a.isDefault});0>e&&(e=0);e=c.Style[e].Identifier;var k={};"Dimension"in c&&c.Dimension.forEach(function(a,b,c){b=a.Identifier;c=a.Default;
void 0===c&&(c=a.Value[0]);k[b]=c});var l=ol.array.find(a.Contents.TileMatrixSet,function(a,b,c){return a.Identifier==f}),m,n=l.SupportedCRS;n&&(m=ol.proj.get(n.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,"$1:$3"))||ol.proj.get(n));"projection"in b&&(n=ol.proj.get(b.projection),!n||m&&!ol.proj.equivalent(n,m)||(m=n));n=c.WGS84BoundingBox;if(void 0!==n){var p=ol.proj.get("EPSG:4326").getExtent();p=n[0]==p[0]&&n[2]==p[2];var q=ol.proj.transformExtent(n,"EPSG:4326",m);(n=m.getExtent())&&(ol.extent.containsExtent(n,
q)||(q=void 0))}g=ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet(l,q,g);var r=[];l=b.requestEncoding;l=void 0!==l?l:"";if("OperationsMetadata"in a&&"GetTile"in a.OperationsMetadata)for(a=a.OperationsMetadata.GetTile.DCP.HTTP.Get,q=0,n=a.length;q<n;++q)if(a[q].Constraint){var u=ol.array.find(a[q].Constraint,function(a){return"GetEncoding"==a.name}).AllowedValues.Value;""===l&&(l=u[0]);if(l===ol.source.WMTSRequestEncoding.KVP)ol.array.includes(u,ol.source.WMTSRequestEncoding.KVP)&&r.push(a[q].href);
else break}else a[q].href&&(l=ol.source.WMTSRequestEncoding.KVP,r.push(a[q].href));0===r.length&&(l=ol.source.WMTSRequestEncoding.REST,c.ResourceURL.forEach(function(a){"tile"===a.resourceType&&(h=a.format,r.push(a.template))}));return{urls:r,layer:b.layer,matrixSet:f,format:h,projection:m,requestEncoding:l,tileGrid:g,style:e,dimensions:k,wrapX:p,crossOrigin:b.crossOrigin}};ol.source.Zoomify=function(a){a=a||{};var b=a.size,c=b[0],d=b[1];b=a.extent||[0,-b[1],b[0],0];var e=[],f=a.tileSize||ol.DEFAULT_TILE_SIZE,g=f;switch(void 0!==a.tierSizeCalculation?a.tierSizeCalculation:ol.source.Zoomify.TierSizeCalculation_.DEFAULT){case ol.source.Zoomify.TierSizeCalculation_.DEFAULT:for(;c>g||d>g;)e.push([Math.ceil(c/g),Math.ceil(d/g)]),g+=g;break;case ol.source.Zoomify.TierSizeCalculation_.TRUNCATED:for(;c>g||d>g;)e.push([Math.ceil(c/g),Math.ceil(d/g)]),c>>=1,d>>=1;break;default:ol.asserts.assert(!1,
53)}e.push([1,1]);e.reverse();d=[1];var h=[0];g=1;for(c=e.length;g<c;g++)d.push(1<<g),h.push(e[g-1][0]*e[g-1][1]+h[g-1]);d.reverse();var k=new ol.tilegrid.TileGrid({tileSize:f,extent:b,origin:ol.extent.getTopLeft(b),resolutions:d});(b=a.url)&&-1==b.indexOf("{TileGroup}")&&-1==b.indexOf("{tileIndex}")&&(b+="{TileGroup}/{z}-{x}-{y}.jpg");b=ol.TileUrlFunction.expandUrl(b);b=ol.TileUrlFunction.createFromTileUrlFunctions(b.map(function(a){return function(b,c,d){if(b){c=b[0];d=b[1];b=-b[2]-1;var f=d+b*
e[c][0],g=k.getTileSize(c),l={z:c,x:d,y:b,tileIndex:f,TileGroup:"TileGroup"+((f+h[c])/g|0)};return a.replace(/\{(\w+?)\}/g,function(a,b){return l[b]})}}}));f=ol.source.Zoomify.Tile_.bind(null,k);ol.source.TileImage.call(this,{attributions:a.attributions,cacheSize:a.cacheSize,crossOrigin:a.crossOrigin,logo:a.logo,projection:a.projection,reprojectionErrorThreshold:a.reprojectionErrorThreshold,tileClass:f,tileGrid:k,tileUrlFunction:b,transition:a.transition})};ol.inherits(ol.source.Zoomify,ol.source.TileImage);
ol.source.Zoomify.Tile_=function(a,b,c,d,e,f,g){ol.ImageTile.call(this,b,c,d,e,f,g);this.zoomifyImage_=null;this.tileSize_=ol.size.toSize(a.getTileSize(b[0]))};ol.inherits(ol.source.Zoomify.Tile_,ol.ImageTile);
ol.source.Zoomify.Tile_.prototype.getImage=function(){if(this.zoomifyImage_)return this.zoomifyImage_;var a=ol.ImageTile.prototype.getImage.call(this);if(this.state==ol.TileState.LOADED){var b=this.tileSize_;if(a.width==b[0]&&a.height==b[1])return this.zoomifyImage_=a;b=ol.dom.createCanvasContext2D(b[0],b[1]);b.drawImage(a,0,0);return this.zoomifyImage_=b.canvas}return a};ol.source.Zoomify.TierSizeCalculation_={DEFAULT:"default",TRUNCATED:"truncated"};goog.exportSymbol("ol.Map",ol.Map);goog.exportSymbol("ol.Overlay",ol.Overlay);goog.exportSymbol("ol.View",ol.View);goog.exportSymbol("ol.control.defaults",ol.control.defaults);goog.exportSymbol("ol.control.OverviewMap",ol.control.OverviewMap);goog.exportSymbol("ol.control.ScaleLine",ol.control.ScaleLine);goog.exportSymbol("ol.control.ZoomSlider",ol.control.ZoomSlider);goog.exportSymbol("ol.control.ZoomToExtent",ol.control.ZoomToExtent);goog.exportSymbol("ol.Geolocation",ol.Geolocation);
goog.exportSymbol("ol.geom.LineString",ol.geom.LineString);goog.exportSymbol("ol.geom.MultiLineString",ol.geom.MultiLineString);goog.exportSymbol("ol.geom.MultiPolygon",ol.geom.MultiPolygon);goog.exportSymbol("ol.geom.Point",ol.geom.Point);goog.exportSymbol("ol.geom.Polygon",ol.geom.Polygon);goog.exportSymbol("ol.format.Feature",ol.format.Feature);goog.exportSymbol("ol.format.GeoJSON",ol.format.GeoJSON);goog.exportSymbol("ol.format.GML2",ol.format.GML2);goog.exportSymbol("ol.format.GML3",ol.format.GML3);
goog.exportSymbol("ol.format.GPX",ol.format.GPX);goog.exportSymbol("ol.format.KML",ol.format.KML);goog.exportSymbol("ol.format.WFS",ol.format.WFS);goog.exportSymbol("ol.format.WKT",ol.format.WKT);goog.exportSymbol("ol.format.WMSCapabilities",ol.format.WMSCapabilities);goog.exportSymbol("ol.format.WMSGetFeatureInfo",ol.format.WMSGetFeatureInfo);goog.exportSymbol("ol.format.WMTSCapabilities",ol.format.WMTSCapabilities);goog.exportSymbol("ol.interaction.Draw",ol.interaction.Draw);
goog.exportSymbol("ol.interaction.Pointer",ol.interaction.Pointer);goog.exportSymbol("ol.interaction.Translate",ol.interaction.Translate);goog.exportSymbol("ol.layer.Tile",ol.layer.Tile);goog.exportSymbol("ol.layer.Image",ol.layer.Image);goog.exportSymbol("ol.layer.Vector",ol.layer.Vector);goog.exportSymbol("ol.proj.Projection",ol.proj.Projection);goog.exportSymbol("ol.source.Cluster",ol.source.Cluster);goog.exportSymbol("ol.source.ImageWMS",ol.source.ImageWMS);
goog.exportSymbol("ol.source.WMTS",ol.source.WMTS);goog.exportSymbol("ol.style.Circle",ol.style.Circle);goog.exportSymbol("ol.style.Fill",ol.style.Fill);goog.exportSymbol("ol.style.Icon",ol.style.Icon);goog.exportSymbol("ol.style.Stroke",ol.style.Stroke);goog.exportSymbol("ol.style.Style",ol.style.Style);goog.exportSymbol("ol.style.Text",ol.style.Text);

﻿!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.proj4=b()}(this,function(){"use strict";function a(a,b){if(a[b])return a[b];for(var c,d,e=Object.keys(a),f=b.toLowerCase().replace(Ob,""),g=-1;++g<e.length;)if(c=e[g],d=c.toLowerCase().replace(Ob,""),d===f)return a[c]}function b(a){if("string"!=typeof a)throw new Error("not a string");this.text=a.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=Qb}function c(a){var c=new b(a);return c.output()}function d(a,b,c){Array.isArray(b)&&(c.unshift(b),b=null);var d=b?{}:a,f=c.reduce(function(a,b){return e(b,a),a},d);b&&(a[b]=f)}function e(a,b){if(!Array.isArray(a))return void(b[a]=!0);var c=a.shift();if("PARAMETER"===c&&(c=a.shift()),1===a.length)return Array.isArray(a[0])?(b[c]={},void e(a[0],b[c])):void(b[c]=a[0]);if(!a.length)return void(b[c]=!0);if("TOWGS84"===c)return void(b[c]=a);Array.isArray(c)||(b[c]={});var f;switch(c){case"UNIT":case"PRIMEM":case"VERT_DATUM":return b[c]={name:a[0].toLowerCase(),convert:a[1]},void(3===a.length&&e(a[2],b[c]));case"SPHEROID":case"ELLIPSOID":return b[c]={name:a[0],a:a[1],rf:a[2]},void(4===a.length&&e(a[3],b[c]));case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"EDATUM":case"ENGINEERINGDATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":case"COMPD_CS":case"COMPOUNDCRS":case"ENGINEERINGCRS":case"ENGCRS":case"FITTED_CS":case"LOCAL_DATUM":case"DATUM":return a[0]=["name",a[0]],void d(b,c,a);default:for(f=-1;++f<a.length;)if(!Array.isArray(a[f]))return e(a,b[c]);return d(b,c,a)}}function f(a,b){var c=b[0],d=b[1];!(c in a)&&d in a&&(a[c]=a[d],3===b.length&&(a[c]=b[2](a[c])))}function g(a){return a*_b}function h(a){function b(b){var c=a.to_meter||1;return b*c}"GEOGCS"===a.type?a.projName="longlat":"LOCAL_CS"===a.type?(a.projName="identity",a.local=!0):"object"==typeof a.PROJECTION?a.projName=Object.keys(a.PROJECTION)[0]:a.projName=a.PROJECTION,a.UNIT&&(a.units=a.UNIT.name.toLowerCase(),"metre"===a.units&&(a.units="meter"),a.UNIT.convert&&("GEOGCS"===a.type?a.DATUM&&a.DATUM.SPHEROID&&(a.to_meter=a.UNIT.convert*a.DATUM.SPHEROID.a):(a.to_meter=a.UNIT.convert,10)));var c=a.GEOGCS;"GEOGCS"===a.type&&(c=a),c&&(c.DATUM?a.datumCode=c.DATUM.name.toLowerCase():a.datumCode=c.name.toLowerCase(),"d_"===a.datumCode.slice(0,2)&&(a.datumCode=a.datumCode.slice(2)),"new_zealand_geodetic_datum_1949"!==a.datumCode&&"new_zealand_1949"!==a.datumCode||(a.datumCode="nzgd49"),"wgs_1984"===a.datumCode&&("Mercator_Auxiliary_Sphere"===a.PROJECTION&&(a.sphere=!0),a.datumCode="wgs84"),"_ferro"===a.datumCode.slice(-6)&&(a.datumCode=a.datumCode.slice(0,-6)),"_jakarta"===a.datumCode.slice(-8)&&(a.datumCode=a.datumCode.slice(0,-8)),~a.datumCode.indexOf("belge")&&(a.datumCode="rnb72"),c.DATUM&&c.DATUM.SPHEROID&&(a.ellps=c.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===a.ellps.toLowerCase().slice(0,13)&&(a.ellps="intl"),a.a=c.DATUM.SPHEROID.a,a.rf=parseFloat(c.DATUM.SPHEROID.rf,10)),~a.datumCode.indexOf("osgb_1936")&&(a.datumCode="osgb36")),a.b&&!isFinite(a.b)&&(a.b=a.a);var d=function(b){return f(a,b)},e=[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_2","Standard_Parallel_2"],["false_easting","False_Easting"],["false_northing","False_Northing"],["central_meridian","Central_Meridian"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",g],["longitude_of_center","Longitude_Of_Center"],["longc","longitude_of_center",g],["x0","false_easting",b],["y0","false_northing",b],["long0","central_meridian",g],["lat0","latitude_of_origin",g],["lat0","standard_parallel_1",g],["lat1","standard_parallel_1",g],["lat2","standard_parallel_2",g],["alpha","azimuth",g],["srsCode","name"]];e.forEach(d),a.long0||!a.longc||"Albers_Conic_Equal_Area"!==a.projName&&"Lambert_Azimuthal_Equal_Area"!==a.projName||(a.long0=a.longc),a.lat_ts||!a.lat1||"Stereographic_South_Pole"!==a.projName&&"Polar Stereographic (variant B)"!==a.projName||(a.lat0=g(a.lat1>0?90:-90),a.lat_ts=a.lat1)}function i(a){var b=this;if(2===arguments.length){var c=arguments[1];"string"==typeof c?"+"===c.charAt(0)?i[a]=Pb(arguments[1]):i[a]=ac(arguments[1]):i[a]=c}else if(1===arguments.length){if(Array.isArray(a))return a.map(function(a){Array.isArray(a)?i.apply(b,a):i(a)});if("string"==typeof a){if(a in i)return i[a]}else"EPSG"in a?i["EPSG:"+a.EPSG]=a:"ESRI"in a?i["ESRI:"+a.ESRI]=a:"IAU2000"in a?i["IAU2000:"+a.IAU2000]=a:console.log(a);return}}function j(a){return"string"==typeof a}function k(a){return a in i}function l(a){return bc.some(function(b){return a.indexOf(b)>-1})}function m(a){return"+"===a[0]}function n(a){return j(a)?k(a)?i[a]:l(a)?ac(a):m(a)?Pb(a):void 0:a}function o(){var a=this.b/this.a;this.es=1-a*a,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1)}function p(a){var b=a.x,c=a.y;if(c*Ib>90&&c*Ib<-90&&b*Ib>180&&b*Ib<-180)return null;var d,e;if(Math.abs(Math.abs(c)-Cb)<=Gb)return null;if(this.sphere)d=this.x0+this.a*this.k0*fc(b-this.long0),e=this.y0+this.a*this.k0*Math.log(Math.tan(Jb+.5*c));else{var f=Math.sin(c),g=gc(this.e,c,f);d=this.x0+this.a*this.k0*fc(b-this.long0),e=this.y0-this.a*this.k0*Math.log(g)}return a.x=d,a.y=e,a}function q(a){var b,c,d=a.x-this.x0,e=a.y-this.y0;if(this.sphere)c=Cb-2*Math.atan(Math.exp(-e/(this.a*this.k0)));else{var f=Math.exp(-e/(this.a*this.k0));if(c=hc(this.e,f),c===-9999)return null}return b=fc(this.long0+d/(this.a*this.k0)),a.x=b,a.y=c,a}function r(){}function s(a){return a}function t(a,b){var c=oc.length;return a.names?(oc[c]=a,a.names.forEach(function(a){nc[a.toLowerCase()]=c}),this):(console.log(b),!0)}function u(a){if(!a)return!1;var b=a.toLowerCase();return"undefined"!=typeof nc[b]&&oc[nc[b]]?oc[nc[b]]:void 0}function v(){mc.forEach(t)}function w(a,b,c,d){var e=a*a,f=b*b,g=(e-f)/e,h=0;d?(a*=1-g*(Db+g*(Eb+g*Fb)),e=a*a,g=0):h=Math.sqrt(g);var i=(e-f)/f;return{es:g,e:h,ep2:i}}function x(b,c,d,e,f){if(!b){var g=a(qc,e);g||(g=rc),b=g.a,c=g.b,d=g.rf}return d&&!c&&(c=(1-1/d)*b),(0===d||Math.abs(b-c)<Gb)&&(f=!0,c=b),{a:b,b:c,rf:d,sphere:f}}function y(a,b,c,d,e,f){var g={};return void 0===a||"none"===a?g.datum_type=Ab:g.datum_type=zb,b&&(g.datum_params=b.map(parseFloat),0===g.datum_params[0]&&0===g.datum_params[1]&&0===g.datum_params[2]||(g.datum_type=xb),g.datum_params.length>3&&(0===g.datum_params[3]&&0===g.datum_params[4]&&0===g.datum_params[5]&&0===g.datum_params[6]||(g.datum_type=yb,g.datum_params[3]*=Bb,g.datum_params[4]*=Bb,g.datum_params[5]*=Bb,g.datum_params[6]=g.datum_params[6]/1e6+1))),g.a=c,g.b=d,g.es=e,g.ep2=f,g}function z(b,c){if(!(this instanceof z))return new z(b);c=c||function(a){if(a)throw a};var d=n(b);if("object"!=typeof d)return void c(b);var e=z.projections.get(d.projName);if(!e)return void c(b);if(d.datumCode&&"none"!==d.datumCode){var f=a(sc,d.datumCode);f&&(d.datum_params=f.towgs84?f.towgs84.split(","):null,d.ellps=f.ellipse,d.datumName=f.datumName?f.datumName:d.datumCode)}d.k0=d.k0||1,d.axis=d.axis||"enu",d.ellps=d.ellps||"wgs84";var g=x(d.a,d.b,d.rf,d.ellps,d.sphere),h=w(g.a,g.b,g.rf,d.R_A),i=d.datum||y(d.datumCode,d.datum_params,g.a,g.b,h.es,h.ep2);cc(this,d),cc(this,e),this.a=g.a,this.b=g.b,this.rf=g.rf,this.sphere=g.sphere,this.es=h.es,this.e=h.e,this.ep2=h.ep2,this.datum=i,this.init(),c(null,this)}function A(a,b){return a.datum_type===b.datum_type&&(!(a.a!==b.a||Math.abs(a.es-b.es)>5e-11)&&(a.datum_type===xb?a.datum_params[0]===b.datum_params[0]&&a.datum_params[1]===b.datum_params[1]&&a.datum_params[2]===b.datum_params[2]:a.datum_type!==yb||a.datum_params[0]===b.datum_params[0]&&a.datum_params[1]===b.datum_params[1]&&a.datum_params[2]===b.datum_params[2]&&a.datum_params[3]===b.datum_params[3]&&a.datum_params[4]===b.datum_params[4]&&a.datum_params[5]===b.datum_params[5]&&a.datum_params[6]===b.datum_params[6]))}function B(a,b,c){var d,e,f,g,h=a.x,i=a.y,j=a.z?a.z:0;if(i<-Cb&&i>-1.001*Cb)i=-Cb;else if(i>Cb&&i<1.001*Cb)i=Cb;else if(i<-Cb||i>Cb)return null;return h>Math.PI&&(h-=2*Math.PI),e=Math.sin(i),g=Math.cos(i),f=e*e,d=c/Math.sqrt(1-b*f),{x:(d+j)*g*Math.cos(h),y:(d+j)*g*Math.sin(h),z:(d*(1-b)+j)*e}}function C(a,b,c,d){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=1e-12,v=u*u,w=30,x=a.x,y=a.y,z=a.z?a.z:0;if(e=Math.sqrt(x*x+y*y),f=Math.sqrt(x*x+y*y+z*z),e/c<u){if(r=0,f/c<u)return s=Cb,t=-d,{x:a.x,y:a.y,z:a.z}}else r=Math.atan2(y,x);g=z/f,h=e/f,i=1/Math.sqrt(1-b*(2-b)*h*h),l=h*(1-b)*i,m=g*i,q=0;do q++,k=c/Math.sqrt(1-b*m*m),t=e*l+z*m-k*(1-b*m*m),j=b*k/(k+t),i=1/Math.sqrt(1-j*(2-j)*h*h),n=h*(1-j)*i,o=g*i,p=o*l-n*m,l=n,m=o;while(p*p>v&&q<w);return s=Math.atan(o/Math.abs(n)),{x:r,y:s,z:t}}function D(a,b,c){if(b===xb)return{x:a.x+c[0],y:a.y+c[1],z:a.z+c[2]};if(b===yb){var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],i=c[5],j=c[6];return{x:j*(a.x-i*a.y+h*a.z)+d,y:j*(i*a.x+a.y-g*a.z)+e,z:j*(-h*a.x+g*a.y+a.z)+f}}}function E(a,b,c){if(b===xb)return{x:a.x-c[0],y:a.y-c[1],z:a.z-c[2]};if(b===yb){var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],i=c[5],j=c[6],k=(a.x-d)/j,l=(a.y-e)/j,m=(a.z-f)/j;return{x:k+i*l-h*m,y:-i*k+l+g*m,z:h*k-g*l+m}}}function F(a){return a===xb||a===yb}function G(a,b){return(a.datum.datum_type===xb||a.datum.datum_type===yb)&&"WGS84"!==b.datumCode||(b.datum.datum_type===xb||b.datum.datum_type===yb)&&"WGS84"!==a.datumCode}function H(a,b,c){var d;return Array.isArray(c)&&(c=vc(c)),a.datum&&b.datum&&G(a,b)&&(d=new z("WGS84"),c=H(a,d,c),a=d),"enu"!==a.axis&&(c=uc(a,!1,c)),"longlat"===a.projName?c={x:c.x*Hb,y:c.y*Hb}:(a.to_meter&&(c={x:c.x*a.to_meter,y:c.y*a.to_meter}),c=a.inverse(c)),a.from_greenwich&&(c.x+=a.from_greenwich),c=tc(a.datum,b.datum,c),b.from_greenwich&&(c={x:c.x-b.from_greenwich,y:c.y}),"longlat"===b.projName?c={x:c.x*Ib,y:c.y*Ib}:(c=b.forward(c),b.to_meter&&(c={x:c.x/b.to_meter,y:c.y/b.to_meter})),"enu"!==b.axis?uc(b,!0,c):c}function I(a,b,c){var d;return Array.isArray(c)?(d=H(a,b,c),3===c.length?[d.x,d.y,d.z]:[d.x,d.y]):H(a,b,c)}function J(a){return a instanceof z?a:a.oProj?a.oProj:z(a)}function K(a,b,c){a=J(a);var d,e=!1;return"undefined"==typeof b?(b=a,a=wc,e=!0):("undefined"!=typeof b.x||Array.isArray(b))&&(c=b,b=a,a=wc,e=!0),b=J(b),c?I(a,b,c):(d={forward:function(c){return I(a,b,c)},inverse:function(c){return I(b,a,c)}},e&&(d.oProj=b),d)}function L(a,b){return b=b||5,T(Q({lat:a[1],lon:a[0]}),b)}function M(a){var b=R(X(a.toUpperCase()));return b.lat&&b.lon?[b.lon,b.lat,b.lon,b.lat]:[b.left,b.bottom,b.right,b.top]}function N(a){var b=R(X(a.toUpperCase()));return b.lat&&b.lon?[b.lon,b.lat]:[(b.left+b.right)/2,(b.top+b.bottom)/2]}function O(a){return a*(Math.PI/180)}function P(a){return 180*(a/Math.PI)}function Q(a){var b,c,d,e,f,g,h,i,j,k=a.lat,l=a.lon,m=6378137,n=.00669438,o=.9996,p=O(k),q=O(l);j=Math.floor((l+180)/6)+1,180===l&&(j=60),k>=56&&k<64&&l>=3&&l<12&&(j=32),k>=72&&k<84&&(l>=0&&l<9?j=31:l>=9&&l<21?j=33:l>=21&&l<33?j=35:l>=33&&l<42&&(j=37)),b=6*(j-1)-180+3,i=O(b),c=n/(1-n),d=m/Math.sqrt(1-n*Math.sin(p)*Math.sin(p)),e=Math.tan(p)*Math.tan(p),f=c*Math.cos(p)*Math.cos(p),g=Math.cos(p)*(q-i),h=m*((1-n/4-3*n*n/64-5*n*n*n/256)*p-(3*n/8+3*n*n/32+45*n*n*n/1024)*Math.sin(2*p)+(15*n*n/256+45*n*n*n/1024)*Math.sin(4*p)-35*n*n*n/3072*Math.sin(6*p));var r=o*d*(g+(1-e+f)*g*g*g/6+(5-18*e+e*e+72*f-58*c)*g*g*g*g*g/120)+5e5,s=o*(h+d*Math.tan(p)*(g*g/2+(5-e+9*f+4*f*f)*g*g*g*g/24+(61-58*e+e*e+600*f-330*c)*g*g*g*g*g*g/720));return k<0&&(s+=1e7),{northing:Math.round(s),easting:Math.round(r),zoneNumber:j,zoneLetter:S(k)}}function R(a){var b=a.northing,c=a.easting,d=a.zoneLetter,e=a.zoneNumber;if(e<0||e>60)return null;var f,g,h,i,j,k,l,m,n,o,p=.9996,q=6378137,r=.00669438,s=(1-Math.sqrt(1-r))/(1+Math.sqrt(1-r)),t=c-5e5,u=b;d<"N"&&(u-=1e7),m=6*(e-1)-180+3,f=r/(1-r),l=u/p,n=l/(q*(1-r/4-3*r*r/64-5*r*r*r/256)),o=n+(3*s/2-27*s*s*s/32)*Math.sin(2*n)+(21*s*s/16-55*s*s*s*s/32)*Math.sin(4*n)+151*s*s*s/96*Math.sin(6*n),g=q/Math.sqrt(1-r*Math.sin(o)*Math.sin(o)),h=Math.tan(o)*Math.tan(o),i=f*Math.cos(o)*Math.cos(o),j=q*(1-r)/Math.pow(1-r*Math.sin(o)*Math.sin(o),1.5),k=t/(g*p);var v=o-g*Math.tan(o)/j*(k*k/2-(5+3*h+10*i-4*i*i-9*f)*k*k*k*k/24+(61+90*h+298*i+45*h*h-252*f-3*i*i)*k*k*k*k*k*k/720);v=P(v);var w=(k-(1+2*h+i)*k*k*k/6+(5-2*i+28*h-3*i*i+8*f+24*h*h)*k*k*k*k*k/120)/Math.cos(o);w=m+P(w);var x;if(a.accuracy){var y=R({northing:a.northing+a.accuracy,easting:a.easting+a.accuracy,zoneLetter:a.zoneLetter,zoneNumber:a.zoneNumber});x={top:y.lat,right:y.lon,bottom:v,left:w}}else x={lat:v,lon:w};return x}function S(a){var b="Z";return 84>=a&&a>=72?b="X":72>a&&a>=64?b="W":64>a&&a>=56?b="V":56>a&&a>=48?b="U":48>a&&a>=40?b="T":40>a&&a>=32?b="S":32>a&&a>=24?b="R":24>a&&a>=16?b="Q":16>a&&a>=8?b="P":8>a&&a>=0?b="N":0>a&&a>=-8?b="M":-8>a&&a>=-16?b="L":-16>a&&a>=-24?b="K":-24>a&&a>=-32?b="J":-32>a&&a>=-40?b="H":-40>a&&a>=-48?b="G":-48>a&&a>=-56?b="F":-56>a&&a>=-64?b="E":-64>a&&a>=-72?b="D":-72>a&&a>=-80&&(b="C"),b}function T(a,b){var c="00000"+a.easting,d="00000"+a.northing;return a.zoneNumber+a.zoneLetter+U(a.easting,a.northing,a.zoneNumber)+c.substr(c.length-5,b)+d.substr(d.length-5,b)}function U(a,b,c){var d=V(c),e=Math.floor(a/1e5),f=Math.floor(b/1e5)%20;return W(e,f,d)}function V(a){var b=a%xc;return 0===b&&(b=xc),b}function W(a,b,c){var d=c-1,e=yc.charCodeAt(d),f=zc.charCodeAt(d),g=e+a-1,h=f+b,i=!1;g>Ec&&(g=g-Ec+Ac-1,i=!0),(g===Bc||e<Bc&&g>Bc||(g>Bc||e<Bc)&&i)&&g++,(g===Cc||e<Cc&&g>Cc||(g>Cc||e<Cc)&&i)&&(g++,g===Bc&&g++),g>Ec&&(g=g-Ec+Ac-1),h>Dc?(h=h-Dc+Ac-1,i=!0):i=!1,(h===Bc||f<Bc&&h>Bc||(h>Bc||f<Bc)&&i)&&h++,(h===Cc||f<Cc&&h>Cc||(h>Cc||f<Cc)&&i)&&(h++,h===Bc&&h++),h>Dc&&(h=h-Dc+Ac-1);var j=String.fromCharCode(g)+String.fromCharCode(h);return j}function X(a){if(a&&0===a.length)throw"MGRSPoint coverting from nothing";for(var b,c=a.length,d=null,e="",f=0;!/[A-Z]/.test(b=a.charAt(f));){if(f>=2)throw"MGRSPoint bad conversion from: "+a;e+=b,f++}var g=parseInt(e,10);if(0===f||f+3>c)throw"MGRSPoint bad conversion from: "+a;var h=a.charAt(f++);if(h<="A"||"B"===h||"Y"===h||h>="Z"||"I"===h||"O"===h)throw"MGRSPoint zone letter "+h+" not handled: "+a;d=a.substring(f,f+=2);for(var i=V(g),j=Y(d.charAt(0),i),k=Z(d.charAt(1),i);k<$(h);)k+=2e6;var l=c-f;if(l%2!==0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+a;var m,n,o,p,q,r=l/2,s=0,t=0;return r>0&&(m=1e5/Math.pow(10,r),n=a.substring(f,f+r),s=parseFloat(n)*m,o=a.substring(f+r),t=parseFloat(o)*m),p=s+j,q=t+k,{easting:p,northing:q,zoneLetter:h,zoneNumber:g,accuracy:m}}function Y(a,b){for(var c=yc.charCodeAt(b-1),d=1e5,e=!1;c!==a.charCodeAt(0);){if(c++,c===Bc&&c++,c===Cc&&c++,c>Ec){if(e)throw"Bad character: "+a;c=Ac,e=!0}d+=1e5}return d}function Z(a,b){if(a>"V")throw"MGRSPoint given invalid Northing "+a;for(var c=zc.charCodeAt(b-1),d=0,e=!1;c!==a.charCodeAt(0);){if(c++,c===Bc&&c++,c===Cc&&c++,c>Dc){if(e)throw"Bad character: "+a;c=Ac,e=!0}d+=1e5}return d}function $(a){var b;switch(a){case"C":b=11e5;break;case"D":b=2e6;break;case"E":b=28e5;break;case"F":b=37e5;break;case"G":b=46e5;break;case"H":b=55e5;break;case"J":b=64e5;break;case"K":b=73e5;break;case"L":b=82e5;break;case"M":b=91e5;break;case"N":b=0;break;case"P":b=8e5;break;case"Q":b=17e5;break;case"R":b=26e5;break;case"S":b=35e5;break;case"T":b=44e5;break;case"U":b=53e5;break;case"V":b=62e5;break;case"W":b=7e6;break;case"X":b=79e5;break;default:b=-1}if(b>=0)return b;throw"Invalid zone letter: "+a}function Point(a,b,c){if(!(this instanceof Point))return new Point(a,b,c);if(Array.isArray(a))this.x=a[0],this.y=a[1],this.z=a[2]||0;else if("object"==typeof a)this.x=a.x,this.y=a.y,this.z=a.z||0;else if("string"==typeof a&&"undefined"==typeof b){var d=a.split(",");this.x=parseFloat(d[0],10),this.y=parseFloat(d[1],10),this.z=parseFloat(d[2],10)||0}else this.x=a,this.y=b,this.z=c||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}function _(){this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.es&&(this.en=Tc(this.es),this.ml0=Uc(this.lat0,Math.sin(this.lat0),Math.cos(this.lat0),this.en))}function aa(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0),h=Math.sin(f),i=Math.cos(f);if(this.es){var j=i*g,k=Math.pow(j,2),l=this.ep2*Math.pow(i,2),m=Math.pow(l,2),n=Math.abs(i)>Gb?Math.tan(f):0,o=Math.pow(n,2),p=Math.pow(o,2);b=1-this.es*Math.pow(h,2),j/=Math.sqrt(b);var q=Uc(f,h,i,this.en);c=this.a*(this.k0*j*(1+k/6*(1-o+l+k/20*(5-18*o+p+14*l-58*o*l+k/42*(61+179*p-p*o-479*o)))))+this.x0,d=this.a*(this.k0*(q-this.ml0+h*g*j/2*(1+k/12*(5-o+9*l+4*m+k/30*(61+p-58*o+270*l-330*o*l+k/56*(1385+543*p-p*o-3111*o))))))+this.y0}else{var r=i*Math.sin(g);if(Math.abs(Math.abs(r)-1)<Gb)return 93;if(c=.5*this.a*this.k0*Math.log((1+r)/(1-r))+this.x0,d=i*Math.cos(g)/Math.sqrt(1-Math.pow(r,2)),r=Math.abs(d),r>=1){if(r-1>Gb)return 93;d=0}else d=Math.acos(d);f<0&&(d=-d),d=this.a*this.k0*(d-this.lat0)+this.y0}return a.x=c,a.y=d,a}function ba(a){var b,c,d,e,f=(a.x-this.x0)*(1/this.a),g=(a.y-this.y0)*(1/this.a);if(this.es)if(b=this.ml0+g/this.k0,c=Wc(b,this.es,this.en),Math.abs(c)<Cb){var h=Math.sin(c),i=Math.cos(c),j=Math.abs(i)>Gb?Math.tan(c):0,k=this.ep2*Math.pow(i,2),l=Math.pow(k,2),m=Math.pow(j,2),n=Math.pow(m,2);b=1-this.es*Math.pow(h,2);var o=f*Math.sqrt(b)/this.k0,p=Math.pow(o,2);b*=j,d=c-b*p/(1-this.es)*.5*(1-p/12*(5+3*m-9*k*m+k-4*l-p/30*(61+90*m-252*k*m+45*n+46*k-p/56*(1385+3633*m+4095*n+1574*n*m)))),e=fc(this.long0+o*(1-p/6*(1+2*m+k-p/20*(5+28*m+24*n+8*k*m+6*k-p/42*(61+662*m+1320*n+720*n*m))))/i)}else d=Cb*ec(g),e=0;else{var q=Math.exp(f/this.k0),r=.5*(q-1/q),s=this.lat0+g/this.k0,t=Math.cos(s);b=Math.sqrt((1-Math.pow(t,2))/(1+Math.pow(r,2))),d=Math.asin(b),g<0&&(d=-d),e=0===r&&0===t?0:fc(Math.atan2(r,t)+this.long0)}return a.x=e,a.y=d,a}function ca(){if(void 0===this.es||this.es<=0)throw new Error("incorrect elliptical usage");this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.cgb=[],this.cbg=[],this.utg=[],this.gtu=[];var a=this.es/(1+Math.sqrt(1-this.es)),b=a/(2-a),c=b;this.cgb[0]=b*(2+b*(-2/3+b*(-2+b*(116/45+b*(26/45+b*(-2854/675)))))),this.cbg[0]=b*(-2+b*(2/3+b*(4/3+b*(-82/45+b*(32/45+b*(4642/4725)))))),c*=b,this.cgb[1]=c*(7/3+b*(-1.6+b*(-227/45+b*(2704/315+b*(2323/945))))),this.cbg[1]=c*(5/3+b*(-16/15+b*(-13/9+b*(904/315+b*(-1522/945))))),c*=b,this.cgb[2]=c*(56/15+b*(-136/35+b*(-1262/105+b*(73814/2835)))),this.cbg[2]=c*(-26/15+b*(34/21+b*(1.6+b*(-12686/2835)))),c*=b,this.cgb[3]=c*(4279/630+b*(-332/35+b*(-399572/14175))),this.cbg[3]=c*(1237/630+b*(-2.4+b*(-24832/14175))),c*=b,this.cgb[4]=c*(4174/315+b*(-144838/6237)),this.cbg[4]=c*(-734/315+b*(109598/31185)),c*=b,this.cgb[5]=c*(601676/22275),this.cbg[5]=c*(444337/155925),c=Math.pow(b,2),this.Qn=this.k0/(1+b)*(1+c*(.25+c*(1/64+c/256))),this.utg[0]=b*(-.5+b*(2/3+b*(-37/96+b*(1/360+b*(81/512+b*(-96199/604800)))))),this.gtu[0]=b*(.5+b*(-2/3+b*(5/16+b*(41/180+b*(-127/288+b*(7891/37800)))))),this.utg[1]=c*(-1/48+b*(-1/15+b*(437/1440+b*(-46/105+b*(1118711/3870720))))),this.gtu[1]=c*(13/48+b*(-.6+b*(557/1440+b*(281/630+b*(-1983433/1935360))))),c*=b,this.utg[2]=c*(-17/480+b*(37/840+b*(209/4480+b*(-5569/90720)))),this.gtu[2]=c*(61/240+b*(-103/140+b*(15061/26880+b*(167603/181440)))),c*=b,this.utg[3]=c*(-4397/161280+b*(11/504+b*(830251/7257600))),this.gtu[3]=c*(49561/161280+b*(-179/168+b*(6601661/7257600))),c*=b,this.utg[4]=c*(-4583/161280+b*(108847/3991680)),this.gtu[4]=c*(34729/80640+b*(-3418889/1995840)),c*=b,this.utg[5]=c*-.03233083094085698,this.gtu[5]=.6650675310896665*c;var d=bd(this.cbg,this.lat0);this.Zb=-this.Qn*(d+cd(this.gtu,2*d))}function da(a){var b=fc(a.x-this.long0),c=a.y;c=bd(this.cbg,c);var d=Math.sin(c),e=Math.cos(c),f=Math.sin(b),g=Math.cos(b);c=Math.atan2(d,g*e),b=Math.atan2(f*e,$c(d,e*g)),b=ad(Math.tan(b));var h=ed(this.gtu,2*c,2*b);c+=h[0],b+=h[1];var i,j;return Math.abs(b)<=2.623395162778?(i=this.a*(this.Qn*b)+this.x0,j=this.a*(this.Qn*c+this.Zb)+this.y0):(i=1/0,j=1/0),a.x=i,a.y=j,a}function ea(a){var b=(a.x-this.x0)*(1/this.a),c=(a.y-this.y0)*(1/this.a);c=(c-this.Zb)/this.Qn,b/=this.Qn;var d,e;if(Math.abs(b)<=2.623395162778){var f=ed(this.utg,2*c,2*b);c+=f[0],b+=f[1],b=Math.atan(Zc(b));var g=Math.sin(c),h=Math.cos(c),i=Math.sin(b),j=Math.cos(b);c=Math.atan2(g*j,$c(i,j*h)),b=Math.atan2(i,j*h),d=fc(b+this.long0),e=bd(this.cgb,c)}else d=1/0,e=1/0;return a.x=d,a.y=e,a}function fa(){var a=hd(this.zone,this.long0);if(void 0===a)throw new Error("unknown utm zone");this.lat0=0,this.long0=(6*Math.abs(a)-183)*Hb,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,gd.init.apply(this),this.forward=gd.forward,this.inverse=gd.inverse}function ga(){var a=Math.sin(this.lat0),b=Math.cos(this.lat0);b*=b,this.rc=Math.sqrt(1-this.es)/(1-this.es*a*a),this.C=Math.sqrt(1+this.es*b*b/(1-this.es)),this.phic0=Math.asin(a/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+Jb)/(Math.pow(Math.tan(.5*this.lat0+Jb),this.C)*ld(this.e*a,this.ratexp))}function ha(a){var b=a.x,c=a.y;return a.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*c+Jb),this.C)*ld(this.e*Math.sin(c),this.ratexp))-Cb,a.x=this.C*b,a}function ia(a){for(var b=1e-14,c=a.x/this.C,d=a.y,e=Math.pow(Math.tan(.5*d+Jb)/this.K,1/this.C),f=md;f>0&&(d=2*Math.atan(e*ld(this.e*Math.sin(a.y),-.5*this.e))-Cb,!(Math.abs(d-a.y)<b));--f)a.y=d;return f?(a.x=c,a.y=d,a):null}function ja(){od.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))}function ka(a){var b,c,d,e;return a.x=fc(a.x-this.long0),od.forward.apply(this,[a]),b=Math.sin(a.y),c=Math.cos(a.y),d=Math.cos(a.x),e=this.k0*this.R2/(1+this.sinc0*b+this.cosc0*c*d),a.x=e*c*Math.sin(a.x),a.y=e*(this.cosc0*b-this.sinc0*c*d),a.x=this.a*a.x+this.x0,a.y=this.a*a.y+this.y0,a}function la(a){var b,c,d,e,f;if(a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,f=Math.sqrt(a.x*a.x+a.y*a.y)){var g=2*Math.atan2(f,this.R2);b=Math.sin(g),c=Math.cos(g),e=Math.asin(c*this.sinc0+a.y*b*this.cosc0/f),d=Math.atan2(a.x*b,f*this.cosc0*c-a.y*this.sinc0*b)}else e=this.phic0,d=0;return a.x=d,a.y=e,od.inverse.apply(this,[a]),a.x=fc(a.x+this.long0),a}function ma(a,b,c){return b*=c,Math.tan(.5*(Cb+a))*Math.pow((1-b)/(1+b),.5*c)}function na(){this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=Gb&&(this.k0=.5*(1+ec(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=Gb&&(this.lat0>0?this.con=1:this.con=-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=Gb&&(this.k0=.5*this.cons*dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/gc(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=dc(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-Cb,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))}function oa(a){var b,c,d,e,f,g,h=a.x,i=a.y,j=Math.sin(i),k=Math.cos(i),l=fc(h-this.long0);return Math.abs(Math.abs(h-this.long0)-Math.PI)<=Gb&&Math.abs(i+this.lat0)<=Gb?(a.x=NaN,a.y=NaN,a):this.sphere?(b=2*this.k0/(1+this.sinlat0*j+this.coslat0*k*Math.cos(l)),a.x=this.a*b*k*Math.sin(l)+this.x0,a.y=this.a*b*(this.coslat0*j-this.sinlat0*k*Math.cos(l))+this.y0,a):(c=2*Math.atan(this.ssfn_(i,j,this.e))-Cb,e=Math.cos(c),d=Math.sin(c),Math.abs(this.coslat0)<=Gb?(f=gc(this.e,i*this.con,this.con*j),g=2*this.a*this.k0*f/this.cons,a.x=this.x0+g*Math.sin(h-this.long0),a.y=this.y0-this.con*g*Math.cos(h-this.long0),a):(Math.abs(this.sinlat0)<Gb?(b=2*this.a*this.k0/(1+e*Math.cos(l)),a.y=b*d):(b=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*d+this.cosX0*e*Math.cos(l))),a.y=b*(this.cosX0*d-this.sinX0*e*Math.cos(l))+this.y0),a.x=b*e*Math.sin(l)+this.x0,a))}function pa(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g=Math.sqrt(a.x*a.x+a.y*a.y);if(this.sphere){var h=2*Math.atan(g/(.5*this.a*this.k0));return b=this.long0,c=this.lat0,g<=Gb?(a.x=b,a.y=c,a):(c=Math.asin(Math.cos(h)*this.sinlat0+a.y*Math.sin(h)*this.coslat0/g),b=fc(Math.abs(this.coslat0)<Gb?this.lat0>0?this.long0+Math.atan2(a.x,-1*a.y):this.long0+Math.atan2(a.x,a.y):this.long0+Math.atan2(a.x*Math.sin(h),g*this.coslat0*Math.cos(h)-a.y*this.sinlat0*Math.sin(h))),a.x=b,a.y=c,a)}if(Math.abs(this.coslat0)<=Gb){if(g<=Gb)return c=this.lat0,b=this.long0,a.x=b,a.y=c,a;a.x*=this.con,a.y*=this.con,d=g*this.cons/(2*this.a*this.k0),c=this.con*hc(this.e,d),b=this.con*fc(this.con*this.long0+Math.atan2(a.x,-1*a.y))}else e=2*Math.atan(g*this.cosX0/(2*this.a*this.k0*this.ms1)),b=this.long0,g<=Gb?f=this.X0:(f=Math.asin(Math.cos(e)*this.sinX0+a.y*Math.sin(e)*this.cosX0/g),b=fc(this.long0+Math.atan2(a.x*Math.sin(e),g*this.cosX0*Math.cos(e)-a.y*this.sinX0*Math.sin(e)))),c=-1*hc(this.e,Math.tan(.5*(Cb+f)));return a.x=b,a.y=c,a}function qa(){var a=this.lat0;this.lambda0=this.long0;var b=Math.sin(a),c=this.a,d=this.rf,e=1/d,f=2*e-Math.pow(e,2),g=this.e=Math.sqrt(f);this.R=this.k0*c*Math.sqrt(1-f)/(1-f*Math.pow(b,2)),this.alpha=Math.sqrt(1+f/(1-f)*Math.pow(Math.cos(a),4)),this.b0=Math.asin(b/this.alpha);var h=Math.log(Math.tan(Math.PI/4+this.b0/2)),i=Math.log(Math.tan(Math.PI/4+a/2)),j=Math.log((1+g*b)/(1-g*b));this.K=h-this.alpha*i+this.alpha*g/2*j}function ra(a){var b=Math.log(Math.tan(Math.PI/4-a.y/2)),c=this.e/2*Math.log((1+this.e*Math.sin(a.y))/(1-this.e*Math.sin(a.y))),d=-this.alpha*(b+c)+this.K,e=2*(Math.atan(Math.exp(d))-Math.PI/4),f=this.alpha*(a.x-this.lambda0),g=Math.atan(Math.sin(f)/(Math.sin(this.b0)*Math.tan(e)+Math.cos(this.b0)*Math.cos(f))),h=Math.asin(Math.cos(this.b0)*Math.sin(e)-Math.sin(this.b0)*Math.cos(e)*Math.cos(f));return a.y=this.R/2*Math.log((1+Math.sin(h))/(1-Math.sin(h)))+this.y0,a.x=this.R*g+this.x0,a}function sa(a){for(var b=a.x-this.x0,c=a.y-this.y0,d=b/this.R,e=2*(Math.atan(Math.exp(c/this.R))-Math.PI/4),f=Math.asin(Math.cos(this.b0)*Math.sin(e)+Math.sin(this.b0)*Math.cos(e)*Math.cos(d)),g=Math.atan(Math.sin(d)/(Math.cos(this.b0)*Math.cos(d)-Math.sin(this.b0)*Math.tan(e))),h=this.lambda0+g/this.alpha,i=0,j=f,k=-1e3,l=0;Math.abs(j-k)>1e-7;){if(++l>20)return;i=1/this.alpha*(Math.log(Math.tan(Math.PI/4+f/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(j))/2)),k=j,j=2*Math.atan(Math.exp(i))-Math.PI/2}return a.x=h,a.y=j,a}function ta(){this.no_off=this.no_off||!1,this.no_rot=this.no_rot||!1,isNaN(this.k0)&&(this.k0=1);var a=Math.sin(this.lat0),b=Math.cos(this.lat0),c=this.e*a;this.bl=Math.sqrt(1+this.es/(1-this.es)*Math.pow(b,4)),this.al=this.a*this.bl*this.k0*Math.sqrt(1-this.es)/(1-c*c);var d=gc(this.e,this.lat0,a),e=this.bl/b*Math.sqrt((1-this.es)/(1-c*c));e*e<1&&(e=1);var f,g;if(isNaN(this.longc)){var h=gc(this.e,this.lat1,Math.sin(this.lat1)),i=gc(this.e,this.lat2,Math.sin(this.lat2));this.lat0>=0?this.el=(e+Math.sqrt(e*e-1))*Math.pow(d,this.bl):this.el=(e-Math.sqrt(e*e-1))*Math.pow(d,this.bl);var j=Math.pow(h,this.bl),k=Math.pow(i,this.bl);f=this.el/j,g=.5*(f-1/f);var l=(this.el*this.el-k*j)/(this.el*this.el+k*j),m=(k-j)/(k+j),n=fc(this.long1-this.long2);this.long0=.5*(this.long1+this.long2)-Math.atan(l*Math.tan(.5*this.bl*n)/m)/this.bl,this.long0=fc(this.long0);var o=fc(this.long1-this.long0);this.gamma0=Math.atan(Math.sin(this.bl*o)/g),this.alpha=Math.asin(e*Math.sin(this.gamma0))}else f=this.lat0>=0?e+Math.sqrt(e*e-1):e-Math.sqrt(e*e-1),this.el=f*Math.pow(d,this.bl),g=.5*(f-1/f),this.gamma0=Math.asin(Math.sin(this.alpha)/e),this.long0=this.longc-Math.asin(g*Math.tan(this.gamma0))/this.bl;this.no_off?this.uc=0:this.lat0>=0?this.uc=this.al/this.bl*Math.atan2(Math.sqrt(e*e-1),Math.cos(this.alpha)):this.uc=-1*this.al/this.bl*Math.atan2(Math.sqrt(e*e-1),Math.cos(this.alpha))}function ua(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0);if(Math.abs(Math.abs(f)-Cb)<=Gb)d=f>0?-1:1,c=this.al/this.bl*Math.log(Math.tan(Jb+d*this.gamma0*.5)),b=-1*d*Cb*this.al/this.bl;else{var h=gc(this.e,f,Math.sin(f)),i=this.el/Math.pow(h,this.bl),j=.5*(i-1/i),k=.5*(i+1/i),l=Math.sin(this.bl*g),m=(j*Math.sin(this.gamma0)-l*Math.cos(this.gamma0))/k;c=Math.abs(Math.abs(m)-1)<=Gb?Number.POSITIVE_INFINITY:.5*this.al*Math.log((1-m)/(1+m))/this.bl,b=Math.abs(Math.cos(this.bl*g))<=Gb?this.al*this.bl*g:this.al*Math.atan2(j*Math.cos(this.gamma0)+l*Math.sin(this.gamma0),Math.cos(this.bl*g))/this.bl}return this.no_rot?(a.x=this.x0+b,a.y=this.y0+c):(b-=this.uc,a.x=this.x0+c*Math.cos(this.alpha)+b*Math.sin(this.alpha),a.y=this.y0+b*Math.cos(this.alpha)-c*Math.sin(this.alpha)),a}function va(a){var b,c;this.no_rot?(c=a.y-this.y0,b=a.x-this.x0):(c=(a.x-this.x0)*Math.cos(this.alpha)-(a.y-this.y0)*Math.sin(this.alpha),b=(a.y-this.y0)*Math.cos(this.alpha)+(a.x-this.x0)*Math.sin(this.alpha),b+=this.uc);var d=Math.exp(-1*this.bl*c/this.al),e=.5*(d-1/d),f=.5*(d+1/d),g=Math.sin(this.bl*b/this.al),h=(g*Math.cos(this.gamma0)+e*Math.sin(this.gamma0))/f,i=Math.pow(this.el/Math.sqrt((1+h)/(1-h)),1/this.bl);return Math.abs(h-1)<Gb?(a.x=this.long0,a.y=Cb):Math.abs(h+1)<Gb?(a.x=this.long0,a.y=-1*Cb):(a.y=hc(this.e,i),a.x=fc(this.long0-Math.atan2(e*Math.cos(this.gamma0)-g*Math.sin(this.gamma0),Math.cos(this.bl*b/this.al))/this.bl)),a}function wa(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<Gb)){var a=this.b/this.a;this.e=Math.sqrt(1-a*a);var b=Math.sin(this.lat1),c=Math.cos(this.lat1),d=dc(this.e,b,c),e=gc(this.e,this.lat1,b),f=Math.sin(this.lat2),g=Math.cos(this.lat2),h=dc(this.e,f,g),i=gc(this.e,this.lat2,f),j=gc(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>Gb?this.ns=Math.log(d/h)/Math.log(e/i):this.ns=b,isNaN(this.ns)&&(this.ns=b),this.f0=d/(this.ns*Math.pow(e,this.ns)),this.rh=this.a*this.f0*Math.pow(j,this.ns),this.title||(this.title="Lambert Conformal Conic")}}function xa(a){var b=a.x,c=a.y;Math.abs(2*Math.abs(c)-Math.PI)<=Gb&&(c=ec(c)*(Cb-2*Gb));var d,e,f=Math.abs(Math.abs(c)-Cb);if(f>Gb)d=gc(this.e,c,Math.sin(c)),e=this.a*this.f0*Math.pow(d,this.ns);else{if(f=c*this.ns,f<=0)return null;e=0}var g=this.ns*fc(b-this.long0);return a.x=this.k0*(e*Math.sin(g))+this.x0,a.y=this.k0*(this.rh-e*Math.cos(g))+this.y0,a}function ya(a){var b,c,d,e,f,g=(a.x-this.x0)/this.k0,h=this.rh-(a.y-this.y0)/this.k0;this.ns>0?(b=Math.sqrt(g*g+h*h),c=1):(b=-Math.sqrt(g*g+h*h),c=-1);var i=0;if(0!==b&&(i=Math.atan2(c*g,c*h)),0!==b||this.ns>0){if(c=1/this.ns,d=Math.pow(b/(this.a*this.f0),c),e=hc(this.e,d),e===-9999)return null}else e=-Cb;return f=fc(i/this.ns+this.long0),a.x=f,a.y=e,a}function za(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq}function Aa(a){var b,c,d,e,f,g,h,i=a.x,j=a.y,k=fc(i-this.long0);return b=Math.pow((1+this.e*Math.sin(j))/(1-this.e*Math.sin(j)),this.alfa*this.e/2),c=2*(Math.atan(this.k*Math.pow(Math.tan(j/2+this.s45),this.alfa)/b)-this.s45),d=-k*this.alfa,
e=Math.asin(Math.cos(this.ad)*Math.sin(c)+Math.sin(this.ad)*Math.cos(c)*Math.cos(d)),f=Math.asin(Math.cos(c)*Math.sin(d)/Math.cos(e)),g=this.n*f,h=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(e/2+this.s45),this.n),a.y=h*Math.cos(g)/1,a.x=h*Math.sin(g)/1,this.czech||(a.y*=-1,a.x*=-1),a}function Ba(a){var b,c,d,e,f,g,h,i,j=a.x;a.x=a.y,a.y=j,this.czech||(a.y*=-1,a.x*=-1),g=Math.sqrt(a.x*a.x+a.y*a.y),f=Math.atan2(a.y,a.x),e=f/Math.sin(this.s0),d=2*(Math.atan(Math.pow(this.ro0/g,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),b=Math.asin(Math.cos(this.ad)*Math.sin(d)-Math.sin(this.ad)*Math.cos(d)*Math.cos(e)),c=Math.asin(Math.cos(d)*Math.sin(e)/Math.cos(b)),a.x=this.long0-c/this.alfa,h=b,i=0;var k=0;do a.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(b/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(h))/(1-this.e*Math.sin(h)),this.e/2))-this.s45),Math.abs(h-a.y)<1e-10&&(i=1),h=a.y,k+=1;while(0===i&&k<15);return k>=15?null:a}function Ca(){this.sphere||(this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.ml0=this.a*Bd(this.e0,this.e1,this.e2,this.e3,this.lat0))}function Da(a){var b,c,d=a.x,e=a.y;if(d=fc(d-this.long0),this.sphere)b=this.a*Math.asin(Math.cos(e)*Math.sin(d)),c=this.a*(Math.atan2(Math.tan(e),Math.cos(d))-this.lat0);else{var f=Math.sin(e),g=Math.cos(e),h=Gd(this.a,this.e,f),i=Math.tan(e)*Math.tan(e),j=d*Math.cos(e),k=j*j,l=this.es*g*g/(1-this.es),m=this.a*Bd(this.e0,this.e1,this.e2,this.e3,e);b=h*j*(1-k*i*(1/6-(8-i+8*l)*k/120)),c=m-this.ml0+h*f/g*k*(.5+(5-i+6*l)*k/24)}return a.x=b+this.x0,a.y=c+this.y0,a}function Ea(a){a.x-=this.x0,a.y-=this.y0;var b,c,d=a.x/this.a,e=a.y/this.a;if(this.sphere){var f=e+this.lat0;b=Math.asin(Math.sin(f)*Math.cos(d)),c=Math.atan2(Math.tan(d),Math.cos(f))}else{var g=this.ml0/this.a+e,h=Id(g,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(h)-Cb)<=Gb)return a.x=this.long0,a.y=Cb,e<0&&(a.y*=-1),a;var i=Gd(this.a,this.e,Math.sin(h)),j=i*i*i/this.a/this.a*(1-this.es),k=Math.pow(Math.tan(h),2),l=d*this.a/i,m=l*l;b=h-i*Math.tan(h)/j*l*l*(.5-(1+3*k)*l*l/24),c=l*(1-m*(k/3+(1+3*k)*k*m/15))/Math.cos(h)}return a.x=fc(c+this.long0),a.y=Hd(b),a}function Fa(){var a=Math.abs(this.lat0);if(Math.abs(a-Cb)<Gb?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(a)<Gb?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0){var b;switch(this.qp=Ld(this.e,1),this.mmf=.5/(1-this.es),this.apa=Ia(this.es),this.mode){case this.N_POLE:this.dd=1;break;case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),b=Math.sin(this.lat0),this.sinb1=Ld(this.e,b)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*b*b)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))}function Ga(a){var b,c,d,e,f,g,h,i,j,k,l=a.x,m=a.y;if(l=fc(l-this.long0),this.sphere){if(f=Math.sin(m),k=Math.cos(m),d=Math.cos(l),this.mode===this.OBLIQ||this.mode===this.EQUIT){if(c=this.mode===this.EQUIT?1+k*d:1+this.sinph0*f+this.cosph0*k*d,c<=Gb)return null;c=Math.sqrt(2/c),b=c*k*Math.sin(l),c*=this.mode===this.EQUIT?f:this.cosph0*f-this.sinph0*k*d}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(d=-d),Math.abs(m+this.phi0)<Gb)return null;c=Jb-.5*m,c=2*(this.mode===this.S_POLE?Math.cos(c):Math.sin(c)),b=c*Math.sin(l),c*=d}}else{switch(h=0,i=0,j=0,d=Math.cos(l),e=Math.sin(l),f=Math.sin(m),g=Ld(this.e,f),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(h=g/this.qp,i=Math.sqrt(1-h*h)),this.mode){case this.OBLIQ:j=1+this.sinb1*h+this.cosb1*i*d;break;case this.EQUIT:j=1+i*d;break;case this.N_POLE:j=Cb+m,g=this.qp-g;break;case this.S_POLE:j=m-Cb,g=this.qp+g}if(Math.abs(j)<Gb)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:j=Math.sqrt(2/j),c=this.mode===this.OBLIQ?this.ymf*j*(this.cosb1*h-this.sinb1*i*d):(j=Math.sqrt(2/(1+i*d)))*h*this.ymf,b=this.xmf*j*i*e;break;case this.N_POLE:case this.S_POLE:g>=0?(b=(j=Math.sqrt(g))*e,c=d*(this.mode===this.S_POLE?j:-j)):b=c=0}}return a.x=this.a*b+this.x0,a.y=this.a*c+this.y0,a}function Ha(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g,h,i=a.x/this.a,j=a.y/this.a;if(this.sphere){var k,l=0,m=0;if(k=Math.sqrt(i*i+j*j),c=.5*k,c>1)return null;switch(c=2*Math.asin(c),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(m=Math.sin(c),l=Math.cos(c)),this.mode){case this.EQUIT:c=Math.abs(k)<=Gb?0:Math.asin(j*m/k),i*=m,j=l*k;break;case this.OBLIQ:c=Math.abs(k)<=Gb?this.phi0:Math.asin(l*this.sinph0+j*m*this.cosph0/k),i*=m*this.cosph0,j=(l-Math.sin(c)*this.sinph0)*k;break;case this.N_POLE:j=-j,c=Cb-c;break;case this.S_POLE:c-=Cb}b=0!==j||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(i,j):0}else{if(h=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(i/=this.dd,j*=this.dd,g=Math.sqrt(i*i+j*j),g<Gb)return a.x=0,a.y=this.phi0,a;e=2*Math.asin(.5*g/this.rq),d=Math.cos(e),i*=e=Math.sin(e),this.mode===this.OBLIQ?(h=d*this.sinb1+j*e*this.cosb1/g,f=this.qp*h,j=g*this.cosb1*d-j*this.sinb1*e):(h=j*e/g,f=this.qp*h,j=g*d)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(j=-j),f=i*i+j*j,!f)return a.x=0,a.y=this.phi0,a;h=1-f/this.qp,this.mode===this.S_POLE&&(h=-h)}b=Math.atan2(i,j),c=Ja(Math.asin(h),this.apa)}return a.x=fc(this.long0+b),a.y=c,a}function Ia(a){var b,c=[];return c[0]=a*Qd,b=a*a,c[0]+=b*Rd,c[1]=b*Td,b*=a,c[0]+=b*Sd,c[1]+=b*Ud,c[2]=b*Vd,c}function Ja(a,b){var c=a+a;return a+b[0]*Math.sin(c)+b[1]*Math.sin(c+c)+b[2]*Math.sin(c+c+c)}function Ka(){Math.abs(this.lat1+this.lat2)<Gb||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=dc(this.e3,this.sin_po,this.cos_po),this.qs1=Ld(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=dc(this.e3,this.sin_po,this.cos_po),this.qs2=Ld(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=Ld(this.e3,this.sin_po,this.cos_po),Math.abs(this.lat1-this.lat2)>Gb?this.ns0=(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.ns0=this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)}function La(a){var b=a.x,c=a.y;this.sin_phi=Math.sin(c),this.cos_phi=Math.cos(c);var d=Ld(this.e3,this.sin_phi,this.cos_phi),e=this.a*Math.sqrt(this.c-this.ns0*d)/this.ns0,f=this.ns0*fc(b-this.long0),g=e*Math.sin(f)+this.x0,h=this.rh-e*Math.cos(f)+this.y0;return a.x=g,a.y=h,a}function Ma(a){var b,c,d,e,f,g;return a.x-=this.x0,a.y=this.rh-a.y+this.y0,this.ns0>=0?(b=Math.sqrt(a.x*a.x+a.y*a.y),d=1):(b=-Math.sqrt(a.x*a.x+a.y*a.y),d=-1),e=0,0!==b&&(e=Math.atan2(d*a.x,d*a.y)),d=b*this.ns0/this.a,this.sphere?g=Math.asin((this.c-d*d)/(2*this.ns0)):(c=(this.c-d*d)/this.ns0,g=this.phi1z(this.e3,c)),f=fc(e/this.ns0+this.long0),a.x=f,a.y=g,a}function Na(a,b){var c,d,e,f,g,h=Yd(.5*b);if(a<Gb)return h;for(var i=a*a,j=1;j<=25;j++)if(c=Math.sin(h),d=Math.cos(h),e=a*c,f=1-e*e,g=.5*f*f/d*(b/(1-i)-c/f+.5/a*Math.log((1-e)/(1+e))),h+=g,Math.abs(g)<=1e-7)return h;return null}function Oa(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1}function Pa(a){var b,c,d,e,f,g,h,i,j=a.x,k=a.y;return d=fc(j-this.long0),b=Math.sin(k),c=Math.cos(k),e=Math.cos(d),g=this.sin_p14*b+this.cos_p14*c*e,f=1,g>0||Math.abs(g)<=Gb?(h=this.x0+this.a*f*c*Math.sin(d)/g,i=this.y0+this.a*f*(this.cos_p14*b-this.sin_p14*c*e)/g):(h=this.x0+this.infinity_dist*c*Math.sin(d),i=this.y0+this.infinity_dist*(this.cos_p14*b-this.sin_p14*c*e)),a.x=h,a.y=i,a}function Qa(a){var b,c,d,e,f,g;return a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,(b=Math.sqrt(a.x*a.x+a.y*a.y))?(e=Math.atan2(b,this.rc),c=Math.sin(e),d=Math.cos(e),g=Yd(d*this.sin_p14+a.y*c*this.cos_p14/b),f=Math.atan2(a.x*c,b*this.cos_p14*d-a.y*this.sin_p14*c),f=fc(this.long0+f)):(g=this.phic0,f=0),a.x=f,a.y=g,a}function Ra(){this.sphere||(this.k0=dc(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))}function Sa(a){var b,c,d=a.x,e=a.y,f=fc(d-this.long0);if(this.sphere)b=this.x0+this.a*f*Math.cos(this.lat_ts),c=this.y0+this.a*Math.sin(e)/Math.cos(this.lat_ts);else{var g=Ld(this.e,Math.sin(e));b=this.x0+this.a*this.k0*f,c=this.y0+this.a*g*.5/this.k0}return a.x=b,a.y=c,a}function Ta(a){a.x-=this.x0,a.y-=this.y0;var b,c;return this.sphere?(b=fc(this.long0+a.x/this.a/Math.cos(this.lat_ts)),c=Math.asin(a.y/this.a*Math.cos(this.lat_ts))):(c=be(this.e,2*a.y*this.k0/this.a),b=fc(this.long0+a.x/(this.a*this.k0))),a.x=b,a.y=c,a}function Ua(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)}function Va(a){var b=a.x,c=a.y,d=fc(b-this.long0),e=Hd(c-this.lat0);return a.x=this.x0+this.a*d*this.rc,a.y=this.y0+this.a*e,a}function Wa(a){var b=a.x,c=a.y;return a.x=fc(this.long0+(b-this.x0)/(this.a*this.rc)),a.y=Hd(this.lat0+(c-this.y0)/this.a),a}function Xa(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.ml0=this.a*Bd(this.e0,this.e1,this.e2,this.e3,this.lat0)}function Ya(a){var b,c,d,e=a.x,f=a.y,g=fc(e-this.long0);if(d=g*Math.sin(f),this.sphere)Math.abs(f)<=Gb?(b=this.a*g,c=-1*this.a*this.lat0):(b=this.a*Math.sin(d)/Math.tan(f),c=this.a*(Hd(f-this.lat0)+(1-Math.cos(d))/Math.tan(f)));else if(Math.abs(f)<=Gb)b=this.a*g,c=-1*this.ml0;else{var h=Gd(this.a,this.e,Math.sin(f))/Math.tan(f);b=h*Math.sin(d),c=this.a*Bd(this.e0,this.e1,this.e2,this.e3,f)-this.ml0+h*(1-Math.cos(d))}return a.x=b+this.x0,a.y=c+this.y0,a}function Za(a){var b,c,d,e,f,g,h,i,j;if(d=a.x-this.x0,e=a.y-this.y0,this.sphere)if(Math.abs(e+this.a*this.lat0)<=Gb)b=fc(d/this.a+this.long0),c=0;else{g=this.lat0+e/this.a,h=d*d/this.a/this.a+g*g,i=g;var k;for(f=ge;f;--f)if(k=Math.tan(i),j=-1*(g*(i*k+1)-i-.5*(i*i+h)*k)/((i-g)/k-1),i+=j,Math.abs(j)<=Gb){c=i;break}b=fc(this.long0+Math.asin(d*Math.tan(i)/this.a)/Math.sin(c))}else if(Math.abs(e+this.ml0)<=Gb)c=0,b=fc(this.long0+d/this.a);else{g=(this.ml0+e)/this.a,h=d*d/this.a/this.a+g*g,i=g;var l,m,n,o,p;for(f=ge;f;--f)if(p=this.e*Math.sin(i),l=Math.sqrt(1-p*p)*Math.tan(i),m=this.a*Bd(this.e0,this.e1,this.e2,this.e3,i),n=this.e0-2*this.e1*Math.cos(2*i)+4*this.e2*Math.cos(4*i)-6*this.e3*Math.cos(6*i),o=m/this.a,j=(g*(l*o+1)-o-.5*l*(o*o+h))/(this.es*Math.sin(2*i)*(o*o+h-2*g*o)/(4*l)+(g-o)*(l*n-2/Math.sin(2*i))-n),i-=j,Math.abs(j)<=Gb){c=i;break}l=Math.sqrt(1-this.es*Math.pow(Math.sin(c),2))*Math.tan(c),b=fc(this.long0+Math.asin(d*l/this.a)/Math.sin(c))}return a.x=b,a.y=c,a}function $a(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013}function _a(a){var b,c=a.x,d=a.y,e=d-this.lat0,f=c-this.long0,g=e/Bb*1e-5,h=f,i=1,j=0;for(b=1;b<=10;b++)i*=g,j+=this.A[b]*i;var k,l,m=j,n=h,o=1,p=0,q=0,r=0;for(b=1;b<=6;b++)k=o*m-p*n,l=p*m+o*n,o=k,p=l,q=q+this.B_re[b]*o-this.B_im[b]*p,r=r+this.B_im[b]*o+this.B_re[b]*p;return a.x=r*this.a+this.x0,a.y=q*this.a+this.y0,a}function ab(a){var b,c,d,e=a.x,f=a.y,g=e-this.x0,h=f-this.y0,i=h/this.a,j=g/this.a,k=1,l=0,m=0,n=0;for(b=1;b<=6;b++)c=k*i-l*j,d=l*i+k*j,k=c,l=d,m=m+this.C_re[b]*k-this.C_im[b]*l,n=n+this.C_im[b]*k+this.C_re[b]*l;for(var o=0;o<this.iterations;o++){var p,q,r=m,s=n,t=i,u=j;for(b=2;b<=6;b++)p=r*m-s*n,q=s*m+r*n,r=p,s=q,t+=(b-1)*(this.B_re[b]*r-this.B_im[b]*s),u+=(b-1)*(this.B_im[b]*r+this.B_re[b]*s);r=1,s=0;var v=this.B_re[1],w=this.B_im[1];for(b=2;b<=6;b++)p=r*m-s*n,q=s*m+r*n,r=p,s=q,v+=b*(this.B_re[b]*r-this.B_im[b]*s),w+=b*(this.B_im[b]*r+this.B_re[b]*s);var x=v*v+w*w;m=(t*v+u*w)/x,n=(u*v-t*w)/x}var y=m,z=n,A=1,B=0;for(b=1;b<=9;b++)A*=y,B+=this.D[b]*A;var C=this.lat0+B*Bb*1e5,D=this.long0+z;return a.x=D,a.y=C,a}function bb(){}function cb(a){var b=a.x,c=a.y,d=fc(b-this.long0),e=this.x0+this.a*d,f=this.y0+this.a*Math.log(Math.tan(Math.PI/4+c/2.5))*1.25;return a.x=e,a.y=f,a}function db(a){a.x-=this.x0,a.y-=this.y0;var b=fc(this.long0+a.x/this.a),c=2.5*(Math.atan(Math.exp(.8*a.y/this.a))-Math.PI/4);return a.x=b,a.y=c,a}function eb(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=Tc(this.es)}function fb(a){var b,c,d=a.x,e=a.y;if(d=fc(d-this.long0),this.sphere){if(this.m)for(var f=this.n*Math.sin(e),g=ne;g;--g){var h=(this.m*e+Math.sin(e)-f)/(this.m+Math.cos(e));if(e-=h,Math.abs(h)<Gb)break}else e=1!==this.n?Math.asin(this.n*Math.sin(e)):e;b=this.a*this.C_x*d*(this.m+Math.cos(e)),c=this.a*this.C_y*e}else{var i=Math.sin(e),j=Math.cos(e);c=this.a*Uc(e,i,j,this.en),b=this.a*d*j/Math.sqrt(1-this.es*i*i)}return a.x=b,a.y=c,a}function gb(a){var b,c,d,e;return a.x-=this.x0,d=a.x/this.a,a.y-=this.y0,b=a.y/this.a,this.sphere?(b/=this.C_y,d/=this.C_x*(this.m+Math.cos(b)),this.m?b=Yd((this.m*b+Math.sin(b))/this.n):1!==this.n&&(b=Yd(Math.sin(b)/this.n)),d=fc(d+this.long0),b=Hd(b)):(b=Wc(a.y/this.a,this.es,this.en),e=Math.abs(b),e<Cb?(e=Math.sin(b),c=this.long0+a.x*Math.sqrt(1-this.es*e*e)/(this.a*Math.cos(b)),d=fc(c)):e-Gb<Cb&&(d=this.long0)),a.x=d,a.y=b,a}function hb(){}function ib(a){for(var b=a.x,c=a.y,d=fc(b-this.long0),e=c,f=Math.PI*Math.sin(c),g=0;!0;g++){var h=-(e+Math.sin(e)-f)/(1+Math.cos(e));if(e+=h,Math.abs(h)<Gb)break}e/=2,Math.PI/2-Math.abs(c)<Gb&&(d=0);var i=.900316316158*this.a*d*Math.cos(e)+this.x0,j=1.4142135623731*this.a*Math.sin(e)+this.y0;return a.x=i,a.y=j,a}function jb(a){var b,c;a.x-=this.x0,a.y-=this.y0,c=a.y/(1.4142135623731*this.a),Math.abs(c)>.999999999999&&(c=.999999999999),b=Math.asin(c);var d=fc(this.long0+a.x/(.900316316158*this.a*Math.cos(b)));d<-Math.PI&&(d=-Math.PI),d>Math.PI&&(d=Math.PI),c=(2*b+Math.sin(2*b))/Math.PI,Math.abs(c)>1&&(c=1);var e=Math.asin(c);return a.x=d,a.y=e,a}function kb(){Math.abs(this.lat1+this.lat2)<Gb||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=Cd(this.es),this.e1=Dd(this.es),this.e2=Ed(this.es),this.e3=Fd(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=dc(this.e,this.sinphi,this.cosphi),this.ml1=Bd(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<Gb?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=dc(this.e,this.sinphi,this.cosphi),this.ml2=Bd(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=Bd(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))}function lb(a){var b,c=a.x,d=a.y;if(this.sphere)b=this.a*(this.g-d);else{var e=Bd(this.e0,this.e1,this.e2,this.e3,d);b=this.a*(this.g-e)}var f=this.ns*fc(c-this.long0),g=this.x0+b*Math.sin(f),h=this.y0+this.rh-b*Math.cos(f);return a.x=g,a.y=h,a}function mb(a){a.x-=this.x0,a.y=this.rh-a.y+this.y0;var b,c,d,e;this.ns>=0?(c=Math.sqrt(a.x*a.x+a.y*a.y),b=1):(c=-Math.sqrt(a.x*a.x+a.y*a.y),b=-1);var f=0;if(0!==c&&(f=Math.atan2(b*a.x,b*a.y)),this.sphere)return e=fc(this.long0+f/this.ns),d=Hd(this.g-c/this.a),a.x=e,a.y=d,a;var g=this.g-c/this.a;return d=Id(g,this.e0,this.e1,this.e2,this.e3),e=fc(this.long0+f/this.ns),a.x=e,a.y=d,a}function nb(){this.R=this.a}function ob(a){var b,c,d=a.x,e=a.y,f=fc(d-this.long0);Math.abs(e)<=Gb&&(b=this.x0+this.R*f,c=this.y0);var g=Yd(2*Math.abs(e/Math.PI));(Math.abs(f)<=Gb||Math.abs(Math.abs(e)-Cb)<=Gb)&&(b=this.x0,c=e>=0?this.y0+Math.PI*this.R*Math.tan(.5*g):this.y0+Math.PI*this.R*-Math.tan(.5*g));var h=.5*Math.abs(Math.PI/f-f/Math.PI),i=h*h,j=Math.sin(g),k=Math.cos(g),l=k/(j+k-1),m=l*l,n=l*(2/j-1),o=n*n,p=Math.PI*this.R*(h*(l-o)+Math.sqrt(i*(l-o)*(l-o)-(o+i)*(m-o)))/(o+i);f<0&&(p=-p),b=this.x0+p;var q=i+l;return p=Math.PI*this.R*(n*q-h*Math.sqrt((o+i)*(i+1)-q*q))/(o+i),c=e>=0?this.y0+p:this.y0-p,a.x=b,a.y=c,a}function pb(a){var b,c,d,e,f,g,h,i,j,k,l,m,n;return a.x-=this.x0,a.y-=this.y0,l=Math.PI*this.R,d=a.x/l,e=a.y/l,f=d*d+e*e,g=-Math.abs(e)*(1+f),h=g-2*e*e+d*d,i=-2*g+1+2*e*e+f*f,n=e*e/i+(2*h*h*h/i/i/i-9*g*h/i/i)/27,j=(g-h*h/3/i)/i,k=2*Math.sqrt(-j/3),l=3*n/j/k,Math.abs(l)>1&&(l=l>=0?1:-1),m=Math.acos(l)/3,c=a.y>=0?(-k*Math.cos(m+Math.PI/3)-h/3/i)*Math.PI:-(-k*Math.cos(m+Math.PI/3)-h/3/i)*Math.PI,b=Math.abs(d)<Gb?this.long0:fc(this.long0+Math.PI*(f-1+Math.sqrt(1+2*(d*d-e*e)+f*f))/2/d),a.x=b,a.y=c,a}function qb(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0)}function rb(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y=a.x,z=a.y,A=Math.sin(a.y),B=Math.cos(a.y),C=fc(y-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=Gb?(a.x=this.x0+this.a*(Cb-z)*Math.sin(C),a.y=this.y0-this.a*(Cb-z)*Math.cos(C),a):Math.abs(this.sin_p12+1)<=Gb?(a.x=this.x0+this.a*(Cb+z)*Math.sin(C),a.y=this.y0+this.a*(Cb+z)*Math.cos(C),a):(s=this.sin_p12*A+this.cos_p12*B*Math.cos(C),q=Math.acos(s),r=q/Math.sin(q),a.x=this.x0+this.a*r*B*Math.sin(C),a.y=this.y0+this.a*r*(this.cos_p12*A-this.sin_p12*B*Math.cos(C)),a):(b=Cd(this.es),c=Dd(this.es),d=Ed(this.es),e=Fd(this.es),Math.abs(this.sin_p12-1)<=Gb?(f=this.a*Bd(b,c,d,e,Cb),g=this.a*Bd(b,c,d,e,z),a.x=this.x0+(f-g)*Math.sin(C),a.y=this.y0-(f-g)*Math.cos(C),a):Math.abs(this.sin_p12+1)<=Gb?(f=this.a*Bd(b,c,d,e,Cb),g=this.a*Bd(b,c,d,e,z),a.x=this.x0+(f+g)*Math.sin(C),a.y=this.y0+(f+g)*Math.cos(C),a):(h=A/B,i=Gd(this.a,this.e,this.sin_p12),j=Gd(this.a,this.e,A),k=Math.atan((1-this.es)*h+this.es*i*this.sin_p12/(j*B)),l=Math.atan2(Math.sin(C),this.cos_p12*Math.tan(k)-this.sin_p12*Math.cos(C)),t=0===l?Math.asin(this.cos_p12*Math.sin(k)-this.sin_p12*Math.cos(k)):Math.abs(Math.abs(l)-Math.PI)<=Gb?-Math.asin(this.cos_p12*Math.sin(k)-this.sin_p12*Math.cos(k)):Math.asin(Math.sin(C)*Math.cos(k)/Math.sin(l)),m=this.e*this.sin_p12/Math.sqrt(1-this.es),n=this.e*this.cos_p12*Math.cos(l)/Math.sqrt(1-this.es),o=m*n,p=n*n,u=t*t,v=u*t,w=v*t,x=w*t,q=i*t*(1-u*p*(1-p)/6+v/8*o*(1-2*p)+w/120*(p*(4-7*p)-3*m*m*(1-7*p))-x/48*o),a.x=this.x0+q*Math.sin(l),a.y=this.y0+q*Math.cos(l),a))}function sb(a){a.x-=this.x0,a.y-=this.y0;var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x;if(this.sphere){if(b=Math.sqrt(a.x*a.x+a.y*a.y),b>2*Cb*this.a)return;return c=b/this.a,d=Math.sin(c),e=Math.cos(c),f=this.long0,Math.abs(b)<=Gb?g=this.lat0:(g=Yd(e*this.sin_p12+a.y*d*this.cos_p12/b),h=Math.abs(this.lat0)-Cb,f=fc(Math.abs(h)<=Gb?this.lat0>=0?this.long0+Math.atan2(a.x,-a.y):this.long0-Math.atan2(-a.x,a.y):this.long0+Math.atan2(a.x*d,b*this.cos_p12*e-a.y*this.sin_p12*d))),a.x=f,a.y=g,a}return i=Cd(this.es),j=Dd(this.es),k=Ed(this.es),l=Fd(this.es),Math.abs(this.sin_p12-1)<=Gb?(m=this.a*Bd(i,j,k,l,Cb),b=Math.sqrt(a.x*a.x+a.y*a.y),n=m-b,g=Id(n/this.a,i,j,k,l),f=fc(this.long0+Math.atan2(a.x,-1*a.y)),a.x=f,a.y=g,a):Math.abs(this.sin_p12+1)<=Gb?(m=this.a*Bd(i,j,k,l,Cb),b=Math.sqrt(a.x*a.x+a.y*a.y),n=b-m,g=Id(n/this.a,i,j,k,l),f=fc(this.long0+Math.atan2(a.x,a.y)),a.x=f,a.y=g,a):(b=Math.sqrt(a.x*a.x+a.y*a.y),q=Math.atan2(a.x,a.y),o=Gd(this.a,this.e,this.sin_p12),r=Math.cos(q),s=this.e*this.cos_p12*r,t=-s*s/(1-this.es),u=3*this.es*(1-t)*this.sin_p12*this.cos_p12*r/(1-this.es),v=b/o,w=v-t*(1+t)*Math.pow(v,3)/6-u*(1+3*t)*Math.pow(v,4)/24,x=1-t*w*w/2-v*w*w*w/6,p=Math.asin(this.sin_p12*Math.cos(w)+this.cos_p12*Math.sin(w)*r),f=fc(this.long0+Math.asin(Math.sin(q)*Math.sin(w)/Math.cos(p))),g=Math.atan((1-this.es*x*this.sin_p12/Math.sin(p))*Math.tan(p)/(1-this.es)),a.x=f,a.y=g,a)}function tb(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0)}function ub(a){var b,c,d,e,f,g,h,i,j=a.x,k=a.y;return d=fc(j-this.long0),b=Math.sin(k),c=Math.cos(k),e=Math.cos(d),g=this.sin_p14*b+this.cos_p14*c*e,f=1,(g>0||Math.abs(g)<=Gb)&&(h=this.a*f*c*Math.sin(d),i=this.y0+this.a*f*(this.cos_p14*b-this.sin_p14*c*e)),a.x=h,a.y=i,a}function vb(a){var b,c,d,e,f,g,h;return a.x-=this.x0,a.y-=this.y0,b=Math.sqrt(a.x*a.x+a.y*a.y),c=Yd(b/this.a),d=Math.sin(c),e=Math.cos(c),g=this.long0,Math.abs(b)<=Gb?(h=this.lat0,a.x=g,a.y=h,a):(h=Yd(e*this.sin_p14+a.y*d*this.cos_p14/b),f=Math.abs(this.lat0)-Cb,Math.abs(f)<=Gb?(g=fc(this.lat0>=0?this.long0+Math.atan2(a.x,-a.y):this.long0-Math.atan2(-a.x,a.y)),a.x=g,a.y=h,a):(g=fc(this.long0+Math.atan2(a.x*d,b*this.cos_p14*e-a.y*this.sin_p14*d)),a.x=g,a.y=h,a))}var wb=function(a){a("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),a("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),a("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),a.WGS84=a["EPSG:4326"],a["EPSG:3785"]=a["EPSG:3857"],a.GOOGLE=a["EPSG:3857"],a["EPSG:900913"]=a["EPSG:3857"],a["EPSG:102113"]=a["EPSG:3857"]},xb=1,yb=2,zb=4,Ab=5,Bb=484813681109536e-20,Cb=Math.PI/2,Db=.16666666666666666,Eb=.04722222222222222,Fb=.022156084656084655,Gb="undefined"==typeof Number.EPSILON?1e-10:Number.EPSILON,Hb=.017453292519943295,Ib=57.29577951308232,Jb=Math.PI/4,Kb=2*Math.PI,Lb=3.14159265359,Mb={};Mb.greenwich=0,Mb.lisbon=-9.131906111111,Mb.paris=2.337229166667,Mb.bogota=-74.080916666667,Mb.madrid=-3.687938888889,Mb.rome=12.452333333333,Mb.bern=7.439583333333,Mb.jakarta=106.807719444444,Mb.ferro=-17.666666666667,Mb.brussels=4.367975,Mb.stockholm=18.058277777778,Mb.athens=23.7163375,Mb.oslo=10.722916666667;var Nb={ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937}},Ob=/[\s_\-\/\(\)]/g,Pb=function(b){var c,d,e,f={},g=b.split("+").map(function(a){return a.trim()}).filter(function(a){return a}).reduce(function(a,b){var c=b.split("=");return c.push(!0),a[c[0].toLowerCase()]=c[1],a},{}),h={proj:"projName",datum:"datumCode",rf:function(a){f.rf=parseFloat(a)},lat_0:function(a){f.lat0=a*Hb},lat_1:function(a){f.lat1=a*Hb},lat_2:function(a){f.lat2=a*Hb},lat_ts:function(a){f.lat_ts=a*Hb},lon_0:function(a){f.long0=a*Hb},lon_1:function(a){f.long1=a*Hb},lon_2:function(a){f.long2=a*Hb},alpha:function(a){f.alpha=parseFloat(a)*Hb},lonc:function(a){f.longc=a*Hb},x_0:function(a){f.x0=parseFloat(a)},y_0:function(a){f.y0=parseFloat(a)},k_0:function(a){f.k0=parseFloat(a)},k:function(a){f.k0=parseFloat(a)},a:function(a){f.a=parseFloat(a)},b:function(a){f.b=parseFloat(a)},r_a:function(){f.R_A=!0},zone:function(a){f.zone=parseInt(a,10)},south:function(){f.utmSouth=!0},towgs84:function(a){f.datum_params=a.split(",").map(function(a){return parseFloat(a)})},to_meter:function(a){f.to_meter=parseFloat(a)},units:function(b){f.units=b;var c=a(Nb,b);c&&(f.to_meter=c.to_meter)},from_greenwich:function(a){f.from_greenwich=a*Hb},pm:function(b){var c=a(Mb,b);f.from_greenwich=(c?c:parseFloat(b))*Hb},nadgrids:function(a){"@null"===a?f.datumCode="none":f.nadgrids=a},axis:function(a){var b="ewnsud";3===a.length&&b.indexOf(a.substr(0,1))!==-1&&b.indexOf(a.substr(1,1))!==-1&&b.indexOf(a.substr(2,1))!==-1&&(f.axis=a)}};for(c in g)d=g[c],c in h?(e=h[c],"function"==typeof e?e(d):f[e]=d):f[c]=d;return"string"==typeof f.datumCode&&"WGS84"!==f.datumCode&&(f.datumCode=f.datumCode.toLowerCase()),f},Qb=1,Rb=2,Sb=3,Tb=4,Ub=5,Vb=-1,Wb=/\s/,Xb=/[A-Za-z]/,Yb=/[A-Za-z84]/,Zb=/[,\]]/,$b=/[\d\.E\-\+]/;b.prototype.readCharicter=function(){var a=this.text[this.place++];if(this.state!==Tb)for(;Wb.test(a);){if(this.place>=this.text.length)return;a=this.text[this.place++]}switch(this.state){case Qb:return this.neutral(a);case Rb:return this.keyword(a);case Tb:return this.quoted(a);case Ub:return this.afterquote(a);case Sb:return this.number(a);case Vb:return}},b.prototype.afterquote=function(a){if('"'===a)return this.word+='"',void(this.state=Tb);if(Zb.test(a))return this.word=this.word.trim(),void this.afterItem(a);throw new Error("havn't handled \""+a+'" in afterquote yet, index '+this.place)},b.prototype.afterItem=function(a){return","===a?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=Qb)):"]"===a?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=Qb,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=Vb))):void 0},b.prototype.number=function(a){if($b.test(a))return void(this.word+=a);if(Zb.test(a))return this.word=parseFloat(this.word),void this.afterItem(a);throw new Error("havn't handled \""+a+'" in number yet, index '+this.place)},b.prototype.quoted=function(a){return'"'===a?void(this.state=Ub):void(this.word+=a)},b.prototype.keyword=function(a){if(Yb.test(a))return void(this.word+=a);if("["===a){var b=[];return b.push(this.word),this.level++,null===this.root?this.root=b:this.currentObject.push(b),this.stack.push(this.currentObject),this.currentObject=b,void(this.state=Qb)}if(Zb.test(a))return void this.afterItem(a);throw new Error("havn't handled \""+a+'" in keyword yet, index '+this.place)},b.prototype.neutral=function(a){if(Xb.test(a))return this.word=a,void(this.state=Rb);if('"'===a)return this.word="",void(this.state=Tb);if($b.test(a))return this.word=a,void(this.state=Sb);if(Zb.test(a))return void this.afterItem(a);throw new Error("havn't handled \""+a+'" in neutral yet, index '+this.place)},b.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(this.state===Vb)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};var _b=.017453292519943295,ac=function(a){var b=c(a),d=b.shift(),f=b.shift();b.unshift(["name",f]),b.unshift(["type",d]);var g={};return e(b,g),h(g),g};wb(i);var bc=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"],cc=function(a,b){a=a||{};var c,d;if(!b)return a;for(d in b)c=b[d],void 0!==c&&(a[d]=c);return a},dc=function(a,b,c){var d=a*b;return c/Math.sqrt(1-d*d)},ec=function(a){return a<0?-1:1},fc=function(a){return Math.abs(a)<=Lb?a:a-ec(a)*Kb},gc=function(a,b,c){var d=a*c,e=.5*a;return d=Math.pow((1-d)/(1+d),e),Math.tan(.5*(Cb-b))/d},hc=function(a,b){for(var c,d,e=.5*a,f=Cb-2*Math.atan(b),g=0;g<=15;g++)if(c=a*Math.sin(f),d=Cb-2*Math.atan(b*Math.pow((1-c)/(1+c),e))-f,f+=d,Math.abs(d)<=1e-10)return f;return-9999},ic=["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"],jc={init:o,forward:p,inverse:q,names:ic},kc=["longlat","identity"],lc={init:r,forward:s,inverse:s,names:kc},mc=[jc,lc],nc={},oc=[],pc={start:v,add:t,get:u},qc={};qc.MERIT={a:6378137,rf:298.257,ellipseName:"MERIT 1983"},qc.SGS85={a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},qc.GRS80={a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},qc.IAU76={a:6378140,rf:298.257,ellipseName:"IAU 1976"},qc.airy={a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},qc.APL4={a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},qc.NWL9D={a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},qc.mod_airy={a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},qc.andrae={a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},qc.aust_SA={a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},qc.GRS67={a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},qc.bessel={a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},qc.bess_nam={a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},qc.clrk66={a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},qc.clrk80={a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},qc.clrk58={a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},qc.CPM={a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},qc.delmbr={a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},qc.engelis={a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},qc.evrst30={a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},qc.evrst48={a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},qc.evrst56={a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},qc.evrst69={a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},qc.evrstSS={a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},qc.fschr60={a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},qc.fschr60m={a:6378155,rf:298.3,ellipseName:"Fischer 1960"},qc.fschr68={a:6378150,rf:298.3,ellipseName:"Fischer 1968"},qc.helmert={a:6378200,rf:298.3,ellipseName:"Helmert 1906"},qc.hough={a:6378270,rf:297,ellipseName:"Hough"},qc.intl={a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},qc.kaula={a:6378163,rf:298.24,ellipseName:"Kaula 1961"},qc.lerch={a:6378139,rf:298.257,ellipseName:"Lerch 1979"},qc.mprts={a:6397300,rf:191,ellipseName:"Maupertius 1738"},qc.new_intl={a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},qc.plessis={a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},qc.krass={a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},qc.SEasia={a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},qc.walbeck={a:6376896,b:6355834.8467,ellipseName:"Walbeck"},qc.WGS60={a:6378165,rf:298.3,ellipseName:"WGS 60"},qc.WGS66={a:6378145,rf:298.25,ellipseName:"WGS 66"},qc.WGS7={a:6378135,rf:298.26,ellipseName:"WGS 72"};var rc=qc.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"};qc.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"};var sc={};sc.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},sc.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},sc.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},sc.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},sc.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},sc.potsdam={towgs84:"606.0,23.0,413.0",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},sc.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},sc.hermannskogel={towgs84:"653.0,-212.0,449.0",ellipse:"bessel",datumName:"Hermannskogel"},sc.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},sc.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},sc.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},sc.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},sc.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},sc.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},sc.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},sc.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"},z.projections=pc,z.projections.start();
var tc=function(a,b,c){return A(a,b)?c:a.datum_type===Ab||b.datum_type===Ab?c:a.es!==b.es||a.a!==b.a||F(a.datum_type)||F(b.datum_type)?(c=B(c,a.es,a.a),F(a.datum_type)&&(c=D(c,a.datum_type,a.datum_params)),F(b.datum_type)&&(c=E(c,b.datum_type,b.datum_params)),C(c,b.es,b.a,b.b)):c},uc=function(a,b,c){var d,e,f,g=c.x,h=c.y,i=c.z||0,j={};for(f=0;f<3;f++)if(!b||2!==f||void 0!==c.z)switch(0===f?(d=g,e="x"):1===f?(d=h,e="y"):(d=i,e="z"),a.axis[f]){case"e":j[e]=d;break;case"w":j[e]=-d;break;case"n":j[e]=d;break;case"s":j[e]=-d;break;case"u":void 0!==c[e]&&(j.z=d);break;case"d":void 0!==c[e]&&(j.z=-d);break;default:return null}return j},vc=function(a){var b={x:a[0],y:a[1]};return a.length>2&&(b.z=a[2]),a.length>3&&(b.m=a[3]),b},wc=z("WGS84"),xc=6,yc="AJSAJS",zc="AFAFAF",Ac=65,Bc=73,Cc=79,Dc=86,Ec=90,Fc={forward:L,inverse:M,toPoint:N};Point.fromMGRS=function(a){return new Point(N(a))},Point.prototype.toMGRS=function(a){return L([this.x,this.y],a)};var Gc="2.4.3",Hc=1,Ic=.25,Jc=.046875,Kc=.01953125,Lc=.01068115234375,Mc=.75,Nc=.46875,Oc=.013020833333333334,Pc=.007120768229166667,Qc=.3645833333333333,Rc=.005696614583333333,Sc=.3076171875,Tc=function(a){var b=[];b[0]=Hc-a*(Ic+a*(Jc+a*(Kc+a*Lc))),b[1]=a*(Mc-a*(Jc+a*(Kc+a*Lc)));var c=a*a;return b[2]=c*(Nc-a*(Oc+a*Pc)),c*=a,b[3]=c*(Qc-a*Rc),b[4]=c*a*Sc,b},Uc=function(a,b,c,d){return c*=b,b*=b,d[0]*a-c*(d[1]+b*(d[2]+b*(d[3]+b*d[4])))},Vc=20,Wc=function(a,b,c){for(var d=1/(1-b),e=a,f=Vc;f;--f){var g=Math.sin(e),h=1-b*g*g;if(h=(Uc(e,g,Math.cos(e),c)-a)*(h*Math.sqrt(h))*d,e-=h,Math.abs(h)<Gb)return e}return e},Xc=["Transverse_Mercator","Transverse Mercator","tmerc"],Yc={init:_,forward:aa,inverse:ba,names:Xc},Zc=function(a){var b=Math.exp(a);return b=(b-1/b)/2},$c=function(a,b){a=Math.abs(a),b=Math.abs(b);var c=Math.max(a,b),d=Math.min(a,b)/(c?c:1);return c*Math.sqrt(1+Math.pow(d,2))},_c=function(a){var b=1+a,c=b-1;return 0===c?a:a*Math.log(b)/c},ad=function(a){var b=Math.abs(a);return b=_c(b*(1+b/($c(1,b)+1))),a<0?-b:b},bd=function(a,b){for(var c,d=2*Math.cos(2*b),e=a.length-1,f=a[e],g=0;--e>=0;)c=-g+d*f+a[e],g=f,f=c;return b+c*Math.sin(2*b)},cd=function(a,b){for(var c,d=2*Math.cos(b),e=a.length-1,f=a[e],g=0;--e>=0;)c=-g+d*f+a[e],g=f,f=c;return Math.sin(b)*c},dd=function(a){var b=Math.exp(a);return b=(b+1/b)/2},ed=function(a,b,c){for(var d,e,f=Math.sin(b),g=Math.cos(b),h=Zc(c),i=dd(c),j=2*g*i,k=-2*f*h,l=a.length-1,m=a[l],n=0,o=0,p=0;--l>=0;)d=o,e=n,o=m,n=p,m=-d+j*o-k*n+a[l],p=-e+k*o+j*n;return j=f*i,k=g*h,[j*m-k*p,j*p+k*m]},fd=["Extended_Transverse_Mercator","Extended Transverse Mercator","etmerc"],gd={init:ca,forward:da,inverse:ea,names:fd},hd=function(a,b){if(void 0===a){if(a=Math.floor(30*(fc(b)+Math.PI)/Math.PI)+1,a<0)return 0;if(a>60)return 60}return a},id="etmerc",jd=["Universal Transverse Mercator System","utm"],kd={init:fa,names:jd,dependsOn:id},ld=function(a,b){return Math.pow((1-a)/(1+a),b)},md=20,nd=["gauss"],od={init:ga,forward:ha,inverse:ia,names:nd},pd=["Stereographic_North_Pole","Oblique_Stereographic","Polar_Stereographic","sterea","Oblique Stereographic Alternative"],qd={init:ja,forward:ka,inverse:la,names:pd},rd=["stere","Stereographic_South_Pole","Polar Stereographic (variant B)"],sd={init:na,forward:oa,inverse:pa,names:rd,ssfn_:ma},td=["somerc"],ud={init:qa,forward:ra,inverse:sa,names:td},vd=["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","omerc"],wd={init:ta,forward:ua,inverse:va,names:vd},xd=["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_2SP","lcc"],yd={init:wa,forward:xa,inverse:ya,names:xd},zd=["Krovak","krovak"],Ad={init:za,forward:Aa,inverse:Ba,names:zd},Bd=function(a,b,c,d,e){return a*e-b*Math.sin(2*e)+c*Math.sin(4*e)-d*Math.sin(6*e)},Cd=function(a){return 1-.25*a*(1+a/16*(3+1.25*a))},Dd=function(a){return.375*a*(1+.25*a*(1+.46875*a))},Ed=function(a){return.05859375*a*a*(1+.75*a)},Fd=function(a){return a*a*a*(35/3072)},Gd=function(a,b,c){var d=b*c;return a/Math.sqrt(1-d*d)},Hd=function(a){return Math.abs(a)<Cb?a:a-ec(a)*Math.PI},Id=function(a,b,c,d,e){var f,g;f=a/b;for(var h=0;h<15;h++)if(g=(a-(b*f-c*Math.sin(2*f)+d*Math.sin(4*f)-e*Math.sin(6*f)))/(b-2*c*Math.cos(2*f)+4*d*Math.cos(4*f)-6*e*Math.cos(6*f)),f+=g,Math.abs(g)<=1e-10)return f;return NaN},Jd=["Cassini","Cassini_Soldner","cass"],Kd={init:Ca,forward:Da,inverse:Ea,names:Jd},Ld=function(a,b){var c;return a>1e-7?(c=a*b,(1-a*a)*(b/(1-c*c)-.5/a*Math.log((1-c)/(1+c)))):2*b},Md=1,Nd=2,Od=3,Pd=4,Qd=.3333333333333333,Rd=.17222222222222222,Sd=.10257936507936508,Td=.06388888888888888,Ud=.0664021164021164,Vd=.016415012942191543,Wd=["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],Xd={init:Fa,forward:Ga,inverse:Ha,names:Wd,S_POLE:Md,N_POLE:Nd,EQUIT:Od,OBLIQ:Pd},Yd=function(a){return Math.abs(a)>1&&(a=a>1?1:-1),Math.asin(a)},Zd=["Albers_Conic_Equal_Area","Albers","aea"],$d={init:Ka,forward:La,inverse:Ma,names:Zd,phi1z:Na},_d=["gnom"],ae={init:Oa,forward:Pa,inverse:Qa,names:_d},be=function(a,b){var c=1-(1-a*a)/(2*a)*Math.log((1-a)/(1+a));if(Math.abs(Math.abs(b)-c)<1e-6)return b<0?-1*Cb:Cb;for(var d,e,f,g,h=Math.asin(.5*b),i=0;i<30;i++)if(e=Math.sin(h),f=Math.cos(h),g=a*e,d=Math.pow(1-g*g,2)/(2*f)*(b/(1-a*a)-e/(1-g*g)+.5/a*Math.log((1-g)/(1+g))),h+=d,Math.abs(d)<=1e-10)return h;return NaN},ce=["cea"],de={init:Ra,forward:Sa,inverse:Ta,names:ce},ee=["Equirectangular","Equidistant_Cylindrical","eqc"],fe={init:Ua,forward:Va,inverse:Wa,names:ee},ge=20,he=["Polyconic","poly"],ie={init:Xa,forward:Ya,inverse:Za,names:he},je=["New_Zealand_Map_Grid","nzmg"],ke={init:$a,forward:_a,inverse:ab,names:je},le=["Miller_Cylindrical","mill"],me={init:bb,forward:cb,inverse:db,names:le},ne=20,oe=["Sinusoidal","sinu"],pe={init:eb,forward:fb,inverse:gb,names:oe},qe=["Mollweide","moll"],re={init:hb,forward:ib,inverse:jb,names:qe},se=["Equidistant_Conic","eqdc"],te={init:kb,forward:lb,inverse:mb,names:se},ue=["Van_der_Grinten_I","VanDerGrinten","vandg"],ve={init:nb,forward:ob,inverse:pb,names:ue},we=["Azimuthal_Equidistant","aeqd"],xe={init:qb,forward:rb,inverse:sb,names:we},ye=["ortho"],ze={init:tb,forward:ub,inverse:vb,names:ye},Ae=function(proj4){proj4.Proj.projections.add(Yc),proj4.Proj.projections.add(gd),proj4.Proj.projections.add(kd),proj4.Proj.projections.add(qd),proj4.Proj.projections.add(sd),proj4.Proj.projections.add(ud),proj4.Proj.projections.add(wd),proj4.Proj.projections.add(yd),proj4.Proj.projections.add(Ad),proj4.Proj.projections.add(Kd),proj4.Proj.projections.add(Xd),proj4.Proj.projections.add($d),proj4.Proj.projections.add(ae),proj4.Proj.projections.add(de),proj4.Proj.projections.add(fe),proj4.Proj.projections.add(ie),proj4.Proj.projections.add(ke),proj4.Proj.projections.add(me),proj4.Proj.projections.add(pe),proj4.Proj.projections.add(re),proj4.Proj.projections.add(te),proj4.Proj.projections.add(ve),proj4.Proj.projections.add(xe),proj4.Proj.projections.add(ze)};return K.defaultDatum="WGS84",K.Proj=z,K.WGS84=new K.Proj("WGS84"),K.Point=Point,K.toPoint=vc,K.defs=i,K.transform=H,K.mgrs=Fc,K.version=Gc,Ae(K),K});
﻿/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

﻿/*
Name: autoComplete
Author: Raymond Camden & Andy Matthews
Contributors: Jim Pease (@jmpease)
Website: http://raymondcamden.com/
http://andyMatthews.net
Packed With: http://jsutility.pjoneil.net/
Version: 1.4
Modificado por Fernando Lacunza
*/

(function ($) {

    "use strict";

    var autocomplete = {
        defaults: {
            method: 'GET',
            cancelRequests: false,
            target: $(),
            source: null,
            callback: null,
            link: null,
            minLength: 0,
            matchFromStart: true
        },
        openXHR: {},
        cache: {}
    },
	buildItems = function ($this, data, settings) {
	    var html = [];
	    if (data)
	    {
	        if (settings.buildHTML)
	        {
	            $(settings.target).html(settings.buildHTML({ results: data }));
	        }
	        else
	        {
	            for (var i = 0; i < data.length; i++)
	            {
	                var elm = data[i];
	                // are we working with objects or strings?
	                if ($.isPlainObject(elm))
	                {
	                    html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm.id) + '">' + elm.label + '</a></li>';
	                } else
	                {
	                    html[html.length] = '<li><a href="' + settings.link + encodeURIComponent(elm) + '">' + elm + '</a></li>';
	                }
	            }
	            $(settings.target).html(html.join(''));
	        }
	        
	    }
	    

	    // is there a callback?
	    if (settings.callback !== null && $.isFunction(settings.callback)) {
	        attachCallback(settings);
	    }

	    if ($this.val().length > 0) {
	        $this.trigger("targetUpdated.autocomplete");
	    } else {
	        $this.trigger("targetCleared.autocomplete");
	    }
	},
	attachCallback = function (settings) {
	    $('li a', $(settings.target)).on('click.autocomplete', function (e) {
	        e.stopPropagation();
	        e.preventDefault();
	        settings.callback(e);
	    });
	},
	clearTarget = function ($this, $target) {
	    $target.html('').closest("fieldset").removeClass("ui-search-active");
	    $this.trigger("targetCleared.autocomplete");
	},
	handleInput = function (e) {
	    var $this = $(this),
			id = $this.attr("id"),
			text,
			data,
			autocomplete = $this.data("autocomplete"),
			element_text,
			re;
	    if (autocomplete) {
	        var settings = autocomplete.settings;
	        var openXHR = autocomplete.openXHR;
	        // get the current text of the input field
	        text = $this.val();
	        // if we don't have enough text zero out the target
	        if (text.length < settings.minLength) {
	            clearTarget($this, $(settings.target));
	        } else {
	            // are we looking at a source array or remote data?
	            if ($.isArray(settings.source)) {
	                data = settings.source.sort().filter(function (element) {
	                    // matching from start, or anywhere in the string?
	                    if (settings.matchFromStart) {
	                        // from start
	                        element_text, re = new RegExp('^' + text, 'i');
	                    } else {
	                        // anywhere
	                        element_text, re = new RegExp(text, 'i');
	                    }
	                    if ($.isPlainObject(element)) {
	                        element_text = element.label;
	                    } else {
	                        element_text = element;
	                    }
	                    return re.test(element_text);
	                });
	                buildItems($this, data, settings);
	            }
	                // Accept a function as source.
	                // Function needs to call the callback, which is the first parameter.
	                // source:function(text,callback) { mydata = [1,2]; callback(mydata); }
                else if (typeof settings.source === 'function') {
                    if (arguments && arguments[0]) {
                        if ([37, 39].indexOf(arguments[0].keyCode) > -1) {
                            return;
                        }
                    }

	                settings.source(text, function (data) {
	                    buildItems($this, data, settings);
	                });

	            } else {
	                $.ajax({
	                    type: settings.method,
	                    url: settings.source,
	                    data: { term: text },
	                    beforeSend: function (jqXHR) {
	                        if (settings.cancelRequests) {
	                            if (openXHR[id]) {
	                                // If we have an open XML HTTP Request for this autoComplete ID, abort it
	                                openXHR[id].abort();
	                            } else {
	                                // Set a loading indicator as a temporary stop-gap to the response time issue
	                                settings.target.html('<li><a href="#">Searching...</a></li>');
	                                settings.target.closest("fieldset").addClass("ui-search-active");
	                            }
	                            // Set this request to the open XML HTTP Request list for this ID
	                            openXHR[id] = jqXHR;
	                        }
	                    },
	                    success: function (data) {
	                        buildItems($this, data, settings);
	                    },
	                    complete: function (jqXHR, textStatus) {
	                        // Clear this ID's open XML HTTP Request from the list
	                        if (settings.cancelRequests) {
	                            openXHR[id] = null;
	                        }
	                    },
	                    dataType: 'json'
	                });
	            }
	        }
	    }
	},
	methods = {
	    init: function (options) {
	        var el = this;
	        var autocomplete = { settings: null};
	        autocomplete.settings = $.extend({}, autocomplete.defaults, options);

	        el.data("autocomplete", autocomplete);
	        var settings = autocomplete.settings;
	        return el.off("keyup.autocomplete")
						.on("keyup.autocomplete", handleInput)
						.next('.ui-input-clear')
						.on('click', function (e) {
						    clearTarget(el, $(settings.target));
						});
	    },
	    // Allow dynamic update of source and link
	    update: function (options) {
	        var autocomplete = this.data("autocomplete");
	        if (autocomplete) {
	            autocomplete.settings = $.extend(autocomplete.settings, options);
	            this.data("autocomplete", autocomplete);
	        }
	        return this;
	    },
	    // Method to forcibly clear our target
	    clear: function () {
	        var autocomplete = this.data("autocomplete");
	        if (autocomplete) {
	            clearTarget(this, $(autocomplete.settings.target));
	        }
	        return this;
	    },
	    // Method to destroy (cleanup) plugin
	    destroy: function () {
	        var autocomplete = this.data("autocomplete");
	        if (autocomplete) {
	            clearTarget(this, $(autocomplete.settings.target));
	            this.removeData("autocomplete");
	            this.off(".autocomplete");
	        }
	        return this;
	    }
	};

    $.fn.autocomplete = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        }
    };

})(jQuery);

﻿/*!
 * Draggabilly PACKAGED v2.2.0
 * Make that shiz draggable
 * https://draggabilly.desandro.com
 * MIT license
 */

!function(i,e){"function"==typeof define&&define.amd?define("jquery-bridget/jquery-bridget",["jquery"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("jquery")):i.jQueryBridget=e(i,i.jQuery)}(window,function(t,i){"use strict";var c=Array.prototype.slice,e=t.console,p=void 0===e?function(){}:function(t){e.error(t)};function n(d,o,u){(u=u||i||t.jQuery)&&(o.prototype.option||(o.prototype.option=function(t){u.isPlainObject(t)&&(this.options=u.extend(!0,this.options,t))}),u.fn[d]=function(t){if("string"==typeof t){var i=c.call(arguments,1);return s=i,a="$()."+d+'("'+(r=t)+'")',(e=this).each(function(t,i){var e=u.data(i,d);if(e){var n=e[r];if(n&&"_"!=r.charAt(0)){var o=n.apply(e,s);h=void 0===h?o:h}else p(a+" is not a valid method")}else p(d+" not initialized. Cannot call methods, i.e. "+a)}),void 0!==h?h:e}var e,r,s,h,a,n;return n=t,this.each(function(t,i){var e=u.data(i,d);e?(e.option(n),e._init()):(e=new o(i,n),u.data(i,d,e))}),this},r(u))}function r(t){!t||t&&t.bridget||(t.bridget=n)}return r(i||t.jQuery),n}),function(t,i){"use strict";"function"==typeof define&&define.amd?define("get-size/get-size",[],function(){return i()}):"object"==typeof module&&module.exports?module.exports=i():t.getSize=i()}(window,function(){"use strict";function m(t){var i=parseFloat(t);return-1==t.indexOf("%")&&!isNaN(i)&&i}var e="undefined"==typeof console?function(){}:function(t){console.error(t)},y=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],b=y.length;function E(t){var i=getComputedStyle(t);return i||e("Style returned "+i+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),i}var _,x=!1;function P(t){if(function(){if(!x){x=!0;var t=document.createElement("div");t.style.width="200px",t.style.padding="1px 2px 3px 4px",t.style.borderStyle="solid",t.style.borderWidth="1px 2px 3px 4px",t.style.boxSizing="border-box";var i=document.body||document.documentElement;i.appendChild(t);var e=E(t);P.isBoxSizeOuter=_=200==m(e.width),i.removeChild(t)}}(),"string"==typeof t&&(t=document.querySelector(t)),t&&"object"==typeof t&&t.nodeType){var i=E(t);if("none"==i.display)return function(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},i=0;i<b;i++)t[y[i]]=0;return t}();var e={};e.width=t.offsetWidth,e.height=t.offsetHeight;for(var n=e.isBorderBox="border-box"==i.boxSizing,o=0;o<b;o++){var r=y[o],s=i[r],h=parseFloat(s);e[r]=isNaN(h)?0:h}var a=e.paddingLeft+e.paddingRight,d=e.paddingTop+e.paddingBottom,u=e.marginLeft+e.marginRight,c=e.marginTop+e.marginBottom,p=e.borderLeftWidth+e.borderRightWidth,f=e.borderTopWidth+e.borderBottomWidth,g=n&&_,l=m(i.width);!1!==l&&(e.width=l+(g?0:a+p));var v=m(i.height);return!1!==v&&(e.height=v+(g?0:d+f)),e.innerWidth=e.width-(a+p),e.innerHeight=e.height-(d+f),e.outerWidth=e.width+u,e.outerHeight=e.height+c,e}}return P}),function(t,i){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",i):"object"==typeof module&&module.exports?module.exports=i():t.EvEmitter=i()}("undefined"!=typeof window?window:this,function(){function t(){}var i=t.prototype;return i.on=function(t,i){if(t&&i){var e=this._events=this._events||{},n=e[t]=e[t]||[];return-1==n.indexOf(i)&&n.push(i),this}},i.once=function(t,i){if(t&&i){this.on(t,i);var e=this._onceEvents=this._onceEvents||{};return(e[t]=e[t]||{})[i]=!0,this}},i.off=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){var n=e.indexOf(i);return-1!=n&&e.splice(n,1),this}},i.emitEvent=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){e=e.slice(0),i=i||[];for(var n=this._onceEvents&&this._onceEvents[t],o=0;o<e.length;o++){var r=e[o];n&&n[r]&&(this.off(t,r),delete n[r]),r.apply(this,i)}return this}},i.allOff=function(){delete this._events,delete this._onceEvents},t}),function(i,e){"function"==typeof define&&define.amd?define("unipointer/unipointer",["ev-emitter/ev-emitter"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("ev-emitter")):i.Unipointer=e(i,i.EvEmitter)}(window,function(o,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindStartEvent=function(t){this._bindStartEvent(t,!0)},e.unbindStartEvent=function(t){this._bindStartEvent(t,!1)},e._bindStartEvent=function(t,i){var e=(i=void 0===i||i)?"addEventListener":"removeEventListener",n="mousedown";o.PointerEvent?n="pointerdown":"ontouchstart"in o&&(n="touchstart"),t[e](n,this)},e.handleEvent=function(t){var i="on"+t.type;this[i]&&this[i](t)},e.getTouch=function(t){for(var i=0;i<t.length;i++){var e=t[i];if(e.identifier==this.pointerIdentifier)return e}},e.onmousedown=function(t){var i=t.button;i&&0!==i&&1!==i||this._pointerDown(t,t)},e.ontouchstart=function(t){this._pointerDown(t,t.changedTouches[0])},e.onpointerdown=function(t){this._pointerDown(t,t)},e._pointerDown=function(t,i){t.button||this.isPointerDown||(this.isPointerDown=!0,this.pointerIdentifier=void 0!==i.pointerId?i.pointerId:i.identifier,this.pointerDown(t,i))},e.pointerDown=function(t,i){this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i])};var n={mousedown:["mousemove","mouseup"],touchstart:["touchmove","touchend","touchcancel"],pointerdown:["pointermove","pointerup","pointercancel"]};return e._bindPostStartEvents=function(t){if(t){var i=n[t.type];i.forEach(function(t){o.addEventListener(t,this)},this),this._boundPointerEvents=i}},e._unbindPostStartEvents=function(){this._boundPointerEvents&&(this._boundPointerEvents.forEach(function(t){o.removeEventListener(t,this)},this),delete this._boundPointerEvents)},e.onmousemove=function(t){this._pointerMove(t,t)},e.onpointermove=function(t){t.pointerId==this.pointerIdentifier&&this._pointerMove(t,t)},e.ontouchmove=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerMove(t,i)},e._pointerMove=function(t,i){this.pointerMove(t,i)},e.pointerMove=function(t,i){this.emitEvent("pointerMove",[t,i])},e.onmouseup=function(t){this._pointerUp(t,t)},e.onpointerup=function(t){t.pointerId==this.pointerIdentifier&&this._pointerUp(t,t)},e.ontouchend=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerUp(t,i)},e._pointerUp=function(t,i){this._pointerDone(),this.pointerUp(t,i)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i])},e._pointerDone=function(){this._pointerReset(),this._unbindPostStartEvents(),this.pointerDone()},e._pointerReset=function(){this.isPointerDown=!1,delete this.pointerIdentifier},e.pointerDone=function(){},e.onpointercancel=function(t){t.pointerId==this.pointerIdentifier&&this._pointerCancel(t,t)},e.ontouchcancel=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerCancel(t,i)},e._pointerCancel=function(t,i){this._pointerDone(),this.pointerCancel(t,i)},e.pointerCancel=function(t,i){this.emitEvent("pointerCancel",[t,i])},i.getPointerPoint=function(t){return{x:t.pageX,y:t.pageY}},i}),function(i,e){"function"==typeof define&&define.amd?define("unidragger/unidragger",["unipointer/unipointer"],function(t){return e(i,t)}):"object"==typeof module&&module.exports?module.exports=e(i,require("unipointer")):i.Unidragger=e(i,i.Unipointer)}(window,function(r,t){function i(){}var e=i.prototype=Object.create(t.prototype);e.bindHandles=function(){this._bindHandles(!0)},e.unbindHandles=function(){this._bindHandles(!1)},e._bindHandles=function(t){for(var i=(t=void 0===t||t)?"addEventListener":"removeEventListener",e=t?this._touchActionValue:"",n=0;n<this.handles.length;n++){var o=this.handles[n];this._bindStartEvent(o,t),o[i]("click",this),r.PointerEvent&&(o.style.touchAction=e)}},e._touchActionValue="none",e.pointerDown=function(t,i){this.okayPointerDown(t)&&(this.pointerDownPointer=i,t.preventDefault(),this.pointerDownBlur(),this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i]))};var o={TEXTAREA:!0,INPUT:!0,SELECT:!0,OPTION:!0},s={radio:!0,checkbox:!0,button:!0,submit:!0,image:!0,file:!0};return e.okayPointerDown=function(t){var i=o[t.target.nodeName],e=s[t.target.type],n=!i||e;return n||this._pointerReset(),n},e.pointerDownBlur=function(){var t=document.activeElement;t&&t.blur&&t!=document.body&&t.blur()},e.pointerMove=function(t,i){var e=this._dragPointerMove(t,i);this.emitEvent("pointerMove",[t,i,e]),this._dragMove(t,i,e)},e._dragPointerMove=function(t,i){var e={x:i.pageX-this.pointerDownPointer.pageX,y:i.pageY-this.pointerDownPointer.pageY};return!this.isDragging&&this.hasDragStarted(e)&&this._dragStart(t,i),e},e.hasDragStarted=function(t){return 3<Math.abs(t.x)||3<Math.abs(t.y)},e.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i]),this._dragPointerUp(t,i)},e._dragPointerUp=function(t,i){this.isDragging?this._dragEnd(t,i):this._staticClick(t,i)},e._dragStart=function(t,i){this.isDragging=!0,this.isPreventingClicks=!0,this.dragStart(t,i)},e.dragStart=function(t,i){this.emitEvent("dragStart",[t,i])},e._dragMove=function(t,i,e){this.isDragging&&this.dragMove(t,i,e)},e.dragMove=function(t,i,e){t.preventDefault(),this.emitEvent("dragMove",[t,i,e])},e._dragEnd=function(t,i){this.isDragging=!1,setTimeout(function(){delete this.isPreventingClicks}.bind(this)),this.dragEnd(t,i)},e.dragEnd=function(t,i){this.emitEvent("dragEnd",[t,i])},e.onclick=function(t){this.isPreventingClicks&&t.preventDefault()},e._staticClick=function(t,i){this.isIgnoringMouseUp&&"mouseup"==t.type||(this.staticClick(t,i),"mouseup"!=t.type&&(this.isIgnoringMouseUp=!0,setTimeout(function(){delete this.isIgnoringMouseUp}.bind(this),400)))},e.staticClick=function(t,i){this.emitEvent("staticClick",[t,i])},i.getPointerPoint=t.getPointerPoint,i}),function(e,n){"function"==typeof define&&define.amd?define(["get-size/get-size","unidragger/unidragger"],function(t,i){return n(e,t,i)}):"object"==typeof module&&module.exports?module.exports=n(e,require("get-size"),require("unidragger")):e.Draggabilly=n(e,e.getSize,e.Unidragger)}(window,function(r,a,t){function e(t,i){for(var e in i)t[e]=i[e];return t}var n=r.jQuery;function i(t,i){this.element="string"==typeof t?document.querySelector(t):t,n&&(this.$element=n(this.element)),this.options=e({},this.constructor.defaults),this.option(i),this._create()}var o=i.prototype=Object.create(t.prototype);i.defaults={},o.option=function(t){e(this.options,t)};var s={relative:!0,absolute:!0,fixed:!0};function d(t,i,e){return e=e||"round",i?Math[e](t/i)*i:t}return o._create=function(){this.position={},this._getPosition(),this.startPoint={x:0,y:0},this.dragPoint={x:0,y:0},this.startPosition=e({},this.position);var t=getComputedStyle(this.element);s[t.position]||(this.element.style.position="relative"),this.on("pointerDown",this.onPointerDown),this.on("pointerMove",this.onPointerMove),this.on("pointerUp",this.onPointerUp),this.enable(),this.setHandles()},o.setHandles=function(){this.handles=this.options.handle?this.element.querySelectorAll(this.options.handle):[this.element],this.bindHandles()},o.dispatchEvent=function(t,i,e){var n=[i].concat(e);this.emitEvent(t,n),this.dispatchJQueryEvent(t,i,e)},o.dispatchJQueryEvent=function(t,i,e){var n=r.jQuery;if(n&&this.$element){var o=n.Event(i);o.type=t,this.$element.trigger(o,e)}},o._getPosition=function(){var t=getComputedStyle(this.element),i=this._getPositionCoord(t.left,"width"),e=this._getPositionCoord(t.top,"height");this.position.x=isNaN(i)?0:i,this.position.y=isNaN(e)?0:e,this._addTransformPosition(t)},o._getPositionCoord=function(t,i){if(-1!=t.indexOf("%")){var e=a(this.element.parentNode);return e?parseFloat(t)/100*e[i]:0}return parseInt(t,10)},o._addTransformPosition=function(t){var i=t.transform;if(0===i.indexOf("matrix")){var e=i.split(","),n=0===i.indexOf("matrix3d")?12:4,o=parseInt(e[n],10),r=parseInt(e[n+1],10);this.position.x+=o,this.position.y+=r}},o.onPointerDown=function(t,i){this.element.classList.add("is-pointer-down"),this.dispatchJQueryEvent("pointerDown",t,[i])},o.dragStart=function(t,i){this.isEnabled&&(this._getPosition(),this.measureContainment(),this.startPosition.x=this.position.x,this.startPosition.y=this.position.y,this.setLeftTop(),this.dragPoint.x=0,this.dragPoint.y=0,this.element.classList.add("is-dragging"),this.dispatchEvent("dragStart",t,[i]),this.animate())},o.measureContainment=function(){var t=this.getContainer();if(t){var i=a(this.element),e=a(t),n=this.element.getBoundingClientRect(),o=t.getBoundingClientRect(),r=e.borderLeftWidth+e.borderRightWidth,s=e.borderTopWidth+e.borderBottomWidth,h=this.relativeStartPosition={x:n.left-(o.left+e.borderLeftWidth),y:n.top-(o.top+e.borderTopWidth)};this.containSize={width:e.width-r-h.x-i.width,height:e.height-s-h.y-i.height}}},o.getContainer=function(){var t=this.options.containment;if(t)return t instanceof HTMLElement?t:"string"==typeof t?document.querySelector(t):this.element.parentNode},o.onPointerMove=function(t,i,e){this.dispatchJQueryEvent("pointerMove",t,[i,e])},o.dragMove=function(t,i,e){if(this.isEnabled){var n=e.x,o=e.y,r=this.options.grid,s=r&&r[0],h=r&&r[1];n=d(n,s),o=d(o,h),n=this.containDrag("x",n,s),o=this.containDrag("y",o,h),n="y"==this.options.axis?0:n,o="x"==this.options.axis?0:o,this.position.x=this.startPosition.x+n,this.position.y=this.startPosition.y+o,this.dragPoint.x=n,this.dragPoint.y=o,this.dispatchEvent("dragMove",t,[i,e])}},o.containDrag=function(t,i,e){if(!this.options.containment)return i;var n="x"==t?"width":"height",o=d(-this.relativeStartPosition[t],e,"ceil"),r=this.containSize[n];return r=d(r,e,"floor"),Math.max(o,Math.min(r,i))},o.onPointerUp=function(t,i){this.element.classList.remove("is-pointer-down"),this.dispatchJQueryEvent("pointerUp",t,[i])},o.dragEnd=function(t,i){this.isEnabled&&(this.element.style.transform="",this.setLeftTop(),this.element.classList.remove("is-dragging"),this.dispatchEvent("dragEnd",t,[i]))},o.animate=function(){if(this.isDragging){this.positionDrag();var t=this;requestAnimationFrame(function(){t.animate()})}},o.setLeftTop=function(){this.element.style.left=this.position.x+"px",this.element.style.top=this.position.y+"px"},o.positionDrag=function(){this.element.style.transform="translate3d( "+this.dragPoint.x+"px, "+this.dragPoint.y+"px, 0)"},o.staticClick=function(t,i){this.dispatchEvent("staticClick",t,[i])},o.setPosition=function(t,i){this.position.x=t,this.position.y=i,this.setLeftTop()},o.enable=function(){this.isEnabled=!0},o.disable=function(){this.isEnabled=!1,this.isDragging&&this.dragEnd()},o.destroy=function(){this.disable(),this.element.style.transform="",this.element.style.left="",this.element.style.top="",this.element.style.position="",this.unbindHandles(),this.$element&&this.$element.removeData("draggabilly")},o._init=function(){},n&&n.bridget&&n.bridget("draggabilly",i),i});
﻿/*! Sortable 1.8.2 - MIT | git://github.com/SortableJS/Sortable.git */

!function(t){"use strict";"function"==typeof define&&define.amd?define(t):"undefined"!=typeof module&&void 0!==module.exports?module.exports=t():window.Sortable=t()}(function(){"use strict";if("undefined"==typeof window||!window.document)return function(){throw new Error("Sortable.js requires a window with a document")};var V,q,G,u,K,Z,h,Y,M,k,Q,o,J,$,l,s,c,f,P,tt,et,nt,ot,it,rt,I=[],at=!1,p=!1,lt=!1,d=[],st=!1,ct=!1,i=/\s+/g,dt="Sortable"+(new Date).getTime(),ht=window,ut=ht.document,g=ht.parseInt,ft=ht.setTimeout,e=ht.jQuery||ht.Zepto,n=ht.Polymer,r={capture:!1,passive:!1},pt=!!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),v=!!navigator.userAgent.match(/Edge/i),m=v||pt?"cssFloat":"float",a="draggable"in ut.createElement("div"),b=function(){if(pt)return!1;var t=ut.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}(),gt=!1,w=!1,vt=Math.abs,_=Math.min,y=[],D=function(t,e){var n=B(t),o=g(n.width),i=W(t,0,e),r=W(t,1,e),a=i&&B(i),l=r&&B(r),s=a&&g(a.marginLeft)+g(a.marginRight)+Mt(i).width,c=l&&g(l.marginLeft)+g(l.marginRight)+Mt(r).width;if("flex"===n.display)return"column"===n.flexDirection||"column-reverse"===n.flexDirection?"vertical":"horizontal";if(i&&"none"!==a.float){var d="left"===a.float?"left":"right";return!r||"both"!==l.clear&&l.clear!==d?"horizontal":"vertical"}return i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||o<=s&&"none"===n[m]||r&&"none"===n[m]&&o<s+c)?"vertical":"horizontal"},mt=function(t,e){if(!t||!t.getBoundingClientRect)return ht;var n=t,o=!1;do{if(n.clientWidth<n.scrollWidth||n.clientHeight<n.scrollHeight){var i=B(n);if(n.clientWidth<n.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||n.clientHeight<n.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!n||!n.getBoundingClientRect||n===ut.body)return ht;if(o||e)return n;o=!0}}}while(n=n.parentNode);return ht},S=j(function(n,t,e,o){if(t.scroll){var i=e?e[dt]:window,r=t.scrollSensitivity,a=t.scrollSpeed,l=n.clientX,s=n.clientY,c=(window.innerWidth,window.innerHeight,!1);M!==e&&(A(),Y=t.scroll,k=t.scrollFn,!0===Y&&(Y=mt(e,!0),M=Y));var d=0,h=Y;do{var u,f,p,g,v,m,b,w,_,y=h,D=Mt(y),S=D.top,C=D.bottom,T=D.left,E=D.right,x=D.width,N=D.height;if(_=y!==ht?(u=y.scrollWidth,f=y.scrollHeight,p=B(y),m=x<u&&("auto"===p.overflowX||"scroll"===p.overflowX),b=N<f&&("auto"===p.overflowY||"scroll"===p.overflowY),w=y.scrollLeft,y.scrollTop):(u=ut.documentElement.scrollWidth,f=ut.documentElement.scrollHeight,p=B(ut.documentElement),m=x<u&&("auto"===p.overflowX||"scroll"===p.overflowX||"visible"===p.overflowX),b=N<f&&("auto"===p.overflowY||"scroll"===p.overflowY||"visible"===p.overflowY),w=ut.documentElement.scrollLeft,ut.documentElement.scrollTop),g=m&&(vt(E-l)<=r&&w+x<u)-(vt(T-l)<=r&&!!w),v=b&&(vt(C-s)<=r&&_+N<f)-(vt(S-s)<=r&&!!_),!I[d])for(var X=0;X<=d;X++)I[X]||(I[X]={});I[d].vx==g&&I[d].vy==v&&I[d].el===y||(I[d].el=y,I[d].vx=g,I[d].vy=v,clearInterval(I[d].pid),!y||0==g&&0==v||(c=!0,I[d].pid=setInterval(function(){o&&0===this.layer&&_t.active._emulateDragOver(!0);var t=I[this.layer].vy?I[this.layer].vy*a:0,e=I[this.layer].vx?I[this.layer].vx*a:0;"function"==typeof k&&"continue"!==k.call(i,e,t,n,P,I[this.layer].el)||(I[this.layer].el===ht?ht.scrollTo(ht.pageXOffset+e,ht.pageYOffset+t):(I[this.layer].el.scrollTop+=t,I[this.layer].el.scrollLeft+=e))}.bind({layer:d}),24))),d++}while(t.bubbleScroll&&h!==ht&&(h=mt(h,!1)));at=c}},30),A=function(){I.forEach(function(t){clearInterval(t.pid)}),I=[]},C=function(t){function s(a,l){return function(t,e,n,o){var i=t.options.group.name&&e.options.group.name&&t.options.group.name===e.options.group.name;if(null==a&&(l||i))return!0;if(null==a||!1===a)return!1;if(l&&"clone"===a)return a;if("function"==typeof a)return s(a(t,e,n,o),l)(t,e,n,o);var r=(l?t:e).options.group.name;return!0===a||"string"==typeof a&&a===r||a.join&&-1<a.indexOf(r)}}var e={},n=t.group;n&&"object"==typeof n||(n={name:n}),e.name=n.name,e.checkPull=s(n.pull,!0),e.checkPut=s(n.put),e.revertClone=n.revertClone,t.group=e},T=function(t){V&&V.parentNode&&V.parentNode[dt]&&V.parentNode[dt]._computeIsAligned(t)},bt=function(t,e){for(var n=e;!n[dt];)n=n.parentNode;return t===n},wt=function(t,e,n){for(var o=t.parentNode;o&&!o[dt];)o=o.parentNode;o&&o[dt][n](U(e,{artificialBubble:!0}))},E=function(){!b&&G&&B(G,"display","none")},x=function(){!b&&G&&B(G,"display","")};ut.addEventListener("click",function(t){if(lt)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),lt=!1},!0);var N,t=function(t){if(t=t.touches?t.touches[0]:t,V){var e=function(t,e){for(var n=0;n<d.length;n++)if(!d[n].children.length){var o=Mt(d[n]),i=d[n][dt].options.emptyInsertThreshold,r=t>=o.left-i&&t<=o.right+i,a=e>=o.top-i&&e<=o.bottom+i;if(r&&a)return d[n]}}(t.clientX,t.clientY);e&&e[dt]._onDragOver({clientX:t.clientX,clientY:t.clientY,target:e,rootEl:e})}};function _t(t,e){if(!t||!t.nodeType||1!==t.nodeType)throw"Sortable: `el` must be HTMLElement, not "+{}.toString.call(t);this.el=t,this.options=e=U({},e),t[dt]=this;var n={group:null,sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0,draggable:/[uo]l/i.test(t.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return D(t,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,touchStartThreshold:g(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==_t.supportPointer&&("PointerEvent"in window||window.navigator&&"msPointerEnabled"in window.navigator),emptyInsertThreshold:5};for(var o in n)!(o in e)&&(e[o]=n[o]);for(var i in C(e),this)"_"===i.charAt(0)&&"function"==typeof this[i]&&(this[i]=this[i].bind(this));this.nativeDraggable=!e.forceFallback&&a,e.supportPointer?X(t,"pointerdown",this._onTapStart):(X(t,"mousedown",this._onTapStart),X(t,"touchstart",this._onTapStart)),this.nativeDraggable&&(X(t,"dragover",this),X(t,"dragenter",this)),d.push(this.el),e.store&&e.store.get&&this.sort(e.store.get(this)||[])}function yt(t,e,n,o){if(t){n=n||ut;do{if(null!=e&&(">"===e[0]&&t.parentNode===n&&z(t,e.substring(1))||z(t,e))||o&&t===n)return t;if(t===n)break}while(t=(i=t).host&&i!==ut&&i.host.nodeType?i.host:i.parentNode)}var i;return null}function X(t,e,n){t.addEventListener(e,n,r)}function O(t,e,n){t.removeEventListener(e,n,r)}function Dt(t,e,n){if(t&&e)if(t.classList)t.classList[n?"add":"remove"](e);else{var o=(" "+t.className+" ").replace(i," ").replace(" "+e+" "," ");t.className=(o+(n?" "+e:"")).replace(i," ")}}function B(t,e,n){var o=t&&t.style;if(o){if(void 0===n)return ut.defaultView&&ut.defaultView.getComputedStyle?n=ut.defaultView.getComputedStyle(t,""):t.currentStyle&&(n=t.currentStyle),void 0===e?n:n[e];e in o||-1!==e.indexOf("webkit")||(e="-webkit-"+e),o[e]=n+("string"==typeof n?"":"px")}}function H(t){var e="";do{var n=B(t,"transform");n&&"none"!==n&&(e=n+" "+e)}while(t=t.parentNode);return window.DOMMatrix?new DOMMatrix(e):window.WebKitCSSMatrix?new WebKitCSSMatrix(e):window.CSSMatrix?new CSSMatrix(e):void 0}function R(t,e,n){if(t){var o=t.getElementsByTagName(e),i=0,r=o.length;if(n)for(;i<r;i++)n(o[i],i);return o}return[]}function St(t,e,n,o,i,r,a,l,s){var c,d=(t=t||e[dt]).options,h="on"+n.charAt(0).toUpperCase()+n.substr(1);!window.CustomEvent||pt||v?(c=ut.createEvent("Event")).initEvent(n,!0,!0):c=new CustomEvent(n,{bubbles:!0,cancelable:!0}),c.to=i||e,c.from=r||e,c.item=o||e,c.clone=u,c.oldIndex=a,c.newIndex=l,c.originalEvent=s,e&&e.dispatchEvent(c),d[h]&&d[h].call(t,c)}function Ct(t,e,n,o,i,r,a,l){var s,c,d=t[dt],h=d.options.onMove;return!window.CustomEvent||pt||v?(s=ut.createEvent("Event")).initEvent("move",!0,!0):s=new CustomEvent("move",{bubbles:!0,cancelable:!0}),s.to=e,s.from=t,s.dragged=n,s.draggedRect=o,s.related=i||e,s.relatedRect=r||Mt(e),s.willInsertAfter=l,s.originalEvent=a,t.dispatchEvent(s),h&&(c=h.call(d,s,a)),c}function L(t){t.draggable=!1}function Tt(){gt=!1}function W(t,e,n){for(var o=0,i=0,r=t.children;i<r.length;){if("none"!==r[i].style.display&&r[i]!==G&&r[i]!==V&&yt(r[i],n.draggable,t,!1)){if(o===e)return r[i];o++}i++}return null}function Et(t){for(var e=t.lastElementChild;(e===G||"none"===e.style.display)&&(e=e.previousElementSibling););return e||null}function F(t){for(var e=t.tagName+t.className+t.src+t.href+t.textContent,n=e.length,o=0;n--;)o+=e.charCodeAt(n);return o.toString(36)}function xt(t,e){var n=0;if(!t||!t.parentNode)return-1;for(;t&&(t=t.previousElementSibling);)"TEMPLATE"!==t.nodeName.toUpperCase()&&t!==u&&n++;return n}function z(t,e){if(t)try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return!1}return!1}function j(n,o){return function(){if(!N){var t=arguments,e=this;N=ft(function(){1===t.length?n.call(e,t[0]):n.apply(e,t),N=void 0},o)}}}function U(t,e){if(t&&e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function Nt(t){return n&&n.dom?n.dom(t).cloneNode(!0):e?e(t).clone(!0)[0]:t.cloneNode(!0)}function Xt(t){return ft(t,0)}function Yt(t){return clearTimeout(t)}function Mt(t,e,n){if(t.getBoundingClientRect||t===ht){var o,i,r,a,l,s,c;if(c=t!==ht?(i=(o=t.getBoundingClientRect()).top,r=o.left,a=o.bottom,l=o.right,s=o.height,o.width):(r=i=0,a=window.innerHeight,l=window.innerWidth,s=window.innerHeight,window.innerWidth),n&&t!==ht){if(e=e||t.parentNode,!pt)do{if(e&&e.getBoundingClientRect&&"none"!==B(e,"transform")){var d=e.getBoundingClientRect();i-=d.top+g(B(e,"border-top-width")),r-=d.left+g(B(e,"border-left-width")),a=i+o.height,l=r+o.width;break}}while(e=e.parentNode);var h=H(t),u=h&&h.a,f=h&&h.d;h&&(a=(i/=f)+(s/=f),l=(r/=u)+(c/=u))}return{top:i,left:r,bottom:a,right:l,width:c,height:s}}}return X(ut,"dragover",t),X(ut,"mousemove",t),X(ut,"touchmove",t),_t.prototype={constructor:_t,_computeIsAligned:function(t){var e;if(G&&!b?(E(),e=ut.elementFromPoint(t.clientX,t.clientY),x()):e=t.target,e=yt(e,this.options.draggable,this.el,!1),!w&&V&&V.parentNode===this.el){for(var n,o,i,r,a,l,s,c,d=this.el.children,h=0;h<d.length;h++)yt(d[h],this.options.draggable,this.el,!1)&&d[h]!==e&&(d[h].sortableMouseAligned=(n=t.clientX,o=t.clientY,i=d[h],r=this._getDirection(t,null),this.options,void 0,a=Mt(i),l="vertical"===r?a.left:a.top,s="vertical"===r?a.right:a.bottom,l<(c="vertical"===r?n:o)&&c<s));yt(e,this.options.draggable,this.el,!0)||(et=null),w=!0,ft(function(){w=!1},30)}},_getDirection:function(t,e){return"function"==typeof this.options.direction?this.options.direction.call(this,t,e,V):this.options.direction},_onTapStart:function(t){if(t.cancelable){var e,n=this,o=this.el,i=this.options,r=i.preventOnFilter,a=t.type,l=t.touches&&t.touches[0],s=(l||t).target,c=t.target.shadowRoot&&(t.path&&t.path[0]||t.composedPath&&t.composedPath()[0])||s,d=i.filter;if(function(t){y.length=0;var e=t.getElementsByTagName("input"),n=e.length;for(;n--;){var o=e[n];o.checked&&y.push(o)}}(o),(!pt||t.artificialBubble||bt(o,s))&&!V&&!(/mousedown|pointerdown/.test(a)&&0!==t.button||i.disabled||c.isContentEditable))if(s=yt(s,i.draggable,o,!1)){if(h!==s){if(e=xt(s,i.draggable),"function"==typeof d){if(d.call(this,t,s,this))return St(n,c,"filter",s,o,o,e),void(r&&t.cancelable&&t.preventDefault())}else if(d&&(d=d.split(",").some(function(t){if(t=yt(c,t.trim(),o,!1))return St(n,t,"filter",s,o,o,e),!0})))return void(r&&t.cancelable&&t.preventDefault());i.handle&&!yt(c,i.handle,o,!1)||this._prepareDragStart(t,l,s,e)}}else pt&&wt(o,t,"_onTapStart")}},_handleAutoScroll:function(e,n){if(V&&this.options.scroll){var o=e.clientX,i=e.clientY,t=ut.elementFromPoint(o,i),r=this;if(n||v||pt){S(e,r.options,t,n);var a=mt(t,!0);!at||l&&o===s&&i===c||(l&&clearInterval(l),l=setInterval(function(){if(V){var t=mt(ut.elementFromPoint(o,i),!0);t!==a&&(a=t,A(),S(e,r.options,a,n))}},10),s=o,c=i)}else{if(!r.options.bubbleScroll||mt(t,!0)===window)return void A();S(e,r.options,mt(t,!1),!1)}}},_prepareDragStart:function(t,e,n,o){var i,r=this,a=r.el,l=r.options,s=a.ownerDocument;n&&!V&&n.parentNode===a&&(K=a,q=(V=n).parentNode,Z=V.nextSibling,h=n,J=l.group,Q=o,f={target:V,clientX:(e||t).clientX,clientY:(e||t).clientY},this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,V.style["will-change"]="all",V.style.transition="",V.style.transform="",i=function(){r._disableDelayedDrag(),V.draggable=r.nativeDraggable,r._triggerDragStart(t,e),St(r,K,"choose",V,K,K,Q),Dt(V,l.chosenClass,!0)},l.ignore.split(",").forEach(function(t){R(V,t.trim(),L)}),l.supportPointer?X(s,"pointerup",r._onDrop):(X(s,"mouseup",r._onDrop),X(s,"touchend",r._onDrop),X(s,"touchcancel",r._onDrop)),l.delay?(X(s,"mouseup",r._disableDelayedDrag),X(s,"touchend",r._disableDelayedDrag),X(s,"touchcancel",r._disableDelayedDrag),X(s,"mousemove",r._delayedDragTouchMoveHandler),X(s,"touchmove",r._delayedDragTouchMoveHandler),l.supportPointer&&X(s,"pointermove",r._delayedDragTouchMoveHandler),r._dragStartTimer=ft(i,l.delay)):i())},_delayedDragTouchMoveHandler:function(t){var e=t.touches?t.touches[0]:t;_(vt(e.clientX-this._lastX),vt(e.clientY-this._lastY))>=this.options.touchStartThreshold&&this._disableDelayedDrag()},_disableDelayedDrag:function(){var t=this.el.ownerDocument;clearTimeout(this._dragStartTimer),O(t,"mouseup",this._disableDelayedDrag),O(t,"touchend",this._disableDelayedDrag),O(t,"touchcancel",this._disableDelayedDrag),O(t,"mousemove",this._delayedDragTouchMoveHandler),O(t,"touchmove",this._delayedDragTouchMoveHandler),O(t,"pointermove",this._delayedDragTouchMoveHandler)},_triggerDragStart:function(t,e){e=e||("touch"==t.pointerType?t:null),!this.nativeDraggable||e?this.options.supportPointer?X(ut,"pointermove",this._onTouchMove):X(ut,e?"touchmove":"mousemove",this._onTouchMove):(X(V,"dragend",this),X(K,"dragstart",this._onDragStart));try{ut.selection?Xt(function(){ut.selection.empty()}):window.getSelection().removeAllRanges()}catch(t){}},_dragStarted:function(t){if(p=!1,K&&V){this.nativeDraggable&&(X(ut,"dragover",this._handleAutoScroll),X(ut,"dragover",T));var e=this.options;!t&&Dt(V,e.dragClass,!1),Dt(V,e.ghostClass,!0),B(V,"transform",""),_t.active=this,t&&this._appendGhost(),St(this,K,"start",V,K,K,Q)}else this._nulling()},_emulateDragOver:function(t){if(P){if(this._lastX===P.clientX&&this._lastY===P.clientY&&!t)return;this._lastX=P.clientX,this._lastY=P.clientY,E();for(var e=ut.elementFromPoint(P.clientX,P.clientY),n=e;e&&e.shadowRoot;)n=e=e.shadowRoot.elementFromPoint(P.clientX,P.clientY);if(n)do{if(n[dt])if(n[dt]._onDragOver({clientX:P.clientX,clientY:P.clientY,target:e,rootEl:n})&&!this.options.dragoverBubble)break;e=n}while(n=n.parentNode);V.parentNode[dt]._computeIsAligned(P),x()}},_onTouchMove:function(t){if(f){var e=this.options,n=e.fallbackTolerance,o=e.fallbackOffset,i=t.touches?t.touches[0]:t,r=G&&H(G),a=G&&r&&r.a,l=G&&r&&r.d,s=(i.clientX-f.clientX+o.x)/(a||1),c=(i.clientY-f.clientY+o.y)/(l||1),d=t.touches?"translate3d("+s+"px,"+c+"px,0)":"translate("+s+"px,"+c+"px)";if(!_t.active&&!p){if(n&&_(vt(i.clientX-this._lastX),vt(i.clientY-this._lastY))<n)return;this._onDragStart(t,!0)}this._handleAutoScroll(i,!0),tt=!0,P=i,B(G,"webkitTransform",d),B(G,"mozTransform",d),B(G,"msTransform",d),B(G,"transform",d),t.cancelable&&t.preventDefault()}},_appendGhost:function(){if(!G){var t=Mt(V,this.options.fallbackOnBody?ut.body:K,!0),e=(B(V),this.options);Dt(G=V.cloneNode(!0),e.ghostClass,!1),Dt(G,e.fallbackClass,!0),Dt(G,e.dragClass,!0),B(G,"box-sizing","border-box"),B(G,"margin",0),B(G,"top",t.top),B(G,"left",t.left),B(G,"width",t.width),B(G,"height",t.height),B(G,"opacity","0.8"),B(G,"position","fixed"),B(G,"zIndex","100000"),B(G,"pointerEvents","none"),e.fallbackOnBody&&ut.body.appendChild(G)||K.appendChild(G)}},_onDragStart:function(t,e){var n=this,o=t.dataTransfer,i=n.options;(u=Nt(V)).draggable=!1,u.style["will-change"]="",this._hideClone(),Dt(u,n.options.chosenClass,!1),n._cloneId=Xt(function(){n.options.removeCloneOnHide||K.insertBefore(u,V),St(n,K,"clone",V)}),!e&&Dt(V,i.dragClass,!0),e?(lt=!0,n._loopId=setInterval(n._emulateDragOver,50)):(O(ut,"mouseup",n._onDrop),O(ut,"touchend",n._onDrop),O(ut,"touchcancel",n._onDrop),o&&(o.effectAllowed="move",i.setData&&i.setData.call(n,o,V)),X(ut,"drop",n),B(V,"transform","translateZ(0)")),p=!0,n._dragStartId=Xt(n._dragStarted.bind(n,e)),X(ut,"selectstart",n)},_onDragOver:function(t){var e,n,o,i=this.el,r=t.target,a=this.options,l=a.group,s=_t.active,c=J===l,d=a.sort,h=this;if(!gt&&(!pt||t.rootEl||t.artificialBubble||bt(i,r))){if(void 0!==t.preventDefault&&t.cancelable&&t.preventDefault(),tt=!0,r=yt(r,a.draggable,i,!0),yt(t.target,null,V,!0)||r.animated)return j();if(r!==V&&(lt=!1),s&&!a.disabled&&(c?d||(o=!K.contains(V)):$===this||(this.lastPutMode=J.checkPull(this,s,V,t))&&l.checkPut(this,s,V,t))){var u=this._getDirection(t,r);if(e=Mt(V),o)return this._hideClone(),q=K,Z?K.insertBefore(V,Z):K.appendChild(V),j();if(0===i.children.length||i.children[0]===G||(O=t,B=u,H=Mt(Et(i)),R="vertical"===B?O.clientY:O.clientX,L="vertical"===B?O.clientX:O.clientY,W="vertical"===B?H.bottom:H.right,F="vertical"===B?H.left:H.top,z="vertical"===B?H.right:H.bottom,("vertical"===B?z+10<L||L<=z&&W<R&&F<=L:W<R&&F<L||R<=W&&z+10<L)&&!V.animated)){if(0!==i.children.length&&i.children[0]!==G&&i===t.target&&(r=Et(i)),r&&(n=Mt(r)),c?s._hideClone():s._showClone(this),!1!==Ct(K,i,V,e,r,n,t,!!r))return i.appendChild(V),q=i,rt=null,U(),this._animate(e,V),r&&this._animate(n,r),j()}else if(r&&r!==V&&r.parentNode===i){var f,p=0,g=r.sortableMouseAligned,v=V.parentNode!==i,m=function(t,e){var n=mt(n,!0),o=Mt(t)[e];for(;n;){var i=Mt(n)[e];if(!("top"===e||"left"===e?i<=o:o<=i))return!0;if(n===ht)break;n=mt(n,!1)}return!1}(r,"vertical"===u?"top":"left");if(et!==r&&(ot=null,f=Mt(r)["vertical"===u?"top":"left"],st=!1),E=r,x=u,N=(T=V)===V&&rt||Mt(T),X=E===V&&rt||Mt(E),Y="vertical"===x?N.left:N.top,M="vertical"===x?N.right:N.bottom,k="vertical"===x?N.width:N.height,P="vertical"===x?X.left:X.top,I="vertical"===x?X.right:X.bottom,A="vertical"===x?X.width:X.height,ot=(Y===P||M===I||Y+k/2===P+A/2)&&g||v||m||a.invertSwap||"insert"===ot||"swap"===ot?("swap"!==ot&&(ct=a.invertSwap||v||at||m),p=function(t,e,n,o,i,r,a){var l=Mt(e),s="vertical"===n?t.clientY:t.clientX,c="vertical"===n?l.height:l.width,d="vertical"===n?l.top:l.left,h="vertical"===n?l.bottom:l.right,u=Mt(V),f=!1;if(!r)if(a&&it<c*o)if(!st&&(1===nt?d+c*i/2<s:s<h-c*i/2)&&(st=!0),st)f=!0;else{"vertical"===n?u.top:u.left,"vertical"===n?u.bottom:u.right;if(1===nt?s<d+it:h-it<s)return-1*nt}else if(d+c*(1-o)/2<s&&s<h-c*(1-o)/2)return d+c/2<s?-1:1;if((f=f||r)&&(s<d+c*i/2||h-c*i/2<s))return d+c/2<s?1:-1;return 0}(t,r,u,a.swapThreshold,null==a.invertedSwapThreshold?a.swapThreshold:a.invertedSwapThreshold,ct,et===r),"swap"):(y=r,S=xt(V,(D=a).draggable),C=xt(y,D.draggable),p=S<C?1:-1,"insert"),0===p)return j();rt=null,nt=p,n=Mt(et=r);var b=r.nextElementSibling,w=!1,_=Ct(K,i,V,e,r,n,t,w=1===p);if(!1!==_)return 1!==_&&-1!==_||(w=1===_),gt=!0,ft(Tt,30),c?s._hideClone():s._showClone(this),w&&!b?i.appendChild(V):r.parentNode.insertBefore(V,w?b:r),q=V.parentNode,void 0===f||ct||(it=vt(f-Mt(r)["vertical"===u?"top":"left"])),U(),!v&&this._animate(n,r),this._animate(e,V),j()}if(i.contains(V))return j()}var y,D,S,C,T,E,x,N,X,Y,M,k,P,I,A,O,B,H,R,L,W,F,z;return pt&&!t.rootEl&&wt(i,t,"_onDragOver"),!1}function j(){return s&&(Dt(V,$?$.options.ghostClass:s.options.ghostClass,!1),Dt(V,a.ghostClass,!0)),$!==h&&h!==_t.active?$=h:h===_t.active&&($=null),(r===V&&!V.animated||r===i&&!r.animated)&&(et=null),a.dragoverBubble||t.rootEl||r===ut||(h._handleAutoScroll(t),V.parentNode[dt]._computeIsAligned(t)),!a.dragoverBubble&&t.stopPropagation&&t.stopPropagation(),!0}function U(){St(h,K,"change",r,i,K,Q,xt(V,a.draggable),t)}},_animate:function(t,e){var n=this.options.animation;if(n){var o=Mt(e);if(e===V&&(rt=o),1===t.nodeType&&(t=Mt(t)),t.left+t.width/2!==o.left+o.width/2||t.top+t.height/2!==o.top+o.height/2){var i=H(this.el),r=i&&i.a,a=i&&i.d;B(e,"transition","none"),B(e,"transform","translate3d("+(t.left-o.left)/(r||1)+"px,"+(t.top-o.top)/(a||1)+"px,0)"),e.offsetWidth,B(e,"transition","transform "+n+"ms"+(this.options.easing?" "+this.options.easing:"")),B(e,"transform","translate3d(0,0,0)")}"number"==typeof e.animated&&clearTimeout(e.animated),e.animated=ft(function(){B(e,"transition",""),B(e,"transform",""),e.animated=!1},n)}},_offUpEvents:function(){var t=this.el.ownerDocument;O(ut,"touchmove",this._onTouchMove),O(ut,"pointermove",this._onTouchMove),O(t,"mouseup",this._onDrop),O(t,"touchend",this._onDrop),O(t,"pointerup",this._onDrop),O(t,"touchcancel",this._onDrop),O(ut,"selectstart",this)},_onDrop:function(t){var e=this.el,n=this.options;st=ct=at=p=!1,clearInterval(this._loopId),clearInterval(l),A(),clearTimeout(N),N=void 0,clearTimeout(this._dragStartTimer),Yt(this._cloneId),Yt(this._dragStartId),O(ut,"mousemove",this._onTouchMove),this.nativeDraggable&&(O(ut,"drop",this),O(e,"dragstart",this._onDragStart),O(ut,"dragover",this._handleAutoScroll),O(ut,"dragover",T)),this._offUpEvents(),t&&(tt&&(t.cancelable&&t.preventDefault(),!n.dropBubble&&t.stopPropagation()),G&&G.parentNode&&G.parentNode.removeChild(G),(K===q||$&&"clone"!==$.lastPutMode)&&u&&u.parentNode&&u.parentNode.removeChild(u),V&&(this.nativeDraggable&&O(V,"dragend",this),L(V),V.style["will-change"]="",Dt(V,$?$.options.ghostClass:this.options.ghostClass,!1),Dt(V,this.options.chosenClass,!1),St(this,K,"unchoose",V,q,K,Q,null,t),K!==q?(0<=(o=xt(V,n.draggable))&&(St(null,q,"add",V,q,K,Q,o,t),St(this,K,"remove",V,q,K,Q,o,t),St(null,q,"sort",V,q,K,Q,o,t),St(this,K,"sort",V,q,K,Q,o,t)),$&&$.save()):V.nextSibling!==Z&&0<=(o=xt(V,n.draggable))&&(St(this,K,"update",V,q,K,Q,o,t),St(this,K,"sort",V,q,K,Q,o,t)),_t.active&&(null!=o&&-1!==o||(o=Q),St(this,K,"end",V,q,K,Q,o,t),this.save()))),this._nulling()},_nulling:function(){K=V=q=G=Z=u=h=Y=M=I.length=l=s=c=f=P=tt=o=Q=et=nt=rt=$=J=_t.active=null,y.forEach(function(t){t.checked=!0}),y.length=0},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":V&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="none");t.cancelable&&t.preventDefault()}(t));break;case"selectstart":t.preventDefault()}},toArray:function(){for(var t,e=[],n=this.el.children,o=0,i=n.length,r=this.options;o<i;o++)yt(t=n[o],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||F(t));return e},sort:function(t){var o={},i=this.el;this.toArray().forEach(function(t,e){var n=i.children[e];yt(n,this.options.draggable,i,!1)&&(o[t]=n)},this),t.forEach(function(t){o[t]&&(i.removeChild(o[t]),i.appendChild(o[t]))})},save:function(){var t=this.options.store;t&&t.set&&t.set(this)},closest:function(t,e){return yt(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var n=this.options;if(void 0===e)return n[t];n[t]=e,"group"===t&&C(n)},destroy:function(){var t=this.el;t[dt]=null,O(t,"mousedown",this._onTapStart),O(t,"touchstart",this._onTapStart),O(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(O(t,"dragover",this),O(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable")}),this._onDrop(),d.splice(d.indexOf(this.el),1),this.el=t=null},_hideClone:function(){u.cloneHidden||(B(u,"display","none"),u.cloneHidden=!0,u.parentNode&&this.options.removeCloneOnHide&&u.parentNode.removeChild(u))},_showClone:function(t){"clone"===t.lastPutMode?u.cloneHidden&&(K.contains(V)&&!this.options.group.revertClone?K.insertBefore(u,V):Z?K.insertBefore(u,Z):K.appendChild(u),this.options.group.revertClone&&this._animate(V,u),B(u,"display",""),u.cloneHidden=!1):this._hideClone()}},X(ut,"touchmove",function(t){(_t.active||p)&&t.cancelable&&t.preventDefault()}),_t.utils={on:X,off:O,css:B,find:R,is:function(t,e){return!!yt(t,e,t,!1)},extend:U,throttle:j,closest:yt,toggleClass:Dt,clone:Nt,index:xt,nextTick:Xt,cancelNextTick:Yt,detectDirection:D,getChild:W},_t.create=function(t,e){return new _t(t,e)},_t.version="1.8.2",_t});
﻿var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=['<table style="border:0;border-collapse:collapse;">'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+';"></td>');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();
﻿(function (n) { n([], function () { var f = -1, e = -2, i = -3, n = -4, r = -5, h = function (s, h) { var l, c, a; h = h || {}; l = h.verbose || !1; l && console.log("Normalize the JSON Object"); s = typeof s == "string" ? this.JSON.parse(s) : s; l && console.log("Creating a empty dictionary"); c = { strings: [], integers: [], floats: [] }; l && console.log("Creating the AST"); var y = function v(s) { var y, w, a, p, h; if (l && console.log("Calling recursiveAstBuilder with " + this.JSON.stringify(s)), y = typeof s, s === null) return { type: "null", index: i }; if (typeof s == "undefined") return { type: "undefined", index: r }; if (s instanceof Array) { a = ["@"]; for (w in s) s.hasOwnProperty(w) && a.push(v(s[w])); return a } if (y === "object") { a = ["$"]; for (p in s) s.hasOwnProperty(p) && (a.push(v(p)), a.push(v(s[p]))); return a } if (s === "") return { type: "empty", index: n }; if (y === "string") return h = u.call(c.strings, s), h == -1 && (c.strings.push(o(s)), h = c.strings.length - 1), { type: "strings", index: h }; if (y === "number" && s % 1 == 0) return h = u.call(c.integers, s), h == -1 && (c.integers.push(t(s)), h = c.integers.length - 1), { type: "integers", index: h }; if (y === "number") return h = u.call(c.floats, s), h == -1 && (c.floats.push(s), h = c.floats.length - 1), { type: "floats", index: h }; if (y === "boolean") return { type: "boolean", index: s ? f : e }; throw new Error("Unexpected argument of type " + typeof s); }(s), p = c.strings.length, w = c.integers.length, k = c.floats.length; return (l && console.log("Parsing the dictionary"), a = c.strings.join("|"), a += "^" + c.integers.join("|"), a += "^" + c.floats.join("|"), l && console.log("Parsing the structure"), a += "^" + function b(u) { var e, s, f, o; if (l && console.log("Calling a recursiveParser with " + this.JSON.stringify(u)), u instanceof Array) { e = u.shift(); for (s in u) u.hasOwnProperty(s) && (e += b(u[s]) + "|"); return (e[e.length - 1] === "|" ? e.slice(0, -1) : e) + "]" } if (f = u.type, o = u.index, f === "strings") return t(o); if (f === "integers") return t(p + o); if (f === "floats") return t(p + w + o); if (f === "boolean") return u.index; if (f === "null") return i; if (f === "undefined") return r; if (f === "empty") return n; throw new TypeError("The item is alien!"); }(y), l && console.log("Ending parser"), h.debug) ? { dictionary: c, ast: y, packed: a } : a }, c = function (t, u) { var p, v, o, w, h, a, k, c; if (u = u || {}, p = t.split("^"), u.verbose && console.log("Building dictionary"), v = [], o = p[0], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the strings dictionary"), h = 0, w = o.length; h < w; h++) v.push(l(o[h])); if (o = p[1], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the integers dictionary"), h = 0, w = o.length; h < w; h++) v.push(s(o[h])); if (o = p[2], o !== "") for (o = o.split("|"), u.verbose && console.log("Parse the floats dictionary"), h = 0, w = o.length; h < w; h++) v.push(parseFloat(o[h])); o = null; u.verbose && console.log("Tokenizing the structure"); var b = "", y = [], g = p[3].length; for (h = 0; h < g; h++) a = p[3].charAt(h), a === "|" || a === "$" || a === "@" || a === "]" ? (b && (y.push(s(b)), b = ""), a !== "|" && y.push(a)) : b += a; return k = y.length, c = 0, u.verbose && console.log("Starting recursive parser"), function d() { var h = y[c++], t, s, o; if (u.verbose && console.log("Reading collection type " + (h === "$" ? "object" : "Array")), h === "@") { for (t = []; c < k; c++) { if (o = y[c], u.verbose && console.log("Read " + o + " symbol"), o === "]") return t; if (o === "@" || o === "$") t.push(d()); else switch (o) { case f: t.push(!0); break; case e: t.push(!1); break; case i: t.push(null); break; case r: t.push(undefined); break; case n: t.push(""); break; default: t.push(v[o]) } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } if (h === "$") { for (t = {}; c < k; c++) { if (s = y[c], s === "]") return t; if (s = s === n ? "" : v[s], o = y[++c], o === "@" || o === "$") t[s] = d(); else switch (o) { case f: t[s] = !0; break; case e: t[s] = !1; break; case i: t[s] = null; break; case r: t[s] = undefined; break; case n: t[s] = ""; break; default: t[s] = v[o] } } return u.verbose && console.log("Parsed " + this.JSON.stringify(t)), t } throw new TypeError("Bad token " + h + " isn't a type"); }() }, a = function (s, h) { var c = typeof h, l; if (c === "boolean") return h ? f : e; if (h === null) return i; if (typeof h == "undefined") return r; if (h === "") return n; if (c === "string" && (h = o(h), l = u.call(s.strings, h), l === -1 && (s.strings.push(h), l = s.strings.length - 1)), c !== "string" && c !== "number") throw new Error("The type is not a JSON type"); return c === "string" ? h = o(h) : h % 1 == 0 && (h = t(h)), h = c === "number" ? t(h) : o(h), l = u.call(s[c], h), l === -1 && (s[c].push(h), l = s[c].length - 1), c === "number" ? "+" + l : l }, o = function (n) { return typeof n != "string" ? n : n.replace(/[\+ \|\^\%]/g, function (n) { return { " ": "+", "+": "%2B", "|": "%7C", "^": "%5E", "%": "%25" }[n] }) }, l = function (n) { return typeof n != "string" ? n : n.replace(/\+|%2B|%7C|%5E|%25/g, function (n) { return { "+": " ", "%2B": "+", "%7C": "|", "%5E": "^", "%25": "%" }[n] }) }, t = function (n) { return Number.prototype.toString.call(n, 36).toUpperCase() }, s = function (n) { return parseInt(n, 36) }, u = Array.prototype.indexOf || function (n, t) { for (var i = t || 0, r = this.length; i < r; i++) if (this[i] === n) return i; return -1 }; return { JSON: JSON, pack: h, unpack: c } }) })(typeof define == "undefined" || !define.amd ? function (n, t) { var i = t(), r; if (typeof exports != "undefined") for (r in i) exports[r] = i[r]; else window.jsonpack = i } : define);
﻿/*!
 * UAParser.js v0.7.19
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 or MIT
 */
(function(window,undefined){"use strict";var LIBVERSION="0.7.19",EMPTY="",UNKNOWN="?",FUNC_TYPE="function",UNDEF_TYPE="undefined",OBJ_TYPE="object",STR_TYPE="string",MAJOR="major",MODEL="model",NAME="name",TYPE="type",VENDOR="vendor",VERSION="version",ARCHITECTURE="architecture",CONSOLE="console",MOBILE="mobile",TABLET="tablet",SMARTTV="smarttv",WEARABLE="wearable",EMBEDDED="embedded";var util={extend:function(regexes,extensions){var margedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){margedRegexes[i]=extensions[i].concat(regexes[i])}else{margedRegexes[i]=regexes[i]}}return margedRegexes},has:function(str1,str2){if(typeof str1==="string"){return str2.toLowerCase().indexOf(str1.toLowerCase())!==-1}else{return false}},lowerize:function(str){return str.toLowerCase()},major:function(version){return typeof version===STR_TYPE?version.replace(/[^\d\.]/g,"").split(".")[0]:undefined},trim:function(str){return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}};var mapper={rgx:function(ua,arrays){var i=0,j,k,p,q,matches,match;while(i<arrays.length&&!matches){var regex=arrays[i],props=arrays[i+1];j=k=0;while(j<regex.length&&!matches){matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];if(typeof q===OBJ_TYPE&&q.length>0){if(q.length==2){if(typeof q[1]==FUNC_TYPE){this[q[0]]=q[1].call(this,match)}else{this[q[0]]=q[1]}}else if(q.length==3){if(typeof q[1]===FUNC_TYPE&&!(q[1].exec&&q[1].test)){this[q[0]]=match?q[1].call(this,match,q[2]):undefined}else{this[q[0]]=match?match.replace(q[1],q[2]):undefined}}else if(q.length==4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined}}else{this[q]=match?match:undefined}}}}i+=2}},str:function(str,map){for(var i in map){if(typeof map[i]===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(util.has(map[i][j],str)){return i===UNKNOWN?undefined:i}}}else if(util.has(map[i],str)){return i===UNKNOWN?undefined:i}}return str}};var maps={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}};var regexes={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[NAME,VERSION],[/(opios)[\/\s]+([\w\.]+)/i],[[NAME,"Opera Mini"],VERSION],[/\s(opr)\/([\w\.]+)/i],[[NAME,"Opera"],VERSION],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,/(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]*)/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i],[NAME,VERSION],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[NAME,"IE"],VERSION],[/(edge|edgios|edga)\/((\d+)?[\w\.]+)/i],[[NAME,"Edge"],VERSION],[/(yabrowser)\/([\w\.]+)/i],[[NAME,"Yandex"],VERSION],[/(puffin)\/([\w\.]+)/i],[[NAME,"Puffin"],VERSION],[/(focus)\/([\w\.]+)/i],[[NAME,"Firefox Focus"],VERSION],[/(opt)\/([\w\.]+)/i],[[NAME,"Opera Touch"],VERSION],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[NAME,"UCBrowser"],VERSION],[/(comodo_dragon)\/([\w\.]+)/i],[[NAME,/_/g," "],VERSION],[/(micromessenger)\/([\w\.]+)/i],[[NAME,"WeChat"],VERSION],[/(brave)\/([\w\.]+)/i],[[NAME,"Brave"],VERSION],[/(qqbrowserlite)\/([\w\.]+)/i],[NAME,VERSION],[/(QQ)\/([\d\.]+)/i],[NAME,VERSION],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(BIDUBrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(2345Explorer)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(MetaSr)[\/\s]?([\w\.]+)/i],[NAME],[/(LBBROWSER)/i],[NAME],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[VERSION,[NAME,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[VERSION,[NAME,"Facebook"]],[/safari\s(line)\/([\w\.]+)/i,/android.+(line)\/([\w\.]+)\/iab/i],[NAME,VERSION],[/headlesschrome(?:\/([\w\.]+)|\s)/i],[VERSION,[NAME,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[NAME,/(.+)/,"$1 WebView"],VERSION],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[NAME,/(.+(?:g|us))(.+)/,"$1 $2"],VERSION],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[VERSION,[NAME,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[NAME,VERSION],[/(dolfin)\/([\w\.]+)/i],[[NAME,"Dolphin"],VERSION],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[NAME,"Chrome"],VERSION],[/(coast)\/([\w\.]+)/i],[[NAME,"Opera Coast"],VERSION],[/fxios\/([\w\.-]+)/i],[VERSION,[NAME,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[VERSION,[NAME,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[VERSION,NAME],[/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[[NAME,"GSA"],VERSION],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[NAME,[VERSION,mapper.str,maps.browser.oldsafari.version]],[/(konqueror)\/([\w\.]+)/i,/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[/(navigator|netscape)\/([\w\.-]+)/i],[[NAME,"Netscape"],VERSION],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]*)/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[NAME,VERSION]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[[ARCHITECTURE,"amd64"]],[/(ia32(?=;))/i],[[ARCHITECTURE,util.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[[ARCHITECTURE,"ia32"]],[/windows\s(ce|mobile);\sppc;/i],[[ARCHITECTURE,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[[ARCHITECTURE,/ower/,"",util.lowerize]],[/(sun4\w)[;\)]/i],[[ARCHITECTURE,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[[ARCHITECTURE,util.lowerize]]],device:[[/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],[MODEL,VENDOR,[TYPE,TABLET]],[/applecoremedia\/[\w\.]+ \((ipad)/],[MODEL,[VENDOR,"Apple"],[TYPE,TABLET]],[/(apple\s{0,1}tv)/i],[[MODEL,"Apple TV"],[VENDOR,"Apple"]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(kf[A-z]+)\sbuild\/.+silk\//i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],[[MODEL,mapper.str,maps.device.amazon.model],[VENDOR,"Amazon"],[TYPE,MOBILE]],[/android.+aft([bms])\sbuild/i],[MODEL,[VENDOR,"Amazon"],[TYPE,SMARTTV]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[MODEL,VENDOR,[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);/i],[MODEL,[VENDOR,"Apple"],[TYPE,MOBILE]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/\(bb10;\s(\w+)/i],[MODEL,[VENDOR,"BlackBerry"],[TYPE,MOBILE]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],[MODEL,[VENDOR,"Asus"],[TYPE,TABLET]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[VENDOR,"Sony"],[MODEL,"Xperia Tablet"],[TYPE,TABLET]],[/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],[MODEL,[VENDOR,"Sony"],[TYPE,MOBILE]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[VENDOR,MODEL,[TYPE,CONSOLE]],[/android.+;\s(shield)\sbuild/i],[MODEL,[VENDOR,"Nvidia"],[TYPE,CONSOLE]],[/(playstation\s[34portablevi]+)/i],[MODEL,[VENDOR,"Sony"],[TYPE,CONSOLE]],[/(sprint\s(\w+))/i],[[VENDOR,mapper.str,maps.device.sprint.vendor],[MODEL,mapper.str,maps.device.sprint.model],[TYPE,MOBILE]],[/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,/(zte)-(\w*)/i,/(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],[VENDOR,[MODEL,/_/g," "],[TYPE,MOBILE]],[/(nexus\s9)/i],[MODEL,[VENDOR,"HTC"],[TYPE,TABLET]],[/d\/huawei([\w\s-]+)[;\)]/i,/(nexus\s6p)/i],[MODEL,[VENDOR,"Huawei"],[TYPE,MOBILE]],[/(microsoft);\s(lumia[\s\w]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[MODEL,[VENDOR,"Microsoft"],[TYPE,CONSOLE]],[/(kin\.[onetw]{3})/i],[[MODEL,/\./g," "],[VENDOR,"Microsoft"],[TYPE,MOBILE]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w*)/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[MODEL,[VENDOR,"Motorola"],[TYPE,MOBILE]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[MODEL,[VENDOR,"Motorola"],[TYPE,TABLET]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[VENDOR,util.trim],[MODEL,util.trim],[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,"SmartTV"],[VENDOR,"Samsung"],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i],[MODEL,[VENDOR,"Sharp"],[TYPE,SMARTTV]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,TABLET]],[/smart-tv.+(samsung)/i],[VENDOR,[TYPE,SMARTTV],MODEL],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,/sec-((sgh\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,MOBILE]],[/sie-(\w*)/i],[MODEL,[VENDOR,"Siemens"],[TYPE,MOBILE]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]*)/i],[[VENDOR,"Nokia"],MODEL,[TYPE,MOBILE]],[/android\s3\.[\s\w;-]{10}(a\d{3})/i],[MODEL,[VENDOR,"Acer"],[TYPE,TABLET]],[/android.+([vl]k\-?\d{3})\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,TABLET]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[VENDOR,"LG"],MODEL,[TYPE,TABLET]],[/(lg) netcast\.tv/i],[VENDOR,MODEL,[TYPE,SMARTTV]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w*)/i,/android.+lg(\-?[\d\w]+)\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,MOBILE]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[MODEL,[VENDOR,"Lenovo"],[TYPE,TABLET]],[/linux;.+((jolla));/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/((pebble))app\/[\d\.]+\s/i],[VENDOR,MODEL,[TYPE,WEARABLE]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/crkey/i],[[MODEL,"Chromecast"],[VENDOR,"Google"]],[/android.+;\s(glass)\s\d/i],[MODEL,[VENDOR,"Google"],[TYPE,WEARABLE]],[/android.+;\s(pixel c)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,TABLET]],[/android.+;\s(pixel( [23])?( xl)?)\s/i],[MODEL,[VENDOR,"Google"],[TYPE,MOBILE]],[/android.+;\s(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,/android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,MOBILE]],[/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,TABLET]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[MODEL,[VENDOR,"Meizu"],[TYPE,TABLET]],[/(mz)-([\w-]{2,})/i],[[VENDOR,"Meizu"],MODEL,[TYPE,MOBILE]],[/android.+a000(1)\s+build/i,/android.+oneplus\s(a\d{4})\s+build/i],[MODEL,[VENDOR,"OnePlus"],[TYPE,MOBILE]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[MODEL,[VENDOR,"RCA"],[TYPE,TABLET]],[/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],[MODEL,[VENDOR,"Dell"],[TYPE,TABLET]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[MODEL,[VENDOR,"Verizon"],[TYPE,TABLET]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],[[VENDOR,"Barnes & Noble"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[MODEL,[VENDOR,"NuVision"],[TYPE,TABLET]],[/android.+;\s(k88)\sbuild/i],[MODEL,[VENDOR,"ZTE"],[TYPE,TABLET]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[MODEL,[VENDOR,"Swiss"],[TYPE,MOBILE]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[MODEL,[VENDOR,"Swiss"],[TYPE,TABLET]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[MODEL,[VENDOR,"Zeki"],[TYPE,TABLET]],[/(android).+[;\/]\s+([YR]\d{2})\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],[[VENDOR,"Dragon Touch"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],[MODEL,[VENDOR,"Insignia"],[TYPE,TABLET]],[/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],[MODEL,[VENDOR,"NextBook"],[TYPE,TABLET]],[/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[VENDOR,"Voice"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],[[VENDOR,"LvTel"],MODEL,[TYPE,MOBILE]],[/android.+;\s(PH-1)\s/i],[MODEL,[VENDOR,"Essential"],[TYPE,MOBILE]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[MODEL,[VENDOR,"Envizen"],[TYPE,TABLET]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],[MODEL,[VENDOR,"MachSpeed"],[TYPE,TABLET]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[MODEL,[VENDOR,"Rotor"],[TYPE,TABLET]],[/android.+(KS(.+))\s+build/i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[TYPE,util.lowerize],VENDOR,MODEL],[/(android[\w\.\s\-]{0,9});.+build/i],[MODEL,[VENDOR,"Generic"]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[VERSION,[NAME,"EdgeHTML"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9}).+(gecko)/i],[VERSION,NAME]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[NAME,VERSION],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[NAME,[VERSION,mapper.str,maps.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[NAME,"Windows"],[VERSION,mapper.str,maps.os.windows.version]],[/\((bb)(10);/i],[[NAME,"BlackBerry"],VERSION],[/(blackberry)\w*\/?([\w\.]*)/i,/(tizen)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,/linux;.+(sailfish);/i],[NAME,VERSION],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],[[NAME,"Symbian"],VERSION],[/\((series40);/i],[NAME],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[NAME,"Firefox OS"],VERSION],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w*)/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,/(hurd|linux)\s?([\w\.]*)/i,/(gnu)\s?([\w\.]*)/i],[NAME,VERSION],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[NAME,"Chromium OS"],VERSION],[/(sunos)\s?([\w\.\d]*)/i],[[NAME,"Solaris"],VERSION],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],[NAME,VERSION],[/(haiku)\s(\w+)/i],[NAME,VERSION],[/cfnetwork\/.+darwin/i,/ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],[[VERSION,/_/g,"."],[NAME,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]*)/i,/(macintosh|mac(?=_powerpc)\s)/i],[[NAME,"Mac OS"],[VERSION,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]*)/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,/(unix)\s?([\w\.]*)/i],[NAME,VERSION]]};var UAParser=function(uastring,extensions){if(typeof uastring==="object"){extensions=uastring;uastring=undefined}if(!(this instanceof UAParser)){return new UAParser(uastring,extensions).getResult()}var ua=uastring||(window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:EMPTY);var rgxmap=extensions?util.extend(regexes,extensions):regexes;this.getBrowser=function(){var browser={name:undefined,version:undefined};mapper.rgx.call(browser,ua,rgxmap.browser);browser.major=util.major(browser.version);return browser};this.getCPU=function(){var cpu={architecture:undefined};mapper.rgx.call(cpu,ua,rgxmap.cpu);return cpu};this.getDevice=function(){var device={vendor:undefined,model:undefined,type:undefined};mapper.rgx.call(device,ua,rgxmap.device);return device};this.getEngine=function(){var engine={name:undefined,version:undefined};mapper.rgx.call(engine,ua,rgxmap.engine);return engine};this.getOS=function(){var os={name:undefined,version:undefined};mapper.rgx.call(os,ua,rgxmap.os);return os};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return ua};this.setUA=function(uastring){ua=uastring;return this};return this};UAParser.VERSION=LIBVERSION;UAParser.BROWSER={NAME:NAME,MAJOR:MAJOR,VERSION:VERSION};UAParser.CPU={ARCHITECTURE:ARCHITECTURE};UAParser.DEVICE={MODEL:MODEL,VENDOR:VENDOR,TYPE:TYPE,CONSOLE:CONSOLE,MOBILE:MOBILE,SMARTTV:SMARTTV,TABLET:TABLET,WEARABLE:WEARABLE,EMBEDDED:EMBEDDED};UAParser.ENGINE={NAME:NAME,VERSION:VERSION};UAParser.OS={NAME:NAME,VERSION:VERSION};if(typeof exports!==UNDEF_TYPE){if(typeof module!==UNDEF_TYPE&&module.exports){exports=module.exports=UAParser}exports.UAParser=UAParser}else{if(typeof define===FUNC_TYPE&&define.amd){define(function(){return UAParser})}else if(window){window.UAParser=UAParser}}var $=window&&(window.jQuery||window.Zepto);if(typeof $!==UNDEF_TYPE&&!$.ua){var parser=new UAParser;$.ua=parser.getResult();$.ua.get=function(){return parser.getUA()};$.ua.set=function(uastring){parser.setUA(uastring);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop]}}}})(typeof window==="object"?window:this);
﻿var TC = TC || {};

TC.tool = TC.tool || {};

TC.tool.Proxification = function (proxy, options) {
    var self = this;

    self.Consts = {
        url: {
            SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/
        }
    };

    if (proxy === undefined) {
        throw new TypeError('"proxy" parameter is undefined', "TC.tool.Proxification.js");
    }

    if (typeof proxy == "function") {
        self.proxy = proxy;
    } else {
        self.proxy = function (url) {
            var result = proxy;
            if (url.substr(0, 4) != "http") {
                result += window.location.protocol;
            }
            result += encodeURIComponent(url);
            return result;
        };
    }

    options = options || {};

    self._location = options.location || window.location;

    self.preventMixedContent = options.allowedMixedContent !== undefined ? !options.allowedMixedContent : true;
};

(function () {
    if (!window.fetch) {
        (function (self) {
            // polyfill https://github.com/github/fetch/
            'use strict'; if (self.fetch) { return }
            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }
            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }
            function normalizeName(name) {
                if (typeof name !== 'string') { name = String(name) }
                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) { throw new TypeError('Invalid character in header field name') }
                return name.toLowerCase()
            }
            function normalizeValue(value) {
                if (typeof value !== 'string') { value = String(value) }
                return value
            }
            function iteratorFor(items) {
                var iterator = {
                    next: function () {
                        var value = items.shift()
                        return { done: value === undefined, value: value }
                    }
                }
                if (support.iterable) { iterator[Symbol.iterator] = function () { return iterator } }
                return iterator
            }
            function Headers(headers) {
                this.map = {}
                if (headers instanceof Headers) { headers.forEach(function (value, name) { this.append(name, value) }, this) } else if (Array.isArray(headers)) { headers.forEach(function (header) { this.append(header[0], header[1]) }, this) } else if (headers) { Object.getOwnPropertyNames(headers).forEach(function (name) { this.append(name, headers[name]) }, this) }
            }
            Headers.prototype.append = function (name, value) {
                name = normalizeName(name)
                value = normalizeValue(value)
                var oldValue = this.map[name]
                this.map[name] = oldValue ? oldValue + ',' + value : value
            }
            Headers.prototype['delete'] = function (name) { delete this.map[normalizeName(name)] }
            Headers.prototype.get = function (name) {
                name = normalizeName(name)
                return this.has(name) ? this.map[name] : null
            }
            Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)) }
            Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = normalizeValue(value) }
            Headers.prototype.forEach = function (callback, thisArg) { for (var name in this.map) { if (this.map.hasOwnProperty(name)) { callback.call(thisArg, this.map[name], name, this) } } }
            Headers.prototype.keys = function () {
                var items = []
                this.forEach(function (value, name) { items.push(name) })
                return iteratorFor(items)
            }
            Headers.prototype.values = function () {
                var items = []
                this.forEach(function (value) { items.push(value) })
                return iteratorFor(items)
            }
            Headers.prototype.entries = function () {
                var items = []
                this.forEach(function (value, name) { items.push([name, value]) })
                return iteratorFor(items)
            }
            if (support.iterable) { Headers.prototype[Symbol.iterator] = Headers.prototype.entries }
            function consumed(body) {
                if (body.bodyUsed) { return Promise.reject(new TypeError('Already read')) }
                body.bodyUsed = !0
            }
            function fileReaderReady(reader) {
                return new Promise(function (resolve, reject) {
                    reader.onload = function () { resolve(reader.result) }
                    reader.onerror = function () { reject(reader.error) }
                })
            }
            function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsArrayBuffer(blob)
                return promise
            }
            function readBlobAsText(blob) {
                var reader = new FileReader()
                var promise = fileReaderReady(reader)
                reader.readAsText(blob)
                return promise
            }
            function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf)
                var chars = new Array(view.length)
                for (var i = 0; i < view.length; i++) { chars[i] = String.fromCharCode(view[i]) }
                return chars.join('')
            }
            function bufferClone(buf) {
                if (buf.slice) { return buf.slice(0) } else {
                    var view = new Uint8Array(buf.byteLength)
                    view.set(new Uint8Array(buf))
                    return view.buffer
                }
            }
            function Body() {
                this.bodyUsed = !1
                this._initBody = function (body) {
                    this._bodyInit = body
                    if (!body) { this._bodyText = '' } else if (typeof body === 'string') { this._bodyText = body } else if (support.blob && Blob.prototype.isPrototypeOf(body)) { this._bodyBlob = body } else if (support.formData && FormData.prototype.isPrototypeOf(body)) { this._bodyFormData = body } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this._bodyText = body.toString() } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                        this._bodyArrayBuffer = bufferClone(body.buffer)
                        this._bodyInit = new Blob([this._bodyArrayBuffer])
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) { this._bodyArrayBuffer = bufferClone(body) } else { throw new Error('unsupported BodyInit type') }
                    if (!this.headers.get('content-type')) { if (typeof body === 'string') { this.headers.set('content-type', 'text/plain;charset=UTF-8') } else if (this._bodyBlob && this._bodyBlob.type) { this.headers.set('content-type', this._bodyBlob.type) } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8') } }
                }
                if (support.blob) {
                    this.blob = function () {
                        var rejected = consumed(this)
                        if (rejected) { return rejected }
                        if (this._bodyBlob) { return Promise.resolve(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(new Blob([this._bodyArrayBuffer])) } else if (this._bodyFormData) { throw new Error('could not read FormData body as blob') } else { return Promise.resolve(new Blob([this._bodyText])) }
                    }
                    this.arrayBuffer = function () { if (this._bodyArrayBuffer) { return consumed(this) || Promise.resolve(this._bodyArrayBuffer) } else { return this.blob().then(readBlobAsArrayBuffer) } }
                }
                this.text = function () {
                    var rejected = consumed(this)
                    if (rejected) { return rejected }
                    if (this._bodyBlob) { return readBlobAsText(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer)) } else if (this._bodyFormData) { throw new Error('could not read FormData body as text') } else { return Promise.resolve(this._bodyText) }
                }
                if (support.formData) { this.formData = function () { return this.text().then(decode) } }
                this.json = function () { return this.text().then(JSON.parse) }
                return this
            }
            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
            function normalizeMethod(method) {
                var upcased = method.toUpperCase()
                return (methods.indexOf(upcased) > -1) ? upcased : method
            }
            function Request(input, options) {
                options = options || {}
                var body = options.body
                if (input instanceof Request) {
                    if (input.bodyUsed) { throw new TypeError('Already read') }
                    this.url = input.url
                    this.credentials = input.credentials
                    if (!options.headers) { this.headers = new Headers(input.headers) }
                    this.method = input.method
                    this.mode = input.mode
                    if (!body && input._bodyInit != null) {
                        body = input._bodyInit
                        input.bodyUsed = !0
                    }
                } else { this.url = String(input) }
                this.credentials = options.credentials || this.credentials || 'omit'
                if (options.headers || !this.headers) { this.headers = new Headers(options.headers) }
                this.method = normalizeMethod(options.method || this.method || 'GET')
                this.mode = options.mode || this.mode || null
                this.referrer = null
                if ((this.method === 'GET' || this.method === 'HEAD') && body) { throw new TypeError('Body not allowed for GET or HEAD requests') }
                this._initBody(body)
            }
            Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }) }
            function decode(body) {
                var form = new FormData()
                body.trim().split('&').forEach(function (bytes) {
                    if (bytes) {
                        var split = bytes.split('=')
                        var name = split.shift().replace(/\+/g, ' ')
                        var value = split.join('=').replace(/\+/g, ' ')
                        form.append(decodeURIComponent(name), decodeURIComponent(value))
                    }
                })
                return form
            }
            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }
            Body.call(Request.prototype)
            function Response(bodyInit, options) {
                if (!options) { options = {} }
                this.type = 'default'
                this.status = options.status === undefined ? 200 : options.status
                this.ok = this.status >= 200 && this.status < 300
                this.statusText = 'statusText' in options ? options.statusText : 'OK'
                this.headers = new Headers(options.headers)
                this.url = options.url || ''
                this._initBody(bodyInit)
            }
            Body.call(Response.prototype)
            Response.prototype.clone = function () { return new Response(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url }) }
            Response.error = function () {
                var response = new Response(null, { status: 0, statusText: '' })
                response.type = 'error'
                return response
            }
            var redirectStatuses = [301, 302, 303, 307, 308]
            Response.redirect = function (url, status) {
                if (redirectStatuses.indexOf(status) === -1) { throw new RangeError('Invalid status code') }
                return new Response(null, { status: status, headers: { location: url } })
            }
            self.Headers = Headers
            self.Request = Request
            self.Response = Response
            self.fetch = function (input, init) {
                return new Promise(function (resolve, reject) {
                    var request = new Request(input, init);
                    init = init || {};
                    var xhr = new XMLHttpRequest();
                    xhr.onload = function () {
                        if (xhr.status === 0) {
                            return new Response(null, { status: xhr.status });
                        } else {
                            var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') }
                            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
                            var body = 'response' in xhr ? xhr.response : xhr.responseText
                            resolve(new Response(body, options))
                        }
                    }
                    xhr.onerror = function () { reject(new TypeError('Network request failed')) }
                    xhr.ontimeout = function () { reject(new TypeError('Network request failed')) }
                    xhr.open(request.method, request.url, !init.sync)
                    if (request.credentials === 'include') { xhr.withCredentials = !0 } else if (request.credentials === 'omit') { xhr.withCredentials = !1 }
                    if (!init.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' }
                    request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) })
                    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
                })
            }
            self.fetch.polyfill = !0
        })(typeof self !== 'undefined' ? self : this);
    }

    var srcToURL = function (src) {
        // GLS: 30/01/2019 Se carga un polyfill que no implementa correctamente el origin
        //if (window.URL && !(src.indexOf('//') == 0)) {
        //    try {
        //        var url = new URL(src);
        //        if (url.origin && url.origin.length > 0) {
        //            return url;
        //        }
        //    }
        //    catch (error) {
        //        // no hacemos nada y seguimos adelante
        //    }
        //}

        var anchor = document.createElement('a');
        anchor.href = src;

        if (!anchor.origin) {

            if (!(anchor.protocol && anchor.hostname)) {
                var urlParts = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(anchor.href);

                anchor.protocol = urlParts[1];

                if (urlParts[4].indexOf(':') > -1) {
                    var hostname = urlParts[4].split(':');
                    anchor.hostname = hostname[0];
                    anchor.port = hostname[1];
                } else {
                    anchor.hostname = urlParts[4];
                }
            }

            anchor.origin = (anchor.protocol.length === 0 ? window.location.protocol : anchor.protocol) + "//" + anchor.hostname + (anchor.port && (src.indexOf(anchor.port) > -1) ? ':' + anchor.port : '');
        }

        return anchor;
    };

    function HostCacheService(objectStoreName) {
        this.database = null;
        this.objectStoreName = objectStoreName;
    }

    HostCacheService.prototype = {
        /* createDB : create the scheme of the database  */
        createDB: function () {

            // In the following line, you should include the prefixes of implementations you want to test.
            window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            // DON'T use "var indexedDB = ..." if you're not in a function.
            // Moreover, you may need references to some window.IDB* objects:
            window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
            window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
            if (!window.indexedDB) {
                window.alert("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
            }

            var request = window.indexedDB.open('HostCacheService', 1);
            var that = this;
            request.onsuccess = function (evt) {
                that.database = evt.target.result;
            };
            request.onerror = function (evt) {
                console.log("IndexedDB--> onerror ");
            };
            request.onupgradeneeded = function (evt) {
                var thisDB = evt.target.result;
                if (!thisDB.objectStoreNames.contains('HostAction')) {
                    var store = thisDB.createObjectStore('HostAction', { keyPath: 'id' });
                    store.createIndex("host", ["action"], { unique: true });
                }
            };
        },
        /* info on available storage */
        info: function () {
            // Request storage usage and capacity left
            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT
                function (used, remaining) {
                    console.log("Used quota: " + used + ", remaining quota: " + remaining);
                }, function (e) {
                    console.log('Error', e);
                });
        },
        /* isReady when objectStore has been created  */
        isReady: function () {
            if (!this.database)
                return false;

            return this.database.objectStoreNames.contains(this.objectStoreName);
        },
        getHost: function (host) {
            return new Promise(function (resolve, reject) {
                if (!this.database) {
                    console.log("getAction no database", this.database);
                    reject("no IndexedDB");
                }
                else {
                    var transaction = this.database.transaction(this.objectStoreName);
                    var hostIndex = transaction.objectStore(this.objectStoreName).index("host");

                    var requestGet = hostIndex.get([host]);
                    requestGet.onsuccess = function (evt) {
                        if (evt.target.result) {
                            resolve({ data: evt.target.result });
                        }
                        else { reject("no action"); }
                    };

                    requestGet.onerror = function (evt) {
                        reject("no action get failed");
                    };
                }
            });
        },
        addHost: function (host, action) {

            if (this.database) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                try {
                    // the transaction could abort because of a QuotaExceededError error
                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });
                    transaction.objectStore(this.objectStoreName).add({ id: guid, host: host, action: action });
                }
                catch (ex) {
                    console.log(ex);
                }

            }
            else {
                console.log("addHost no database");
            }
        },
        removeHost: function (host) {
            this.getHost(host).then(function (host) {
                var transaction = this.database.transaction(this.objectStoreName, "readwrite");
                transaction.objectStore(this.objectStoreName).delete(host.data.id);
            });
        }
    };

    const HostCacheItem = function () {
        this.key = "";
        this.action = null;
        this.actionName = "";
    };

    const HostCache = function () {
        var toHost = function (src) {
            var url = srcToURL(src);
            if (url) {
                return url.origin;
            }

            return null;
        };

        //this.hostCacheService = new HostCacheService("HostAction");
        //this.hostCacheService.createDB();

        this._hosts = [];
        this._hostsImage = [];

        this.is = function (src, options) {
            var host = toHost(src);

            return this.get(host, options) !== null;
        };

        this.get = function (host, options) {
            if (this.getList(options).length === 0) {
                return null;
            } else {
                var filtered = this.getList(options).filter(function (h) {
                    return h.key === host && options.exportable == h.exportable;
                });
                if (filtered.length === 0) {
                    return null;
                } else {
                    return filtered[0];
                }
            }
        };

        this.getList = function (options) {
            return options.forImage ? this._hostsImage : this._hosts;
        };

        this.addKey = function (src, options) {
            var host = toHost(src);
            var newItem = { key: host, action: null };
            if (options.exportable) {
                newItem.exportable = options.exportable;
            }
            this.getList(options).push(newItem);
            return this.getList(options)[this.getList(options).length - 1];
        };

        this.removeKey = function (src, options) {
            var host = toHost(src);

            for (var i = 0; i < this.getList(options).length; i++) {
                if (this.getList(options)[i].key && options.exportable == this.getList(options)[i].exportable) {
                    this.getList(options).splice(i, 1);
                    break;
                }
            }
        };

        this.getAction = function (src, options) {
            options = options || {};

            var host = toHost(src);
            var cache = this.get(host, options);
            return cache._actionPromise;
        };
    };

    var toolProto = TC.tool.Proxification.prototype;

    toolProto.cacheHost = new HostCache();

    toolProto._isServiceWorker = function () {
        if (navigator.serviceWorker) {
            if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    toolProto._isSameOrigin = function (uri) {
        var self = this;

        var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
        var urlParts = !result && uri.match(self.Consts.url.SPLIT_REGEX);
        if (urlParts) {
            var uProtocol = urlParts[1];
            result = (uProtocol == self._location.protocol || uProtocol == undefined) && urlParts[3] == self._location.hostname;
            var uPort = urlParts[4], lPort = self._location.port;
            if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                result = result && uPort == lPort;
            }
        }
        return result;
    };

    toolProto._isSameProtocol = function (uri) {
        var protocolRegex = /^(https?:\/\/)/i;
        var uriProtocol = uri.match(protocolRegex);
        if (uriProtocol && uriProtocol.length > 1) {
            var locationProtocol = self._location.match(protocolRegex);
            if (locationProtocol && locationProtocol.length > 1) {
                return uriProtocol[0].trim() === locationProtocol[0].trim();
            }
        }

        return false;
    };

    toolProto._isSecureURL = function (url) {
        //sino empieza por http ni por https la consideramos segura
        if (!/^(f|ht)tps?:\/\//i.test(url))
            return true;
        return (/^(f|ht)tps:\/\//i.test(url));
    };

    var changeProtocol = function (src, newProtocol) {
        var url = srcToURL(src);
        return src.replace(url.protocol, newProtocol);
    };

    var toHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    var toHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    var _currentHTTP = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTPS(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTPS);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTP(src), options, resolve, reject);
            }
        });
    };

    var _currentHTTPS = function (src, options, resolve, reject) {
        var self = this;
        src = toHTTP(src);

        self._image.getImgTag(src, options).then(function (img) {
            resolve(img, self._actionHTTP);
        }, function (error) {
            if (error === self._image.ErrorType.PROTOCOL) {
                reject(error);
            } else {
                _byProxy.call(self, toHTTPS(src), options, resolve, reject);
            }
        });
    };

    var _byProxy = function (src, options, resolve, reject) {
        var self = this;

        options.sameOrigin = self._isSameOrigin(self._actionProxy.call(self, src));

        self._image.getImgTagByAction(src, options, self._actionProxy.bind(self)).then(function (img) {
            resolve(img, self._actionProxy);
        }, function (error) {
            reject(error);
        });
    };

    toolProto._actionDirect = function (src) {
        return src;
    };

    toolProto._actionHTTP = function (src) {
        return changeProtocol(src, "http:");
    };

    toolProto._actionHTTPS = function (src) {
        return changeProtocol(src, "https:");
    };

    toolProto._actionProxy = function (src) {
        var self = this;

        return self.proxy(src);
    };

    toolProto._image = {
        ErrorType: {
            CORS: 'cors',
            PROTOCOL: 'protocol',
            NOTFOUNDED: 'notfounded',
            UNEXPECTED: 'unexpected'
        },
        checkHttpStatus: function (src) {
            const self = this;
            return fetch(src, { credentials: 'omit' })
                .then(function (response) {
                    return { status: response.status, statusText: response.statusText };
                })
                .catch(function (error) {
                    return self.ErrorType.UNEXPECTED;
                });
        },
        getImgTag: function (src, options) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (options.exportable && !options.sameOrigin) {
                    img.dataset.checkCORSHeaders = true;
                    img.crossOrigin = "anonymous";
                }

                img.onload = function () {

                    console.log('Load OK: ' + img.src);

                    img.onload = img.onerror = undefined;

                    if (options.exportable && !options.sameOrigin) {
                        var createCanvas = function (img) {
                            var canvas = document.createElement('CANVAS');
                            var ctx = canvas.getContext('2d');
                            canvas.height = img.height;
                            canvas.width = img.width;
                            ctx.drawImage(img, 0, 0);

                            return canvas;
                        };

                        try {
                            var canvas = createCanvas(img);
                            result = canvas.toDataURL("image/png");
                            resolve(img);
                        } catch (e) {
                            if (e.code === 18) { // GLS: 18 - SECURITY_ERR
                                reject(self.ErrorType.CORS);
                            } else {
                                resolve(img);
                            }
                        }
                    } else { resolve(img); }
                };

                img.onerror = function (error) {

                    console.log('Load crossOrigin ERROR: ' + img.src);

                    if (img.dataset.checkCORSHeaders) {
                        img.crossOrigin = null;

                        img.onerror = undefined;
                        img.onerror = function (error) {
                            console.log('Load ERROR: ' + img.src);

                            self.checkHttpStatus(img.src).then(function (error) {
                                if (options.ignoreProxification) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    if (error.status === 400) {
                                        reject(self.ErrorType.PROTOCOL);
                                    } else {
                                        reject(error);
                                    }
                                }
                            }).catch(reject);
                            img.onload = img.onerror = undefined;
                        };

                        img.src = src;

                    } else {
                        console.log('Load ERROR: ' + img.src);

                        img.onload = img.onerror = undefined;

                        self.checkHttpStatus(img.src).then(function (error) {
                            if (options.ignoreProxification) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                if (error.status === 400) {
                                    reject(self.ErrorType.PROTOCOL);
                                } else {
                                    reject(error);
                                }
                            }
                        }).catch(reject);
                    }
                };

                try {
                    img.src = src;
                } catch (ex) {
                    console.log('Load ERROR: ' + img.src);

                    reject(self.ErrorType.UNEXPECTED);
                }
            }.bind(toolProto._image));
        },
        getImgTagByAction: function (src, options, action) {
            return new Promise(function (resolve, reject) {
                var self = this;

                var img = document.createElement("img");

                if (!options.sameOrigin) {
                    if (options.exportable) {
                        img.crossOrigin = "anonymous";
                    }
                }

                img.onload = function () {
                    img.onload = img.onerror = undefined;
                    resolve(img);
                };
                img.onerror = function (error) {
                    console.log('Load ERROR: ' + img.src);
                    img.onload = img.onerror = undefined;

                    self.checkHttpStatus(img.src).then(function (error) {
                        if (options.ignoreProxification) {
                            reject(self.ErrorType.PROTOCOL);
                        } else {
                            if (error.status === 400) {
                                reject(self.ErrorType.PROTOCOL);
                            } else {
                                reject(error);
                            }
                        }
                    }).catch(reject);
                };
                img.src = action(src);
            }.bind(toolProto._image));
        }
    };

    toolProto._fetch = {
        Headers: {
            CONTENTTYPE: "content-type"
        },
        ErrorType: {
            CORS: 'cors',
            NOTFOUNDED: 'Not_Founded',
            UNEXPECTED: 'Un_Expected',
            UNEXPECTEDCONTENTTYPE: 'Un_Expected_ContentType'
        },
        validateResponse: function (response) {
            if (!response.ok) { // status no está en el rango 200-299
                throw Error(response.statusText);
            }
            return response;
        },
        validateContentType: function (expectedContentType, response) {
            const self = this;

            if (!expectedContentType) {
                return response;
            }

            var contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);
            if (contentType && contentType.indexOf(expectedContentType) === -1) {
                throw Error(self._fetch.ErrorType.UNEXPECTEDCONTENTTYPE);
            }

            return response;
        }
    };

    /* Sólo GET */
    toolProto.fetchImage = function (src, options) {
        var self = this;

        options = options || {};
        options.forImage = true;

        return new Promise(function (resolve, reject) {

            if (self.cacheHost.is(src, options)) {
                self.cacheHost.getAction(src, options).then(function (cache) {
                    options.sameOrigin = self._isSameOrigin(cache.action(src));
                    self._image.getImgTagByAction(src, options, cache.action).then(function (img) {
                        resolve(img);
                    }, function (error) {
                        reject(error);
                    });
                });
            } else {
                var cache = self.cacheHost.addKey(src, options);
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    const _caching = function (img, action) {
                        cache.action = action.bind(self);
                        cache.exportable = options.exportable;

                        resolveActionPromise({ action: cache.action });

                        resolve(img);
                    };

                    const _reject = function (error) {
                        if (error.status == 200) {
                            //options.useCredentials = true;

                            // GLS: 04/01/2019 comento la siguiente línea porque no para de pedir al obtener una respuesta correcta y en el cuerpo viene una excepción
                            //makeRequest(options);

                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        } else {
                            self.cacheHost.removeKey(src, options);
                            reject(error);
                        }
                    };

                    const makeRequest = function (options) {
                        if (self._isSameOrigin(src)) {
                            options.sameOrigin = true;
                            self._image.getImgTag(src, options).then(function (img) {
                                _caching(img, self._actionDirect);
                            }, _reject);
                        } else {
                            if (!self._isSecureURL(src)) {
                                if (self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                    // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                    _currentHTTP.call(self, src, options, _caching, _reject);
                                } else {
                                    // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                    self._image.getImgTag(src, options).then(function (img) {
                                        _caching(img, self._actionDirect);
                                    }, function (error) {
                                        if ((options.exportable && error === self._image.ErrorType.CORS) || !self._isSecureURL(self._location)) {
                                            // Si la imagen debe ser exportable y en la solicitud por HTTP tenemos error de CORS, deducimos que por HTTPS pasará lo mismo
                                            if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                                _reject(error);
                                            } else {
                                                _byProxy.call(self, src, options, _caching, _reject);
                                            }
                                        } else {
                                            _currentHTTP.call(self, src, options, _caching, _reject);
                                        }
                                    });

                                }
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                self._image.getImgTag(src, options).then(function (img) {
                                    _caching(img, self._actionDirect);
                                }, function (error) {
                                    if ((options.exportable && error === self._image.ErrorType.CORS) || self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {
                                        // Si la imagen debe ser exportable y en la solicitud por HTTPS tenemos error de CORS, deducimos que por HTTP pasará lo mismo
                                        if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {
                                            _reject(error);
                                        } else {
                                            _byProxy.call(self, src, options, _caching, _reject);
                                        }
                                    } else {
                                        _currentHTTPS.call(self, src, options, _caching, _reject);
                                    }
                                });
                            }
                        }
                    };

                    makeRequest(options);
                });
            }
        });
    };

    toolProto.fetchRetry = function (url, options, n) {
        const self = this;
        var _fetch = fetch;

        if (options.sync) {
            _fetch = self.fetchSync;
        }

        return _fetch(url, options).catch(function (error) {
            if (n === 1) throw error;
            return self.fetchRetry(url, options, n - 1);
        });
    };

    toolProto.fetchSync = function (url, options) {
        var self = this;

        return new Promise(function (resolve, reject) {

            var support = {
                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {
                    try {
                        new Blob()
                        return !0
                    } catch (e) { return !1 }
                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self
            }

            if (support.arrayBuffer) {
                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']
                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }
                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }
            }

            function parseHeaders(rawHeaders) {
                var headers = new Headers()
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
                preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
                    var parts = line.split(':')
                    var key = parts.shift().trim()
                    if (key) {
                        var value = parts.join(':').trim()
                        headers.append(key, value)
                    }
                })
                return headers
            }


            var request = new Request(url, options);
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') };
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
            };
            xhr.onerror = function () { reject(new TypeError('Network request failed')) };
            xhr.ontimeout = function () { reject(new TypeError('Network request failed')) };
            xhr.open(request.method, request.url, false);
            if (request.credentials === 'include') { xhr.withCredentials = !options.sync } else if (request.credentials === 'omit') { xhr.withCredentials = !1 };
            if (!options.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' };
            request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) });
            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        })
    };

    toolProto.fetchXML = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "xml"; // No puedo usar la constante de la API porque está como application/xml y hay servicios que devuelven text/xml //TC.Consts.mimeType.XML;

        return self.fetch(url, options);
    };

    toolProto.fetchJSON = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = TC.Consts.mimeType.JSON;

        return self.fetch(url, options);
    };

    toolProto.fetchBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "blob";

        return self.fetch(url, options);
    };

    /* Para imágenes por POST */
    toolProto.fetchImageAsBlob = function (url, options) {
        const self = this;

        options = options || {};
        options.responseType = "image";

        return self.fetch(url, options);
    };

    /*
        type: GET|POST
        data: cuerpo del mensaje
        contentType: tipo del cuerpo del mensaje
        responseType: tipo de respuesta esperada
        retryAttempts: número de intentos por llamada
    */
    // indicar responseType en options
    toolProto.fetch = function (url, options) {
        const self = this;

        options = options || {};

        if (options.type) {
            options.method = options.type;

            delete options.type;
        }

        if (options.data) {
            options.body = options.data;

            delete options.data;
        }

        if (options.contentType) {
            options.headers = new Headers();
            options.headers.append('Content-Type', options.contentType);

            delete options.contentType;
        }

        if (!options.responseType) {
            options.responseType = '';
        }

        var _makeRequest = function (url, options, actions, cache) {
            var request;

            // fetch no incluye por defecto las cookies de autenticación, hay que indicarlo.
            //options.credentials = 'include';

            return (options.retryAttempts ? self.fetchRetry(actions[0].call(self, url), options, options.retryAttempts) : fetch(actions[0].call(self, url), options))
                .then(self._fetch.validateResponse)
                .then(self._fetch.validateContentType.bind(self, options.responseType))
                .then(function (response) {
                    if (cache) {
                        cache.action = actions[0].bind(self);
                    }

                    const contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);

                    //if (!options.responseType) {
                    //    if (contentType) {
                    //        options.responseType = contentType;
                    //    } else {
                    //        return response.text();
                    //    }
                    //}

                    const responseWithCharsetToDecodedString = function (charset) {
                        /*
                                2018 08 16
                                https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods
                                No existe método xml

                                https://developer.mozilla.org/en-US/docs/Web/API/Body/text
                                The text() method of the Body mixin takes a Response stream and reads it to completion.
                                It returns a promise that resolves with a USVString object (text).
                                The response is always decoded using UTF-8.
                            */

                        return response.blob().then(function (blob) {
                            const reader = new FileReader();

                            return new Promise(function (resolve, reject) {

                                reader.addEventListener("error", function () {
                                    reader.abort();
                                    reject(new DOMException("Problem decoding"));
                                });

                                reader.addEventListener("loadend", function () {
                                    resolve(reader.result);
                                });

                                reader.readAsText(blob, charset);
                            });
                        });
                    };

                    switch (true) {
                        case options.responseType.indexOf('xml') > -1:
                        case options.responseType.indexOf('text/xml') > -1:
                        case options.responseType.indexOf(TC.Consts.mimeType.XML) > -1:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    return (new window.DOMParser()).parseFromString(text, "text/xml");
                                });
                            } else {
                                return response.text().then(function (data) {
                                    return (new window.DOMParser()).parseFromString(data, "text/xml");
                                });
                            }
                        case options.responseType.indexOf('arraybuffer') > -1:
                            return response.arrayBuffer();
                        case options.responseType.indexOf('image') > -1:
                        case options.responseType.indexOf('blob') > -1:
                            return response.blob().then(function (blob) {
                                return new Blob([blob], { type: contentType });
                            });
                        case options.responseType.indexOf('document') > -1:
                            throw new DeveloperError('Unhandled responseType: ' + options.responseType);
                        case options.responseType.indexOf(TC.Consts.mimeType.JSON) > -1:
                            return response.json();
                        case options.responseType == '':
                        case options.responseType.indexOf('text') > -1:
                        default:
                            var hasCharset = /charset=([^;]*)/i.exec(contentType);
                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== "UTF-8") {
                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            } else {
                                return response.text().then(function (text) {
                                    if (options.responseType == '') {
                                        return { responseText: text, contentType: contentType };
                                    } else {
                                        return text;
                                    }
                                });
                            }
                    }
                })
                .catch(function (error) {
                    if (actions.length === 1) {
                        console.log('request failed', error);
                        return Promise.reject(new Error(error.message));
                    }

                    actions.shift();
                    return _makeRequest(url, options, actions, cache);
                });
        };

        if (self.cacheHost.is(url, options)) {
            return self.cacheHost.getAction(url, options).then(function (cache) {
                return _makeRequest(url, options, [cache.action]);
            }).catch(function (error) {
                return Promise.reject(new Error(error));
            });
        } else {
            var cache = self.cacheHost.addKey(url, options);
            return new Promise(function (resolve, reject) {
                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {

                    url = srcToURL(url).href;

                    const fnResolve = function (data) {
                        //self.cacheHost.hostCacheService.addHost(cache.key, cache.action);
                        resolveActionPromise({ action: cache.action });
                        resolve(data);
                    };

                    const fnReject = function (error) {
                        //self.cacheHost.hostCacheService.removeHost(cache.key);
                        self.cacheHost.removeKey(url, options);

                        rejectActionPromise(error);
                        reject(error);
                    };

                    if (self._isSameOrigin(url)) {
                        _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                    } else {
                        if (!self._isSecureURL(url)) {
                            if (self._isServiceWorker()) {
                                // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy
                                _makeRequest(url, options, [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy
                                _makeRequest(url, options, self._isSecureURL(self._location) ? [self._actionDirect, self._actionHTTPS, self._actionProxy] : [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        } else {
                            if (self._isServiceWorker()) {
                                // HTTPS -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            } else {
                                // HTTPS -> HTTP -> (HTTPS)Proxy
                                _makeRequest(url, options, [self._actionDirect, self._actionHTTP, self._actionProxy], cache).then(fnResolve).catch(fnReject);
                            }
                        }
                    }
                });
            });
        }
    };
})();
﻿var TC = TC || {};

TC.inherit = function (childCtor, parentCtor) {
    childCtor.prototype = Object.create(parentCtor.prototype);
    childCtor.prototype.constructor = childCtor;
    childCtor._super = parentCtor.prototype;
};

(function () {

    // Polyfill de CustomEvent
    /*! (c) Andrea Giammarchi - ISC */
    var self = this || /* istanbul ignore next */ {};
    self.CustomEvent = typeof CustomEvent === 'function' ?
        CustomEvent :
        (function (__p__) {
            CustomEvent[__p__] = new CustomEvent('').constructor[__p__];
            return CustomEvent;
            function CustomEvent(type, init) {
                if (!init) init = {};
                var e = document.createEvent('CustomEvent');
                e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);
                return e;
            }
        }('prototype'));

    if (!Element.prototype.matches) {
        Element.prototype.matches =
            Element.prototype.matchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.oMatchesSelector ||
            Element.prototype.webkitMatchesSelector;
    }

    const getNativeListener = function (evt, callback) {
        const result = function (evt) {
            const cbParameter = {
                type: evt.type,
                target: this,
                currentTarget: this
            };
            if (evt.detail) {
                Object.keys(evt.detail).forEach(function (key) {
                    if (!(key in cbParameter)) {
                        cbParameter[key] = evt.detail[key];
                    }
                });
            }
            return callback.call(this, cbParameter);
        }.bind(this);
        const stack = this._listeners[evt] = this._listeners[evt] || new Map();
        stack.set(callback, result);
        return result;
    };

    const onInternal = function (events, callback, options) {
        const self = this;
        events.split(' ').forEach(function (evt) {
            self.$events.addEventListener(evt, getNativeListener.call(self, evt, callback), options);
        });
        return self;
    };

    TC.EventTarget = function () {
        const self = this;
        self._listeners = {};
        self.$events = document.createDocumentFragment();

        const delegate = function (method) {
            this[method] = self.$events[method].bind(self.$events);
        };
        const methods = [
            'addEventListener',
            'dispatchEvent',
            'removeEventListener'
        ];
        methods.forEach(delegate, self);

        const fill$events = function (method) {
            self.$events[method] = self[method].bind(self);
        };
        methods.push('on');
        methods.push('one');
        methods.push('off');
        methods.push('trigger');
        methods.forEach(fill$events, self);
    };

    const etProto = TC.EventTarget.prototype;

    etProto.on = function (events, callback) {
        return onInternal.call(this, events, callback);
    };

    if (navigator.userAgent.indexOf("Trident") >= 0 || navigator.userAgent.indexOf("MSIE") >= 0) {
        // Parche para IE
        etProto.one = function (events, callback) {
            const self = this;
            const newCallback = function (e) {
                self.off(events, newCallback);
                callback.call(this, e);
            };
            self.on(events, newCallback);
            return self;
        };
    } else {
        etProto.one = function (events, callback) {
            return onInternal.call(this, events, callback, { once: true });
        };
    }

    etProto.off = function (events, callback) {
        const self = this;
        const eventList = events.split(' ');
        if (callback) {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack && stack.has(callback)) {
                    self.$events.removeEventListener(evt, stack.get(callback));
                }
            });
        }
        else {
            eventList.forEach(function (evt) {
                const stack = self._listeners[evt];
                if (stack) {
                    stack.forEach(function (cb) {
                        self.$events.removeEventListener(evt, cb);
                    });
                    stack.clear();
                }
            });
        }
        return self;
    };

    etProto.trigger = function (type, options) {
        const self = this;
        //Compatibilidad hacia atrás
        if (window.$ && $.Event && type instanceof $.Event) {
            options = {};
            Object.keys(type).forEach(function (key) {
                if (key !== 'type') {
                    options[key] = type[key];
                }
            });
            type = type.type;
        }
        var ceOptions;
        if (options) {
            ceOptions = {
                detail: options
            };
        }
        const event = new CustomEvent(type, ceOptions);
        self.dispatchEvent(event);
    };

    TC.EventTarget._onBySelectorMap = new WeakMap();

    TC.EventTarget.listenerBySelector = function (selector, callback) {
        // Crea una estructura a partir de un mapa cuyas claves son los elementos.
        // Los valores son objetos cuyas claves son tipos de eventos
        // y cuyos valores son objetos que tienen como claves los selectores
        // y cuyos valores son las funciones de callback.
        // Se crea una función que va buscando la primera correspondencia con un selector.
        // En cuanto la encuentra, ejecuta el callback y deja de procesar.
        return function (e) {
            const element = this;
            const eventType = e.type;
            var eventTypes = TC.EventTarget._onBySelectorMap.get(element);
            if (!eventTypes) {
                eventTypes = {};
                TC.EventTarget._onBySelectorMap.set(element, eventTypes);
            }
            var selectors = eventTypes[eventType];
            if (!selectors) {
                eventTypes[eventType] = selectors = {};
            }
            if (!selectors[selector]) {
                selectors[selector] = callback;
            }
            // Para cada evento en cada elemento hay que llamar una sola vez al callback que toque.
            // Así que si se ejecuta un callback, prohibimos al resto de los listeners resolverse.
            if (!e._listenerBySelectorCalled) {
                var matches = false;
                var elm = e.target;
                var result;
                while (elm && elm !== element) {
                    for (selector in selectors) {
                        if (elm.matches && elm.matches(selector)) {
                            matches = true;
                            result = selectors[selector].call(element, e);
                            e._listenerBySelectorCalled = true;
                        }
                    }
                    if (matches) {
                        return result;
                    }
                    elm = elm.parentNode;
                }
            }
        };
    };

    /**
     * <p>Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que el constructor es asíncrono, por tanto cualquier código que haga uso de este objeto debería
     * estar dentro de una función de callback pasada como parámetro al método {{#crossLink "TC.Map/loaded:method"}}{{/crossLink}}.</p>
     * <p>Puede consultar también online el <a href="../../examples/Map.1.html">ejemplo 1</a>, el <a href="../../examples/Map.2.html">ejemplo 2</a> y el <a href="../../examples/Map.3.html">ejemplo 3</a>.</p>
     * @class TC.Map
     * @constructor
     * @async
     * @param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
     * @param {object} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global {{#crossLink "TC.Cfg"}}{{/crossLink}}.
     * @param {string} [options.crs="EPSG:25830"] Código EPSG del sistema de referencia espacial del mapa.
     * @param {array} [options.initialExtent] Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. 
     * Esta opción es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver TC.Cfg.{{#crossLink "TC.Cfg/crs:property"}}{{/crossLink}}).
     * Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/initialExtent:property"}}{{/crossLink}}.
     * @param {array} [options.maxExtent] Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima. Para más información consultar TC.Cfg.{{#crossLink "TC.Cfg/maxExtent:property"}}{{/crossLink}}.
     * @param {string} [options.layout] URL de una carpeta de maquetación. Consultar TC.Cfg.{{#crossLink "TC.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones.
     * @param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. 
     * @param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "TC.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. 
     * @param {TC.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.
     * @param {TC.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geográficas.
     * @param {string} [options.locale="es-ES"] Código de idioma de la interfaz de usuario. Este código debe ser obedecer la sintaxis definida por la <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF</a>.
     * Los valores posibles son <code>es-ES</code>, <code>eu-ES</code> y <code>en-US</code>.
     * @param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver TC.Cfg.{{#crossLink "TC.Cfg/proxy:property"}}{{/crossLink}}).
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa con las opciones por defecto.
     *         var map = new TC.Map("mapa");
     *     </script>
     * @example
     *     <div id="mapa"/>
     *     <script>
     *         // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
     *         var map = new TC.Map("mapa", {
     *             crs: "EPSG:4326",
     *             initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             maxExtent: [
     *                 -2.84820556640625,
     *                 41.78912492257675,
     *                 -0.32135009765625,
     *                 43.55789822064767
     *             ],
     *             baseLayers: [
     * 				TC.Consts.layer.IDENA_DYNBASEMAP
     *             ]
     *         });
     *     </script>
     * @example
     *     <div id="mapa"></div>
     *     <script>
     *         // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
     *         var map = new TC.Map("mapa", {
     *             workLayers: [
     *                 {
     *                     id: "topo_mallas",
     *                     title: "Toponimia y mallas cartográficas",
     *                     type: TC.Consts.layerType.WMS,
     *                     url: "//idena.navarra.es/ogc/wms",
     *                     layerNames: "IDENA:toponimia,IDENA:mallas"
     *                 }
     *             ]
     *         });
     *     </script>
     */

    var currentState = null;
    var previousState = null;
    const _setupStateControl = function () {
        const self = this;

        var MIN_TIMEOUT_VALUE = 4;

        // eventos a los que estamos suscritos para obtener el estado            
        var events = [
            TC.Consts.event.LAYERADD,
            TC.Consts.event.LAYERORDER,
            TC.Consts.event.LAYERREMOVE,
            //TC.Consts.event.LAYEROPACITY, // Este evento lo vamos a tratar por separado, para evitar exceso de actualizaciones de estado.
            TC.Consts.event.LAYERVISIBILITY,
            TC.Consts.event.ZOOM,
            TC.Consts.event.BASELAYERCHANGE].join(' ');

        // gestión siguiente - anterior

        // registramos el estado inicial                
        self.replaceCurrent = true;
        _addToHistory.call(self);

        const fn_addToHistory = _addToHistory.bind(self);

        // nos suscribimos a los eventos para registrar el estado en cada uno de ellos
        self.on(events, fn_addToHistory);

        // a la gestión del evento de opacidad le metemos un retardo, para evitar que haya un exceso de actualizaciones de estado.
        var layerOpacityHandlerTimeout;
        self.on(TC.Consts.event.LAYEROPACITY, function (e) {
            clearTimeout(layerOpacityHandlerTimeout);
            layerOpacityHandlerTimeout = setTimeout(function () {
                _addToHistory.call(self, e);
            }, 500);
        });

        // gestión siguiente - anterior
        window.addEventListener('popstate', function (e) {
            var wait;
            wait = self.loadingCtrl && self.loadingCtrl.addWait();
            setTimeout(function () {
                if (e) {
                    // eliminamos la suscripción para no registrar el cambio de estado que vamos a provocar
                    self.off(events, fn_addToHistory);

                    var state = e.state;
                    if (Object.prototype.toString.call(state) === '[object Object]') {
                        state = self.checkLocation();
                    }

                    // gestionamos la actualización para volver a suscribirnos a los eventos del mapa                        
                    _loadIntoMap.call(self, state).then(function () {
                        setTimeout(function () {
                            self.on(events, fn_addToHistory);
                        }, 200);
                        self.loadingCtrl && self.loadingCtrl.removeWait(wait);
                    });
                }
            }, MIN_TIMEOUT_VALUE);
        });
    };
    const _addToHistory = function (e) {
        const self = this;

        var state = _getMapState.call(self);
        if (self.replaceCurrent) {
            window.history.replaceState(state, null, null);
            delete self.replaceCurrent;

            return;
        } else {

            /*if (self.registerState != undefined && !self.registerState) {
                self.registerState = true;
                return;
            }*/
            self.lastEventType = e.type;

            var saveState = function () {
                previousState = currentState;
                currentState = TC.Util.utf8ToBase64(state);
                if (currentState !== previousState) {                    
                    window.history.pushState(state, null, window.location.href.split('#').shift() + '#' + currentState);
                }
            };

            if (e) {
                switch (true) {
                    case (e.type == TC.Consts.event.BASELAYERCHANGE):
                    case (e.type == TC.Consts.event.LAYERORDER):
                    case (e.type == TC.Consts.event.ZOOM):
                        saveState();
                        break;
                    case (e.type.toLowerCase().indexOf("LAYER".toLowerCase()) > -1):
                        // unicamente modifico el hash si la capa es WMS
                        if (e.layer.type == TC.Consts.layerType.WMS)
                            saveState();
                        break;
                }
            }
        }
    };
    const _getMapState = function (extraStates) {
        const self = this;

        var state = {};

        if (self.crs !== self.options.crs) {
            state.crs = self.crs;
        }

        var ext = self.getExtent();
        for (var i = 0; i < ext.length; i++) {
            if (Math.abs(ext[i]) > 180)
                ext[i] = Math.floor(ext[i] * 1000) / 1000;
        }
        state.ext = ext;

        //determinar capa base
        var baseLayerData = [];

        // ¿es una capa de respaldo?
        if (self.baseLayers) {            
            baseLayerData = self.baseLayers.filter(function (baseLayer) {                
                return baseLayer.isRaster() && baseLayer.fallbackLayer;
            }).map(function (baseLayer) {
                return {
                    baseLayer: baseLayer, fallbackLayerID: baseLayer.fallbackLayer.id
                };
            }).filter(function (baseLayerData) {
                return baseLayerData.fallbackLayerID === (self.baseLayer ? self.baseLayer.id : self.baseLayers[0].id);
            });
        }

        if (baseLayerData.length > 0) {
            state.base = baseLayerData[0].baseLayer.id;
        } else {
            state.base = (self.baseLayer || self.baseLayers[0]).id;
        }

        //capas cargadas
        state.layers = [];

        var layer, entry;
        for (var i = 0; i < self.workLayers.length; i++) {
            layer = self.workLayers[i];
            if (layer.type == "WMS" && !layer.options.stateless) {
                if (layer.layerNames && layer.layerNames.length) {
                    entry = {
                        u: TC.Util.isOnCapabilities(layer.url),
                        n: $.isArray(layer.names) ? layer.names.join(',') : layer.names,
                        o: layer.getOpacity(),
                        v: layer.getVisibility(),
                        h: layer.options.hideTitle,
                        ur: layer.unremovable,
                        t: layer.title,
                    };

                    state.layers.push(entry);
                }
            }
        }

        if (self.on3DView && self.view3D.cameraControls) {
            state.vw3 = self.view3D.cameraControls.getCameraState();
        }

        if (!window.jsonpack) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSONPACK);
        }

        if (extraStates) {
            $.extend(state, extraStates);
        }

        return jsonpack.pack(state);
    };
    const _clearMap = function () {
        const self = this;

        self.workLayers.filter(function (layer) {
            return !(layer instanceof (TC.layer.Vector));
        }).forEach(function (layer) {
            if (layer.unremovable) {
                layer.unremovable = false;
            }
            self.removeLayer(layer);
        });
    };
    const _loadIntoMap = function (stringOrJson) {
        const self = this;
        const promises = [];

        if (!self.loadingctrl) {
            self.loadingCtrl = self.getControlsByClass("TC.control.LoadingIndicator")[0];
        }

        if (!self.hasWait) {
            self.hasWait = self.loadingCtrl && self.loadingCtrl.addWait();
        }

        // GLS lo añado para poder gestionar el final de la actualización de estado y volver a suscribirme a los eventos del mapa
        return new Promise(function (resolve, reject) {
            var resolved = function () {
                self.loadingCtrl && self.loadingCtrl.removeWait(self.hasWait);
                delete self.hasWait;
                resolve();
            };

            var obj;
            if (typeof (stringOrJson) == "string") {
                try {
                    obj = jsonpack.unpack(stringOrJson);
                }
                catch (error) {
                    try {
                        obj = JSON.parse(stringOrJson);
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'));
                    }
                }
            } else {
                obj = stringOrJson;
            }

            if (obj) {
                // CRS
                if ((obj.crs && obj.crs !== self.crs) || (typeof obj.crs === 'undefined' && self.crs !== self.options.crs)) {
                    promises.push(self.setProjection({
                        crs: obj.crs || self.options.crs,
                        oldCrs: self.crs,
                        extent: obj.ext,
                        baseLayer: self.getLayer(obj.base)
                    }));
                }
                else {
                    //capa base
                    if (obj.base != self.getBaseLayer().id) {
                        if (self.getLayer(obj.base)) {
                            self.setBaseLayer(obj.base);
                        }
                        const firstOption = self.baseLayers.filter(function (baseLayer) {
                            return baseLayer.options.fallbackLayer === obj.base;
                        })[0];
                        if (firstOption) {
                            const fbPromise = self.addLayer(firstOption.getFallbackLayer());
                            promises.push(fbPromise);
                            fbPromise.then(function (newLayer) {
                                self.setBaseLayer(newLayer);
                            });
                        }
                    }

                    //extent
                    if (obj.ext) {
                        promises.push(self.setExtent(obj.ext, { animate: false }));
                    }
                }

                //capas cargadas        
                //borrar primero
                _clearMap.call(self);

                obj.layers = obj.layers || obj.capas || [];

                if (obj.layers.length > 0) {

                    for (var i = 0; i < obj.layers.length; i++) {
                        var capa = obj.layers[i];

                        var layerInConfig = false;

                        for (j = 0; j < self.options.workLayers.length; j++) {
                            var lyrCfg = $.extend({}, self.options.workLayers[j], { map: self });

                            if (capa.u === lyrCfg.url && lyrCfg.layerNames.indexOf(capa.n) >= 0) {
                                layerInConfig = true;
                                lyrCfg.renderOptions = { "opacity": capa.o, "hide": !capa.v };
                                lyrCfg.unremovable = capa.ur;                                
                                lyrCfg.title = capa.t;
                                promises.push(self.addLayer(lyrCfg).then(function (layer) {
                                    layer.setVisibility(this.v);
                                    layer.setOpacity(this.o, true);
                                }.bind(capa)));
                            }
                        }

                        if (!layerInConfig) {                            
                            promises.push(self.addLayer({
                                id: TC.getUID(),
                                url: TC.Util.isOnCapabilities(capa.u, capa.u.indexOf(window.location.protocol) < 0) || capa.u,
                                hideTitle: capa.h,
                                layerNames: capa.n ? capa.n.split(',') : "",
                                unremovable: capa.ur,
                                title: capa.t,
                                renderOptions: {
                                    opacity: capa.o,
                                    hide: !capa.v
                                }
                            }).then(function (layer) {
                                var rootNode = layer.wrap.getRootLayerNode();
                                layer.title = rootNode.Title || rootNode.title;
                                /*URI:el setOpacity recibe un nuevo parametro. Que indica si se no se va a lanzar evento LAYEROPACITY
                                esto es porque en el loadstate al establecer la opacidad dedido a un timeout pasados X segundos se lanzaba 
                                este evento y producía un push en el state innecesario*/
                                layer.setOpacity(this.o, true);
                                layer.setVisibility(this.v);
                            }.bind(capa)));
                        }
                    }
                }

                Promise.all(promises)
                    .then(function () {
                        resolved();
                    })
                    .catch(function () {
                        resolved();
                    });
            }
        });
    };

    const getReduceByBooleanFunction = function (prop) {
        return function (prev, cur, idx) {
            return cur[prop] ? idx : prev;
        };
    };
    const getReduceByIdFunction = function (id) {
        return function (prev, cur, idx, arr) {
            return cur.id === id ? idx : prev;
        };
    };

    const getAvailableBaseLayer = function (id) {
        const ablCollection = this instanceof TC.Map ? this.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
        return ablCollection.filter(function (abl) {
            return abl.id === id;
        })[0];
    };

    TC.Map = TC.Map || function (div, options) {
        ///<summary>
        ///Constructor
        ///</summary>
        ///<param name="div" type="HTMLElement|string">Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.</param>
        ///<param name="options" type="object" optional="true">Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global TC.Cfg.</param>
        ///<returns type="TC.Map"></returns>
        ///<field name='isReady' type='boolean'>Indica si todos los controles del mapa están cargados.</field>
        ///<field name='isLoaded' type='boolean' default='false'>Indica si todos los controles y todas las capas del mapa están cargados.</field>
        ///<field name='activeControl' type='TC.Control'>Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.</field>
        ///<field name='layers' type='array' elementType='TC.Layer'>Lista de todas las capas base cargadas en el mapa.</field>
        ///<field name='controls' type='array' elementType='TC.Control'>Lista de todos los controles del mapa.</field>
        const self = this;
        TC.EventTarget.call(self);
        TC.Map._instances.push(self);

        //TC.Object.apply(self, arguments);

        /**
         * Indica si todos los controles del mapa están cargados.
         * @property isReady
         * @type boolean
         * @default false
         */
        self.isReady = false;

        /**
         * Indica si todos los controles y todas las capas del mapa están cargados.
         * @property isLoaded
         * @type boolean
         * @default false
         */
        self.isLoaded = false;

        /**
         * Lista de todos los controles del mapa.
         * @property controls
         * @type array
         * @default []
         */
        self.controls = [];

        /**
         * Control que está activo en el mapa, y que por tanto responderá a los eventos de ratón en su área de visualización.
         * @property activeControl
         * @type TC.Control
         * @default null
         */
        self.activeControl = null;

        /**
         * Lista de todas las capas cargadas en el mapa.
         * @property layers
         * @type array
         * @default []
         */
        self.layers = [];

        /**
         * Lista de todas las capas base cargadas en el mapa.
         * @property baseLayers
         * @type array
         * @default []
         */
        self.baseLayers = [];

        /**
         * Lista de todas las capas de trabajo cargadas en el mapa.
         * @property workLayers
         * @type array
         * @default []
         */
        self.workLayers = [];

        /**
         * Capa base actual del mapa.
         * @property baseLayer
         * @type TC.Layer
         */
        self.baseLayer = null;

        /**
         * Capa donde se dibujan las entidades geográficas si no se especifica la capa explícitamente. Se instancia en el momento de añadir la primera entidad.
         * @property vectors
         * @type TC.layer.Vector
         * @default null
         */
        self.vectors = null;

        var loadingLayerCount = 0;
        /**
         * Elemento del DOM donde se ha creado el mapa.
         * @property div
         * @type HTMLElement
         */
        self.div = TC.Util.getDiv(div);
        self._$div = $(self.div);
        /**
         * El mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event MAPLOAD
         */
        /**
         * El mapa ha cargado todos sus controles, pero no hay garantía de que estén cargadas las capas
         * @event MAPREADY
         */
        /**
         * Se va a añadir una capa al mapa.
         * @event BEFORELAYERADD
         * @param {TC.Layer} layer Capa que se va a añadir.
         */
        /**
         * Se ha añadido una capa al mapa.
         * @event LAYERADD
         * @param {TC.Layer} layer Capa que se ha añadido.
         */
        /**
         * Se ha eliminado una capa del mapa.
         * @event LAYERREMOVE
         * @param {TC.Layer} layer Capa que se ha eliminado.
         */
        /**
         * Se ha cambiado de posición una capa en la lista de capas del mapa.
         * @event LAYERORDER
         * @param {TC.Layer} layer Capa que se ha eliminado.
         * @param {number} oldIndex Índice de la posición antes del cambio.
         * @param {number} newIndex Índice de la posición después del cambio.
         */
        /**
         * Se va a actualizar una capa del mapa: se van a modificar sus entidades o se va solicitar una nueva imagen.
         * @event BEFORELAYERUPDATE
         * @param {TC.Layer} layer Capa que va a actualizarse.
         */
        /**
         * Se ha actualizado una capa del mapa: se ha modificado sus entidades o se ha cargado una imagen nueva.
         * @event LAYERUPDATE
         * @param {TC.Layer} layer Capa que se ha actualizado.
         */
        /**
         * Ha habido un error al cargar la capa, bien porque no se ha podido obtener su capabilities o porque no soporta CRS compatibles.
         * @event LAYERERROR
         * @param {TC.Layer} layer Capa que sufre el error.
         */
        /**
         * Se ha establecido una nueva capa como mapa base.
         * @event BASELAYERCHANGE
         * @param {TC.Layer} layer Capa que es el nuevo mapa base.
         */
        /**
         * Se va a actualizar alguna capa del mapa.
         * @event BEFOREUPDATE
         */

        self.div.classList.add(TC.Consts.classes.LOADING);
        $(self.div).data('map', self);
        self.div.classList.add(TC.Consts.classes.MAP);

        // Para gestionar zoomToMarkers
        self._markerPromises = [];

        self._layerBuffer = {
            layers: [],
            contains: function (id) {
                return this.layers.some(function (l) {
                    return l.id === id;
                });
            },
            getIndex: function (id) {
                return this.layers.reduce(getReduceByIdFunction(id), -1);
            },
            add: function (id, isRaster, isBase) {
                var idx;
                const obj = {
                    id: id,
                    pending: true,
                    isRaster: isRaster,
                    isBase: isBase
                };
                if (isRaster) {
                    idx = this.getRasterIndex();
                    this.layers.splice(idx, 0, obj);
                }
                else {
                    idx = this.layers.length;
                    this.layers[idx] = obj;
                }
            },
            remove: function (id) {
                this.layers.splice(this.getIndex(id), 1);
            },
            getMapLayers: function () {
                return this.layers
                    .filter(function (l) {
                        return l.pending === false;
                    })
                    .map(function (l) {
                        return l.mapLayer;
                    });
            },
            resolve: function (map, layer, isBase) {
                const layerObj = this.layers[this.getIndex(layer.id)];
                layerObj.mapLayer = layer;
                layerObj.pending = false;
                map.layers = this.getMapLayers();
                if (isBase) {
                    if (map.baseLayers.length === 0) {
                        map.baseLayers = new Array(map.options.baseLayers.length);
                    }

                    var index = map.options.baseLayers.map(function (l) { return l.id }).indexOf(layer.id);
                    if (index < 0) {
                        var index = map.baseLayers.map(function (l) { return l.type }).indexOf(TC.Consts.layerType.VECTOR);
                        if (index < 0) {
                            map.baseLayers.push(layer);
                        } else {
                            map.baseLayers.splice(index, 0, layer);
                        }
                    } else {
                        map.baseLayers.splice(index, 1, layer);
                    }
                }
                else {
                    map.workLayers = map.layers.filter(function (l) {
                        return !l.isBase;
                    });
                }
            },
            reject: function (map, layer, isBase) {
                const layerObj = this.layers[this.getIndex(layer.id)];
                layerObj.mapLayer = layer;
                layerObj.pending = false;
                layerObj.rejected = true;
                var index = map.options.baseLayers.map(function (l) { return l.id }).indexOf(layer.id);
                map.baseLayers.splice(index, 1);
            },
            getResolvedWorkLayerIndex: function (map, id) {
                return this.layers.filter(function (l) {
                    return l.id === id || (!l.isBase && l.pending === false);
                }).reduce(getReduceByIdFunction(id), -1);
            },
            getResolvedVisibleLayerIndex: function (map, id) {
                var index = this.getResolvedWorkLayerIndex(map, id);
                if (map.baseLayer) {
                    index = index + 1;
                }
                return index;
            },
            getRasterIndex: function () {
                return this.layers.reduce(getReduceByBooleanFunction('isRaster'), -1) + 1;
            },
            checkMapLoad: function (map) {
                const self = this;
                if (map.options.baseLayers
                    .concat(map.options.workLayers)
                    .every(function (l) {
                        return self.contains(l.id || l);
                    }) && // Si ya se han empezado a procesar todas las capas de las opciones
                    !this.layers.some(function (layer) {
                        return layer.pending === true; // Si ya se han terminado de procesar
                    })) {
                    const throwMapLoad = function () {
                        if (!map.isLoaded) {
                            const setLoaded = function () {

                                // 07/03/2019 GLS: Bug 24832 la gestión del estado comienza después de TC.Consts.event.MAPLOAD, 
                                // como los callbacks a loaded se lanzan según el orden de suscripción, el de script.js de IDENA se lanza antes 
                                // que el de la gestión del estado, lo que provoca que las capas añadidas por queryString no se registren.
                                if (map.options.stateful) {
                                    _setupStateControl.call(map);
                                }

                                map.isLoaded = true;
                                map.trigger(TC.Consts.event.MAPLOAD);

                                // GLS 13/02/2019 Si el usuario navega con IE, no quitamos el loading del mapa hasta que el usuario haga click
                                if (!(Number.isInteger(TC.Util.detectIE()) && TC.Util.detectIE() < 12 && map.options.warningIE)) {
                                    map.div.classList.remove(TC.Consts.classes.LOADING);
                                }
                            };
                            // tenemos estado 3d
                            if (map.state && map.state.vw3) {
                                if (Number.isInteger(TC.Util.detectIE()) && TC.Util.detectIE() < 12) {
                                    map.toast(TC.Util.getLocaleString(map.options.locale, "threed.not.supported"), { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
                                    setLoaded();
                                } else {
                                    if (!map.div.classList.contains(TC.Consts.classes.THREED)) {
                                        map.div.classList.add(TC.Consts.classes.THREED);

                                        TC.loadJS(
                                            !TC.view || !TC.view.ThreeD,
                                            TC.apiLocation + 'TC/view/ThreeD',
                                            function () {
                                                TC.view.ThreeD.apply({
                                                    map: map, state: map.state.vw3, callback: function () {
                                                        setLoaded();

                                                        map.getControlsByClass(TC.control.ThreeD)[0].button.removeAttribute("disabled");
                                                    }
                                                });
                                            }
                                        );
                                    }
                                }
                            } else {
                                setLoaded();
                            }
                        }
                    };
                    // Gestionamos el final de la carga del mapa
                    if (map.baseLayer) {
                        throwMapLoad();
                    }
                    else {
                        //GLS: Si no hay mapa de fondo cargado es posible que se haya añadido desde diálogo modal, lo comprobamos en todos los mapas de fondo disponibles del API
                        var onAvailables = [];
                        if (map.state && map.state.base) {
                            onAvailables = TC.Cfg.availableBaseLayers.filter(function (l) { return l.id === map.state.base });
                        }

                        if (onAvailables.length > 0) {
                            onAvailables[0].isBase = true;
                            map.addLayer(onAvailables[0]).then(function (layer) {
                                throwMapLoad();
                            });
                        }
                        else {
                            // Si no hay capa base cargada cargamos la primera compatible
                            const lastResortBaseLayer = map.baseLayers.filter(function (layer) {
                                return !layer.mustReproject;
                            }).filter(function (l) {
                                return l.wrap && l.wrap.layer;
                            });

                            if (lastResortBaseLayer.length > 0) {
                                map.wrap.setBaseLayer(lastResortBaseLayer[0].wrap.layer);
                                map.baseLayer = lastResortBaseLayer[0];
                            }

                            throwMapLoad();
                        }
                    }
                }
            }
        };

        if (!TC.ready) {
            TC.Cfg = $.extend({}, TC.Defaults, TC.Cfg);
            TC.ready = true;
        }

        // GLS: mergeOptions es inclusivo, para poder sobrescribir los tipos de búsqueda, añado con valor a false las que el usuario no haya configurado.
        if (options && options.controls && options.controls.search && options.controls.search.allowedSearchTypes) {
            for (var allowed in TC.Cfg.controls.search.allowedSearchTypes) {
                if (!options.controls.search.allowedSearchTypes.hasOwnProperty(allowed)) {
                    options.controls.search.allowedSearchTypes[allowed] = false;
                }
            }
        }

        // Añado las capas disponibles a la configuración general

        /**
         * Objeto de opciones del constructor.
         * @property options
         * @type object
         */
        options = options || {};
        mergeOptions.call(self, options);

        const manageWarningIE = function () {
            const WARNINGIE_CLASS = '.tc-warningIE';
            const WARNINGIE_ID_TEMPLATE = "warningIE";
            const WARNINGIE_TEMPLATE = TC.isDebug ? TC.apiLocation + "TC/templates/WarningIE.html" : function () { dust.register(WARNINGIE_ID_TEMPLATE, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-warningIE\"><span>").h("i18n", ctx, {}, { "$key": "warningIE" }).w("</span><button class=\"tc-button tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "warningIEContinue" }).w("\">").h("i18n", ctx, {}, { "$key": "warningIEContinue" }).w("</button></div>"); } body_0.__dustBody = !0; return body_0 };

            TC.Util.getRenderedHtml(WARNINGIE_ID_TEMPLATE, WARNINGIE_TEMPLATE, null, function (html) {

                var template = document.createElement('template');
                template.innerHTML = html.trim();
                self.div.appendChild(template.content ? template.content.firstChild : template.firstChild);

                self.loaded(function () {
                    const button = document.querySelector(WARNINGIE_CLASS + ' > button');
                    button.classList.remove(TC.Consts.classes.HIDDEN);

                    const onWarningClick = function (e) {
                        button.removeEventListener('click', onWarningClick);
                        self.div.removeChild(document.querySelector(WARNINGIE_CLASS));
                        self.div.classList.remove(TC.Consts.classes.LOADING);
                    };

                    button.addEventListener('click', onWarningClick);
                });
            });
        };

        var init = function () {

            TC.loadJS(
                self.options.stateful && !window.jsonpack,
                [TC.apiLocation + TC.Consts.url.JSONPACK],
                function () {
                    if (self.options.stateful) {
                        self.state = self.checkLocation();
                    }

                    if (self.options.layout) {
                        self.trigger(TC.Consts.event.LAYOUTLOAD, { map: self });
                    }

                    if (options && options.workLayers !== undefined) {
                        self.options.workLayers = options.workLayers;
                    }
                    if (options && options.baseLayers !== undefined) {
                        self.options.baseLayers = options.baseLayers;
                    }

                    if (self.options.zoomToFeatures) {
                        // zoom a features solo cuando se cargue el mapa
                        var handleFeaturesAdd = function handleFeaturesAdd(e) {
                            clearTimeout(self._zoomToFeaturesTimeout);

                            self._zoomToFeaturesTimeout = setTimeout(function () {
                                self.zoomToFeatures(e.layer.features, { animate: false });
                                self.off(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                            }, 100);
                        };
                        self.on(TC.Consts.event.FEATURESADD, handleFeaturesAdd);
                    }
                    var _handleLayerAdd = function _handleLayerAdd(e) {
                        if (e.layer.isBase && (e.layer === self.baseLayer || (self.baseLayer && e.layer.fallbackLayer && e.layer.fallbackLayer.id === self.baseLayer.id))) {
                            if (typeof self.state !== "undefined") {
                                if (self.state.crs) {
                                    self.loaded(function () {
                                        self.setProjection({
                                            crs: self.state.crs,
                                            extent: self.state.ext
                                        });
                                    });
                                }
                                else {
                                    self.setExtent(self.state.ext, { animate: false });
                                }
                            }
                            self.off(TC.Consts.event.LAYERADD, _handleLayerAdd);
                        }
                    };
                    self.on(TC.Consts.event.LAYERADD, _handleLayerAdd);


                    /**
                     * Well-known ID (WKID) del CRS del mapa.
                     * @property crs
                     * @type string
                     */
                    self.crs = self.options.crs;
                    self.initialExtent = self.options.initialExtent;
                    self.maxExtent = self.options.maxExtent;

                    if (Number.isInteger(TC.Util.detectIE()) && TC.Util.detectIE() < 12 && self.options.warningIE) {
                        manageWarningIE();
                    }

                    self.wrap = new TC.wrap.Map(self);

                    TC.loadJS(
                        !(TC.isLegacy ? window[TC.Consts.PROJ4JSOBJ_LEGACY] : window[TC.Consts.PROJ4JSOBJ]),
                        [
                            TC.url.proj4js
                        ],
                        function () {
                            TC.loadJSInOrder(
                                !(TC.isLegacy ? window[TC.Consts.OLNS_LEGACY] : window[TC.Consts.OLNS]),
                                [
                                    TC.url.ol,
                                    TC.url.olConnector
                                ],
                                function () {
                                    TC.loadProjDef({
                                        crs: self.options.crs,
                                        callback: function () {
                                            self.wrap.setMap();
                                            const ctlPromises = [];
                                            for (var name in self.options.controls) {
                                                var ctlOptions = self.options.controls[name];
                                                if (ctlOptions) {
                                                    ctlOptions = typeof ctlOptions === 'boolean' ? {} : $.extend(true, {}, ctlOptions);
                                                    if (typeof ctlOptions.div === 'string') {
                                                        ctlOptions.div = self.div.querySelector('#' + ctlOptions.div) || ctlOptions.div;
                                                    }
                                                    ctlPromises.push(self.addControl(name, ctlOptions));
                                                }
                                            }

                                            self.on(TC.Consts.event.BEFORELAYERUPDATE, _triggerLayersBeforeUpdateEvent);
                                            self.on(TC.Consts.event.LAYERUPDATE, _triggerLayersUpdateEvent);

                                            var i;
                                            var j;
                                            var lyrCfg;
                                            for (i = 0; i < self.options.baseLayers.length; i++) {
                                                lyrCfg = self.options.baseLayers[i];
                                                if (typeof lyrCfg === 'string') {
                                                    lyrCfg = getAvailableBaseLayer.call(self, lyrCfg);
                                                }
                                                self.addLayer($.extend({}, lyrCfg, { isBase: true, map: self }));
                                            }

                                            var setVisibility = function (layer) {
                                                if (layer.isRaster() && !layer.names) {
                                                    layer.setVisibility(false);
                                                }
                                            };
                                            const workLayersNotInState = self.options.workLayers
                                                .map(function (workLayer) {
                                                    return $.extend({}, workLayer, { map: self });
                                                })
                                                .filter(function (workLayer) {
                                                    if (!self.state || !self.state.layers) {
                                                        return true;
                                                    }
                                                    return !self.state.layers.some(function (stateLayer) {
                                                        const result = stateLayer.u === workLayer.url && workLayer.layerNames.indexOf(stateLayer.n) >= 0;
                                                        if (result) {
                                                            stateLayer.id = workLayer.id; // Hemos identificado la capa, le damos el id que le corresponde
                                                        }
                                                        return result;
                                                    });
                                                });
                                            workLayersNotInState.forEach(function (workLayer) {
                                                self.addLayer(workLayer).then(setVisibility);
                                            });

                                            if (self.state && self.state.layers) {

                                                self.state.layers.forEach(function (stateLayer) {
                                                                                                        
                                                    // añado como promesa cada una de las capas que se añaden
                                                    self.addLayer({
                                                        id: stateLayer.id || TC.getUID(),
                                                        url: TC.Util.isOnCapabilities(stateLayer.u, stateLayer.u.indexOf(window.location.protocol) < 0) || stateLayer.u,
                                                        hideTitle: stateLayer.h,
                                                        layerNames: stateLayer.n ? stateLayer.n.split(',') : "",
                                                        unremovable: stateLayer.ur,
                                                        title: stateLayer.t,
                                                        renderOptions: {
                                                            opacity: stateLayer.o,
                                                            hide: !stateLayer.v
                                                        }
                                                    }).then(function (layer) {
                                                        layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                                                            var layer = this.parent;
                                                            if (event.error.code === 401 || event.error.code === 403)
                                                                layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                                                            layer.map.removeLayer(layer);
                                                        });
                                                        var rootNode = layer.wrap.getRootLayerNode();
                                                        layer.title = stateLayer.t || rootNode.Title || rootNode.title;
                                                        if (this.o < 1) {
                                                            layer.setOpacity(this.o);
                                                        }
                                                        if (!this.v) {
                                                            layer.setVisibility(this.v);
                                                        }
                                                    }.bind(stateLayer));
                                                });
                                            }
                                            Promise.all(ctlPromises).then(function () {
                                                self.isReady = true;
                                                self.trigger(TC.Consts.event.MAPREADY);
                                            })
                                            setHeightFix(self.div);
                                        }
                                    });
                                }
                            );
                        }
                    );

                    self.on(TC.Consts.event.FEATURECLICK, function (e) {
                        if (!self.activeControl || !self.activeControl.isExclusive()) {
                            if (self.on3DView) {
                                e.feature.showResultsPanel();
                            } else {
                                e.feature.showPopup();
                            }
                        }
                    });

                    self.on(TC.Consts.event.NOFEATURECLICK, function (e) {
                        e.layer._noFeatureClicked = true;
                        var allLayersClicked = true;
                        for (var i = 0, len = self.workLayers.length; i < len; i++) {
                            if (!self.workLayers[i]._noFeatureClicked) {
                                allLayersClicked = false;
                                break;
                            }
                        }
                        if (allLayersClicked) {
                            self.workLayers.forEach(function (wl) {
                                delete wl._noFeatureClicked;
                            });
                            self.getControlsByClass(TC.control.Popup).forEach(function (p) {
                                p.hide();
                            });
                        }
                    });
                }
            );
        };

        mapProto.getMapState = function (extraStates) {
            const self = this;

            var state = _getMapState.call(self, extraStates);
            return TC.Util.utf8ToBase64(state);
        };

        mapProto.getPreviousMapState = function () {
            return previousState;
        };

        mapProto.checkLocation = function () {
            var hash = window.location.hash;

            if (hash && hash.length > 1) {
                hash = hash.substr(1);

                var obj;
                try {
                    obj = jsonpack.unpack(TC.Util.base64ToUtf8(hash));
                }
                catch (error) {
                    try {
                        obj = JSON.parse(TC.Util.base64ToUtf8(hash));
                    }
                    catch (err) {
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                        return;
                    }
                }

                if (TC.Util.detectIE() && window.location.href.length === 2047) {
                    TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValidForIE'), TC.Consts.msgErrorMode.TOAST);
                }

                if (obj) {
                    var inValidState = false;
                    //chequeo la integriadad del objeto restaurado del State
                    if (!obj.hasOwnProperty("ext")) {
                        inValidState = true;
                        obj.ext = self.options.initialExtent;
                    }
                    if (!obj.hasOwnProperty("base")) {
                        inValidState = true;
                        obj.base = self.options.defaultBaseLayer;
                    }
                    if (!obj.hasOwnProperty("layers")) {
                        inValidState = true;
                        obj.layers = [];
                    }
                    else {
                        for (var i = obj.layers.length - 1; i >= 0; i--) {
                            if (!obj.layers[i] || !obj.layers[i].hasOwnProperty("u") || !obj.layers[i].hasOwnProperty("n")) {
                                inValidState = true;
                                obj.layers.length = obj.layers.length - 1;
                                continue;
                            }
                            else if (!obj.layers[i].hasOwnProperty("o") || !obj.layers[i].hasOwnProperty("v") || !obj.layers[i].hasOwnProperty("h")) {
                                inValidState = true
                                jQuery.extend(obj.layers[i], {
                                    o: (obj.layers[i].o || 1),
                                    v: (obj.layers[i].v || true),
                                    h: (obj.layers[i].h || false)
                                });
                            }
                        }
                    }

                    if (obj.hasOwnProperty("vw3")) {

                        if (!obj.vw3) {
                            inValidState = true;
                        } else if (!obj.vw3.cp || (obj.vw3.cp && obj.vw3.cp.length != 3) ||
                            !obj.vw3.chpr || (obj.vw3.chpr && obj.vw3.chpr.length != 3) ||
                            !obj.vw3.bcpd) {
                            inValidState = true;
                        }
                    }

                    if (inValidState)
                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
                    return obj;
                }
                TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            return;
        };

        var _checkIntegrity = function () {
        };

        /*
        *  _triggerLayersBeforeUpdateEvent: Triggers map beforeupdate event (jQuery.Event) when any layer starts loading
        *  Parameters: OpenLayers.Layer, event name ('loadstart', 'loadend')
        */
        var _triggerLayersBeforeUpdateEvent = function (e) {
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.BEFOREUPDATE);
            }
            loadingLayerCount = loadingLayerCount + 1;
        };

        var _triggerLayersUpdateEvent = function (e) {
            loadingLayerCount = loadingLayerCount - 1;
            if (loadingLayerCount <= 0) {
                loadingLayerCount = 0;
                self.trigger(TC.Consts.event.UPDATE);
            }
        };

        const buildLayout = function (layout) {
            var layoutObj = {};
            const tryGetFile = function (url, resource) {
                return new Promise(function (res, rej) {
                    //Comprobamos si existe el fichero enviando una petición HEAD
                    TC.ajax({
                        method: 'HEAD',
                        url: url
                    })
                        .then(function (data) {
                            res({ resource: resource, found: true, url: url });
                        })
                        .catch(function (error) {
                            res({ resource: resource, found: error.status !== 404, url: url });
                        })
                });
            };

            return new Promise(function (resolve, reject) {
                if (typeof (layout) === 'string') {
                    var layoutPath = layout;

                    var isAbsoluteUrl = /^(https?:)?\/\//i.test(layoutPath);

                    const getFileFromAvailableLocation = function (loObj, key, fileName) {
                        return new Promise(function (res, rej) {
                            // 1. Buscamos en un layout local
                            // 2. Buscamos en un layout en el API con el mismo nombre
                            // 3. Buscamos en el layout responsive del API
                            var urlsToQuery = [
                                layoutPath + '/' + fileName,
                                apiTcUrl + layoutPath + '/' + fileName,
                                apiTcUrl + 'layout/responsive' + '/' + fileName
                            ];

                            // flacunza: si la URL tiene pinta de ser absoluta es ella sola la más probable, así que la ponemos la primera
                            if (isAbsoluteUrl) {
                                urlsToQuery.unshift(layoutPath + '/' + fileName);
                            }

                            var i = 0;
                            (function iterate(pos) {
                                tryGetFile(urlsToQuery[pos], key).then(function (result) {
                                    if (result.found) {
                                        res(addFileToLayout(loObj, result));
                                    } else {
                                        if (pos === urlsToQuery.length - 1) {
                                            res(loObj);
                                        }
                                        else {
                                            iterate(++pos);
                                        }
                                    }
                                });
                            })(i);
                        });
                    };

                    var addFileToLayout = function (loObj, data) {
                        if (!(data.resource in loObj)) {

                            var resourceUrl = (data.found ? data.url : apiTcUrl + layoutPath + '/' + layoutFiles[data.resource]);
                            loObj[data.resource] = resourceUrl;
                        }

                        return loObj;
                    };

                    //buscamos el parámetro layout en la url del navegador
                    var apiTcUrl = TC.apiLocation + 'TC/';
                    //var defaultLayout = 'idena';
                    //var layoutPath = idena.layout ? idena.layout : defaultLayout;

                    var layoutFiles = { script: 'script.js', style: 'style.css', markup: 'markup.html', config: 'config.json', i18n: 'resources' };
                    var layoutFilesLength = Object.keys(layoutFiles).length;

                    Promise.all(Object.keys(layoutFiles).map(function (key) {
                        return getFileFromAvailableLocation(layoutObj, key, layoutFiles[key])
                    })).then(function () {
                        resolve(layoutObj);
                    });
                } else {
                    resolve(layout);
                }
            });
        };


        TC.i18n = TC.i18n || {};
        // i18n: carga de recursos si no está cargados previamente
        TC.i18n.loadResources = TC.i18n.loadResources || function (condition, path, locale) {
            var result;
            if (condition) {
                result = new Promise(function (resolve, reject) {
                    TC.ajax({
                        url: path + locale + '.json',
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    })
                        .then(function (data) {
                            TC.i18n[locale] = TC.i18n[locale] || {};
                            $.extend(TC.i18n[locale], data);
                            if (typeof (dust) !== 'undefined') {
                                TC.loadJS(
                                    !window.dust.i18n,
                                    TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                                    function () {
                                        dust.i18n.add(locale, TC.i18n[locale]);
                                        resolve();
                                    });
                            }
                        })
                        .catch(function (err) {
                            reject(err instanceof Error ? err : Error(err));
                        });
                });
            } else {
                dust.i18n.add(locale, TC.i18n[locale]);
                result = Promise.resolve();
            }
            return result;
        };

        var i18nPromises = [];
        var locale = self.options.locale;
        i18nPromises.push(new Promise(function (resolve, reject) {
            TC.loadJSInOrder(
                !window.dust || !window.dust.i18n,
                TC.url.templating,
                function () {
                    if (locale) {
                        dust.i18n.setLanguages([locale]);

                        i18nPromises.push(TC.i18n.loadResources(!TC.i18n[locale], TC.apiLocation + 'TC/resources/', locale));
                    }
                    resolve();
                }
            );
        }));

        Promise.all(i18nPromises).finally(function () {

            // Prevalece el layout que recibamos por parámetro en la aplicación. Si no lo hay, entonces usamos el de las opciones.
            const mapLayout = TC.Util.getParameterByName(TC.Cfg.layoutURLParamName) || self.options.layout;
            if (mapLayout) {
                buildLayout(mapLayout).then(function (layout) {
                    self.trigger(TC.Consts.event.BEFORELAYOUTLOAD, { map: self });

                    var layoutURLs;
                    if (typeof layout === 'string') {
                        layoutURLs = { href: $.trim(layout) };
                    }
                    else if (
                        layout.hasOwnProperty('config') ||
                        layout.hasOwnProperty('markup') ||
                        layout.hasOwnProperty('style') ||
                        layout.hasOwnProperty('ie8Style') ||
                        layout.hasOwnProperty('script') ||
                        layout.hasOwnProperty('href') ||
                        layout.hasOwnProperty('i18n')
                    ) {
                        layoutURLs = $.extend({}, layout);
                    }
                    if (layoutURLs.href) {
                        layoutURLs.href += layoutURLs.href.match(/\/$/) ? '' : '/';
                    }
                    else {
                        for (var key in layoutURLs) {
                            const value = layoutURLs[key];
                            if (value) {
                                layoutURLs.href = value.substr(0, value.lastIndexOf('/') + 1);
                                break;
                            }
                        }
                    }
                    layoutURLs.config = layoutURLs.config || layoutURLs.href + 'config.json';
                    layoutURLs.markup = layoutURLs.markup || layoutURLs.href + 'markup.html';
                    layoutURLs.style = layoutURLs.style || layoutURLs.href + 'style.css';
                    layoutURLs.ie8Style = layoutURLs.ie8Style || layoutURLs.href + 'ie8.css';
                    layoutURLs.script = layoutURLs.script || layoutURLs.href + 'script.js';
                    layoutURLs.i18n = layoutURLs.i18n || layoutURLs.href + 'resources';
                    if (layoutURLs.i18n) {
                        layoutURLs.i18n += layoutURLs.i18n.match(/\/$/) ? '' : '/';
                    }

                    self.layout = layoutURLs;

                    const layoutPromises = [];

                    const i18LayoutPromise = new Promise(function (resolve, reject) {
                        if (layoutURLs.config) {
                            const request = TC.ajax({
                                url: layoutURLs.config,
                                method: 'GET',
                                responseType: TC.Consts.mimeType.JSON,
                                //async: Modernizr.canvas, // !IE8,
                            });
                            request
                                .then(function (data) {
                                    resolve(data.i18n);
                                    mergeOptions.call(self, data, options);
                                })
                                .catch(function (error) {
                                    TC.error(error);
                                    resolve(false);
                                });
                            layoutPromises.push(request);
                        }
                        else {
                            resolve(false);
                        }
                    });
                    layoutPromises.push(i18LayoutPromise);

                    if (layoutURLs.style) {
                        // Añadimos una clase para hacer más fáciles las reglas del layout
                        self.div.classList.add('tc-lo');
                        TC.loadCSS(layoutURLs.style);
                    }
                    if (!Modernizr.canvas && layoutURLs.ie8Style) {
                        TC.loadCSS(layoutURLs.ie8Style);
                    }

                    if (layoutURLs.markup) {
                        layoutPromises.push(new Promise(function (resolve, reject) {
                            TC.ajax({
                                url: layoutURLs.markup,
                                method: 'GET',
                                responseType: 'text',
                                //async: Modernizr.canvas, // !IE8
                            })
                                .then(function (data) {
                                    // markup.html puede ser una plantilla dust para soportar i18n, compilarla si es el caso
                                    i18LayoutPromise.then(function (i18n) {
                                        if (i18n && locale) {
                                            TC.i18n.loadResources(true, layoutURLs.i18n, locale).finally(function () {
                                                var templateId = 'tc-markup';
                                                var replacerFunction = function (str, match1, match2) {
                                                    return TC.Util.getLocaleString(locale, match1 || match2);
                                                };
                                                //data = data.replace(/\{\{([^\}\{]+)\}\}/g, replacerFunction); // Estilo {{key}}
                                                //data = data.replace(/\{@i18n \$key="([^\}\{]+)"\/\}/g, replacerFunction); // Estilo {@i18n $key="key"/}
                                                data = data.replace(/(?:\{\{([^\}\{]+)\}\}|\{@i18n \$key="([^\}\{]+)"\/\})/g, replacerFunction); // Ambos estilos anteriores
                                                if (self.div.lastElementChild) {
                                                    self.div.lastElementChild.insertAdjacentHTML('afterend', data);
                                                }
                                                else {
                                                    self.div.innerHTML = data;
                                                }
                                                resolve();
                                            });
                                        }
                                        else {
                                            if (self.div.lastElementChild) {
                                                self.div.lastElementChild.insertAdjacentHTML('afterend', data);
                                            }
                                            else {
                                                self.div.innerHTML = data;
                                            }
                                            resolve();
                                        }
                                    });
                                })
                                .catch(function (error) {
                                    reject(Error(error));
                                });
                        }));
                    }

                    Promise.all(layoutPromises).finally(function () {
                        TC.loadJS(
                            layoutURLs.script,
                            layoutURLs.script,
                            function () {
                                setHeightFix(self.div);
                                init();
                            });
                    });
                });
            }
            else {
                init();
            }
        });

        // Borramos árboles de capas cacheados
        self.on(TC.Consts.event.UPDATEPARAMS, function (e) {
            deleteTreeCache(e.layer);
        });
        self.on(TC.Consts.event.ZOOM, function () {
            for (var i = 0; i < self.workLayers.length; i++) {
                deleteTreeCache(self.workLayers[i]);
            }
        });

        // Redefinimos TC.error para añadir un aviso en el mapa
        /*var oldError = TC.error;
        TC.error = function (text) {
            oldError(text);
            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
        };*/
        var oldError = TC.error;
        TC.error = function (text, options, subject) {
            if (TC.isDebug && console.trace) {
                console.trace();
            }
            if (!options) {
                oldError(text);
                self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
            }
            else {
                var fnc = function (text, mode, subject) {
                    switch (mode) {
                        case TC.Consts.msgErrorMode.TOAST:
                            if (!self.toast) { console.warn("No existe el objeto Toast"); return; }
                            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });
                            break;
                        case TC.Consts.msgErrorMode.EMAIL:
                            if (TC.Cfg.loggingErrorsEnabled) {
                                JL("onerrorLogger").fatalException(!subject ? text : {
                                    "msg": subject,
                                    "errorMsg": text,
                                }, null);
                            }
                            break;
                        case TC.Consts.msgErrorMode.CONSOLE:
                        default:
                            console.error(text)
                            break;
                    }
                }
                if (!$.isArray(options)) {
                    fnc(text, options, subject)
                }
                else {
                    for (var i = 0; i < options.length; i++)
                        fnc(text, options[i], subject)
                }
            }

        };
    };

    TC.Map._instances = [];

    TC.Map.get = function (elm) {
        for (var i = 0, len = TC.Map._instances.length; i < len; i++) {
            const instance = TC.Map._instances[i];
            if (instance.div === elm) {
                return instance;
            }
        }
    };

    TC.inherit(TC.Map, TC.EventTarget);

    var deleteTreeCache = function (layer) {
        if (layer.type === TC.Consts.layerType.WMS) {
            layer.tree = null;
        }
    };

    /**
     * Función que mezcla opciones de mapa relativos a capa, teniendo cuidado de que puede haber objetos de opciones de capa o identificadores de capa.
     * En este último caso, si no son la opción prioritaria, hay que sustituirlos por los objetos de definiciones de capa.
     */
    var mergeLayerOptions = function (optionsArray, propertyName) {
        // lista de opciones de capa de los argumentos
        var layerOptions = $.map(optionsArray, function (elm) {
            var result = {};
            if (elm) {
                result[propertyName] = elm[propertyName];
            }
            return result;
        });
        if (propertyName === 'availableBaseLayers') console.log("layerOptions", layerOptions);
        // añadimos las opciones de capa de la configuración general
        var layerOption = {};
        layerOption[propertyName] = TC.Cfg[propertyName];
        layerOptions.unshift(layerOption);

        //Si se han definido baseLayers en el visor, hay que hacer un merge con las predefinidas en la API
        if (propertyName === 'baseLayers' && layerOptions[1]['baseLayers']) {
            layerOption = layerOptions[1];

            for (var i = 0; i < layerOption['baseLayers'].length; i++) {
                if (typeof layerOption['baseLayers'][i] === 'object') {
                    $.extend(layerOption['baseLayers'][i], getAvailableBaseLayer.call(this, layerOption['baseLayers'][i].id));
                }
            }
        } else {
            layerOptions.unshift(true); // Deep merge
            layerOption = $.extend.apply(this, layerOptions);
            if (propertyName === 'availableBaseLayers') console.log("layerOption", layerOption);
        }

        return layerOption[propertyName];
    };

    const mergeControlOptions = function (controlOptions) {
        if (controlOptions.controlContainer) {
            Object.keys(controlOptions).filter(function (key) {
                return Object.keys(controlOptions.controlContainer.controls).indexOf(key) > -1
            }).forEach(function (key) {
                delete controlOptions[key];
            });
        }

        return controlOptions;
    }

    var mergeOptions = function () {
        const result = this.options = $.extend.apply(this, $.merge([true, {}, TC.Cfg], arguments));
        // Concatenamos las colecciones availableBaseLayers
        result.availableBaseLayers = TC.Cfg.availableBaseLayers.concat.apply(TC.Cfg.availableBaseLayers, Array.prototype.map.call(arguments, function (arg) {
            return arg.availableBaseLayers || [];
        }));
        result.baseLayers = mergeLayerOptions.call(this, arguments, 'baseLayers');
        result.workLayers = mergeLayerOptions.call(this, arguments, 'workLayers');

        const controls = Array.prototype.slice.call(arguments).filter(function (elem) { return elem.controls }).map(function (elem) { return elem.controls });
        if (controls.length > 0) {
            result.controls = mergeControlOptions(result.controls);
        }

        return result;
    };

    var mapProto = TC.Map.prototype;

    var crsLayerError = function (map, layer) {
        var errorMessage = 'Layer "' + layer.title + '" ("' + layer.names + '"): ';
        var reason;
        if (layer.isValidFromNames()) {
            reason = 'layerSrsNotCompatible'
        } else {
            reason = 'layerNameNotValid';
        }
        errorMessage += TC.Util.getLocaleString(map.options.locale, reason);
        TC.error(errorMessage);
        map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: reason });
    };

    mapProto.getCRS = function () {
        const self = this;

        if (!self.on3DView) {
            return self.crs;
        } else {
            return self.view3D.crs;
        }
    };

    /**
     * Añade una capa al mapa.
     * @method addLayer
     * @async
     * @param {TC.Layer|TC.cfg.LayerOptions|string} layer Objeto de capa, objeto de opciones del constructor de la capa, o identificador de capa.
     * @param {function} [callback] Función de callback.
     * @return {jQuery.Promise} Promesa de objeto {{#crossLink "TC.Layer"}}{{/crossLink}}
     */
    mapProto.addLayer = function (layer, callback) {
        const self = this;

        const result = new Promise(function (resolve, reject) {

            const isLayerRaster = isRaster(layer);
            if (typeof layer === 'object' && !layer.id) {
                layer.id = TC.getUID();
            }

            self._layerBuffer.add(layer.id || layer, isLayerRaster, layer.isBase);

            var lyr;
            var test;
            var objUrl;

            if (isLayerRaster) {
                test = !TC.layer || !TC.layer.Raster;
                objUrl = TC.apiLocation + 'TC/layer/Raster';
            }
            else {
                test = !TC.layer || !TC.layer.Vector;
                objUrl = TC.apiLocation + 'TC/layer/Vector';
            }
            TC.loadJS(
                test,
                [objUrl],
                function () {
                    if (typeof layer === 'string') {
                        lyr = new TC.layer.Raster($.extend({}, getAvailableBaseLayer.call(self, layer), { map: self }));
                    }
                    else {
                        if (layer instanceof TC.Layer) {
                            lyr = layer;
                            lyr.map = self;
                        }
                        else {
                            layer.map = self;
                            if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                                lyr = new TC.layer.Vector(layer);
                            }
                            else {
                                lyr = new TC.layer.Raster(layer);
                            }
                        }
                    }

                    Promise.all([self.wrap.getMap(), lyr.wrap.getLayer()]).then(function () {

                        self.trigger(TC.Consts.event.BEFORELAYERADD, { layer: lyr });

                        // Nos aseguramos de que las capas raster se quedan por debajo de las vectoriales
                        var idx;
                        if (isRaster(lyr)) {
                            idx = self.wrap.indexOfFirstVector();
                        }
                        if (idx === -1) {
                            idx = self.wrap.getLayerCount();
                        }

                        const currentCrs = self.state && self.state.crs ? self.state.crs : self.getCRS();
                        const isCompatible = lyr.isCompatible(currentCrs);
                        if (lyr.isBase) {
                            if (!isCompatible) {
                                if (!lyr.type === TC.Consts.layerType.WMTS) {
                                    lyr.mustReproject = true;
                                }
                                else {
                                    const compatibleMatrixSet = lyr.wrap.getCompatibleMatrixSets(currentCrs)[0];
                                    if (compatibleMatrixSet) {
                                        lyr.wrap.setMatrixSet(compatibleMatrixSet);
                                    }
                                    else {
                                        lyr.mustReproject = true;
                                    }
                                }
                            }
                            if (self.state) {
                                lyr.isDefault = (self.state.base === lyr.id) || (self.state.base === lyr.options.fallbackLayer);
                            }
                            else if (typeof self.options.defaultBaseLayer === 'string') {
                                lyr.isDefault = self.options.defaultBaseLayer === lyr.id;
                            }
                            else if (typeof self.options.defaultBaseLayer === 'number') {
                                lyr.isDefault = self.options.defaultBaseLayer === self.baseLayers.length;
                            }
                            if (lyr.isDefault) {
                                var fit;
                                if (lyr.mustReproject && !lyr.type === TC.Consts.layerType.WMTS ||
                                    lyr.mustReproject && lyr.type === TC.Consts.layerType.WMTS && !lyr.wrap.getCompatibleMatrixSets(currentCrs)[0]) {
                                    if (lyr.options.fallbackLayer && lyr.getFallbackLayer) {

                                        self.addLayer(lyr.getFallbackLayer()).then(function (l) {
                                            self.wrap.setBaseLayer(l.wrap.layer);
                                            self.baseLayer = l.wrap.parent;
                                            // GLS: Tema casita + initialExtent
                                            fitToExtent(fit);

                                            resolve(lyr);
                                        });
                                    } else {
                                        crsLayerError(self, lyr);
                                        reject(layer);
                                    }
                                }
                                else {
                                    fit = self.baseLayer === null;

                                    lyr.wrap.getLayer().then(function (ollyr) {
                                        self.wrap.setBaseLayer(ollyr);
                                        self.baseLayer = lyr;

                                        // GLS: Tema casita + initialExtent
                                        fitToExtent(fit);

                                        resolve(lyr);
                                    });
                                }
                            }
                            else {
                                //self.baseLayers[self.baseLayers.length] = lyr;
                                resolve(lyr);
                            }
                        }
                        else {
                            if (isCompatible) {
                                lyr.wrap.getLayer().then(function (l) {
                                    resolve(lyr);
                                });
                            }
                            else {
                                crsLayerError(self, lyr);
                                reject(layer);
                            }
                        }
                    }, function (error) {
                        reject(layer);
                    });
                }
            );
        });

        result
            .then(function (l) {
                self._layerBuffer.resolve(self, l, l.isBase);
                if (!l.isBase) {
                    self.wrap.insertLayer(l.wrap.layer, self._layerBuffer.getResolvedVisibleLayerIndex(self, l.id));
                }
                self.trigger(TC.Consts.event.LAYERADD, { layer: l });
                self._layerBuffer.checkMapLoad(self);
                if ($.isFunction(callback)) {
                    callback(l);
                }
            })
            .catch(function (l) {
                self._layerBuffer.reject(self, l, l.isBase);                
                self._layerBuffer.checkMapLoad(self);
            });

        const fitToExtent = function (fit) {
            if (fit) {
                var opt = {
                    projection: self.wrap.map.getView().getProjection(),
                    extent: self.initialExtent
                };
                var resolutions = self.baseLayer.getResolutions();
                if (resolutions && resolutions.length) {
                    opt.resolutions = resolutions;
                }
                else {
                    opt.minZoom = self.wrap.map.getView().getMinZoom();
                    opt.maxZoom = self.wrap.map.getView().getMaxZoom();
                    var minResolution = self.baseLayer.wrap.layer.getMinResolution();
                    if (minResolution !== 0) {
                        opt.minResolution = minResolution;
                    }
                    var maxResolution = self.baseLayer.wrap.layer.getMaxResolution();
                    if (maxResolution !== Number.POSITIVE_INFINITY) {
                        opt.maxResolution = maxResolution;
                    }
                }

                self.wrap.map.setView(new ol.View(opt));
                self.wrap.map.getView().fit(self.initialExtent);
            }
        };
        return result;
    };


    mapProto.removeLayer = function (layer) {
        const self = this;

        return new Promise(function (resolve, reject) {

            if (layer.unremovable) {
                return reject("Unremovable");
            }

            layer.wrap.getLayer().then(function (olLayer) {
                for (var i = 0; i < self.layers.length; i++) {
                    if (self.layers[i] === layer) {
                        self.layers.splice(i, 1);
                    }
                }
                if (layer.isBase) {
                    for (var i = 0; i < self.baseLayers.length; i++) {
                        if (self.baseLayers[i] === layer) {
                            self.baseLayers.splice(i, 1);
                            if (self.baseLayer === layer) {
                                self.setBaseLayer(self.baseLayers[0]);
                            }
                            break;
                        }
                    }
                }
                else {
                    for (var i = 0; i < self.workLayers.length; i++) {
                        if (self.workLayers[i] === layer) {
                            self.workLayers.splice(i, 1);
                            break;
                        }
                    }
                    if (layer === self.vectors) {
                        self.vectors = null;
                    }
                }
                self.wrap.removeLayer(olLayer);
                self._layerBuffer.remove(layer.id);
                self.trigger(TC.Consts.event.LAYERREMOVE, { layer: layer });
                self._layerBuffer.checkMapLoad(self);
                resolve(layer);
            });
        });
    };


    mapProto.insertLayer = function (layer, idx, callback) {
        var self = this;
        var beforeIdx = -1;
        for (var i = 0; i < self.layers.length; i++) {
            if (layer === self.layers[i]) {
                beforeIdx = i;
                break;
            }
        }

        var promises = [];
        promises.push(layer.wrap.getLayer());
        var targetLayer = self.layers[idx];
        if (targetLayer) {
            promises.push(targetLayer.wrap.getLayer());
        }
        Promise.all(promises).then(function (olLayers) {
            const olLayer = olLayers[0];
            const olTargetLayer = olLayers[1];
            var olIdx = -1;
            if (olTargetLayer) {
                olIdx = self.wrap.getLayerIndex(olTargetLayer);
            }
            else {
                olIdx = self.wrap.getLayerCount();
            }
            if (olIdx >= 0) {
                layer.map = self;
                self.wrap.insertLayer(olLayer, olIdx);
                if (beforeIdx > -1) {
                    self.layers.splice(beforeIdx, 1);
                }
                self.layers.splice(idx, 0, layer);
                self.workLayers = self.layers.filter(function (elm) {
                    return !elm.isBase;
                });
                self.trigger(TC.Consts.event.LAYERORDER, { layer: layer, oldIndex: beforeIdx, newIndex: idx });
            }
            if ($.isFunction(callback)) {
                callback();
            }
        });
    };

    mapProto.setLayerIndex = function (layer, idx) {
        this.wrap.setLayerIndex(layer.wrap.layer, idx);
    };

    mapProto.putLayerOnTop = function (layer) {
        var self = this;
        var n = self.wrap.getLayerCount();
        self.setLayerIndex(layer, n - 1);
    };

    /*
    *  setBaseLayer: Set a layer as base layer, it is added to layers collection it wasn't before
    *  Parameters: TC.Layer or string, callback which accepts layer as parameter
    *  Returns: TC.Layer promise
    */
    mapProto.setBaseLayer = function (layer, callback) {
        var self = this;
        var result = null;
        var found = false;

        if (typeof layer === 'string') {
            var i;
            for (i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    layer = self.layers[i];
                    found = true;
                    break;
                }
            }
            if (!found) {
                layer = getAvailableBaseLayer.call(self, layer);
                if (layer) {
                    layer = self.addLayer($.extend(true, {}, layer, { isDefault: true, map: self }));
                    found = true;
                }
            }
        }
        else {
            if ($.inArray(layer, self.layers) < 0) {
                layer.isDefault = true;
                layer.map = self;
                self.addLayer(layer);
                // GLS: comento lo siguiente porque ya se va a tratar en la línea 1838, si no, se lanza el evento 2 veces
                //.then(function () {                
                //self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                //if ($.isFunction(callback)) {
                //    callback();
                //}
                //});

                //result = layer;
                //return result;
            }
            found = true;
        }
        if (!found) {
            TC.error('Base layer is not available');
        }
        else {
            if (!layer.isCompatible(self.getCRS()) && (!layer.fallbackLayer || layer.fallbackLayer && !layer.fallbackLayer.isCompatible(self.getCRS()))) {
                TC.error('Base layer must be reprojected');
            }
            else {
                self.trigger(TC.Consts.event.BEFOREBASELAYERCHANGE, { oldLayer: self.getBaseLayer(), newLayer: layer });

                result = layer;
                self.wrap.getMap().then(function (olMap) {
                    layer.wrap.getLayer().then(function (olLayer) {
                        self.wrap.setBaseLayer(olLayer).then(function () {
                            self.baseLayer = layer;
                            self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });
                            if ($.isFunction(callback)) {
                                callback();
                            }
                        });
                    });
                });
            }
        }
        return result;
    };

    mapProto.setView = function (view) {
        const self = this;

        self.view = view;
        self.trigger(TC.Consts.event.VIEWCHANGE, { view: view });
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles del mapa se hayan cargado.
     * @method ready
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.ready = function (callback) {
        var self = this;
        if ($.isFunction(callback)) {
            if (self.isReady) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPREADY, callback);
            }
        }
    };

    /**
     * Asigna un callback que se ejecutará cuando los controles y las capas iniciales del mapa se hayan cargado.
     * @method loaded
     * @async
     * @param {function} [callback] Función a ejecutar.
     */
    mapProto.loaded = function (callback) {
        var self = this;
        if ($.isFunction(callback)) {
            if (self.isLoaded) {
                callback();
            }
            else {
                self.one(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };



    /**
     * Devuelve un árbol de capas del mapa.
     * @method getLayerTree
     * @return {TC.LayerTree}
     */
    mapProto.getLayerTree = function () {


        var _traverse = function (o, func) {
            for (var i in o.children) {
                if (o.children && o.children.length > 0) {
                    //bajar un nivel en el árbol
                    _traverse(o.children[i], func);
                }

                func.apply(this, [o]);
            }
        };



        var self = this;
        var result = { baseLayers: [], workLayers: [] };
        if (self.baseLayer) {
            result.baseLayers[0] = self.baseLayer.getTree();
        }
        for (var i = 0; i < self.workLayers.length; i++) {
            var tree = self.workLayers[i].getTree();

            if (tree) {
                result.workLayers.unshift(tree);
            }
        }
        return result;
    };

    /**
     * Añade un control al mapa.
     * @method addControl
     * @async
     * @param {TC.Control|string} control Control a añadir o nombre del control
     * @param {object} [options] Objeto de opciones de configuración del control. Consultar el parámetro de opciones del constructor del control.
     * @return {jQuery.Promise} Promesa de objeto {{#crossLink "TC.Control"}}{{/crossLink}}
     */
    mapProto.addControl = function (control, options) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const _addCtl = function (ctl) {
                self.controls.push(ctl);
                // Lo envolvemos en Promise.resolve para asegurarse compatibilidad hacia atrás con los controles que devuelven un $.Deferred.
                return Promise.resolve(ctl.register(self))
                    .then(function (c) {
                        if (!ctl.div.parentElement) {
                            self.div.appendChild(ctl.div);
                        }
                        self.trigger(TC.Consts.event.CONTROLADD, { control: ctl });
                        return c;
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            };
            if (typeof control === 'string') {
                control = control.substr(0, 1).toUpperCase() + control.substr(1);
                TC.loadJS(
                    !TC.Control || !TC.control[control],
                    [TC.apiLocation + 'TC/control/' + control],
                    function () {
                        _addCtl(new TC.control[control](null, options)).then(function (ctl) {
                            resolve(ctl)
                        });
                    }
                );
            }
            else {
                _addCtl(control).then(function (ctl) {
                    resolve(ctl);
                });
            }
        });
    };

    /**
     * Devuelve la lista de controles que son de la clase especificada.
     * @method getControlsByClass
     * @param {function|string} classObj Nombre de la clase o función constructora de la clase.
     * @return {array}
     */
    mapProto.getControlsByClass = function (classObj) {
        var self = this;
        var result = [];
        var obj = classObj;
        if (typeof classObj === 'string') {
            obj = window;
            var namespaces = classObj.split('.');
            for (var i = 0; i < namespaces.length; i++) {
                obj = obj[namespaces[i]];
                if (!obj) {
                    break;
                }
            }
        }
        if ($.isFunction(obj)) {
            for (var i = 0; i < self.controls.length; i++) {
                var ctl = self.controls[i];
                if (ctl instanceof obj) {
                    result.push(ctl);
                }
            }
        }

        return result;
    };

    mapProto.getControlById = function (id) {
        const self = this;
        for (var i = 0, len = self.controls.length; i < len; i++) {
            const ctl = self.controls[i];
            if (ctl.id === id) {
                return ctl;
            }
        }
        return null;
    };

    mapProto.getDefaultControl = function () {
        var candidate = this.getControlsByClass("TC.control.FeatureInfo");
        if (candidate && candidate.length)
            return candidate[0];
        else
            return null;
    };

    /**
     * Devuelve el primer control del mapa que sea de la clase {{#crossLink "TC.control.LoadingIndicator"}}{{/crossLink}}.
     * @method getLoadingIndicator
     * @return {TC.control.LoadingIndicator}
     */
    mapProto.getLoadingIndicator = function () {
        var result = null;
        var ctls = this.getControlsByClass('TC.control.LoadingIndicator');
        if (ctls.length) {
            result = ctls[0];
        }
        return result;
    };

    /**
     * Establece la extensión del mapa.
     * @method setExtent
     * @param {array} extent Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al cambiar la extensión.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.setExtent = function (extent, options) {
        return this.wrap.setExtent(extent, options);
    };

    /**
     * Obtiene la extensión actual del mapa.
     * @method getExtent
     * @return {array} Array de cuatro números que representan las coordenadas x mínima, y mínima, x máxima e y máxima respectivamente.
     * La unidad de las coordenadas es la correspondiente al CRS del mapa.
     */
    mapProto.getExtent = function () {
        return this.wrap.getExtent();
    };

    /**
     * Establece el centro del mapa.
     * @method setCenter
     * @param {array} coord Array de dos números que representan la coordenada del punto en las unidades correspondientes al CRS del mapa.
     * @param {object} [options] Objeto de opciones.
     * @param {boolean} [options.animate=true] Establece si se realiza una animación al centrar.
     */
    mapProto.setCenter = function (coord, options) {
        return this.wrap.setCenter(coord, options);
    };

    mapProto.getCenter = function () {
        return this.wrap.getCenter();
    };

    mapProto.setRotation = function (rotation) {
        this.wrap.setRotation(rotation);
    };

    mapProto.getRotation = function () {
        return this.wrap.getRotation();
    };

    mapProto.getViewHTML = function () {
        return this.wrap.getViewport();
    };


    mapProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        const layers = options.layers || self.workLayers.concat(self.baseLayer);
        const crsLists = layers
            .filter(function (layer) {
                return layer.isRaster();
            }) // capas raster
            .map(function (layer) {
                return layer.getCompatibleCRS({ normalized: true, includeFallback: options.includeFallbacks });
            });
        const otherCrsLists = crsLists.slice(1);
        return crsLists[0].filter(function (elm) {
            return otherCrsLists.every(function (crsList) {
                return crsList.indexOf(elm) >= 0;
            });
        });
    };

    mapProto.loadProjections = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            const crsList = options.crsList || [];
            Promise.all(crsList
                .map(function (crs) {
                    return TC.getProjectionData({
                        crs: TC.Util.getCRSCode(crs)
                    });
                })).then(function (responses) {
                    var projList = responses
                        .filter(function (response) {
                            return response.status === 'ok' && response.number_result > 0;
                        })
                        .map(function (response) {
                            const projData = response.results[0];
                            const code = 'EPSG:' + projData.code;
                            TC.loadProjDef({
                                crs: code,
                                def: projData.def,
                                name: projData.name
                            });
                            return {
                                code: code,
                                name: projData.name,
                                proj4: projData.proj4,
                                unit: projData.unit
                            };
                        });
                    if (options.orderBy) {
                        projList = projList
                            .sort(TC.Util.getSorterByProperty(options.orderBy));
                    }
                    resolve(projList);
                },
                function (error) {
                    reject(error);
                });
        });
    };

    mapProto.setProjection = function (options) {
        const self = this;
        options = options || {};
        return new Promise(function (resolve, reject) {
            var baseLayer;
            if (options.crs) {
                if (options.baseLayer) {
                    baseLayer = options.baseLayer;
                }
                else if (options.allowFallbackLayer) {
                    // Cambiamos de capa de fondo si es mejor o no hay más remedio
                    if (!self.baseLayer.isCompatible(options.crs) &&
                        self.baseLayer.wrap.getCompatibleMatrixSets(options.crs).length === 0) {
                        if (self.baseLayer.options.fallbackLayer) {
                            baseLayer = self.baseLayer.getFallbackLayer();
                        }
                    }
                    else if (self.baseLayer.firstOption && (self.baseLayer.firstOption.isCompatible(options.crs) ||
                        self.baseLayer.firstOption.wrap.getCompatibleMatrixSets(options.crs).length > 0)) {
                        baseLayer = self.baseLayer.firstOption;
                    }
                }
                if (!baseLayer) {
                    baseLayer = self.baseLayer;
                }

                // 03/04/2019 GLS: esperamos a que termine de añadirse la capa porque si no se duplica en la gestión de la carga del CRS.
                const loadProj = function () {
                    TC.loadProjDef({
                        crs: options.crs,
                        callback: function () {                            
                            const setProjection = function (baseLayer) {

                            const _setProjection = function () {
                                const layerProjectionOptions = $.extend({}, options, { oldCrs: self.crs });
                                const setLayerProjection = function (layer) {
                                    layer.setProjection(layerProjectionOptions);
                                };
                                if (baseLayer.isCompatible(options.crs) || baseLayer.wrap.getCompatibleMatrixSets(options.crs).length > 0) {
                                    baseLayer.setProjection(layerProjectionOptions);
                                    self.wrap.setProjection($.extend({}, options, { baseLayer: baseLayer }));
                                    self.crs = options.crs;
                                    // En las capas base disponibles, evaluar su compatibilidad con el nuevo CRS
                                    self.baseLayers
                                        .filter(function (layer) {
                                            return layer !== baseLayer;
                                        })
                                        .forEach(setLayerProjection);
                                    // Reprojectamos capas cargadas
                                    self.workLayers.forEach(setLayerProjection);
                                    const resolveChange = function () {
                                        self.trigger(TC.Consts.event.PROJECTIONCHANGE, { crs: options.crs });
                                        resolve();
                                    };
                                    if (baseLayer && baseLayer !== self.baseLayer) {
                                        self.setBaseLayer(baseLayer, resolveChange);
                                    }
                                    else {
                                        resolveChange();
                                    }
                                }
                                else if (baseLayer.fallbackLayer) {
                                    setProjection(baseLayer.fallbackLayer);
                                } else {
                                    reject();
                                }
                            };

                                if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WTMS) {
                                    baseLayer.getCapabilitiesPromise().then(_setProjection);
                                } else {
                                    _setProjection();
                                }
                            };

                            setProjection(baseLayer);
                        }
                    });
                };

                if (self.baseLayers.indexOf(baseLayer) < 0) {
                    self.addLayer(baseLayer).then(loadProj);
                } else {
                    loadProj();
                }
            }
        });
    };

    mapProto.getMetersPerUnit = function () {
        return this.wrap.getMetersPerUnit();
    };

    /**
     * Obtiene una coordenada a partir de una posición del área de visualización del mapa en píxeles.
     * @method getCoordinateFromPixel
     * @param {array} xy Coordenada en píxeles de la posición en el área de visualización.
     * @return {array} Array de dos números que representa las coordenada del punto en las unidades correspondientes al CRS del mapa.
     */
    mapProto.getCoordinateFromPixel = function (xy) {
        return this.wrap.getCoordinateFromPixel(xy);
    };

    /**
     * Obtiene una posición en el área de visualización a partir de una coordenada.
     * @method getCoordinateFromPixel
     * @param {array} coord Coordenada en el mapa.
     * @return {array} Array de dos números que representa las posición del punto en píxeles.
     */
    mapProto.getPixelFromCoordinate = function (coord) {
        return this.wrap.getPixelFromCoordinate(coord);
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas las entidades geográficas pasadas por parámetro.
     * @method zoomToFeatures
     * @param {array} features Array de entidades geográficas. Si está vacío este método no hace nada.
     * @param {object} [options] Objeto de opciones de zoom.
     * @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del punto que se respetará al hacer zoom.
     * @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas las entidades. 
     * @param {boolean} [options.animate=false] Realizar animación al hacer el zoom. 
     * El valor es la relación resultante de la diferencia de dimensiones entre la extensión ampliada y la original relativa a la original.
     */
    mapProto.zoomToFeatures = function (features, options) {
        var self = this;
        if (features.length > 0) {
            var bounds = [Infinity, Infinity, -Infinity, -Infinity];
            var opts = options || {};
            var radius = opts.pointBoundsRadius || self.options.pointBoundsRadius;
            radius = radius / self.getMetersPerUnit();
            var extentMargin = opts.extentMargin;
            if (typeof extentMargin !== 'number') {
                extentMargin = self.options.extentMargin;
            }
            for (var i = 0; i < features.length; i++) {
                var b = features[i].getBounds();
                if (b) {
                    bounds[0] = Math.min(bounds[0], b[0]);
                    bounds[1] = Math.min(bounds[1], b[1]);
                    bounds[2] = Math.max(bounds[2], b[2]);
                    bounds[3] = Math.max(bounds[3], b[3]);
                }
            }
            if (bounds[2] - bounds[0] === 0) {
                bounds[0] = bounds[0] - radius;
                bounds[2] = bounds[2] + radius;
            }
            if (bounds[3] - bounds[1] === 0) {
                bounds[1] = bounds[1] - radius;
                bounds[3] = bounds[3] + radius;
            }
            if (self.options.extentMargin) {
                var dx = (bounds[2] - bounds[0]) * extentMargin / 2;
                var dy = (bounds[3] - bounds[1]) * extentMargin / 2;
                bounds[0] = bounds[0] - dx;
                bounds[1] = bounds[1] - dy;
                bounds[2] = bounds[2] + dx;
                bounds[3] = bounds[3] + dy;
            }
            if (self.options.maxExtent) {
                bounds[0] = Math.max(bounds[0], self.options.maxExtent[0]);
                bounds[1] = Math.max(bounds[1], self.options.maxExtent[1]);
                bounds[2] = Math.min(bounds[2], self.options.maxExtent[2]);
                bounds[3] = Math.min(bounds[3], self.options.maxExtent[3]);
            }
            self.wrap.setExtent(bounds, opts);

            // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
            self.trigger(TC.Consts.event.ZOOMTO, { extent: bounds });
        }
    };

    /**
     * Establece la extensión del mapa de forma que abarque todas los marcadores que existen en él.
     * El método espera a todos los marcadores pendientes de incluir, dado que el método {{#crossLink "TC.Map/addMarker:method"}}{{/crossLink}} es asíncrono.
     * @method zoomToMarkers
     */
    mapProto.zoomToMarkers = function (options) {
        var self = this;
        Promise.all(self._markerPromises).then(function () {
            var markers = [];
            for (var i = 0; i < self.workLayers.length; i++) {
                var layer = self.workLayers[i];
                if (layer.type === TC.Consts.layerType.VECTOR) {
                    for (var j = 0; j < layer.features.length; j++) {
                        var feature = layer.features[j];
                        if (feature instanceof TC.feature.Marker) {
                            markers[markers.length] = feature;
                        }
                    }
                }
            }

            self.zoomToFeatures(markers, options);
            self._markerPromises = [];
        });
    };

    /**
     * Obtiene una capa por su identificador o devuelve la propia capa.
     * @method getLayer
     * @param {string|TC.Layer} layer Identificador de la capa u objeto de capa.
     * @return {TC.Layer}
     */
    mapProto.getLayer = function (layer) {
        var self = this;
        var result = null;
        if (typeof layer === 'string') {
            for (var i = 0; i < self.layers.length; i++) {
                if (self.layers[i].id === layer) {
                    result = self.layers[i];
                    break;
                }
            }
        }
        else if (TC.Layer && layer instanceof TC.Layer) {
            result = layer;
        }
        return result;
    };

    var _getVectors = function (map) {
        var result;
        if (!map.vectors) {
            result = map.addLayer({
                id: TC.getUID(), title: TC.i18n[map.options.locale]['vectors'], type: TC.Consts.layerType.VECTOR
            });
            map.vectors = result;
            result.then(function (vectors) {
                map.vectors = vectors;
            });
        }
        else {
            result = Promise.resolve(map.vectors);
        }
        return result;
    };

    /**
     * Añade un punto al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPoint
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.PointStyleOptions} [options] Opciones del punto.
     */
    mapProto.addPoint = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                layer.addPoint(coord, options);
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPoint(coord, options);
            });
        }
    };

    /**
     * Añade un marcador puntual al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addMarker
     * @async
     * @param {array} coord Array de dos números representando la coordenada del punto en las unidades del CRS del mapa.
     * @param {TC.cfg.MarkerStyleOptions} [options] Opciones del marcador.
     */
    mapProto.addMarker = function (coord, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                self._markerPromises.push(layer.addMarker(coord, options));

            }
        }
        else {
            // Se añade una promise más para evitar que zoomToMarkers salte antes de poblarse el array _markerPromises.
            self._markerPromises.push(new Promise(function (resolve, reject) {
                _getVectors(self).then(function (vectors) {
                    vectors.addMarker(coord, options).then(function (marker) {
                        resolve(marker);
                    });
                });
            }));
        }
    };

    /**
     * Añade una polilínea al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolyline
     * @async
     * @param {array} coords Array de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * @param {object} [options] Opciones de la polilínea.
     */
    mapProto.addPolyline = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolyline(coords, options);
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolyline(coords, options);
            });
        }
    };

    /**
     * Añade un polígono al mapa. Si no se especifica una capa en el parámetro de opciones se añadirá a una capa vectorial destinada a añadir entidades geográficas.
     * Esta capa se crea al añadir por primera vez una entidad sin especificar capa.
     * @method addPolygon
     * @async
     * @param {array} coords Array que contiene anillos. Estos a su vez son arrays de arrays de dos números representando las coordenadas de los vértices en las unidades del CRS del mapa.
     * El primer anillo es el exterior y el resto son islas. No es necesario cerrar los anillos (poner el mismo vértice al principio y al final).
     * @param {object} [options] Opciones del polígono.
     */
    mapProto.addPolygon = function (coords, options) {
        var self = this;
        if (options && options.layer) {
            var layer = self.getLayer(options.layer);
            if (layer) {
                options.layer.addPolygon(coords, options);
            }
        }
        else {
            _getVectors(self).then(function (vectors) {
                vectors.addPolygon(coords, options);
            });
        }
    };




    mapProto.getBaseLayer = function () {
        return this.baseLayer || this.baseLayers[0];
    };

    mapProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    mapProto.getResolution = function () {
        return this.wrap.getResolution();
    };

    mapProto.setResolution = function (resolution) {
        this.wrap.setResolution(resolution);
    };

    mapProto.exportFeatures = function (features, options) {
        var self = this;
        options = options || {};
        var loadingCtl = self.getLoadingIndicator();
        var waitId = loadingCtl && loadingCtl.addWait();
        // Eliminamos las elevaciones nulas
        // En GPX hay un bug con los valores cero, que hace que se tome el valor de elevación del punto previo, por eso ponemos NaN.
        const elevSubst = options.format === TC.Consts.format.GPX ? Number.NaN : 0;
        features.forEach(function (feature, idx) {
            var flatCoords = feature.getCoords({ pointArray: true });
            if (flatCoords.some(function (point) {
                return point[2] === null;
            })) {
                features[idx] = feature = feature.clone();
                flatCoords = feature.getCoords({ pointArray: true });
                flatCoords.forEach(function (point) {
                    if (point[2] === null) {
                        point[2] = elevSubst;
                    }
                });
            }
        });

        const text = self.wrap.exportFeatures(features, options);
        const mimeType = TC.Consts.mimeType[options.format];
        const format = options.format || "";
        TC.Util.downloadFile((options.fileName || TC.getUID()) + '.' + format.toLowerCase(), mimeType, text);
        loadingCtl && loadingCtl.removeWait(waitId);
    };


    var toastContainerClass = 'tc-toast-container';
    var toastClass = 'tc-toast';
    var toasts = {};
    var toastHide = function () {
        const toast = this;
        var container = toast;
        do {
            container = container.parentElement;
        }
        while (container && !container.matches('.' + toastContainerClass));
        const text = toast.innerHTML;
        toast.classList.add(TC.Consts.classes.HIDDEN);
        if (toasts[text] !== undefined) {
            toasts[text] = undefined;
        }
        setTimeout(function () {
            if (toast.parentElement) {
                toast.parentElement.removeChild(toast);
            }            
            if (container && !container.querySelector('.' + toastClass) && container.parentElement) {                
                container.parentElement.removeChild(container);                
            }
        }, 1000);
    };

    mapProto.toastHide = function (text) {
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
    };

    mapProto.toast = function (text, options) {
        const self = this;
        var opts = options || {
        };
        var duration = opts.duration || TC.Cfg.toastDuration;
        var toastInfo = toasts[text];
        if (toastInfo) {
            clearTimeout(toastInfo.timeout);
            if (toastInfo.toast && toastInfo.toast.parentElement) {
                toastInfo.toast.parentElement.removeChild(toastInfo.toast);
            }
            toastInfo.toast = null;
        }
        var container = self.div.querySelector('.' + toastContainerClass);
        if (!container) {
            container = document.createElement('div');
            container.classList.add(toastContainerClass);
            (opts.container ? opts.container : self.div).appendChild(container);
        }
        const toast = document.createElement('div');
        const span = document.createElement('span');
        toast.classList.add(toastClass);        
        toast.appendChild(span);
        const p = document.createElement('p');
        p.innerHTML = text;
        toast.appendChild(p);
        toast.addEventListener(TC.Consts.event.CLICK, toastHide);
        container.appendChild(toast);
        toastInfo = toasts[text] = {
            toast: toast
        };

        var className = '';
        switch (opts.type) {
            case TC.Consts.msgType.INFO:
                className = TC.Consts.classes.INFO;
                break;
            case TC.Consts.msgType.WARNING:
                className = TC.Consts.classes.WARNING;
                break;
            case TC.Consts.msgType.ERROR:
                className = TC.Consts.classes.ERROR;
                break;
        }
        if (className.length) {
            toastInfo.toast.classList.add(className);
        }

        toastInfo.timeout = setTimeout(function () {
            toastHide.call(toastInfo.toast);
        }, duration);
    };

    // iPad iOS7 bug fix
    var mapHeightNeedsFix = false;
    var setHeightFix = function (div) {
        if (/iPad/i.test(navigator.userAgent)) {
            var ih = window.innerHeight;
            var mh = div.getBoundingClientRect.height;
            var dh = Modernizr.mq('only screen and (orientation : landscape)') ? 20 : 0;
            if (mh === ih + dh) {
                mapHeightNeedsFix = true;
            }
        }
        var fix = function () {
            if (Modernizr.mq('only screen and (orientation : landscape)')) {
                div.classList.add(TC.Consts.classes.IPAD_IOS7_FIX);
            }
            else {
                div.classList.remove(TC.Consts.classes.IPAD_IOS7_FIX);
            }
        };
        if (mapHeightNeedsFix) {
            fix();
            window.addEventListener('resize', fix);
        }
        else {
            window.removeEventListener('resize', fix);
        }
    };

    var isRaster = function (layer) {
        return typeof layer === 'string' || (layer.type !== TC.Consts.layerType.VECTOR && layer.type !== TC.Consts.layerType.KML && layer.type !== TC.Consts.layerType.WFS);
    };

    mapProto.exportImage = function () {
        var self = this;
        var result = null;
        var errorMsg = 'El mapa actual no es compatible con la exportación de imágenes';
        var canvas = self.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
        if (canvas && self.options.crossOrigin) {
            try {
                result = canvas.toDataURL();
            }
            catch (e) {
                TC.error(errorMsg + ': ' + e.message);
            }
        }
        else {
            TC.error(errorMsg);
        }
        return result;
    };
})();

/**
 * Árbol de capas del mapa.
 * Esta clase no tiene constructor.
 * @class TC.LayerTree
 * @static
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas base del mapa.
 * @property baseLayers
 * @type array
 */
/**
 * Lista de árboles de (objetos de la clase {{#crossLink "TC.layer.LayerTree"}}{{/crossLink}}) de todas las capas de trabajo del mapa.
 * @property workLayers
 * @type array
 */

﻿; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Util = factory();
    }
})(TC, function () {

    String.prototype.soundex = function () {
        var a = this.toLowerCase().split('')
        f = a.shift(),
            r = '',
            codes = {
                a: '', e: '', i: '', o: '', u: '',
                b: 1, f: 1, p: 1, v: 1,
                c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2,
                d: 3, t: 3,
                l: 4,
                m: 5, n: 5,
                r: 6
            };

        r = f +
            a
                .map(function (v, i, a) { return codes[v] })
                .filter(function (v, i, a) { return ((i === 0) ? v !== codes[f] : v !== a[i - 1]); })
                .join('');

        return (r + '000').slice(0, 4).toUpperCase();
    }

    // Polyfill para IE
    Number.isInteger = Number.isInteger || function (value) {
        return typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value;
    };

    // GLS: Parche: Chrome no formatea correctamente los números en euskera, establece como separador de decimales el (.)
    var toLocaleString = Number.prototype.toLocaleString;
    Number.prototype.toLocaleString = function (locale, options) {
        if (locale == "eu-ES" && !TC.Util.detectIE()) {
            var sNum = toLocaleString.apply(this, arguments);
            sNum = sNum.replace(/\,/g, '.')
            if (!(Math.floor(this) == this && Number.isInteger(Math.floor(this))))
                sNum = sNum.replace(/.([^.]*)$/, ",$1");

            return sNum;
        }
        else
            return toLocaleString.apply(this, arguments);
    }

    var iconUrlCache = {};
    var markerGroupClassCache = {};

    var path1 = ["Capability", "Request", "GetMap", "DCPType", "0", "HTTP", "Get", "OnlineResource"];
    var path2 = ["OperationsMetadata", "GetTile", "DCP", "HTTP", "Get", "0", "href"];
    var getOnPath = function (obj, p, i) {
        if (i < p.length - 1) {
            if (obj.hasOwnProperty(p[i]))
                return getOnPath(obj[p[i]], p, ++i);
            else return null;
        } else {
            return obj[p[i]];
        }
    };

    const swipeHandlers = new WeakMap();
    const modalCloseHandlers = new WeakMap();

    var Util = {

        isPlainObject: function (obj) {
            return Object.prototype.toString.call(obj) === '[object Object]';
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        isFunction: function (obj) {
            return typeof obj === 'function';
        },

        getMapLocale: function (map) {
            return map.options && map.options.locale && map.options.locale.replace('_', '-') || "es-ES";
        },

        regex: {
            PROTOCOL: /(^https?:)/i
        },

        isOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            if (withProtocol) {
                if (TC.capabilities[testUrl])
                    return url;
            } else {
                for (var c in TC.capabilities) {
                    if (c.replace(TC.Util.regex.PROTOCOL, "") == testUrl)
                        return c;
                }
            }

            for (c in TC.capabilities) {
                var u = getOnPath(TC.capabilities[c], path1, 0) || getOnPath(TC.capabilities[c], path2, 0);

                if (u && withProtocol && url == u) return u;
                else if (u && url.replace(TC.Util.regex.PROTOCOL, "") == u.replace(TC.Util.regex.PROTOCOL, "")) return u;
            }

            return url;
        },

        reqGetMapOnCapabilities: function (url) {
            var withProtocol = arguments.length == 2 ? arguments[1] : true;
            var testUrl = !withProtocol ? url.replace(TC.Util.regex.PROTOCOL, "") : url;

            var _get = function (caps) {
                var u = getOnPath(caps, path1, 0) || getOnPath(caps, path2, 0);
                if (u)
                    return !withProtocol ? u.split('?')[0].replace(TC.Util.regex.PROTOCOL, "") : u.split('?')[0];

                return null;
            };
            if (TC.capabilities[url]) {
                return _get(TC.capabilities[url]);
            }

            return null;
        },

        getFNFromString: function (fnName) {
            var scope = window;
            var scopeSplit = fnName.split('.');
            for (i = 0; i < scopeSplit.length - 1; i++) {
                scope = scope[scopeSplit[i]];

                if (scope == undefined) return;
            }

            return scope[scopeSplit[scopeSplit.length - 1]];
        },

        isURL: function (text) {
            return /^(http|https|ftp|mailto)\:\/\//i.test(text);
        },

        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        isSameOrigin: function (uri) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var location = window.location;
                var uProtocol = urlParts[1];
                result =
                    (uProtocol == location.protocol || uProtocol == undefined) &&
                    urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        formatNumber: function (value, locale) {
            var t = typeof value;
            if (t === 'number') {
                return value.toLocaleString(locale);
            }
            else if (t === 'string') {
                n = parseFloat(value);
                if (n === new Number(value).valueOf()) {
                    return n.toLocaleString(locale);
                }
            }
            return value;
        },

        addProtocol: function (uri) {
            var result = uri;
            if (uri && uri.indexOf('//') === 0) {
                result = location.protocol + uri;
            }
            return result;
        },

        /* 
        * getDiv: returns HTML element or null if the parameter is invalid
        * Parameter: string with element ID or HTML element
        */
        getDiv: function (div) {
            var result;
            if (typeof div === 'string') {
                result = document.getElementById(div);
            }
            else if (div instanceof HTMLElement) {
                result = div;
            }
            else if ('$' in window && div instanceof $ && div.length) {
                result = div[0];
            }
            else {
                result = document.createElement('div');
            }
            return result;
        },

        getScriptLocation: function () {
            var src;
            var script;
            if (document.currentScript) {
                script = document.currentScript;
            }
            else {
                var scripts = document.getElementsByTagName('script');
                script = scripts[scripts.length - 1];
            }
            src = script.getAttribute('src');
            if (src) {
                return src.substr(0, src.lastIndexOf('/') + 1);
            }
            return "";
        },

        /* 
        * getBackgroundUrlFromCss: devuelve la URL de background-image en CSS
        * Parameter: string con nombre de clase
        */
        getBackgroundUrlFromCss: function (cssClass) {
            var result = '';

            if (cssClass) {
                if (iconUrlCache[cssClass] !== undefined) {
                    result = iconUrlCache[cssClass];
                }
                else {
                    const iconDiv = document.createElement('div');
                    iconDiv.style.display = 'none';
                    iconDiv.classList.add(cssClass);                    
                    document.body.appendChild(iconDiv);                    
                    // The regular expression is nongreedy (.*?), otherwise in FF and IE it gets 'url_to_image"'
                    var match = /^url\(['"]?(.*?)['"]?\)$/gi.exec(window.getComputedStyle(iconDiv, null).backgroundImage);
                    if (match && match.length > 1) {
                        result = match[match.length - 1];
                    }
                    iconDiv.parentElement.removeChild(iconDiv);
                    iconUrlCache[cssClass] = result;
                }
            }
            return result;
        },

        getPointIconUrl: function getPointIconUrl(options) {
            var result = null;
            if (options.url) {
                result = options.url;
            }
            else {
                var className;
                if (typeof options.cssClass === 'string') {
                    className = options.cssClass;
                }
                else {
                    var classes = options.classes || TC.Cfg.styles.marker.classes;
                    className = classes[0];
                    if (options.group) {
                        if (markerGroupClassCache[options.group] === undefined) {
                            var i = 0;
                            for (var key in markerGroupClassCache) {
                                i++;
                            }
                            i = i % classes.length;
                            markerGroupClassCache[options.group] = classes[i];
                        }
                        className = markerGroupClassCache[options.group];
                    }
                }
                result = TC.Util.getBackgroundUrlFromCss(className);
            }
            if (!result && options !== TC.Cfg.styles.point && options.cssClass !== '') {
                result = getPointIconUrl(TC.Cfg.styles.point);
            }
            return result;
        },

        /* 
        * addPathToTree: añade a un array a un árbol, cada elemento en un nivel anidado
        * Parameters: array, nodo de árbol, [índice]
        * Returns: último nodo insertado, null si ya existía la ruta
        */
        addArrayToTree: function addArrayToTree(path, treeNode, index) {
            var result = null;
            var found = false;
            index = index || 0;
            var name = path[index];
            if (name) {
                var n;
                for (var i = 0, len = treeNode.children.length; i < len; i++) {
                    n = treeNode.children[i];
                    if (n.name === name) {
                        found = true;
                        var r = addArrayToTree(path, n, index + 1);
                        if (r) {
                            result = r;
                        }
                        break;
                    }
                }
                if (!found) {
                    n = { name: name, title: name, uid: '/' + path.slice(0, index + 1).join('/'), children: [] };
                    treeNode.children.push(n);
                    result = n;
                }
            }
            return result;
        },

        parseCoords: function (text) {
            var result = null;

            var _parseGeoCoord = function (text) {
                var t = text;
                var result = {};
                result.type = TC.Consts.GEOGRAPHIC;
                var idx = t.indexOf('\u00B0');
                result.value = parseFloat(t.substr(0, idx));
                t = t.substr(idx + 1);
                idx = t.indexOf('\'');
                if (idx >= 0) {
                    var v = parseFloat(t.substr(0, idx)) / 60;
                    if (result.value >= 0) {
                        result.value += v;
                    }
                    else {
                        result.value -= v;
                    }
                    t = t.substr(idx + 1);
                    idx = t.indexOf('\'');
                    if (idx >= 0) {
                        v = parseFloat(t.substr(0, idx).replace(',', '.')) / 3600;
                        if (result.value >= 0) {
                            result.value += v;
                        }
                        else {
                            result.value -= v;
                        }
                    }
                }
                return result;
            };

            var _parseCoord = function (text) {
                var t = $.trim(text);
                // nnºnn'nn''N
                if (t.match(/^1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?\s*[NnSsWwOoEe]$/g)) {
                    switch (t[t.length - 1]) {
                        case 'S':
                        case 's':
                        case 'W':
                        case 'w':
                        case 'O':
                        case 'o':
                            t = '-' + t;
                            break;
                    }
                    t = t.substr(0, t.length - 1);
                    return _parseGeoCoord(t);
                }
                // +nnºnn'nn''
                if (t.match(/^[+-]?1?\d{0,2}\s*\u00B0(\s*\d{1,2}\s*'(\s*\d{1,2}([.,]\d+)?\s*'')?)?$/g)) {
                    return _parseGeoCoord(t);
                }
                // nn.nn N
                if (t.match(/^1?\d{0,2}([.,]\d+)?\s*\u00B0?\s*[NnSsWwOoEe]$/g)) {
                    var result = { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.substr(0, t.length - 1).replace(',', '.')) };
                    if (t.match(/[SsWwOo]$/)) {
                        result.value = -result.value;
                    }
                    return result;
                }
                // +nn.nn
                if (t.match(/^[+-]?1?\d{0,2}([.,]\d+)?\s*\u00B0?$/g)) {
                    return { type: TC.Consts.GEOGRAPHIC, value: parseFloat(t.replace(',', '.')) };
                }
                // UTM
                if (t.match(/^\d{6,7}([.,]\d+)?$/g)) {
                    return { type: TC.Consts.UTM, value: parseFloat(t.replace(',', '.')) };
                }
                return null;
            };

            text = $.trim(text).toUpperCase();
            var xy = text.split(',');
            if (xy.length === 4) {
                xy = [xy.slice(0, 1).join('.'), xy.slice(2, 3).join('.')];
            }
            else if (xy.length === 1 || xy.length === 3) {
                xy = text.split(' ');
            }
            if (xy.length === 2) {
                var x = _parseCoord(xy[0]);
                var y = _parseCoord(xy[1]);
                if (x !== null && y !== null) {
                    result = [x, y];
                }
            }
            return result;
        },

        reproject: function (coords, sourceCrs, targetCrs) {
            var result;
            var multipoint = true;
            var multiring = true;
            var multipoly = true;
            if ($.isArray(coords[0])) {
                if ($.isArray(coords[0][0])) {
                    if (!$.isArray(coords[0][0][0])) {
                        multipoly = false;
                        coords = [coords];
                    }
                }
                else {
                    multiring = false;
                    coords = [[coords]];
                }
            }
            else {
                multipoint = false;
                multiring = false;
                multipoly = false;
                coords = [[[coords]]];
            }
            TC.loadProjDef({ crs: sourceCrs, sync: true });
            TC.loadProjDef({ crs: targetCrs, sync: true });
            var sourcePrj = new Proj4js.Proj(sourceCrs);
            var targetPrj = new Proj4js.Proj(targetCrs);
            result = new Array(coords.length);
            coords.forEach(function (poly, pidx) {
                const rp = result[pidx] = [];
                poly.forEach(function (ring, ridx) {
                    const rr = rp[ridx] = [];
                    ring.forEach(function (coord, cidx) {
                        var point = Proj4js.transform(sourcePrj, targetPrj, { x: coord[0], y: coord[1] });
                        rr[cidx] = [point.x, point.y];
                        if (coord.length > 2) {
                            rr[cidx][2] = coord[2];
                        }
                    });
                });
            });
            if (!multipoint) {
                result = result[0][0][0];
            }
            else if (!multiring) {
                result = result[0][0];
            }
            else if (!multipoly) {
                result = result[0];
            }
            return result;
        },

        getMetersPerDegree: function (extent) {
            var result = undefined;
            var R = 6370997; // m
            var toRad = function (number) {
                return number * Math.PI / 180;
            };
            if ($.isArray(extent) && extent.length >= 4) {
                var dLat = this.degToRad(extent[3] - extent[1]);
                var sindlat2 = Math.sin(dLat / 2);
                var a = sindlat2 * sindlat2;
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                result = R * c / (extent[3] - extent[1]);
            }
            return result;
        },

        radToDeg: function (rad) { // convert radians to degrees
            return rad * 180 / Math.PI;
        },
        degToRad: function (deg) { // convert degrees to radians
            return deg * Math.PI / 180;
        },
        mod: function (n) { // modulo for negative values
            return ((n % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        },

        getCRSCode: function (crs) {
            var result = null;
            crs = crs.trim();
            if (/^EPSG:\d{4,6}$/g.test(crs) || //formato EPSG
                /^urn:ogc:def:crs:EPSG:.*:\d{4,6}/g.test(crs) || // formato URN
                /http:\/\/www.opengis.net\/gml\/srs\/epsg.xml#\d{4,6}$/g.test(crs)) { // formato GML
                var match = crs.trim().match(/^.+[:#](\d{4,6})$/); // devuelve la parte numérica del código
                if (match) {
                    result = match[1];
                }
            }
            return result;
        },

        CRSCodesEqual: function (crs1, crs2) {
            if (crs1 === crs2) {
                return true;
            }
            var code1 = this.getCRSCode(crs1);
            var code2 = this.getCRSCode(crs2);
            return code1 !== null && code2 !== null && code1 === code2;
        },

        getLocaleString: function (locale, key, texts) {
            var result = key;
            if (TC.i18n && TC.i18n[locale]) {
                var text = TC.i18n[locale][key];
                if (text) {
                    result = text;
                    if (texts) {
                        for (var k in texts) {
                            result = result.replace('{' + k + '}', texts[k]);
                        }
                    }
                }
            }
            return result;
        },

        getSimpleMimeType: function (mimeType) {
            var result = '';
            if (mimeType) {
                var end = mimeType.indexOf(';');
                if (end > 0) {
                    mimeType = mimeType.substring(0, end);
                }
                result = mimeType;
            }
            return result;
        },

        getQueryStringParams: function (url) {
            var queryString;
            if (url) {
                var queryIdx = url.indexOf('?');
                if (queryIdx >= 0) {
                    queryString = url.substr(queryIdx);
                    var fragmentIdx = queryString.indexOf('#');
                    if (fragmentIdx >= 0) {
                        queryString = queryString.substr(0, fragmentIdx)
                    }
                }
                else {
                    queryString = '?';
                }
            }
            else {
                queryString = location.search;
            }
            var result = $.map(queryString.replace(/(^\?)/, '').split("&"), function (elm) {
                return elm = elm.split("="), this[elm[0]] = elm[1], this
            }.bind({}))[0];
            delete result[''];
            return result;
        },

        getParamString: function (obj) {
            const arr = [];
            for (var key in obj) {
                arr[arr.length] = encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]);
            }
            return arr.join('&').replace(/%20/g, '+');
        },

        fastUnshift: function (a, elm) {
            var len = a.length;
            while (len) {
                a[len] = a[len - 1];
                len--;
            }
            a[0] = elm;
        },

        storage: {
            getCookie: function (key) {
                return TC.cookie(key);
            },
            setCookie: function (key, value, options) {
                return TC.cookie(key, value, options);
            },
            getLocalValue: function (key) {
                var result = null;
                if (localStorage && localStorage instanceof Storage) {
                    result = localStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setLocalValue: function (key, value) {
                if (localStorage && localStorage instanceof Storage) {
                    if (value === undefined) {
                        localStorage.removeItem(key);
                    }
                    else {
                        localStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            },
            getSessionLocalValue: function (key) {
                var result = null;
                if (sessionStorage && sessionStorage instanceof Storage) {
                    result = sessionStorage.getItem(key);
                }
                else {
                    result = TC.Util.storage.getCookie(key);
                }
                return result;
            },
            setSessionLocalValue: function (key, value) {
                if (sessionStorage && sessionStorage instanceof Storage) {
                    if (value === undefined) {
                        sessionStorage.removeItem(key);
                    }
                    else {
                        sessionStorage.setItem(key, value);
                    }
                }
                else {

                    if (value === undefined) {
                        var exDate = new Date();
                        exDate.setDate(exDate.getDate() - 1);
                        TC.Util.storage.setCookie(key, "", { expires: exDate });
                    }
                    else {
                        TC.Util.storage.setCookie(key, value);
                    }
                }
                return key;
            }
        },
        detectFirefox: function () {
            if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent)) //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);
                return new Number(RegExp.$1); // capture x.x portion and store as a number
            else
                return false;
        },
        detectIE: function () {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            // GLS: 13/02/2019. Comento lo que respecta a Edge, no tiene sentido meterlo en el mismo saco que un navegador obsoleto.
            // No lo comento porque en la mesa no hay quorum.
            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // IE 12 => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },
        detectChrome: function () {
            return window.chrome;

        },
        detectSafari: function () {
            return !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);
        },
        detectMouse: function () {
            if (Modernizr.mq('(pointer:coarse)') && Modernizr.mq('(pointer:fine)'))
                return true;
            if (Modernizr.mq('(pointer:coarse)') && !Modernizr.mq('(pointer:fine)')) {
                var testHover = function () {
                    //console.log('estamos en testHover');
                    var mq = '(hover: hover)',
                        hover = !Modernizr.touch, // fallback if mq4 not supported: no hover for touch
                        mqResult;

                    if ('matchMedia' in window) {
                        //console.log('dispone de matchMedia');
                        mqResult = window.matchMedia(mq);
                        //console.log('resultado de window.matchMedia(mq): ' + mqResult.media);
                        //console.log('mq: ' + mq);
                        if (mqResult.media === mq) {
                            //console.log('es igual');
                            // matchMedia supports hover detection, so we rely on that
                            hover = mqResult.matches;
                            //console.log('va retornar: ' + hover);
                        }
                    } else { console.log('no dispone de matchMedia'); }

                    return hover;
                };

                if (testHover())
                    return true;
                else return false;
            }
            if (!Modernizr.mq('(pointer:coarse)') && Modernizr.mq('(pointer:fine)'))
                return true;
            if (Modernizr.mq('(pointer:none)'))
                return false;
            if (!Modernizr.touch)
                return true;
        },
        detectAndroid: function () {
            return navigator.userAgent.match(/Android/i);
        },
        detectBlackBerry: function () {
            return navigator.userAgent.match(/BlackBerry/i);
        },
        detectIOS: function () {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        detectMobileWindows: function () {
            return navigator.userAgent.match(/IEMobile/i);
        },
        detectMobile: function () {
            return (TC.Util.detectAndroid() || TC.Util.detectIOS() || TC.Util.detectMobileWindows() || TC.Util.detectBlackBerry());
        },
        getBrowser: function () {
            if (!window.UAParser) {
                TC.syncLoadJS(TC.apiLocation + TC.Consts.url.UA_PARSER);
            }

            var parser = new UAParser();
            var browser = parser.getBrowser();
            return { name: browser.name, version: browser.major };
        },
        getElementByNodeName: function (parentNode, nodeName) {
            var colonIndex = nodeName.indexOf(":");
            var tag = nodeName.substr(colonIndex + 1);
            var nodes = parentNode.getElementsByTagNameNS("*", tag);

            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeName == nodeName)
                    return nodes;
            }
            return undefined;
        },
        addURLParameters: function (url, parameters) {
            if (!parameters) {
                return url;
            }
            var toAdd = Object.keys(parameters).map(function (key) {
                return encodeURIComponent(key) + '=' + (parameters[key] ? encodeURIComponent(parameters[key]) : '');
            }).join('&');

            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var params = urlparts[1].split(/[&;]/g);
                params.push(toAdd);

                url = urlparts[0] + '?' + params.join('&');
                return url;
            } else {
                urlparts = url.split('#');
                if (urlparts.length >= 2) {
                    urlparts.shift();
                    url = urlparts[0] + '?' + toAdd + '#' + urlparts.join('#');
                    return url;
                }
                else {
                    url = url + '?' + toAdd;
                    return url;
                }
            }
        },
        removeURLParameter: function (url, parameter) {
            var urlparts = url.split('?');
            if (urlparts.length >= 2) {

                var prefix = encodeURIComponent(parameter.toLowerCase()) + '=';
                var pars = urlparts[1].toLowerCase().split(/[&;]/g);

                //reverse iteration as may be destructive
                for (var i = pars.length; i-- > 0;) {
                    //idiom for string.startsWith
                    if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                        pars.splice(i, 1);
                    }
                }

                url = urlparts[0] + '?' + pars.join('&');
                return url;
            } else {
                return url;
            }
        },

        showModal: function (contentNode, options) {
            options = options || {};

            contentNode.hidden = false;
            $(contentNode).fadeIn(250, function () {
                if (window.$ && contentNode instanceof $) {
                    contentNode = contentNode.get(0);
                }
                const closeButton = contentNode.querySelectorAll('.tc-modal-close');
                if (closeButton && closeButton.length > 0) {
                    for (var i = 0; i < closeButton.length; i++) {
                        var closeCallback = modalCloseHandlers.get(closeButton[i]);
                        if (closeCallback) {
                            modalCloseHandlers.delete(closeButton[i]);
                        }
                        else {
                            closeCallback = function (e) {
                                e.stopPropagation();
                                return TC.Util.closeModal(options.closeCallback, e.target);
                            };
                            modalCloseHandlers.set(closeButton[i], closeCallback);
                        }
                        modalCloseHandlers.set(closeButton[i], closeCallback);
                        closeButton[i].addEventListener('click', closeCallback);
                        if ($.isFunction(options.openCallback)) {
                            options.openCallback();
                        }
                    }
                }
            });
        },

        closeModal: function (callback, target) {

            const hide = function (modal) {
                modal.style.display = 'none';
                modal.querySelector('.tc-modal-window').removeAttribute('style');
            };

            var modal;
            if (target) {
                modal = target;
                while (modal && !modal.matches('.tc-modal')) {
                    modal = modal.parentElement;
                }

                hide(modal);
            } else {
                Array.prototype.forEach.call(document.querySelectorAll('.tc-modal'), function (modal) {
                    hide(modal);
                });
            }

            if (callback) {
                callback();
            }
        },

        closeAlert: function (btn) {
            var elm = btn;
            do {
                elm = elm.parentElement;
                if (elm.matches('.tc-alert')) {
                    elm.style.display = 'none';
                }
            }
            while (elm);
        },

        swipe: function (target, options) {
            const addListeners = function (handlers) {
                target.addEventListener('mousedown', handlers.start);
                target.addEventListener('touchstart', handlers.start);
                target.addEventListener('mouseup', handlers.end);
                target.addEventListener('touchend', handlers.end);
            };

            if (options === 'disable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    target.removeEventListener('mousedown', handlers.start);
                    target.removeEventListener('touchstart', handlers.start);
                    target.removeEventListener('mouseup', handlers.end);
                    target.removeEventListener('touchend', handlers.end);
                }
                return;
            }
            else if (options === 'enable') {
                const handlers = swipeHandlers.get(target);
                if (handlers) {
                    addListeners(handlers);
                }
                return;
            }

            options = options || {};
            const minDistance = options.minDistance || 30;
            const maxCrossDistance = options.maxCrossDistance || 30;
            const maxAllowedTime = options.maxAllowedTime || 1000;
            var touchStartCoords = { 'x': -1, 'y': -1 }, // X and Y coordinates on mousedown or touchstart events.
                touchEndCoords = { 'x': -1, 'y': -1 },// X and Y coordinates on mouseup or touchend events.
                startTime = 0,// Time on swipeStart
                elapsedTime = 0;// Elapsed time between swipeStart and swipeEnd

            const getDirection = function (startCoords, endCoords) {
                const dx = endCoords.x - startCoords.x;
                const dy = endCoords.y - startCoords.y;
                const adx = Math.abs(dx);
                const ady = Math.abs(dy);
                if (adx > ady && adx > minDistance && ady <= maxCrossDistance) {
                    return dx < 0 ? 'left' : 'right';
                }
                if (ady > adx && ady > minDistance && adx <= maxCrossDistance) {
                    return dy < 0 ? 'up' : 'down';
                }
                return 'none';
            };

            const mustSwipe = function (e) {
                if (options.noSwipe) {
                    var elm = e.target;
                    while (elm && elm !== target) {
                        if (elm.matches && elm.matches(options.noSwipe)) {
                            return false;
                        }
                        elm = elm.parentNode;
                    }
                }
                return true;
            };

            const swipeStart = function (e) {
                if (mustSwipe(e)) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchStartCoords.x = e.pageX;
                    touchStartCoords.y = e.pageY;
                    startTime = new Date().getTime();
                }
            };

            const swipeEnd = function (e) {
                if (startTime) {
                    e = 'changedTouches' in e ? e.changedTouches[0] : e;
                    touchEndCoords.x = e.pageX;
                    touchEndCoords.y = e.pageY;
                    elapsedTime = new Date().getTime() - startTime;
                    if (elapsedTime <= maxAllowedTime) {
                        const callback = options[getDirection(touchStartCoords, touchEndCoords)];
                        if (callback) {
                            callback.call(target);
                        }
                    }
                    startTime = 0;
                }
            };

            const handlers = {
                start: swipeStart,
                end: swipeEnd
            };
            swipeHandlers.set(target, handlers);
            addListeners(handlers);
        },

        getParameterByName: function (name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)", "i"),
                results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        },

        getLocaleUserChoice: function (options) {
            var result = 'en-US';
            options = options || {};
            var cookieName = options.cookieName || 'SITNA.language';
            var paramName = options.paramName || 'lang';
            // Obtenemos preferencia de lenguaje
            var browserLanguage = (navigator.languages && navigator.languages.length) ? navigator.languages[0] : navigator.language || navigator.userLanguage;
            var lang = TC.Util.getParameterByName(paramName) || TC.Util.storage.getCookie(cookieName) || browserLanguage;
            var hyphenIdx = lang.indexOf('-');
            if (hyphenIdx >= 0) {
                lang = lang.substr(0, hyphenIdx);
            }
            var expirationDate = new Date(new Date().getTime() + 365 * 24 * 60 * 60 * 1000);
            TC.Util.storage.setCookie(cookieName, lang, { expires: expirationDate });

            switch (lang) {
                case 'eu':
                    result = 'eu-ES';
                    break;
                case 'es':
                    result = 'es-ES';
                    break;
                default:
                    result = 'en-US';
                    break;
            }
            return result;
        },

        getValidFilename: function (filename) {
            return (filename || '').replace(/[/\\?%*:|"<>]/g, '-');
        },

        downloadBlob: function (filename, blob) {
            var link = document.createElement("a");
            if (link.download !== undefined) {
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", TC.Util.getValidFilename(filename));
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        downloadFile: function (filename, type, data) {
            var blob = new Blob([data], { type: type });
            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        downloadDataURI: function (filename, type, dataURI) {
            var binary = atob(dataURI.split(',')[1]);

            var array = [];
            for (var i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            var blob = new Blob([new Uint8Array(array)], { type: type });

            filename = TC.Util.getValidFilename(filename);
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                TC.Util.downloadBlob(filename, blob);
            }
        },

        /**
         * Acorta una URL utilizando el servicio de Bit.ly. No funciona para URLs locales.
         */
        shortenUrl: function (url) {
            return TC.ajax({
                url: "https://api-ssl.bitly.com/v3/shorten",
                data: { access_token: "6c466047309f44bd8173d83e81491648b243ee3d", longUrl: url },
            });
        },

        /**
         * Convierte a Base64.
         */
        utf8ToBase64: function (str) {
            return window.btoa(unescape(encodeURIComponent(str)));
        },

        /**
         * Decodifica un string en Base64.
         */
        base64ToUtf8: function (str) {
            var result;
            try {
                result = decodeURIComponent(escape(window.atob(str)));
            }
            catch (error) {
                result = null;
            }
            return result;
        },

        colorArrayToString: function (color) {
            if ($.isArray(color)) {
                color = color
                    .slice(0, 3)
                    .reduce(function (prev, cur) {
                        const str = cur.toString(16);
                        return prev + '00'.substring(0, 2 - str.length) + str;
                    }, '#');
            }
            return color;
        },

        // Generic helper function that can be used for the three operations:        
        operation: function (list1, list2, comparerFn, operationIsUnion) {
            var result = [];

            for (var i = 0; i < list1.length; i++) {
                var item1 = list1[i],
                    found = false;
                for (var j = 0; j < list2.length; j++) {
                    if (comparerFn(item1, list2[j])) {
                        found = true;
                        break;
                    }
                }
                if (found === operationIsUnion) {
                    result.push(item1);
                }
            }
            return result;
        },
        isSecureURL: function (url) {
            //sino empieza por http ni por https la consideramos segura
            if (!/^(f|ht)tps?:\/\//i.test(url))
                return true;
            return (/^(f|ht)tps:\/\//i.test(url));
        },

        // Following functions are to be used:
        inBoth: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, true);
        },

        inFirstOnly: function (list1, list2, comparerFn) {
            return this.operation(list1, list2, comparerFn, false);
        },

        inSecondOnly: function (list1, list2, comparerFn) {
            return this.inFirstOnly(list2, list1, comparerFn);
        },

        toDataUrl: function (canvas, backgroundColour) {
            var defaultOptions = { type: 'image/png', encoderOptions: 0.92 };

            var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions,
                type = _ref.type,
                encoderOptions = _ref.encoderOptions;

            var context = canvas.getContext('2d');

            if (!context) {
                return '';
            }

            var width = canvas.width;
            var height = canvas.height;

            var data = context.getImageData(0, 0, width, height);
            var compositeOperation = context.globalCompositeOperation;

            if (backgroundColour) {

                context.globalCompositeOperation = 'destination-over';
                context.fillStyle = backgroundColour;
                context.fillRect(0, 0, width, height);
            }

            var imageData = canvas.toDataURL(type, encoderOptions);

            if (backgroundColour) {
                context.clearRect(0, 0, width, height);
                context.putImageData(data, 0, 0);
                context.globalCompositeOperation = compositeOperation;
            }

            return imageData;
        },

        imgToDataUrl: function (src, outputFormat) {

            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function () {
                    var canvas = createCanvas(img);
                    var dataURL;

                    try {
                        dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                            type: outputFormat || 'image/jpeg',
                            encoderOptions: 1.0
                        });
                        resolve({ dataUrl: dataURL, canvas: canvas });
                    } catch (error) {
                        img.src = TC.proxify(src);
                    }
                };

                img.onerror = function (error) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', TC.proxify(src), true);
                    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function (e) {
                        if (this.status === 200) {
                            var uInt8Array = new Uint8Array(this.response);
                            var i = uInt8Array.length;
                            var binaryString = new Array(i);
                            while (i--) {
                                binaryString[i] = String.fromCharCode(uInt8Array[i]);
                            }
                            var data = binaryString.join('');
                            var type = xhr.getResponseHeader('content-type');
                            if (type.indexOf('image') === 0) {
                                img.src = 'data:' + type + ';base64,' + window.btoa(data);
                                img.onload = function () {
                                    var canvas = createCanvas(img);
                                    dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                                        type: outputFormat || 'image/jpeg',
                                        encoderOptions: 1.0
                                    });
                                    resolve({ dataUrl: dataURL, canvas: canvas });
                                }
                            }
                        }
                    };
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4) {
                            if (xhr.status !== 200) {
                                reject();
                            }
                        }
                    };

                    xhr.send();
                };

                img.src = src;
                if (img.complete || img.complete === undefined) {
                    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                    img.src = src;
                }
            });
        },

        imgTagToDataUrl: function (img, outputFormat) {
            var createCanvas = function (img) {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');
                canvas.height = img.height;
                canvas.width = img.width;
                ctx.drawImage(img, 0, 0);

                return canvas;
            };

            var canvas = createCanvas(img);
            var dataURL;

            try {
                dataURL = TC.Util.toDataUrl(canvas, '#ffffff', {
                    type: outputFormat || 'image/jpeg',
                    encoderOptions: 1.0
                });
                return { base64: dataURL, canvas: canvas };
            } catch (error) {
                return null;
            }
        },

        addToCanvas: function (canvas, img, position, size) {
            var newCanvas = TC.Util.cloneCanvas(canvas);
            var context = newCanvas.getContext('2d');

            return new Promise(function (resolve, reject) {
                var newImage = new Image();
                img.crossOrigin = 'anonymous';
                newImage.src = img;
                newImage.onload = function () {
                    if (size) {
                        context.drawImage(newImage, position.x || 0, position.y || 0, size.width, size.height);
                    } else {
                        context.drawImage(newImage, position.x || 0, position.y || 0);
                    }
                    resolve(newCanvas);
                }
            });
        },

        cloneCanvas: function (oldCanvas) {
            //create a new canvas
            var newCanvas = document.createElement('canvas');
            var context = newCanvas.getContext('2d');

            //set dimensions
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;

            //apply the old canvas to the new one
            context.drawImage(oldCanvas, 0, 0);

            //return the new canvas
            return newCanvas;
        },

        calculateAspectRatioFit: function (srcWidth, srcHeight, maxWidth, maxHeight) {
            var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);

            return { width: srcWidth * ratio, height: srcHeight * ratio };
        },

        getFormattedDate: function (date, hasTime) {
            function pad(s) { return (s < 10) ? '0' + s : s; }

            var d = new Date(date);
            return [d.getFullYear(), pad(d.getMonth() + 1), pad(d.getDate())].concat(hasTime ? ["_", pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())] : []).join('');

        },

        replaceAccent: function (t) {
            var translate = {
                "ä": "a", "ö": "o", "ü": "u",
                "Ä": "A", "Ö": "O", "Ü": "U",
                "á": "a", "é": "e", "i": "i", "ó": "o", "ú": "u",
                "Á": "A", "É": "E", "Í": "I", "Ó": "O", "Ú": "U",
                "ñ": "n", "Ñ": "N"
            };
            return t.replace(/[öäüÖÄÜáéíóúÁÉÍÓÚñÑ]/g, function (match) {
                return translate[match];
            });
        },

        downloadFileForm: function (url, data) {

            var download = function (url, data) {
                const fragment = document.createDocumentFragment();
                var form = document.createElement('form');
                form.classList.add('tc-ctl-download-form');
                form.setAttribute('method', 'post');
                form.setAttribute('enctype', 'text/plain');
                form.setAttribute('action', TC.Util.detectIE() !== false && TC.Util.detectIE() <= 11 ? TC.proxify(url) : url);
                const input = document.createElement('input');
                input.classList.add('tc-ctl-download-query');
                input.setAttribute('name', data.substring(0, data.indexOf("=")));
                form.appendChild(input);
                fragment.appendChild(form);
                const iframes = document.querySelectorAll('iframe');
                var iframe;
                for (var i = 0, len = iframes.length; i < len; i++) {
                    const currentIframe = iframes[i];
                    if (currentIframe.dataset.downloadUrl === url) {
                        iframe = currentIframe;
                        break;
                    }
                }
                if (!iframe) {
                    iframe = document.createElement('iframe');
                    iframe.style.visibility = 'hidden';
                    iframe.style.display = 'none';
                    iframe.dataset.downloadUrl = url;
                    document.body.appendChild(iframe);
                }

                const content = iframe.contentDocument;
                content.open();
                content.write(form.outerHTML);
                content.close();
                content.querySelector('input').value = data.substring(data.indexOf("=") + 1);
                form = content.querySelector('form');
                return form;
            };

            var htmlObj = [];
            if ($.isArray(url)) {
                var arrDownloads = url;
                for (var i = 0; i < arrDownloads.length; i++) {
                    htmlObj.push(download(arrDownloads[i].url, arrDownloads[i].data));
                }
            }
            else {
                htmlObj.push(download(url, data));
            }
            htmlObj.forEach(function (form) {
                form.submit();
            });
            setTimeout(function () {
                document.querySelectorAll('.tc-ctl-download-form').forEach(function (form) {
                    form.parentElement.removeChild(form);
                });
            }, 1000);
        },

        WFSQueryBuilder: function (layers, filter, capabilities, outputFormat, onlyHits) {
            if (!$.isArray(layers))
                layers = [layers];
            var queryHeader = 'xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd" ' +
                'xmlns:ogc="http://www.opengis.net/ogc" service="WFS" {resultType} {format} ';
            switch (capabilities.version) {
                case "1.0.0":
                case "1.1.0":
                    queryHeader += 'xmlns:gml="http://www.opengis.net/gml" xmlns:wfs="http://www.opengis.net/wfs" ';
                    break;
                case "2.0.0":
                    queryHeader += 'xmlns:wfs=\"http://www.opengis.net/wfs/2.0\" xmlns:gml=\"http://www.opengis.net/gml/3.2\" ';
                    break;
            }
            for (var i in capabilities) {
                if (typeof (capabilities[i]) === "string" && i.indexOf("gml") < 0 && capabilities[i].indexOf("wfs") < 0)
                    queryHeader += (i + '="' + capabilities[i] + '" ');
            }

            var query = '<wfs:GetFeature ' + queryHeader.format({ resultType: (onlyHits ? 'resultType="hits"' : ''), format: 'outputFormat="' + outputFormat + '"' }) + '>';
            var queryBody = '';

            var queryItem = '<wfs:Query typeName' + (capabilities.version === "2.0.0" ? 's' : '') + '="{typeName}">{filter}</wfs:Query>';
            $.each(layers, function (index, value) {
                queryBody += queryItem.format({ typeName: value, filter: (filter ? filter.getText(capabilities.version) : "") });
            });
            query += queryBody + '</wfs:GetFeature>'
            return query;
        },

        WFSFilterBuilder: function (feature, version) {
            var filter = '';
            if (jQuery.isPlainObject(feature)) {
                filter = '<{prefix}:Filter><{prefix}:Intersects><fes:ValueReference></fes:ValueReference><{prefix}:Function name="querySingle"><{prefix}:Literal>{clipLayer}</{prefix}:Literal><{prefix}:Literal>{geometryName}</{prefix}:Literal><{prefix}:Literal>{where}</{prefix}:Literal></{prefix}:Function></{prefix}:Intersects></{prefix}:Filter>'
                    .format({ prefix: (version === "2.0.0" ? "fes" : "ogc"), "clipLayer": feature.clipLayer, "geometryName": feature.geometryName, "where": feature.where })
            }
            else {
                switch (true) {
                    case !feature:
                        break;
                    case $.isArray(feature)://bbox
                        var gmlEnvelope = ('<gml:Envelope>' +
                            '<gml:lowerCorner>{lowerCorner}</gml:lowerCorner>' +
                            '<gml:upperCorner>{upperCorner}</gml:upperCorner>' +
                            '</gml:Envelope>').format({ lowerCorner: (feature[0] + ' ' + feature[1]), upperCorner: (feature[2] + ' ' + feature[3]) });
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:BBOX>' + gmlEnvelope + '</ogc:BBOX></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:BBOX>' + gmlEnvelope + '</fes:BBOX></fes:Filter>';
                                break;
                        }
                        break;
                    case feature instanceof TC.Feature:
                        switch (true) {
                            case version === "1.0.0":
                            case version === "1.1.0":
                                filter += '<ogc:Filter><ogc:Intersects><ogc:PropertyName></ogc:PropertyName>' + TC.Util.writeGMLGeometry(feature, "2.0") + '</ogc:Intersects></ogc:Filter>';
                                break;
                            case version === "2.0.0":
                                filter += '<fes:Filter><fes:Intersects><fes:ValueReference></fes:ValueReference>' + TC.Util.writeGMLGeometry(feature, "3.2") + '</fes:Intersects></fes:Filter>';
                                break;
                        }

                        break;
                    default:
                        TC.error("Geometr\u00eda no v\u00e1lida");
                        break;
                }
            }

            return filter;
        },

        writeGMLGeometry: function (feature, gmlVersion) {

            var getGmlCoordinates = function (coords) {
                var result;
                if (gmlVersion.indexOf('3') === 0) {
                    result = coords.toString();
                    while (result.indexOf(",") >= 0) {
                        result = result.replace(",", " ");
                    }
                }
                else {
                    result = coords;
                    jQuery.each(result, function (i, item) { return item.join(",") }).join(" ");
                }
                return result;
            };

            switch (gmlVersion) {
                case "3.1.1":
                    break;
                case "3.2":
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString srsDimension=\"2\"><gml:posList>" +
                                getGmlCoordinates(feature.geometry) +
                                "</gml:posList></gml:LineString>";
                            break;
                            break;
                        default:
                            return "<gml:Polygon srsDimension=\"2\"><gml:exterior><gml:LinearRing><gml:posList>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>";
                            break;
                    }
                    break;
                case "2.0":
                default:
                    switch (true) {
                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                            return "<gml:LineString><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LineString>";
                            break;
                        default:
                            return "<gml:Polygon><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>" +
                                getGmlCoordinates(feature.geometry[0]) +
                                "</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>";
                            break;
                    }
                    break;
            }
        },

        isServiceWorker: function () {
            if (navigator.serviceWorker) {
                if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === "activated") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        },

        isSameOriginByLocation: function (uri, location) {
            var result = uri.indexOf("http") !== 0 && uri.indexOf("//") !== 0;
            var urlParts = !result && uri.match(TC.Consts.url.SPLIT_REGEX);
            if (urlParts) {
                var uProtocol = urlParts[1];
                result = (uProtocol == location.protocol || uProtocol == undefined) && urlParts[3] == location.hostname;
                var uPort = urlParts[4], lPort = location.port;
                if (uPort != 80 && uPort !== "" || lPort != "80" && lPort !== "") {
                    result = result && uPort == lPort;
                }
            }
            return result;
        },

        isSameProtocol: function (uri, location) {
            if (uri.match(/^(\/\/)/i)) {
                return true;
            }
            var protocolRegex = /^(https?:\/\/)/i;
            var uriProtocol = uri.match(protocolRegex);
            if (uriProtocol && uriProtocol.length > 1) {
                var locationProtocol = location.match(protocolRegex);
                if (locationProtocol && locationProtocol.length > 1) {
                    return uriProtocol[0].trim() === locationProtocol[0].trim();
                }
            }

            return false;
        },

        consoleRegister: function (msg) {
            if (TC.isDebug) {
                console.log(msg);
            }
        },

        getSorterByProperty: function (propName) {
            return function (a, b) {
                if (a[propName] > b[propName]) {
                    return 1;
                }
                if (a[propName] < b[propName]) {
                    return -1;
                }
                return 0;
            };
        },

        getSoundexDifference: function (a, b) {
            var res = 0

            for (var i = 0; i < a.length; i++) {
                if (a.charAt(i) == b.charAt(i)) {
                    res++;
                }
            }

            return res;
        },

        toAbsolutePath: function (href) {
            var link = document.createElement("a");
            link.href = href;
            return link.href;
        },

        getRenderedHtml: function (templateId, template, data, callback) {
            return new Promise(function (resolve, reject) {
                var render = function () {
                    if (dust.cache[templateId]) {
                        dust.render(templateId, data, function (err, out) {
                            if (err) {
                                TC.error(err);
                                reject(Error(err));
                            }
                            else {
                                if ($.isFunction(callback)) {
                                    callback(out);
                                }
                                resolve(out);
                            }
                        });
                    }
                };
                TC.loadJSInOrder(
                    !window.dust,
                    TC.url.templating,
                    function () {
                        if (!dust.cache[templateId]) {
                            if (typeof template === 'string') {
                                TC.ajax({
                                    url: template,
                                    method: "GET",
                                    responseType: 'text'
                                })
                                    .then(function (html) {
                                        var tpl = dust.compile(html, templateId);
                                        dust.loadSource(tpl);
                                        render();
                                    })
                                    .catch(function (err) {
                                        console.log("Error fetching template: " + err)
                                    });
                            }
                            else if ($.isFunction(template)) {
                                template();
                                render();
                            }
                        }
                        else {
                            render();
                        }
                    }
                );
            });
        },

        explodeGeometry: function (obj) {
            const origin = obj.origin;
            const iterationFunction = function (elm, idx, arr) {
                if ($.isArray(elm)) {
                    elm.forEach(iterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = elm + origin[0];
                    }
                    if (idx === 1) {
                        arr[1] = elm + origin[1];
                    }
                }
            };
            obj.geom.forEach(iterationFunction);
            return obj.geom;
        },

        cloneMappingFunction: function (elm) {
            if ($.isArray(elm)) {
                return elm.map(TC.Util.cloneMappingFunction);
            }
            return elm;
        },

        compactGeometry: function (geometry, precision) {
            const origin = [Number.MAX_VALUE, Number.MAX_VALUE];
            const newGeom = geometry.map(TC.Util.cloneMappingFunction);
            const firstIterationFunction = function (elm, idx) {
                if ($.isArray(elm)) {
                    elm.forEach(firstIterationFunction);
                }
                else {
                    if (idx === 0 && elm < origin[0]) {
                        origin[0] = elm;
                    }
                    else if (idx === 1 && elm < origin[1]) {
                        origin[1] = elm;
                    }
                }
            };
            newGeom.forEach(firstIterationFunction);

            const round = function (val) {
                return Math.round(val * precision) / precision;
            }
            origin[0] = round(origin[0]);
            origin[1] = round(origin[1]);
            const secondIterationFunction = function (elm, idx, arr) {
                if ($.isArray(elm)) {
                    elm.forEach(secondIterationFunction);
                }
                else {
                    if (idx === 0) {
                        arr[0] = round(elm - origin[0]);
                    }
                    if (idx === 1) {
                        arr[1] = round(elm - origin[1]);
                    }
                }
            };
            newGeom.forEach(secondIterationFunction);
            return {
                origin: origin,
                geom: newGeom
            }
        }
    };
    String.prototype.format = function () {
        var str = this.toString();
        if (!arguments.length)
            return str;
        var args = typeof arguments[0],
            args = (("string" == args || "number" == args) ? arguments : arguments[0]);
        for (arg in args)
            str = str.replace(RegExp("\\{" + arg + "\\}", "gi"), args[arg]);
        return str;
    };
    var fncOvelaps = function (elem1, elem2,comparisonFnc) {        
        return comparisonFnc(elem1.getBoundingClientRect(), elem2.getBoundingClientRect());
    }
    HTMLElement.prototype.colliding = function (other) {
        return fncOvelaps(this, other, function (rect1, rect2) {
            return !(
                rect1.top > rect2.bottom ||
                rect1.right < rect2.left ||
                rect1.bottom < rect2.top ||
                rect1.left > rect2.right
            );
        });        
    };
    HTMLElement.prototype.containing = function (other) {
        fncOvelaps(this, other, function (rect1, rect2) {
            return !(
                rect1.left <= rect2.left &&
                rect2.left < rect1.width &&
                rect1.top <= rect2.top &&
                rect2.top < rect1.height
            );
        });
    };
    HTMLElement.prototype.inside = function (other) {
        return fncOvelaps(this, other, function (rect1, rect2) {
            return (
                ((rect2.top <= rect1.top) && (rect1.top <= rect2.bottom)) &&
                ((rect2.top <= rect1.bottom) && (rect1.bottom <= rect2.bottom)) &&
                ((rect2.left <= rect1.left) && (rect1.left <= rect2.right)) &&
                ((rect2.left <= rect1.right) && (rect1.right <= rect2.right))
            );
        });        
    };
    return Util;
});

﻿/**
 * LoadJS descargado de https://github.com/muicss/loadjs
 * @version 3.6.1
 */
loadjs = (function () {
    /**
     * Global dependencies.
     * @global {Object} document - DOM
     */

    var devnull = function () { },
        bundleIdCache = {},
        bundleResultCache = {},
        bundleCallbackQueue = {};


    /**
     * Subscribe to bundle load event.
     * @param {string[]} bundleIds - Bundle ids
     * @param {Function} callbackFn - The callback function
     */
    function subscribe(bundleIds, callbackFn) {
        // listify
        bundleIds = bundleIds.push ? bundleIds : [bundleIds];

        var depsNotFound = [],
            i = bundleIds.length,
            numWaiting = i,
            fn,
            bundleId,
            r,
            q;

        // define callback function
        fn = function (bundleId, pathsNotFound) {
            if (pathsNotFound.length) depsNotFound.push(bundleId);

            numWaiting--;
            if (!numWaiting) callbackFn(depsNotFound);
        };

        // register callback
        while (i--) {
            bundleId = bundleIds[i];

            // execute callback if in result cache
            r = bundleResultCache[bundleId];
            if (r) {
                fn(bundleId, r);
                continue;
            }

            // add to callback queue
            q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
            q.push(fn);
        }
    }


    /**
     * Publish bundle load event.
     * @param {string} bundleId - Bundle id
     * @param {string[]} pathsNotFound - List of files not found
     */
    function publish(bundleId, pathsNotFound) {
        // exit if id isn't defined
        if (!bundleId) return;

        var q = bundleCallbackQueue[bundleId];

        // cache result
        bundleResultCache[bundleId] = pathsNotFound;

        // exit if queue is empty
        if (!q) return;

        // empty callback queue
        while (q.length) {
            q[0](bundleId, pathsNotFound);
            q.splice(0, 1);
        }
    }


    /**
     * Execute callbacks.
     * @param {Object or Function} args - The callback args
     * @param {string[]} depsNotFound - List of dependencies not found
     */
    function executeCallbacks(args, depsNotFound) {
        // accept function as argument
        if (args.call) args = { success: args };

        // success and error callbacks
        if (depsNotFound.length) (args.error || devnull)(depsNotFound);
        else (args.success || devnull)(args);
    }


    /**
     * Load individual file.
     * @param {string} path - The file path
     * @param {Function} callbackFn - The callback function
     */
    function loadFile(path, callbackFn, args, numTries) {
        var doc = document,
            async = args.async,
            maxTries = (args.numRetries || 0) + 1,
            beforeCallbackFn = args.before || devnull,
            pathStripped = path.replace(/^(css|img)!/, ''),
            isLegacyIECss,
            e;

        numTries = numTries || 0;

        if (/(^css!|\.css$)/.test(path)) {
            // css
            e = doc.createElement('link');
            e.rel = 'stylesheet';
            e.href = pathStripped;

            // tag IE9+
            isLegacyIECss = 'hideFocus' in e;

            // use preload in IE Edge (to detect load errors)
            if (isLegacyIECss && e.relList) {
                isLegacyIECss = 0;
                e.rel = 'preload';
                e.as = 'style';
            }
        } else if (/(^img!|\.(png|gif|jpg|svg)$)/.test(path)) {
            // image
            e = doc.createElement('img');
            e.src = pathStripped;
        } else {
            // javascript
            e = doc.createElement('script');
            e.src = path;
            e.async = async === undefined ? true : async;
        }

        e.onload = e.onerror = e.onbeforeload = function (ev) {
            var result = ev.type[0];

            // treat empty stylesheets as failures to get around lack of onerror
            // support in IE9-11
            if (isLegacyIECss) {
                try {
                    if (!e.sheet.cssText.length) result = 'e';
                } catch (x) {
                    // sheets objects created from load errors don't allow access to
                    // `cssText` (unless error is Code:18 SecurityError)
                    if (x.code != 18) result = 'e';
                }
            }

            // handle retries in case of load failure
            if (result == 'e') {
                // increment counter
                numTries += 1;

                // exit function and try again
                if (numTries < maxTries) {
                    return loadFile(path, callbackFn, args, numTries);
                }
            } else if (e.rel == 'preload' && e.as == 'style') {
                // activate preloaded stylesheets
                return e.rel = 'stylesheet'; // jshint ignore:line
            }

            // execute callback
            callbackFn(path, result, ev.defaultPrevented);
        };

        // add to document (unless callback returns `false`)
        if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);
    }


    /**
     * Load multiple files.
     * @param {string[]} paths - The file paths
     * @param {Function} callbackFn - The callback function
     */
    function loadFiles(paths, callbackFn, args) {
        // listify paths
        paths = paths.push ? paths : [paths];

        var numWaiting = paths.length,
            x = numWaiting,
            pathsNotFound = [],
            fn,
            i;

        // define callback function
        fn = function (path, result, defaultPrevented) {
            // handle error
            if (result == 'e') pathsNotFound.push(path);

            // handle beforeload event. If defaultPrevented then that means the load
            // will be blocked (ex. Ghostery/ABP on Safari)
            if (result == 'b') {
                if (defaultPrevented) pathsNotFound.push(path);
                else return;
            }

            numWaiting--;
            if (!numWaiting) callbackFn(pathsNotFound);
        };

        // load scripts
        for (i = 0; i < x; i++) loadFile(paths[i], fn, args);
    }


    /**
     * Initiate script load and register bundle.
     * @param {(string|string[])} paths - The file paths
     * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
     *   callback or (3) object literal with success/error arguments, numRetries,
     *   etc.
     * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
     *   literal with success/error arguments, numRetries, etc.
     */
    function loadjs(paths, arg1, arg2) {
        var bundleId,
            args;

        // bundleId (if string)
        if (arg1 && arg1.trim) bundleId = arg1;

        // args (default is {})
        args = (bundleId ? arg2 : arg1) || {};

        // throw error if bundle is already defined
        if (bundleId) {
            if (bundleId in bundleIdCache) {
                throw "LoadJS";
            } else {
                bundleIdCache[bundleId] = true;
            }
        }

        function loadFn(resolve, reject) {
            loadFiles(paths, function (pathsNotFound) {
                // execute callbacks
                executeCallbacks(args, pathsNotFound);

                // resolve Promise
                if (resolve) {
                    executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
                }

                // publish bundle load event
                publish(bundleId, pathsNotFound);
            }, args);
        }

        if (args.returnPromise) return new Promise(loadFn);
        else loadFn();
    }


    /**
     * Execute callbacks when dependencies have been satisfied.
     * @param {(string|string[])} deps - List of bundle ids
     * @param {Object} args - success/error arguments
     */
    loadjs.ready = function ready(deps, args) {
        // subscribe to bundle load event
        subscribe(deps, function (depsNotFound) {
            // execute callbacks
            executeCallbacks(args, depsNotFound);
        });

        return loadjs;
    };


    /**
     * Manually satisfy bundle dependencies.
     * @param {string} bundleId - The bundle id
     */
    loadjs.done = function done(bundleId) {
        publish(bundleId, []);
    };


    /**
     * Reset loadjs dependencies statuses
     */
    loadjs.reset = function reset() {
        bundleIdCache = {};
        bundleResultCache = {};
        bundleCallbackQueue = {};
    };


    /**
     * Determine if bundle has already been defined
     * @param String} bundleId - The bundle id
     */
    loadjs.isDefined = function isDefined(bundleId) {
        return bundleId in bundleIdCache;
    };


    // export
    return loadjs;

})();

var TC = TC || {};
/*
 * Initialization
 */
TC.version = '1.6.0';
(function () {
    if (!TC.apiLocation) {
        var src;
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
    }
})();

if (!TC.Consts) {
    TC.Consts = {};
    TC.Consts.OLNS_LEGACY = 'OpenLayers';
    TC.Consts.OLNS = 'ol';
    TC.Consts.PROJ4JSOBJ_LEGACY = 'Proj4js';
    TC.Consts.PROJ4JSOBJ = 'proj4';
    TC.Consts.GEOGRAPHIC = 'geographic';
    TC.Consts.UTM = 'UTM';
    TC.Consts.OLD_BROWSER_ALERT = 'TC.oldBrowserAlert';
    TC.Consts.CLUSTER_ANIMATION_DURATION = 200;
    TC.Consts.ZOOM_ANIMATION_DURATION = 300;
    TC.Consts.URL_MAX_LENGTH = 2048;
    TC.Consts.METER_PRECISION = 0;
    TC.Consts.DEGREE_PRECISION = 5;
    TC.Consts.EXTENT_TOLERANCE = 0.9998;/*URI: debido al redondeo del extente en el hash se obtiene un nivel de resolución mayor al debido. Con este valor definimos una tolerancia para que use una resolución si es muy muy muy próxima*/
    TC.Consts.url = {
        SPLIT_REGEX: /([^:]*:)?\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
        MODERNIZR: 'lib/modernizr.js',
        JQUERY_LEGACY: TC.apiLocation + 'lib/jquery/jquery.1.10.2.js',
        JQUERY: '//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.js',
        OL_LEGACY: 'lib/OpenLayers/OpenLayers.sitna.js',
        OL: 'lib/ol/build/ol-custom.js',
        OL_CONNECTOR_LEGACY: 'TC/ol/ol2.js',
        OL_CONNECTOR: 'TC/ol/ol.js',
        TEMPLATING: 'lib/dust/dust-full-helpers.min.js',
        TEMPLATING_I18N: 'lib/dust/dustjs-i18n.min.js',
        TEMPLATING_OVERRIDES: 'lib/dust/dust.overrides.js',
        PROJ4JS_LEGACY: 'lib/proj4js/legacy/proj4js-compressed.js',
        PROJ4JS: 'lib/proj4js/proj4-src.js',
        EPSG: 'https://epsg.io/',
        LOCALFORAGE: TC.apiLocation + 'lib/localForage/localforage.min.js',
        D3C3: TC.apiLocation + 'lib/d3c3/d3c3.min.js',
        CESIUM: TC.apiLocation + 'lib/cesium/release/Cesium.js',
        JSNLOG: 'lib/jsnlog/jsnlog.min.js',
        ERROR_LOGGER: TC.apiLocation + 'errors/logger.ashx',
        PDFMAKE: TC.apiLocation + 'lib/pdfmake/pdfmake-fonts.min.js',
        JSONPACK: 'lib/jsonpack/jsonpack.min.js',
        UA_PARSER: 'lib/ua-parser/ua-parser.min.js',
        HASH: 'lib/jshash/md5-min.js',
        URL_POLYFILL: 'lib/polyfill/url.js',
        PROMISE_POLYFILL: 'lib/polyfill/promise/polyfill.min.js'
    };
    TC.Consts.classes = {
        MAP: 'tc-map',
        POINT: 'tc-point',
        MARKER: 'tc-marker',
        VISIBLE: 'tc-visible',
        HIDDEN: 'tc-hidden',
        COLLAPSED: 'tc-collapsed',
        CHECKED: 'tc-checked',
        DISABLED: 'tc-disabled',
        ACTIVE: 'tc-active',
        DEFAULT: 'tc-default',
        LASTCHILD: 'tc-lastchild',
        TRANSPARENT: 'tc-transparent',
        DROP: 'tc-drop',
        LOADING: 'tc-loading',
        IPAD_IOS7_FIX: 'tc-ipad-ios7-fix',
        INFO: 'tc-msg-info',
        WARNING: 'tc-msg-warning',
        ERROR: 'tc-msg-error',
        THREED: 'tc-threed'
    };
    TC.Consts.msgType = {
        INFO: 'info',
        WARNING: 'warning',
        ERROR: 'error'
    };
    TC.Consts.msgErrorMode = {
        TOAST: 'toast',
        CONSOLE: 'console',
        EMAIL: 'email'
    };
    TC.Consts.event = {
        /**
         * Se lanza cuando el mapa ha cargado todas sus capas iniciales y todos sus controles
         * @event mapload
         */
        MAPLOAD: 'mapload.tc',
        MAPREADY: 'mapready.tc',
        BEFORELAYERADD: 'beforelayeradd.tc',
        LAYERADD: 'layeradd.tc',
        LAYERREMOVE: 'layerremove.tc',
        LAYERORDER: 'layerorder.tc',
        BEFORELAYERUPDATE: 'beforelayerupdate.tc',
        LAYERUPDATE: 'layerupdate.tc',
        LAYERERROR: 'layererror.tc',
        BEFOREBASELAYERCHANGE: 'beforebaselayerchange.tc',
        BASELAYERCHANGE: 'baselayerchange.tc',
        BEFOREUPDATE: 'beforeupdate.tc',
        UPDATE: 'update.tc',
        BEFOREZOOM: 'beforezoom.tc',
        ZOOM: 'zoom.tc',
        BEFOREUPDATEPARAMS: 'beforeupdateparams.tc',
        UPDATEPARAMS: 'updateparams.tc',
        VECTORUPDATE: 'vectorupdate.tc',
        FEATUREADD: 'featureadd.tc',
        BEFOREFEATURESADD: 'beforefeaturesadd.tc',
        FEATURESADD: 'featuresadd.tc',
        FEATUREREMOVE: 'featureremove.tc',
        FEATURESCLEAR: 'featuresclear.tc',
        FEATURESIMPORT: 'featuresimport.tc',
        FEATURESIMPORTERROR: 'featuresimporterror.tc',
        BEFORETILELOAD: 'beforetileload.tc',
        TILELOAD: 'tileload.tc',
        TILELOADERROR: 'tileloaderror.tc',
        CONTROLADD: 'controladd.tc',
        CONTROLACTIVATE: 'controlactivate.tc',
        CONTROLDEACTIVATE: 'controldeactivate.tc',
        BEFORECONTROLRENDER: 'beforecontrolrender.tc',
        CONTROLRENDER: 'controlrender.tc',
        BEFORELAYOUTLOAD: 'beforelayoutload.tc',
        LAYOUTLOAD: 'layoutload.tc',
        LAYERVISIBILITY: 'layervisibility.tc',
        LAYEROPACITY: 'layeropacity.tc',
        FEATURECLICK: 'featureclick.tc',
        NOFEATURECLICK: 'nofeatureclick.tc',
        FEATUREOVER: 'featureover.tc',
        FEATUREOUT: 'featureout.tc',
        BEFOREFEATUREINFO: 'beforefeatureinfo.tc',
        FEATUREINFO: 'featureinfo.tc',
        NOFEATUREINFO: 'nofeatureinfo.tc',
        FEATUREINFOERROR: 'featureinfoerror.tc',
        CLICK: 'click',
        MOUSEUP: 'mouseup',
        MOUSEMOVE: 'mousemove',
        MOUSELEAVE: 'mouseleave',
        STARTLOADING: 'startloading.tc',
        STOPLOADING: 'stoploading.tc',
        EXTERNALSERVICEADDED: 'externalserviceadded.tc',
        ZOOMTO: 'zoomto.tc',
        PROJECTIONCHANGE: 'projectionchange.tc',
        VIEWCHANGE: 'viewchange.tc',
        TERRAINPROVIDERADD: 'terrainprovideradd.tc',
        TERRAINPROVIDERREMOVE: 'terrainproviderremove.tc',
        OVERVIEWBASELAYERCHANGE: 'overviewbaselayerchange.tc',
        POPUP: 'popup.tc'
    };
    TC.Consts.layer = {
        IDENA_ORTHOPHOTO: 'ortofoto',
        IDENA_BASEMAP: 'mapabase',
        IDENA_CADASTER: 'catastro',
        IDENA_CARTO: 'cartografia',
        IDENA_ORTHOPHOTO2018: 'ortofoto2018',
        IDENA_ORTHOPHOTO2017: 'ortofoto2017',
        IDENA_ORTHOPHOTO2014: 'ortofoto2014',
        IDENA_ORTHOPHOTO2012: 'ortofoto2012',
        IDENA_DYNBASEMAP: 'mapabase_dinamico',
        IDENA_DYNORTHOPHOTO: 'ortofoto_dinamico',
        IDENA_DYNORTHOPHOTO2018: 'ortofoto2018_dinamico',
        IDENA_DYNORTHOPHOTO2017: 'ortofoto2017_dinamico',
        IDENA_DYNORTHOPHOTO2014: 'ortofoto2014_dinamico',
        IDENA_DYNORTHOPHOTO2012: 'ortofoto2012_dinamico',
        IDENA_DYNCARTO: 'cartografia_dinamico',
        IDENA_BW_RELIEF: 'relieve_bn',
        IDENA_BASEMAP_ORTHOPHOTO: 'base_orto',

        IGN_ES_CARTO: "ign-raster",
        IGN_ES_BASEMAP: "ign-base",
        IGN_ES_BASEMAP_GREY: "ign-base-gris",
        IGN_ES_RELIEF: "ign-mtn",
        IGN_ES_ORTHOPHOTO: "ign-pnoa",

        IGN_ES_DYNCARTO: "ign-raster-dyn",
        IGN_ES_DYNBASEMAP: "ign-base-dyn",
        IGN_ES_DYNBASEMAP_GREY: "ign-base-gris-dyn",
        IGN_ES_DYNRELIEF: "ign-mtn-dyn",
        IGN_ES_DYNORTHOPHOTO: "ign-pnoa-dyn",

        IGN_FR_CARTO: "ign-fr-cartes",
        IGN_FR_BASEMAP: "ign-fr-base",
        IGN_FR_RELIEF: "ign-fr-estompage",
        IGN_FR_ORTHOPHOTO: "ign-fr-orto",

        IGN_FR_DYNCARTO: "ign-fr-cartes-dyn",
        IGN_FR_DYNBASEMAP: "ign-fr-base-dyn",
        IGN_FR_DYNRELIEF: "ign-fr-estompage-dyn",
        IGN_FR_DYNORTHOPHOTO: "ign-fr-orto-dyn",

        OSM: 'osm',
        CARTO_VOYAGER: 'carto_voyager',
        CARTO_LIGHT: 'carto_light',
        CARTO_DARK: 'carto_dark',
        MAPBOX_STREETS: 'mapbox_streets',
        MAPBOX_SATELLITE: 'mapbox_satellite',

        BLANK: 'ninguno'
    };
    TC.Consts.text = {
        API_ERROR: 'Error API SITNA',
        APP_ERROR: 'Error de aplicación'
    };
    /**
     * Colección de identificadores de tipo de capa.
     * No se deberían modificar las propiedades de esta clase.
     * @class TC.consts.LayerType
     * @static
     */
    /**
     * Identificador de capa de tipo WMS.
     * @property WMS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo WMTS.
     * @property WMTS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo WFS.
     * @property WFS
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo KML.
     * @property KML
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo GPX.
     * @property GPX
     * @type string
     * @final
     */
    /**
     * Identificador de capa de tipo vectorial. Este tipo de capa es la que se utiliza para dibujar marcadores.
     * @property VECTOR
     * @type string
     * @final
     */
    /**
     * Identificador de capa de grupo.
     * @property GROUP
     * @type string
     * @final
     */
    TC.Consts.layerType = {
        WMS: 'WMS',
        WMTS: 'WMTS',
        WFS: 'WFS',
        VECTOR: 'vector',
        KML: 'KML',
        GPX: 'GPX',
        GML: 'GML',
        GEOJSON: 'GeoJSON',
        GROUP: 'group'
    };
    TC.Consts.geom = {
        POINT: 'point',
        MULTIPOINT: 'multipoint',
        POLYLINE: 'polyline',
        POLYGON: 'polygon',
        MULTIPOLYLINE: 'multipolyline',
        MULTIPOLYGON: 'multipolygon',
        CIRCLE: 'circle',
        RECTANGLE: 'rectangle'
    };
    TC.Consts.searchType = {
        CADASTRAL: 'cadastral',
        COORDINATES: 'coordinates',
        MUNICIPALITY: 'municipality',
        COUNCIL: 'council',
        LOCALITY: 'locality',
        STREET: 'street',
        NUMBER: 'number',
        URBAN: 'urban',
        COMMONWEALTH: 'commonwealth',
        ROAD: 'road',
        ROADPK: 'roadpk',
        PLACENAME: 'placename',
        PLACENAMEMUNICIPALITY: 'placenamemunicipality'
    };
    TC.Consts.mapSearchType = {
        MUNICIPALITY: TC.Consts.searchType.MUNICIPALITY,
        COUNCIL: TC.Consts.searchType.COUNCIL,
        URBAN: TC.Consts.searchType.URBAN,
        COMMONWEALTH: TC.Consts.searchType.COMMONWEALTH,
        GENERIC: 'generic'
    };
    TC.Consts.comparison = {
        EQUAL_TO: '==',
        NOT_EQUAL_TO: '!=',
        LESS_THAN: '<',
        GREATER_THAN: '>',
        LESS_THAN_EQUAL_TO: '=<',
        GREATER_THAN_EQUAL_TO: '>=',
        LIKE: 'is'
    };
    TC.Consts.logicalOperator = {
        AND: 'and',
        OR: 'or'
    };
    TC.Consts.WMTSEncoding = {
        KVP: 'KVP',
        RESTFUL: 'RESTful'
    };
    TC.Consts.mimeType = {
        PNG: 'image/png',
        JPEG: 'image/jpeg',
        JSON: 'application/json',
        GEOJSON: 'application/vnd.geo+json',
        KML: 'application/vnd.google-earth.kml+xml',
        GML: 'application/gml+xml',
        GPX: 'application/gpx+xml',
        XML: 'application/xml'
    };
    TC.Consts.format = {
        JSON: 'JSON',
        KML: 'KML',
        GML: 'GML',
        GML2: 'GML2',
        GML3: 'GML2',
        GEOJSON: 'GeoJSON',
        TOPOJSON: 'TopoJSON',
        GPX: 'GPX',
        WKT: 'WKT'
    };
    //enumerado de errores y warninqs derivados de descargas, getfeatures
    TC.Consts.WFSErrors = {
        GetFeatureNotAvailable: "GetFeatureNotAvailable",
        LayersNotAvailable: "LayersNotAvailable",
        NoLayers: "NoLayers",
        NoValidLayers: "noValidLayers",
        QueryNotAvailable: "QueryNotAvailable",
        CapabilitiesParseError: "CapabilitiesParseError",
        NumMaxFeatures: "NumMaxFeatures",
        GetCapabilities: "GetCapabilities",
        Indeterminate: "Indeterminate",
        NoFeatures: "NoFeatures"
    }
    /**
     * Colección de identificadores de estados de visibilidad.
     * No se deberían modificar las propiedades de esta clase.
     * @class TC.consts.Visibility
     * @static
     */
    /**
     * Identificador de nodo no visible.
     * @property NOT_VISIBLE
     * @type number
     * @final
     */
    /**
     * Identificador de nodo no visible a la resolución actual.
     * @property NOT_VISIBLE_AT_RESOLUTION
     * @type number
     * @final
     */
    /**
     * Identificador de nodo no visible pero que tiene nodos hijos visibles.
     * @property HAS_VISIBLE
     * @type number
     * @final
     */
    /**
     * Identificador de nodo visible.
     * @property VISIBLE
     * @type number
     * @final
     */
    TC.Consts.visibility = {
        NOT_VISIBLE: 0,
        NOT_VISIBLE_AT_RESOLUTION: 1,
        HAS_VISIBLE: 2,
        VISIBLE: 4
    };

    TC.Consts.view = {
        DEFAULT: 0,
        THREED: 1,
        PRINTING: 2
    };

    TC.Consts.units = {
        DEGREES: "degrees",
        METERS: "m"
    };

    TC.Consts.MARKER = 'marker';

    TC.Defaults = (function () {

        var clusterRadii = {};
        var getClusterRadius = function (feature) {
            var count = feature.features.length;
            var result = clusterRadii[count];
            if (!result) {
                result = 2 + Math.round(Math.sqrt(count) * 5);
                clusterRadii[count] = result;
            }
            return result;
        };

        return {
            imageRatio: 1.05,
            proxy: '',

            crs: 'EPSG:25830',
            utmCrs: 'EPSG:25830',
            geoCrs: 'EPSG:4326',
            initialExtent: [541084.221, 4640788.225, 685574.4632, 4796618.764],
            maxExtent: false,
            baselayerExtent: [480408, 4599748, 742552, 4861892],
            resolutions: [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, .5, .25],
            pointBoundsRadius: 30,
            extentMargin: 0.2,
            mouseWheelZoom: true,
            attribution: '<a href="http://sitna.navarra.es/" target="_blank">SITNA</a>',
            oldBrowserAlert: true,
            notifyApplicationErrors: false,
            loggingErrorsEnabled: true,
            maxErrorCount: 10,
            layoutURLParamName: 'layout', // Parámetro donde leer en la URL de la aplicación para cargar un layout.
            titleURLParamName: 'title', // Parámetro donde leer en la URL de la aplicación para cargar un título de mapa, p. e. al imprimir.

            locale: 'es-ES',

            view: TC.Consts.view.DEFAULT,

            screenSize: 20,
            pixelTolerance: 10, // Used in GFI requests
            maxResolutionError: 0.01, // Max error ratio to consider two resolutions equivalent

            toastDuration: 5000,

            avgTileSize: 31000,

            availableBaseLayers: [
                {
                    id: TC.Consts.layer.IDENA_BASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830extended',
                    layerNames: 'mapabase',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: true,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO,
                    title: 'Ortofoto máxima actualidad',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto_maxima_actualidad',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2018,
                    title: 'Ortofoto 2018',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2018',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2017,
                    title: 'Ortofoto 2017',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2017',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830reduced',
                    layerNames: 'ortofoto2014',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_ORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'ortofoto2012',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CARTO,
                    title: 'Cartografía topográfica',
                    type: TC.Consts.layerType.WMTS,
                    url: '//idena.navarra.es/ogc/wmts/',
                    matrixSet: 'epsg25830',
                    layerNames: 'mapaTopografico',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    fallbackLayer: TC.Consts.layer.IDENA_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_CADASTER,
                    title: 'Catastro',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'catastro,regionesFronterizas',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-cadaster.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BW_RELIEF,
                    title: 'Relieve',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'IDENA:mapa_relieve_bn',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_bw.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_BASEMAP_ORTHOPHOTO,
                    title: 'Mapa base/ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase_orto',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-base_ortho.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_BASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNBASEMAP,
                    title: 'Mapa base',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'mapaBase,regionesFronterizas',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO,
                    title: 'Ortofoto',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_maxima_actualidad',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2018,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2018',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2018.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2017,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2017',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2017.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2014,
                    title: 'Ortofoto 2014',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2014',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2014.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNORTHOPHOTO2012,
                    title: 'Ortofoto 2012',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'ortofoto_5000_2012',
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-ortho2012.jpg',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IDENA_DYNCARTO,
                    title: 'Cartografía topográfica',
                    type: TC.Consts.layerType.WMS,
                    url: '//idena.navarra.es/ogc/wms',
                    layerNames: 'MTNa5_BTA',
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-bta.png',
                    overviewMapLayer: TC.Consts.layer.IDENA_DYNBASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_CARTO,
                    type: TC.Consts.layerType.WMTS,
                    title: "Cartografía raster \r\n (IGN ES)",
                    url: "//www.ign.es/wmts/mapa-raster",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "MTN",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNCARTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP,
                    title: "Callejero \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBaseTodo",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_BASEMAP_GREY,
                    title: "Callejero gris \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/ign-base",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "IGNBase-gris",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-basemap_grey_ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_RELIEF,
                    title: "Relieve \r\n (IGN ES)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/mdt",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "Relieve",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-relief_ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_ORTHOPHOTO,
                    title: "Ortofoto PNOA",
                    type: TC.Consts.layerType.WMTS,
                    url: "//www.ign.es/wmts/pnoa-ma",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "OI.OrthoimageCoverage",
                    matrixSet: "EPSG:25830",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-orthophoto_pnoa.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNBASEMAP_GREY,
                    title: 'Callejero gris \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/ign-base',
                    layerNames: 'IGNBaseTodo-gris',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-basemap_grey_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/pnoa-ma',
                    layerNames: 'OI.OrthoimageCoverage',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-orthophoto_pnoa.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNCARTO,
                    title: 'Cartografía topográfica \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mapa-raster',
                    layerNames: 'mtn_rasterizado',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto_ign.png',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_ES_DYNRELIEF,
                    title: 'Relieve \r\n (IGN ES)',
                    type: TC.Consts.layerType.WMS,
                    url: '//www.ign.es/wms-inspire/mdt',
                    layerNames: 'relieve',
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-relief_ign.jpg',
                    overviewMapLayer: TC.Consts.layer.IGN_ES_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_CARTO,
                    title: "Cartografía raster \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNCARTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_BASEMAP,
                    title: "Mapa base \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_RELIEF,
                    title: "Relieve \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE.SHADOW",
                    matrixSet: "PM",
                    format: "image/png",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_ORTHOPHOTO,
                    title: "Ortofoto \r\n (IGN FR)",
                    type: TC.Consts.layerType.WMTS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/wmts",
                    encoding: TC.Consts.WMTSEncoding.KVP,
                    layerNames: "ORTHOIMAGERY.ORTHOPHOTOS",
                    matrixSet: "PM",
                    format: "image/jpeg",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    fallbackLayer: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNCARTO,
                    title: 'Cartografía raster \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-carto-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP,
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNBASEMAP,
                    title: 'Mapa base \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "GEOGRAPHICALGRIDSYSTEMS.PLANIGN",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-base-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNRELIEF,
                    title: 'Relieve \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "ELEVATION.ELEVATIONGRIDCOVERAGE",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-estom-fr-ign.png",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.IGN_FR_DYNORTHOPHOTO,
                    title: 'Ortofoto \r\n (IGN FR)',
                    type: TC.Consts.layerType.WMS,
                    url: "//wxs.ign.fr/njfzwf3vgc55gekk8ra4zezx/geoportail/r/wms",
                    layerNames: "HR.ORTHOIMAGERY.ORTHOPHOTOS",
                    thumbnail: TC.apiLocation + "tc/css/img/thumb-ortho-fr-ign.jpg",
                    ignoreProxification: true,
                    overviewMapLayer: TC.Consts.layer.IGN_FR_BASEMAP
                },
                {
                    id: TC.Consts.layer.OSM,
                    title: 'OSM',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/osm/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'osm',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-osm.png',
                    overviewMapLayer: TC.Consts.layer.OSM
                },
                {
                    id: TC.Consts.layer.CARTO_VOYAGER,
                    title: 'CARTO Voyager',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'voyager',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-voyager.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_LIGHT,
                    title: 'CARTO light',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'light_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-light.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.CARTO_DARK,
                    title: 'CARTO dark',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/carto/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'dark_all',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-carto-dark.png',
                    overviewMapLayer: TC.Consts.layer.CARTO_VOYAGER
                },
                {
                    id: TC.Consts.layer.MAPBOX_STREETS,
                    title: 'Mapbox Streets',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'streets',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/png',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-streets.png',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.MAPBOX_SATELLITE,
                    title: 'Mapbox Satellite',
                    type: TC.Consts.layerType.WMTS,
                    url: TC.apiLocation + 'wmts/mapbox/',
                    matrixSet: 'WorldWebMercatorQuad',
                    layerNames: 'satellite',
                    encoding: TC.Consts.WMTSEncoding.RESTFUL,
                    format: 'image/jpeg',
                    isDefault: false,
                    hideTree: true,
                    thumbnail: TC.apiLocation + 'TC/css/img/thumb-mapbox-satellite.jpg',
                    overviewMapLayer: TC.Consts.layer.MAPBOX_STREETS
                },
                {
                    id: TC.Consts.layer.BLANK,
                    title: 'Mapa en blanco',
                    type: TC.Consts.layerType.VECTOR
                }
            ],

            baseLayers: [
                TC.Consts.layer.IDENA_BASEMAP,
                TC.Consts.layer.IDENA_ORTHOPHOTO,
                TC.Consts.layer.IDENA_CADASTER,
                TC.Consts.layer.IDENA_CARTO
            ],

            defaultBaseLayer: TC.Consts.layer.IDENA_BASEMAP,

            workLayers: [],

            controls: {
                loadingIndicator: true,
                navBar: false,
                scaleBar: false,
                scale: false,
                scaleSelector: false,
                overviewMap: false,
                basemapSelector: false,
                attribution: true,
                TOC: false,
                coordinates: true,
                legend: false,
                popup: false,
                search: {
                    url: '//idena.navarra.es/ogc/wfs',
                    allowedSearchTypes: {
                        coordinates: {},
                        municipality: {},
                        urban: {},
                        street: {},
                        number: {},
                        cadastral: {}
                    }
                },
                measure: false,                
                streetView: true,
                featureInfo: true,
                featureTools: true
            },

            layout: null,

            styles: {
                point: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    radius: 6,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -16],
                    fontColor: '#000000',
                    fontSize: 10
                },
                marker: {
                    classes: [
                        TC.Consts.classes.MARKER + 1,
                        TC.Consts.classes.MARKER + 2,
                        TC.Consts.classes.MARKER + 3,
                        TC.Consts.classes.MARKER + 4,
                        TC.Consts.classes.MARKER + 5
                    ],
                    anchor: [.5, 1],
                    width: 32,
                    height: 32,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    labelOffset: [0, -32],
                    fontColor: '#000000',
                    fontSize: 10
                },
                line: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                polygon: {
                    strokeColor: '#ff0000',
                    strokeWidth: 2,
                    fillColor: '#000000',
                    fillOpacity: 0.3,
                    labelOutlineWidth: 2,
                    labelOutlineColor: '#ffffff',
                    fontColor: '#000000',
                    fontSize: 10
                },
                cluster: {
                    point: {
                        fillColor: '#333366',
                        fillOpacity: 0.6,
                        radius: getClusterRadius,
                        label: '${features.length}',
                        fontColor: "#fff",
                        fontSize: 9
                    }
                },
                selection: {
                    point: {
                        fillColor: '#0000ff',
                        fillOpacity: 0.5,
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        radius: 6,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        labelOffset: [0, -16],
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    line: {
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    },
                    polygon: {
                        strokeColor: '#0000ff',
                        strokeWidth: 2,
                        fillColor: '#000000',
                        fillOpacity: .3,
                        labelOutlineWidth: 2,
                        labelOutlineColor: '#ffffff',
                        fontColor: '#000000',
                        fontSize: 10
                    }
                }
            }
        };
    })();

    (function () {
        if (!Array.prototype.map) {
            Array.prototype.map = function (fun /*, thisArg */) {
                "use strict";

                if (this === void 0 || this === null)
                    throw new TypeError();

                var t = Object(this);
                var len = t.length >>> 0;
                if (typeof fun !== "function")
                    throw new TypeError();

                var res = new Array(len);
                var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                for (var i = 0; i < len; i++) {
                    // NOTE: Absolute correctness would demand Object.defineProperty
                    //       be used.  But this method is fairly new, and failure is
                    //       possible only if Object.prototype or Array.prototype
                    //       has a property |i| (very unlikely), so use a less-correct
                    //       but more portable alternative.
                    if (i in t)
                        res[i] = fun.call(thisArg, t[i], i, t);
                }

                return res;
            };
        }

        /* 
         * proxify: returns cross-origin safe URL
         */
        TC.proxify = function (url) {
            url = $.trim(url);
            var result = url;
            if (TC.Cfg.proxy) {
                var prevent = false;
                if (TC.Cfg.proxyExceptions) {
                    for (var i = 0; i < TC.Cfg.proxyExceptions.length; i++) {
                        if (url.indexOf(TC.Cfg.proxyExceptions[i]) > -1) {
                            prevent = true;
                            break;
                        }
                    }
                }

                if (!prevent && !TC.Util.isSameOrigin(url)) {
                    if (typeof TC.Cfg.proxy == "function") {
                        result = TC.Cfg.proxy(url);
                    } else {
                        result = TC.Cfg.proxy;
                        if (url.substr(0, 4) != "http") result += window.location.protocol;
                        result += encodeURIComponent(url);
                    }
                }
            }
            return result;
        };

        var getHead = function () {
            var result;
            var d = document;
            var ah = d.getElementsByTagName("head");
            if (ah.length === 0) {
                result = d.createElement("head");
                d.documentElement.insertBefore(result, document.body);
            }
            else {
                result = ah[0];
            }
            return result;
        };

        if (typeof TC.isDebug != "boolean") {
            TC.isDebug = true;
        };

        var _showLoadFailedError = function (url) {
            var mapObj = $('.' + TC.Consts.classes.MAP).data('map');
            TC.error(
                TC.Util.getLocaleString(mapObj.options.locale, "urlFailedToLoad",
                    { url: url }),
                [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],
                "Error al cargar " + url);
        };

        TC.syncLoadJS = function (url) {
            var _sendRequest = function (url, callbackErrorFn) {
                var req = new XMLHttpRequest();
                req.open("GET", url, false); // 'false': synchronous.
                var result;

                req.onreadystatechange = function (e) {
                    if (req.readyState === 4) {
                        if (req.status === 404) {
                            result = false;
                            callbackErrorFn(true);
                        } else if (req.status !== 200) {
                            callbackErrorFn();
                            result = false;
                        } else {
                            result = req.responseText;
                        }
                    }
                };


                try {
                    req.send(null);
                } catch (error) {
                    result = false;
                    callbackErrorFn();
                }

                return result;
            };

            if (!/(\.js|\/)$/i.test(url)) { // Si pedimos un archivo sin extensión se la ponemos según el entorno
                url = url + (TC.isDebug ? '.js' : '.min.js');
            }

            var reqResult = _sendRequest(url, function (is404) {
                if (is404) {
                    _showLoadFailedError(url);
                    return false;
                } else {
                    return _sendRequest(url, function () {
                        _showLoadFailedError(url);
                    });
                }
            });

            if (reqResult) {
                var script = document.createElement("script");
                script.type = "text/javascript";
                script.text = reqResult;
                getHead().appendChild(script);
            }
        };

        if (!window.Modernizr) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.MODERNIZR);
        }
        Modernizr.touch = Modernizr.touchevents; // compatibilidad hacia atrás

        TC.isLegacy = false;

        if (!window.jQuery) {
            if (Modernizr.canvas && !TC.isLegacy) { // > ie8
                TC.syncLoadJS(TC.Consts.url.JQUERY);
            }
            else {
                TC.syncLoadJS(TC.Consts.url.JQUERY_LEGACY);
            }
        }

        if (!('Promise' in window)) {
            TC.syncLoadJS(TC.apiLocation + TC.Consts.url.PROMISE_POLYFILL);
        }
        // Polyfill para NodeList.forEach
        if (window.NodeList && !NodeList.prototype.forEach) {
            NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if (!('finally' in Promise.prototype)) {
            // Muchos polyfills de Promise no implementan finally, lo hacemos aquí en ese caso
            Promise.prototype.finally = function (callback) {
                const ctor = this.constructor;
                return this.then(
                    function (val) {
                        return ctor.resolve(callback()).then(function () {
                            return value;
                        });
                    },
                    function (err) {
                        return ctor.resolve(callback()).then(function () {
                            return ctor.reject(err);
                        });
                    }
                );
            };
        }

        // Parche para soportar $.when
        if ('$' in window) {
            $._oldWhen = $.when;
            $.when = function () {
                const newArgs = new Array(arguments.length);
                for (var i = 0; i < arguments.length; i++) {
                    const arg = newArgs[i] = arguments[i];
                    if (arg instanceof Promise) {
                        const newArg = $.Deferred();
                        arg
                            .then(function (val) {
                                newArg.resolve(val)
                            })
                            .catch(function (err) {
                                newArg.reject(err);
                            });
                        newArgs[i] = newArg;
                    }
                }
                return $._oldWhen.apply(this, newArgs);
            };
        }

        // Transformación de petición AJAX de jQuery a promesa nativa
        TC.ajax = function (options) {
            return new Promise(function (resolve, reject) {
                options = options || {};
                const method = options.method || 'GET';
                var data;
                if (options.data) {
                    if (typeof options.data === 'string') {
                        data = options.data;
                    }
                    else if (typeof options.data === 'object') {
                        const paramArray = [];
                        for (var key in options.data) {
                            paramArray[paramArray.length] = key + '=' + options.data[key].toString();
                        }
                        data = paramArray.join('&');
                    }
                }
                var url = options.url;
                if (method === 'GET') {
                    url = url + '?' + data;
                }
                const request = new XMLHttpRequest();
                request.open(method, options.url);

                if (options.contentType || typeof options.contentType === 'boolean') {
                    if (options.contentType) {
                        request.setRequestHeader('Content-Type', options.contentType + '; charset=UTF-8');
                    }
                    
                }
                else {
                    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                }

                request.onreadystatechange = function (e) {
                    if (request.readyState === 4) { // DONE
                        if (request.status !== 200) {
                            reject({
                                status: request.status,
                                msg: request.statusText,
                                url: options.url
                            });
                        } else {
                            var responseData;
                            try {
                                switch (options.responseType) {
                                    case TC.Consts.mimeType.JSON:
                                        responseData = JSON.parse(request.responseText);
                                        break;
                                    case TC.Consts.mimeType.XML:
                                        responseData = new DOMParser().parseFromString(request.responseText, 'application/xml');
                                        break;
                                    default:
                                        responseData = request.responseText;
                                        break;
                                }
                                resolve(responseData);
                            }
                            catch (error) {
                                reject(error);
                            }
                        }
                    }
                };

                try {
                    request.send(method === 'POST' ? data : null);
                } catch (error) {
                    reject(Error(error));
                }
            });
        };

        // Completamos los datos de versión
        document.addEventListener('DOMContentLoaded', function () {
            var build;
            var mapLibrary = 'Unknown library';
            var OL2 = 'OpenLayers 2';
            var OL = 'OpenLayers 4';
            if (TC.Control) {
                build = 'Compiled';
                if (TC.isLegacy) {
                    if (window.OpenLayers) {
                        mapLibrary = OL2;
                    }
                }
                else {
                    if (window.ol) {
                        mapLibrary = OL;
                    }
                }
            }
            else {
                build = 'On demand';
                mapLibrary = TC.isLegacy ? OL2 : OL;
            }
            TC.version = TC.version + ' (' + build + '; ' + mapLibrary + '; @ ' + TC.apiLocation + ')';
        });

        TC.loadJSInOrder = function (condition, url, callback) {
            TC.loadJS(condition, url, callback, true);
        };

        const addCrossOriginAttr = function (path, scriptEl) {
            if (!TC.Util.isSameOrigin(path)) {
                scriptEl.crossOrigin = "anonymous";
            }
        };

        TC.loadJS = function (condition, url, callback, inOrder, notCrossOrigin) {
            if (arguments.length < 4) {
                inOrder = false;
            }

            var urls = $.isArray(url) ? url : [url];
            urls = urls.map(function (elm) {
                if (!/\.js$/i.test(elm) && elm.indexOf(TC.apiLocation) === 0) { // Si pedimos un archivo sin extensión y es nuestro se la ponemos según el entorno
                    return elm + (TC.isDebug ? '.js' : '.min.js');
                }
                return elm;
            });

            //si tiene canvas, es que es un navegador nuevo
            if (Modernizr.canvas) {
                if (condition) {
                    urls = urls instanceof Array ? urls : [urls];                    

                    var name = "";
                    const getName = function (path) {
                        return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
                    };
                    if (urls.length > 1) {
                        var toReduce = urls.slice(0).filter(function (path, index) {
                            if (loadjs.isDefined(getName(path))) {
                                urls.splice(index, 1);
                                loadjs.ready(getName(path), callback);
                                return false;
                            } else {
                                return true;
                            }
                        });
                        if (toReduce.length === 1) {
                            name = getName(toReduce[0]);
                        } else if (toReduce.length > 0) {
                            name = toReduce.reduce(function (prev, curr) {
                                return getName(prev) + "_" + getName(curr);
                            });
                        }
                    } else {
                        name = getName(urls[0]);
                    }

                    if (name.length > 0) {
                        if (!loadjs.isDefined(name)) {
                            var options = {
                                async: !inOrder,
                                numRetries: 1
                            };

                            if (!notCrossOrigin && !TC.Util.detectIE()) {
                                options.before = addCrossOriginAttr;
                            }

                            loadjs(urls, name, options);
                            loadjs.ready(name, {
                                success: function () {
                                    callback();
                                },
                                error: function (pathsNotFound) {
                                    _showLoadFailedError(pathsNotFound);
                                }
                            });
                        } else {
                            loadjs.ready(name, callback);
                        }
                    }
                }
                else {
                    callback();
                }
            }
            else {
                if (condition) {
                    for (var i = 0; i < urls.length; i++) {
                        TC.syncLoadJS(urls[i]);
                    }
                }
                if (callback) {
                    callback();
                }
            }
        };        

        TC.loadCSS = function (url) {
            const getName = function (path) {
                return path.split('/').reverse().slice(0, 2).reverse().join('_').toLowerCase();
            };

            const name = getName(url);
            if (!loadjs.isDefined(name)) {
                loadjs(url, name, {
                    error: function (pathsNotFound) {
                        _showLoadFailedError(pathsNotFound);
                    },
                    numRetries: 1
                });
            } else {
                loadjs.ready(name);
            }
        };

        var projectionDataCache = {};

        TC.getProjectionData = function (options) {
            return new Promise(function (resolve, reject) {
                options = options || {};
                var code = options.crs.substr(options.crs.indexOf(':') + 1);
                if (parseInt(code) === Number.NaN) {
                    // El CRS no está en modo urn o EPSG
                    code = options.crs.substr(options.crs.lastIndexOf('/') + 1);
                }
                var projData = projectionDataCache[code];
                if (projData) {
                    resolve(projData);
                }
                else {
                    var url = TC.Consts.url.EPSG + '?format=json&q=' + code;
                    const toolProxification = new TC.tool.Proxification(TC.proxify);
                    toolProxification.fetchJSON(url, options).then(function (data) {
                        projectionDataCache[code] = data;
                        resolve(data);
                    }).catch(function (error) {
                        reject(Error(error));
                    });
                }
            });
        };

        TC.loadProjDef = function (options) {
            options = options || {};
            const crs = options.crs;
            const epsgPrefix = 'EPSG:';
            const urnPrefix = 'urn:ogc:def:crs:EPSG::';
            const gmlPrefix = 'http://www.opengis.net/gml/srs/epsg.xml#';

            var getDef;
            if (TC.isLegacy) {
                if (!window[TC.Consts.PROJ4JSOBJ_LEGACY]) {
                    TC.syncLoadJS(TC.url.proj4js);
                }
                getDef = function (name) {
                    return Proj4js.defs[name];
                };
            }
            else {
                if (!window[TC.Consts.PROJ4JSOBJ]) {
                    TC.syncLoadJS(TC.url.proj4js);
                }
                getDef = function (name) {
                    return proj4.defs(name);
                };
            }
            if (!window.Proj4js) {
                window.Proj4js = {
                    Proj: function (code) { return proj4(Proj4js.defs[code]); },
                    defs: proj4.defs,
                    transform: proj4
                };
            }
            const loadProj4Def = function (code, def) {
                Proj4js.defs[code] = def;
                if (!TC.isLegacy) {
                    proj4.defs(code, def);
                }
            };
            const loadDef = function (code, def, name) {
                const epsgCode = epsgPrefix + code;
                const urnCode = urnPrefix + code;
                const gmlCode = gmlPrefix + code;
                var axisUnawareDef;
                if (typeof def === 'object') {
                    axisUnawareDef = $.extend({}, def);
                    def = $.extend({}, def);
                    if (axisUnawareDef.axis) {
                        delete axisUnawareDef.axis;
                    }
                }
                else if (typeof def === 'string') {
                    axisUnawareDef = def.replace('+axis=neu', '');
                }
                loadProj4Def(epsgCode, def);
                loadProj4Def(urnCode, def);
                // Por convención, los CRS definidos por URI siempre tienen orden de coordenadas X-Y.
                loadProj4Def(gmlCode, axisUnawareDef);
                if (crs.indexOf('http') === 0) {
                    // El CRS es tipo URI, usado seguramente en un GML.
                    loadProj4Def(crs, axisUnawareDef);
                    getDef(crs).name = name;
                }
                getDef(epsgCode).name = name;
                getDef(gmlCode).name = name;
            };
            const loadDefResponse = function (data) {
                var result = data.status === 'ok' && data.number_result === 1;
                if (result) {
                    var def = data.results[0];
                    loadDef(def.code, def.proj4, def.name);
                }
                return result;
            };

            var idx = crs.lastIndexOf('#');
            if (idx < 0) {
                idx = crs.lastIndexOf('/');
            }
            if (idx < 0) {
                idx = crs.lastIndexOf(':');
            }
            var code = crs.substr(idx + 1);
            var def = getDef(crs);
            if (def) {
                loadDef(code, def, options.name);
                if ($.isFunction(options.callback)) {
                    options.callback();
                }
            }
            else {
                if (options.def) {
                    loadDef(code, options.def, options.name);
                    if ($.isFunction(options.callback)) {
                        options.callback();
                    }
                }
                else {
                    TC.getProjectionData(options).then(function (data) {
                        if (loadDefResponse(data) && $.isFunction(options.callback)) {
                            options.callback();
                        };
                    });
                }
            }
        };

        TC.url = {
            templating: [
                TC.apiLocation + TC.Consts.url.TEMPLATING,
                TC.apiLocation + TC.Consts.url.TEMPLATING_I18N,
                TC.apiLocation + TC.Consts.url.TEMPLATING_OVERRIDES
            ]
        };

        if (TC.isLegacy) {
            TC.url.ol = TC.apiLocation + TC.Consts.url.OL_LEGACY;
            TC.url.olConnector = TC.apiLocation + TC.Consts.url.OL_CONNECTOR_LEGACY;
            TC.url.proj4js = TC.apiLocation + TC.Consts.url.PROJ4JS_LEGACY;
        }
        else {
            TC.url.ol = TC.apiLocation + TC.Consts.url.OL;
            TC.url.olConnector = TC.apiLocation + TC.Consts.url.OL_CONNECTOR;
            TC.url.proj4js = TC.apiLocation + TC.Consts.url.PROJ4JS;
        }

        // Precargamos el CRS por defecto
        TC.loadProjDef({ crs: 'EPSG:25830', name: 'ETRS89 / UTM zone 30N', def: '+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs' });
        // Precargamos los CRS de IDENA que tienen orden de ejes neu
        TC.loadProjDef({ crs: 'EPSG:4258', name: 'ETRS89', def: '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3040', name: 'ETRS89 / UTM zone 28N (N-E)', def: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3041', name: 'ETRS89 / UTM zone 29N (N-E)', def: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3042', name: 'ETRS89 / UTM zone 30N (N-E)', def: '+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:3043', name: 'ETRS89 / UTM zone 31N (N-E)', def: '+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +axis=neu' });
        TC.loadProjDef({ crs: 'EPSG:4230', name: 'ED50', def: '+proj=longlat +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +no_defs +axis=neu' });

        TC.Cfg = $.extend(true, {}, TC.Defaults, TC.Cfg);

        TC.capabilities = {};

        TC.WFScapabilities = {};

        TC.cache = {};

        TC.alert = function (text) {
            alert(text);
        };

        TC.prompt = function (text, value, callback) {
            var newValue = prompt(text, value);
            if ($.isFunction(callback)) {
                callback(newValue);
            }
        };

        TC.confirm = function (text, accept, cancel) {
            if (confirm(text)) {
                if ($.isFunction(accept)) {
                    accept();
                }
            }
            else {
                if ($.isFunction(cancel)) {
                    cancel();
                }
            }
        };

        TC.error = function (text) {
            if (window.console) {
                console.error(text);
            }

        };

        if (!TC.Map) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Map');
        }
        if (!TC.Util) {
            TC.syncLoadJS(TC.apiLocation + 'TC/Util');
        }

        // OpenLayers connectors
        TC.wrap = {
            Map: function (map) {
                var self = this;
                self.parent = map;
                self.map = null;
                /*
                 *  wrap.getMap: Gets OpenLayers map or a promise for the OpenLayers map
                 */
                self.getMap = function () {
                    return self._promise;
                };
            },
            Layer: function (layer) {
                var self = this;
                self.parent = layer;
                self.layer = null;
                TC.EventTarget.call(self);
                /*
                 *  getLayer: Gets OpenLayers layer or a promise for the OpenLayers layer
                 */
                self.getLayer = function () {
                    if (self.layer) {
                        return Promise.resolve(self.layer);
                    }
                    return self._promise;
                };
                /*
                 *  setLayer: Resolves the deferred layer object
                 * Parameter: the OpenLayers layer
                 */
                self.setLayer = function (olLayer) {
                    self.layer = olLayer;
                };
            },
            layer: {
                Raster: function () { TC.wrap.Layer.apply(this, arguments); },
                Vector: function () { TC.wrap.Layer.apply(this, arguments); }
            },
            Control: function (ctl) {
                var self = this;
                self.parent = ctl;
            },
            control: {
                Click: function () { TC.wrap.Control.apply(this, arguments); },
                ScaleBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBar: function () { TC.wrap.Control.apply(this, arguments); },
                NavBarHome: function () { TC.wrap.Control.apply(this, arguments); },
                Coordinates: function () { TC.wrap.Control.apply(this, arguments); },
                Search: function () { TC.wrap.Control.apply(this, arguments); },
                Measure: function () { TC.wrap.Control.apply(this, arguments); },
                OverviewMap: function () { TC.wrap.Control.apply(this, arguments); },
                FeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Popup: function () { TC.wrap.Control.apply(this, arguments); },
                GeometryFeatureInfo: function () { TC.wrap.Control.apply(this, arguments); },
                Geolocation: function () { TC.wrap.Control.apply(this, arguments); },
                Draw: function () { TC.wrap.Control.apply(this, arguments); },
                Modify: function () { TC.wrap.Control.apply(this, arguments); },
                CacheBuilder: function () { TC.wrap.Control.apply(this, arguments); },
                Edit: function () { TC.wrap.Control.apply(this, arguments); },
                ResultsPanel: function () { TC.wrap.Control.apply(this, arguments); }
            },
            Feature: function () { },
            Geometry: function () { }
        };
        TC.inherit(TC.wrap.Layer, TC.EventTarget);
        TC.inherit(TC.wrap.layer.Raster, TC.wrap.Layer);
        TC.inherit(TC.wrap.layer.Vector, TC.wrap.Layer);
        TC.inherit(TC.wrap.control.Click, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ScaleBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBar, TC.wrap.Control);
        TC.inherit(TC.wrap.control.NavBarHome, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Coordinates, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Measure, TC.wrap.Control);
        TC.inherit(TC.wrap.control.OverviewMap, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Popup, TC.wrap.Control);
        TC.inherit(TC.wrap.control.FeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.GeometryFeatureInfo, TC.wrap.control.Click);
        TC.inherit(TC.wrap.control.Geolocation, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Draw, TC.wrap.Control);
        TC.inherit(TC.wrap.control.CacheBuilder, TC.wrap.Control);
        TC.inherit(TC.wrap.control.Edit, TC.wrap.Control);
        TC.inherit(TC.wrap.control.ResultsPanel, TC.wrap.Control);

        TC.loadCSS(TC.apiLocation + 'TC/css/tcmap.css');


        TC.loadJS(!Modernizr.urlparser, TC.apiLocation + TC.Consts.url.URL_POLYFILL, function () { });

        var uids = {};
        TC.getUID = function (prefix) {
            prefix = prefix || '';
            var value = uids[prefix];
            if (!value) {
                value = uids[prefix] = 1;
            }
            var result = prefix + value;
            uids[prefix] = value + 1;
            return result;
        };

        const pluses = /\+/g;
        function raw(s) {
            return s;
        }
        function decoded(s) {
            return decodeURIComponent(s.replace(pluses, ' '));
        }

        TC.cookie = function (key, value, options) {

            // key and at least value given, set cookie...
            if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value === null)) {
                options = $.extend({}, options);

                if (value === null) {
                    options.expires = -1;
                }

                if (typeof options.expires === 'number') {
                    var days = options.expires, t = options.expires = new Date();
                    t.setDate(t.getDate() + days);
                }

                value = String(value);

                return (document.cookie = [
                    encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
                    options.expires ? ';expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    options.path ? ';path=' + options.path : '',
                    options.domain ? ';domain=' + options.domain : '',
                    options.secure ? ';secure' : ''
                ].join(''));
            }

            // key and possibly options given, get cookie...
            options = value || {};
            var decode = options.raw ? raw : decoded;
            var cookies = document.cookie.split('; ');
            for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
                if (decode(parts.shift()) === key) {
                    return decode(parts.join('='));
                }
            }
            return null;
        };

    })();
}

document.addEventListener('DOMContentLoaded', function () {

    TC.browser = TC.Util.getBrowser();

    TC.loadJS(!TC.Cfg.acceptedBrowserVersions, TC.apiLocation + 'TC/config/browser-versions.js', function (result) {
        var isSupported = true;
        var versions = TC.Cfg.acceptedBrowserVersions;

        var match = versions.filter(function (item) {
            return item.name.toLowerCase() === TC.browser.name.toLowerCase();
        });

        // GLS: 14/02/2019 Añadimos gestión para que no muestre tostada ni envíe correos en caso de que el navegador sea uno expirado
        if (match.length > 0 && match[0].expired) {            
            TC.Cfg.loggingErrorsEnabled = false;
        } else {
            if (match.length > 0 && !isNaN(match[0].version)) {
                if (TC.browser.version < match[0].version) {
                    isSupported = false;
                }
            }

            if (TC.Cfg.oldBrowserAlert && !isSupported) {
                TC.Cfg.loggingErrorsEnabled = false;
                var mapObj = $('.' + TC.Consts.classes.MAP).data('map');

                TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale).then(function () {
                    TC.error(TC.Util.getLocaleString(mapObj.options.locale, 'outdatedBrowser'), TC.Consts.msgErrorMode.TOAST);
                });
            }
        }        
    });

    if (/ip(ad|hone|od)/i.test(navigator.userAgent)) {
        // En iOS, el primer click es un mouseover, por eso usamos touchstart como sustituto.
        TC.Consts.event.CLICK = "touchstart";
    }

    // Gestión de errores
    if (!window.JL) {
        TC.syncLoadJS(TC.apiLocation + TC.Consts.url.JSNLOG);
    }
    JL.defaultAjaxUrl = TC.Consts.url.ERROR_LOGGER;

    const onError = (function () {
        var errorCount = 0;

        var mapObj;

        return function (e) {
            mapObj = mapObj || TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));

            var errorMsg, url = "", lineNumber = -1, column = -1, errorObj, apiError;

            if (e.type === "unhandledrejection") {
                errorMsg = e.reason.message;
                if (e.reason.stack) {
                    apiError = e.reason.stack.indexOf(TC.apiLocation) > 0;
                } else {
                    apiError = true;
                }
                errorObj = e.reason;
            } else {
                errorMsg = e.message;
                url = e.filename;
                lineNumber = e.lineno;
                column = e.colno;
                errorObj = e.error;
                apiError = url.indexOf(TC.apiLocation) > 0;
            }

            // Si notifyApplicationErrors === false solo capturamos los errores de la API
            if ((TC.Cfg.notifyApplicationErrors || apiError) && errorCount < TC.Cfg.maxErrorCount && TC.Cfg.loggingErrorsEnabled) {
                // Send object with all data to server side log, using severity fatal, 
                // from logger "onerrorLogger"
                var msg = apiError ? TC.Consts.text.API_ERROR : TC.Consts.text.APP_ERROR;
                JL("onerrorLogger").fatalException({
                    "msg": msg,
                    "errorMsg": errorMsg,
                    "url": url,
                    "lineNumber": lineNumber,
                    "column": column,
                    "appUrl": location.href,
                    "prevState": mapObj.getPreviousMapState(),
                    "userAgent": navigator.userAgent
                }, errorObj);
                errorCount++;

                if (!TC.isDebug) {
                    var DEFAULT_CONTACT_EMAIL = "webmaster@itracasa.es";
                    TC.i18n.loadResources(!TC.i18n[mapObj.options.locale], TC.apiLocation + 'TC/resources/', mapObj.options.locale)
                        .then(function () {
                            TC.error(TC.Util.getLocaleString(mapObj.options.locale, "genericError") + (mapObj.options.contactEmail || DEFAULT_CONTACT_EMAIL), { type: TC.Consts.msgType.ERROR });
                        });
                }
            }
            // Tell browser to run its own error handler as well   
            return false;
        };
    })();

    window.addEventListener('error', onError, false);
    window.addEventListener('unhandledrejection', onError, false);
});
﻿/*!
    localForage -- Offline Storage, Improved
    Version 1.5.5
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&"object"==typeof a&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=c=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},c.resolve=k,c.reject=l,c.all=m,c.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!la)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function l(a){return new oa(function(b){var c=a.transaction(pa,sa),d=g([""]);c.objectStore(pa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function m(a){return"boolean"==typeof ma?oa.resolve(ma):l(a).then(function(a){return ma=a})}function n(a){var b=na[a.name],c={};c.promise=new oa(function(a){c.resolve=a}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function o(a){var b=na[a.name],c=b.deferredOperations.pop();c&&c.resolve()}function p(a,b){var c=na[a.name],d=c.deferredOperations.pop();d&&d.reject(b)}function q(a,b){return new oa(function(c,d){if(a.db){if(!b)return c(a.db);n(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=la.open.apply(la,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(pa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),o(a)}})}function r(a){return q(a,!1)}function s(a){return q(a,!0)}function t(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function u(a){return new oa(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function v(a){return g([k(atob(a.data))],{type:a.type})}function w(a){return a&&a.__local_forage_encoded_blob}function x(a){var b=this,c=b._initReady().then(function(){var a=na[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function y(a){n(a);for(var b=na[a.name],c=b.forages,d=0;d<c.length;d++)c[d]._dbInfo.db&&(c[d]._dbInfo.db.close(),c[d]._dbInfo.db=null);return q(a,!1).then(function(a){for(var b=0;b<c.length;b++)c[b]._dbInfo.db=a}).catch(function(b){throw p(a,b),b})}function z(a,b,c){try{var d=a.db.transaction(a.storeName,b);c(null,d)}catch(d){if(!a.db||"InvalidStateError"===d.name)return y(a).then(function(){var d=a.db.transaction(a.storeName,b);c(null,d)});c(d)}}function A(a){function b(){return oa.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];na||(na={});var f=na[d.name];f||(f={forages:[],db:null,dbReady:null,deferredOperations:[]},na[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=x);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return oa.all(g).then(function(){return d.db=f.db,r(d)}).then(function(a){return d.db=a,t(d,c._defaultConfig.version)?s(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function B(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),w(a)&&(a=v(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function C(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;w(d)&&(d=v(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function D(a,b,c){var d=this;a=j(a);var e=new oa(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===qa.call(b)?m(f.db).then(function(a){return a?b:u(b)}):b}).then(function(b){z(d._dbInfo,sa,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function E(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){z(c._dbInfo,sa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,sa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function G(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,ra,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function H(a,b){var c=this,d=new oa(function(b,d){if(a<0)return void b(null);c.ready().then(function(){z(c._dbInfo,ra,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function I(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){z(b._dbInfo,ra,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(){return"function"==typeof openDatabase}function K(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=ua.indexOf(a[b]),d=ua.indexOf(a[b+1]),e=ua.indexOf(a[b+2]),f=ua.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function L(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=ua[c[b]>>2],d+=ua[(3&c[b])<<4|c[b+1]>>4],d+=ua[(15&c[b+1])<<2|c[b+2]>>6],d+=ua[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function M(a,b){var c="";if(a&&(c=La.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===La.call(a.buffer))){var d,e=xa;a instanceof ArrayBuffer?(d=a,e+=za):(d=a.buffer,"[object Int8Array]"===c?e+=Ba:"[object Uint8Array]"===c?e+=Ca:"[object Uint8ClampedArray]"===c?e+=Da:"[object Int16Array]"===c?e+=Ea:"[object Uint16Array]"===c?e+=Ga:"[object Int32Array]"===c?e+=Fa:"[object Uint32Array]"===c?e+=Ha:"[object Float32Array]"===c?e+=Ia:"[object Float64Array]"===c?e+=Ja:b(new Error("Failed to get type for BinaryArray"))),b(e+L(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=va+a.type+"~"+L(this.result);b(xa+Aa+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function N(a){if(a.substring(0,ya)!==xa)return JSON.parse(a);var b,c=a.substring(Ka),d=a.substring(ya,Ka);if(d===Aa&&wa.test(c)){var e=c.match(wa);b=e[1],c=c.substring(e[0].length)}var f=K(c);switch(d){case za:return f;case Aa:return g([f],{type:b});case Ba:return new Int8Array(f);case Ca:return new Uint8Array(f);case Da:return new Uint8ClampedArray(f);case Ea:return new Int16Array(f);case Ga:return new Uint16Array(f);case Fa:return new Int32Array(f);case Ha:return new Uint32Array(f);case Ia:return new Float32Array(f);case Ja:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function O(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new oa(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){e.executeSql("CREATE TABLE IF NOT EXISTS "+c.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],function(){b._dbInfo=c,a()},function(a,b){d(b)})})});return c.serializer=Ma,e}function P(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Q(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function R(a,b,c,d){var e=this;a=j(a);var f=new oa(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){c.executeSql("INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(R.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function S(a,b,c){return R.apply(this,[a,b,c,1])}function T(a,b){var c=this;a=j(a);var d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function U(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function V(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function W(a,b){var c=this,d=new oa(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function X(a){var b=this,c=new oa(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function Y(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&"function"==typeof localStorage.setItem}catch(a){return!1}}function Z(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function $(){return!Z()||localStorage.length>0}function _(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=c.name+"/",c.storeName!==b._defaultConfig.storeName&&(c.keyPrefix+=c.storeName+"/"),$()?(b._dbInfo=c,c.serializer=Ma,oa.resolve()):oa.reject()}function aa(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ba(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ca(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function da(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ea(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function fa(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function ga(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function ha(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new oa(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function ia(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function ja(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&(Pa(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ka="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},la=e();"undefined"==typeof Promise&&a(3);var ma,na,oa=Promise,pa="local-forage-detect-blob-support",qa=Object.prototype.toString,ra="readonly",sa="readwrite",ta={_driver:"asyncStorage",_initStorage:A,_support:f(),iterate:C,getItem:B,setItem:D,removeItem:E,clear:F,length:G,key:H,keys:I},ua="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",va="~~local_forage_type~",wa=/^~~local_forage_type~([^~]+)~/,xa="__lfsc__:",ya=xa.length,za="arbf",Aa="blob",Ba="si08",Ca="ui08",Da="uic8",Ea="si16",Fa="si32",Ga="ur16",Ha="ui32",Ia="fl32",Ja="fl64",Ka=ya+za.length,La=Object.prototype.toString,Ma={serialize:M,deserialize:N,stringToBuffer:K,bufferToString:L},Na={_driver:"webSQLStorage",_initStorage:O,_support:J(),iterate:Q,getItem:P,setItem:S,removeItem:T,clear:U,length:V,key:W,keys:X},Oa={_driver:"localStorageWrapper",_initStorage:_,_support:Y(),iterate:ca,getItem:ba,setItem:ha,removeItem:ga,clear:aa,length:fa,key:da,keys:ea},Pa=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},Qa={},Ra={},Sa={INDEXEDDB:ta,WEBSQL:Na,LOCALSTORAGE:Oa},Ta=[Sa.INDEXEDDB._driver,Sa.WEBSQL._driver,Sa.LOCALSTORAGE._driver],Ua=["clear","getItem","iterate","key","keys","length","removeItem","setItem"],Va={description:"",driver:Ta.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},Wa=function(){function a(b){d(this,a);for(var c in Sa)if(Sa.hasOwnProperty(c)){var e=Sa[c],f=e._driver;this[c]=f,Qa[f]||this.defineDriver(e)}this._defaultConfig=ja({},Va),this._config=ja({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ka(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new oa(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=Ua.concat("_initStorage"),g=0,h=f.length;g<h;g++){var i=f[g];if(!i||!a[i]||"function"!=typeof a[i])return void c(e)}var j=function(c){Qa[d]&&console.info("Redefining LocalForage driver: "+d),Qa[d]=a,Ra[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(j,c):j(!!a._support):j(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=Qa[a]?oa.resolve(Qa[a]):oa.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=oa.resolve(Ma);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=oa.reject(h),g._driverSet}var c=0;return b()}}var g=this;Pa(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return oa.resolve()}):oa.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=oa.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!Ra[a]},a.prototype._extend=function(a){ja(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=Ua.length;a<b;a++)ia(this,Ua[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),Xa=new Wa;b.exports=Xa},{3:3}]},{},[4])(4)});
﻿/**
 * Opciones de capa.
 * Esta clase no tiene constructor.
 * @class TC.cfg.LayerOptions
 * @static
 */
/**
 * Identificador único de capa.
 * @property id
 * @type string|undefined
 */
/**
 * Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
 * @property title
 * @type string|undefined
 */
/**
 * Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {{#crossLink "TC.consts.LayerType"}}{{/crossLink}}.
 * @property type
 * @type string|undefined
 */
/**
 * Tipo MIME del formato de archivo de imagen a obtener del servicio. Si esta propiedad no está definida, se comprobará si la capa es un mapa de fondo 
 * (consultar propiedad {{#crossLink "TC.cfg.LayerOptions/isBase:property"}}{{/crossLink}}). En caso afirmativo, el formato elegido será <code>"image/jpeg"</code>, 
 * de lo contrario el formato será <code>"image/png"</code>.
 * @property format
 * @type string|undefined
 */
/**
 * La capa se muestra por defecto si forma parte de los mapas de fondo.
 * @property isDefault
 * @type boolean|undefined
 */
/**
 * La capa es un mapa de fondo.
 * @property isBase
 * @type boolean|undefined
 */
/**
 * Aplicable a capas de tipo WMS y KML. La capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
 * @property hideTree
 * @type boolean|undefined
 */
/**
 * La capa no muestra su título cuando es añadida al control de capas de trabajo.
 * @property hideTitle
 * @type boolean|undefined
 * @default false
 */
/**
 * La capa no aparece en la tabla de contenidos ni en la leyenda. De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
 * @property stealth
 * @type boolean|undefined
 */
/**
 * URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
 * @property thumbnail
 * @type string|undefined
 */
/**
 * Opciones de clustering de puntos.
 * @property cluster
 * @type TC.cfg.ClusterOptions|undefined
 */

/**
 * Árbol de elementos de capa.
 * Esta clase no tiene constructor.
 * @class TC.layer.LayerTree
 * @static
 */
/**
 * Nombre de capa en servicios WMS o WMTS.
 * @property name
 * @type string|undefined
 */
/**
 * Título de capa. Es un texto descriptivo para el usuario.
 * @property title
 * @type string|undefined
 */
/**
 * Identificador único de la capa.
 * @property uid
 * @type string|undefined
 */
/**
 * URL de la imagen con la leyenda de la capa.
 * @property legend
 * @type string|undefined
 */
/**
 * Lista de nodos hijos del nodo actual.
 * @property children
 * @type array|undefined
 */

/**
 * Capa de mapa. Esta clase no debería instanciarse directamente, sino mediante alguna de las clases que heredan de ella.
 * @class TC.Layer
 * @constructor
 * @async
 * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
 */
TC.Layer = function (options) {
    ///<summary>
    ///Constructor
    ///</summary>
    ///<param name="options" type="object">Objeto de opciones de capa.</param>
    ///<returns type="TC.Layer"></returns>
    var _layer = this;

    /**
     * Objeto de opciones de capa.
     * @property options
     * @type TC.cfg.LayerOptions
     * @default {}
     */
    _layer.options = options || {};
    $.extend(_layer, _layer.options);

    /**
     * Identificador de capa, debe ser único en el mapa. Si no se asigna en las opciones del constructor, se genera uno automáticamente.
     * @property id
     * @type string
     */
    _layer.id = _layer.options.id || TC.getUID();

    /**
     * Objeto del mapa al que pertenece la capa.
     * @property map
     * @type TC.Map|undefined
     */
    _layer.map = _layer.options.map;
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     */
    _layer.type = _layer.options.type || TC.Consts.layerType.WMS;

    /**
     * Fragmento HTML para utilizar como leyenda.
     * @property customLegend
     * @type string
     */
    _layer.customLegend = _layer.options.customLegend; 
    var defaultFormat = _layer.options.isBase ? TC.Consts.mimeType.JPEG : TC.Consts.mimeType.PNG;
    _layer.options.format = _layer.options.format || defaultFormat;

    if (_layer.options.hideTree === undefined) {
        _layer.options.hideTree = true;
    }

    if (_layer.options.hideTitle === undefined) {
        _layer.options.hideTitle = false;
    }

    _layer._cache = {
        visibilityStates: {}
    };

    /**
     * Árbol de los componentes de la capa. Estos componentes son distintos según el tipo de capa: así, en una capa WMS son las distintas capas del servicio, 
     * en una capa KML son carpetas.
     * @property tree
     * @type TC.layer.LayerTree|null
     */
    _layer.tree = null;

    /**
     * Objeto envoltorio de la capa nativa de OpenLayers.
     * @property wrap
     * @type TC.wrap.Layer|null
     */
    _layer.wrap = null;
};

TC.Layer.state = {
    IDLE: 'idle',
    LOADING: 'loading'
};

/**
 * Establece la visibilidad de la capa en el mapa.
 * @method setVisibility
 * @param {boolean} visible <code>true</code> si se quiere mostrar la capa, <code>false</code> si se quiere ocultarla.
 */
TC.Layer.prototype.setVisibility = function (visible) {
    this.wrap.setVisibility(visible);
};

/**
 * Obtiene la visibilidad actual de la capa en el mapa.
 * @method getVisibility
 * @return {boolean} <code>true</code> si la capa está visible, <code>false</code> si está oculta.
 */
TC.Layer.prototype.getVisibility = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.getVisibility();
        }
    }
    return result;
};


/**
 * Obtiene la opacidad actual de la capa en el mapa.
 * @method getOpacity
 * @return {number}.
 */
TC.Layer.prototype.getOpacity = function () {
    var layer = this;
    var result = false;
    if (layer.map) {
        if (!layer.isBase || layer.map.getBaseLayer() === layer) {
            result = layer.wrap.layer.getOpacity();
        }
    }
    return result;
};

/**
 * Establece la opacidad de la capa en el mapa. Hay que tener en cuenta que establecer opacidad 0 a una capa no es 
 * equivalente que llamar a TC.Layer.{{#crossLink "TC.Layer/setVisibility:method"}}{{/crossLink}} con el valor del parámetro <code>false</code>.
 * @method setOpacity
 * @param {number} opacity Valor entre <code>0</code> (capa transparente) y <code>1</code> (capa opaca).
 * @param {boolean} mute Indica si al establecer opacidad no se lanza evento LAYEROPACITY.
 */
TC.Layer.prototype.setOpacity = function (opacity, mute) {
    var layer = this;
    this.wrap.getLayer().then(function (olLayer) {
        olLayer.setOpacity(opacity);
        layer.opacity = opacity;
        if (layer.map && !mute) {
            layer.map.trigger(TC.Consts.event.LAYEROPACITY, { layer: layer, opacity: opacity });
        }
    });
};

/**
 * Determina si la capa se puede mostrar en el CRS especificado.
 * @method isCompatible
 * @param {string} crs Cadena con el well-known ID (WKID) del CRS.
 * @return {boolean}
 */
TC.Layer.prototype.isCompatible = function (crs) {
    return true;
};

/**
 * Determina si la capa tiene nombres válidos.
 * @method isValidFromNames
 * @return {boolean}
 */
TC.Layer.prototype.isValidFromNames = function () {
    return true;
};

/**
 * Determina si la capa es de tipo raster.
 * @method isRaster
 * @return {boolean}
 */
TC.Layer.prototype.isRaster = function () {
    var result = true;
    var _layer = this;
    switch (_layer.type) {
        case TC.Consts.layerType.VECTOR:
        case TC.Consts.layerType.KML:
        case TC.Consts.layerType.WFS:
        case TC.Consts.layerType.GROUP:
            result = false;
            break;
        default:
            break;
    }
    return result;
};

/**
 * Determina si la capa es visible a la resolución actual. Para ello consulta el documento de capabilities en los casos en que exista.
 * @method isVisibleByScale
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByScale = function (name) {
    return true;
};


/**
 * Determina si una capa del servicio está establecida en el mapa como visible.
 * @method isVisibleByName
 * @return {boolean}
 */
TC.Layer.prototype.isVisibleByName = function (name) {
    return true;
};

/**
 * <p>Devuelve un árbol de información de la capa. Como mínimo devuelve un nodo raíz con el título de la capa.</p>
 * <p>En capas de servicios WMS es la jerarquía de capas obtenida del documento capabilities. Dependiendo del valor de la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/hideTree:property"}}{{/crossLink}}, 
 * puede mostrar un árbol de todas las capas del servicio o solo un árbol de las capas visibles inicialmente.</p>
 * <p>En capas de documentos KML cada nodo es una carpeta del documento.</p>
 * <p>Si la propiedad TC.cfg.LayerOptions.{{#crossLink "TC.cfg.LayerOptions/stealth:property"}}{{/crossLink}} está establecida a <code>true</code>, este método devuelve <code>null</code>.</p>
 * @method getTree
 * @return {TC.layer.LayerTree}
 */
TC.Layer.prototype.getTree = function () {
    var _layer = this;
    var result = { name: _layer.name, title: _layer.title };
    return result;
};

/**
 * Devuelve un nodo del árbol de información de la capa.
 * @method findNode
 * @param {string} id Identificador del nodo.
 * @param {TC.layer.LayerTree} parent Nodo desde el que se comienza la búsqueda.
 * @return {TC.layer.LayerTree} Si no se encuentra el nodo el método devuelve <code>null</code>.
 */
TC.Layer.prototype.findNode = function findNode(id, parent) {
    var result = null;
    if (parent.uid == id) {
        result = parent;
    }
    else {
        for (var i = 0; i < parent.children.length; i++) {
            var r = findNode(id, parent.children[i]);
            if (r) {
                result = r;
                break;
            }
        }
    }
    return result;
};


/**
 * Establece la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method setNodeVisibility
 * @param {string} id Identificador del nodo.
 * @param {boolean} visible <code>true</code> si se quiere mostrar el elemento, <code>false</code> si se quiere ocultar.
 */
TC.Layer.prototype.setNodeVisibility = function (id, visible) {
    this.setVisibility(visible);
};

/**
 * Obtiene la visibilidad en el mapa de un elemento asociado a un nodo de árbol de la capa. Dependiendo del tipo de capa este elemento 
 * es una entidad u otra, así, en capas de tipo WMS son capas de servicio, en KML son carpetas y en capas vectoriales genéricas son grupos de marcadores.
 * @method getNodeVisibility
 * @param {string} id Identificador del nodo.
 * @return {TC.consts.Visibility}
 */
TC.Layer.prototype.getNodeVisibility = function (id) {
    return TC.Consts.visibility.VISIBLE;
};


TC.Layer.prototype.getResolutions = function () {
    if (this.wrap.getResolutions) {
        return this.wrap.getResolutions();
    }
    else {
        return [];
    }
};

TC.Layer.prototype.setProjection = function () {
};

﻿TC.control = TC.control || {};
TC.Control = function () {
    const self = this;
    TC.EventTarget.call(self);

    self.map = null;
    self.isActive = false;
    self.isDisabled = false;

    var len = arguments.length;

    self.options = $.extend({}, len > 1 ? arguments[1] : arguments[0]);
    self.id = self.options.id || TC.getUID(self.CLASS.substr(TC.Control.prototype.CLASS.length + 1) + '-');
    self.div = TC.Util.getDiv(self.options.div ? self.options.div : arguments[0]);
    self._$div = $(self.div);

    // 12/03/2019 GLS https://developer.mozilla.org/es/docs/Web/API/Element/classList
    // Múltiples argumentos para add() y remove() IE	Sin soporte
    self.div.classList.add(TC.Control.prototype.CLASS);
    self.div.classList.add(self.CLASS);    
    
    self.template = self.options.template || self.template;
    self.exportsState = false;
};

TC.inherit(TC.Control, TC.EventTarget);

(function () {
    const ctlProto = TC.Control.prototype;

    ctlProto.CLASS = 'tc-ctl';

    ctlProto.template = '';

    ctlProto.show = function () {
        this.div.style.display = '';
    };

    ctlProto.hide = function () {
        this.div.style.display = 'none';
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(null, function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto._set1stRenderPromise = function (promise) {
        const self = this;
        if (!self._firstRender) {
            self._firstRender = promise;
        }
        return promise;
    };

    const processTemplates = function (ctl, data, templates) {
        return new Promise(function (resolve, reject) {
            const htmlPromises = [];
            const templateKeys = [];
            for (var key in templates) {
                var template = templates[key];
                if (typeof template === 'string') {
                    if (dust.cache[ctl.CLASS]) {
                        dust.render(ctl.CLASS, data, function (err, out) {
                            ctl.div.innerHTML = out;
                            if (err) {
                                TC.error(err);
                            }
                        });
                    } else {
                        var prom = TC.ajax({
                            url: template,
                            method: "GET",
                            responseType: 'text'
                        });
                        htmlPromises.push(prom);
                        templateKeys.push(key);
                    }
                }
                else if ($.isFunction(template)) {
                    template();
                }
            }

            if (htmlPromises.length === 0) {
                resolve();
            }
            else {
                Promise.all(htmlPromises)
                    .then(function (templateArray) {
                        templateArray.forEach(function (template, idx) {
                            const tpl = dust.compile(template, templateKeys[idx]);
                            dust.loadSource(tpl);
                        });
                        resolve();
                    })
                    .catch(function (err) {
                        console.error("Error fetching templates: " + err);
                        reject(err instanceof Error ? err : Error(err));
                    });
            }

        });
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.map) {
                self.trigger(TC.Consts.event.BEFORECONTROLRENDER, { dataObject: data });
            }
            if (self.isDisabled) {
                self.div.classList.add(TC.Consts.classes.DISABLED);
            }
            else {
                self.div.classList.remove(TC.Consts.classes.DISABLED);
            }

            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    var tplProm;

                    if (typeof self.template === 'object') {
                        tplProm = processTemplates(self, data, self.template);
                    }
                    else {
                        var templates = {};

                        if (self.template) templates[self.CLASS] = self.template;


                        tplProm = processTemplates(self, data, templates);
                    }

                    tplProm
                        .then(function () {
                            if (dust.cache[self.CLASS]) {
                                dust.render(self.CLASS, data, function (err, out) {
                                    self.div.innerHTML = out;
                                    if (err) {
                                        reject(Error(err));
                                        TC.error(err);
                                    }
                                });
                            }

                            self.trigger(TC.Consts.event.CONTROLRENDER);
                            if ($.isFunction(callback)) {
                                callback();
                            }
                            resolve();
                        })
                        .catch(function (err) {
                            reject(Error(err));
                        });
                }
            );
        });
    };

    ctlProto.getRenderedHtml = function (templateId, data, callback) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var render = function () {
                if (dust.cache[templateId]) {
                    dust.render(templateId, data, function (err, out) {
                        if (err) {
                            TC.error(err);
                            reject(Error(err));
                        }
                        else {
                            if ($.isFunction(callback)) {
                                callback(out);
                            }
                            resolve(out);
                        }
                    });
                }
            };
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    if (!dust.cache[templateId]) {
                        var template = self.template[templateId];
                        if (typeof template === 'string') {
                            TC.ajax({
                                url: template,
                                method: "GET",
                                responseType: 'text'
                            })
                                .then(function (html) {
                                    var tpl = dust.compile(html, templateId);
                                    dust.loadSource(tpl);
                                    render();
                                })
                                .catch(function (err) {
                                    console.log("Error fetching template: " + err)
                                });
                        }
                        else if ($.isFunction(template)) {
                            template();
                            render();
                        }
                    }
                    else {
                        render();
                    }
                }
            );
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.map = map;
            Promise.resolve(self.render()).then(function () {
                if (self.options.active) {
                    self.activate();
                }
                resolve(self);
            });
        });
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.map && self.map.activeControl && self.map.activeControl != self) {
            self.map.previousActiveControl = self.map.activeControl;
            self.map.activeControl.deactivate();
        }
        self.isActive = true;
        if (self.map) {
            self.map.activeControl = self;
            self.map.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLACTIVATE, { control: self });
        }
    };

    ctlProto.deactivate = function (stopChain) {
        if (arguments.length == 0) stopChain = false;

        var self = this;
        self.isActive = false;
        if (self.map) {
            self.map.activeControl = null;

            if (!stopChain) {
                //determinar cuál es el control predeterminado para reactivarlo
                //salvo que sea yo mismo, claro
                var nextControl = self.map.getDefaultControl();
                if (nextControl == self) nextControl = null;
                else if (self.map.previousActiveControl == self) // GLS: Validamos antes de activar que el control activo anterior sea distinto al control actual
                    nextControl = null;
                else if (!nextControl) {
                    nextControl = self.map.previousActiveControl;
                }

                if (nextControl)
                    nextControl.activate();
            }
            self.map.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
            self.trigger(TC.Consts.event.CONTROLDEACTIVATE, { control: self });
        }
    };

    ctlProto.enable = function () {
        var self = this;
        self.isDisabled = false;
        if (self.div) {
            self.div.classList.remove(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.disable = function () {
        var self = this;
        self.isDisabled = true;
        if (self.div) {
            self.div.classList.add(TC.Consts.classes.DISABLED);
        }
    };

    ctlProto.renderPromise = function () {
        const self = this;
        return self._firstRender || new Promise(function (resolve, reject) {
            self.one(TC.Consts.event.CONTROLRENDER, function () {
                resolve(self);
            });
        });
    };

    ctlProto.addUIEventListener = function (selector, event, listener) {
        const self = this;
        const elements = selector ? self.div.querySelectorAll(selector) : [self.div];
        elements.forEach(function (elm) {
            elm.addEventListener(event, listener);
        });
    };

    ctlProto.addUIEventListeners = function () {
    };

    ctlProto.isExclusive = function () {
        return false;
    };

    ctlProto.getLocaleString = function (key, texts) {
        var self = this;
        var locale = self.map ? self.map.options.locale : TC.Cfg.locale;
        return TC.Util.getLocaleString(locale, key, texts);
    };

    ctlProto.getUID = function () {
        const self = this;
        return TC.getUID(self.id + '-');
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {};
        }
        return null;
    };

    ctlProto.importState = function (state) {
    };
})();
﻿TC.feature = TC.feature || {};
TC.Feature = function (coords, options) {
    var self = this;

    self.wrap = new TC.wrap.Feature();
    self.wrap.parent = self;

    if ($.isArray(coords)) {
        self.geometry = coords;
    }
    else if (self.wrap.isNative(coords)) {
        self.wrap.feature = coords;
        self.id = self.wrap.getId();
        self.geometry = self.wrap.getGeometry();
        self.folders = coords._folders;
        self.data = self.wrap.getData();
    }

    var opts = self.options = $.extend(true, {}, options);

    self.id = self.id || opts.id || TC.getUID();
    self.data = opts.data || self.data || null;
    self._visibilityState = TC.Consts.visibility.VISIBLE;
    if (opts.showsPopup === undefined) {
        self.showsPopup = true;
    }
    else {
        self.showsPopup = opts.showsPopup;
    }
    self.layer = opts.layer || null;
    self._selected = false;

    if (opts.selected) {
        self.select();
    }
};

TC.Feature.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.Feature.prototype.CLASSNAME = 'TC.Feature';

TC.Feature.prototype.getPath = function () {
    var result = [];
    var self = this;
    if (self.folders) {
        result = self.folders;
    }
    else if (self.options.group) {
        result = [self.options.group];
    }
    return result;
};

TC.Feature.prototype.setVisibility = function (visible) {
    var self = this;

    // Ocultamos el posible popup
    if (!visible && self.showsPopup && self.layer) {
        var popup = self.layer.map.getControlsByClass(TC.control.Popup).filter(function (popup) {
            return popup.currentFeature === self
        });

        if (popup.length > 0) {
            popup[0].hide();
        }
    }

    if ((visible && self._visibilityState === TC.Consts.visibility.NOT_VISIBLE) || (!visible && self._visibilityState === TC.Consts.visibility.VISIBLE)) {
        self._visibilityState = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
        self.layer.wrap.setFeatureVisibility(self, visible);
    }
};

TC.Feature.prototype.setId = function (id) {
    var self = this;
    self.id = id;
    self.wrap.setId(id);
};

TC.Feature.prototype.getBounds = function () {
    return this.wrap.getBounds();
};

TC.Feature.prototype.setStyle = function (style) {
    this.wrap.setStyle(style);
};

TC.Feature.prototype.toggleSelectedStyle = function (condition) {
    this.wrap.toggleSelectedStyle(condition);
};

TC.Feature.prototype.getLegend = function () {
    var self = this;
    if (!self._legend) {
        self._legend = self.wrap.getLegend();
    }
    return self._legend;
};

TC.Feature.prototype.getCoords = function () {
    const self = this;
    self.geometry = self.wrap.getGeometry();
    return self.geometry;
};

TC.Feature.prototype.getCoordsArray = function () {
    const self = this;
    const isPoint = function (elm) {
        return $.isArray(elm) && elm.length >= 2 && typeof elm[0] === 'number' && typeof elm[1] === 'number';
    };
    const flattenFn = function (val) {
        return isPoint(val) ? [val] : val.reduce(reduceFn, []);
    }
    const reduceFn = function (acc, elm) {
        if (isPoint(elm)) {
            acc[acc.length] = elm;
        }
        else {
            acc = acc.concat(flattenFn(elm));
        }
        return acc;
    };
    return flattenFn(this.getCoords());
};

TC.Feature.prototype.getGeometryStride = function () {
    const self = this;
    const coordsArray = self.getCoordsArray();
    const firstCoord = coordsArray[0];
    if (firstCoord) {
        return firstCoord.length;
    }
    return 0;
}


TC.Feature.prototype.setCoords = function (coords) {
    const self = this;
    self.geometry = coords;
    return self.wrap.setGeometry(coords);
};

TC.Feature.prototype.getData = function () {
    var result = null;
    var self = this;
    if (self.data) {
        result = self.data;
    }
    else {
        result = self.wrap.getData();
    }
    return result;
};

TC.Feature.prototype.setData = function (data) {
    var self = this;
    self.data = $.extend(self.data, data);
    self.wrap.setData(data);
};

TC.Feature.prototype.clearData = function () {
    var self = this;
    self.data = {};
    self.wrap.clearData();
};

TC.Feature.prototype.getInfo = function (options) {
    var result = null;
    var self = this;
    options = options || {};
    var locale = options.locale || (self.layer && self.layer.map && TC.Util.getMapLocale(self.layer.map));
    var data = self.getData();
    if (typeof data === 'object') {
        var template = self.wrap.getTemplate();
        if (template) {
            // GLS: Contemplo en la expresión regular la opción de que el nombre del campo se componga de $[aaa/abc/loQueMeInteresa] 
            // (la expresión no está limitada a 2 niveles), hasta ahora se manejaba $[loQueMeInteresa]
            result = template.replace(/\$\[?(?:\w+\/)*(\w+)\]/g, function (match, p1) {
                return data[p1];
            });
        }
        else {
            var html = [];
            const hSlots = [];
            var openText = TC.Util.getLocaleString(locale, 'open');
            for (var key in data) {
                const value = data[key];
                const match = key.match(/^h(\d)_/i);
                if (match) {
                    hSlots[match[1]] = value;
                }
                else {
                    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined') {
                        html[html.length] = '<tr><th>';
                        html[html.length] = key;
                        html[html.length] = '</th><td>';
                        var isUrl = TC.Util.isURL(value);
                        if (isUrl) {
                            html[html.length] = '<a href="';
                            html[html.length] = value;
                            html[html.length] = '" target="_blank">';
                            html[html.length] = openText;
                            html[html.length] = '</a>';
                        }
                        else {
                            html[html.length] = value !== undefined ? TC.Util.formatNumber(value, locale) : '&mdash;';
                        }
                        html[html.length] = '</td></tr>';
                    }
                }
            }
            const headers = hSlots
                .map(function (val, idx) {
                    if (val) {
                        return '<h' + idx + '>' + val + '</h' + idx + '>';
                    }
                })
                .filter(function (val) {
                    return val;
                });
            if (headers.length) {
                html = headers.concat(html);
            }
            if (html.length > 0) {
                html.unshift('<table class="tc-attr">');
                html[html.length] = '</table>';
                result = html.join('');
            }
        }
    }
    else if (typeof data === 'string') {
        result = data;
    }
    if (!result) {
        result = self.title;
        if (self.group) {
            result += ' ' + self.group;
        }
    }
    if (!result) {
        result = TC.Util.getLocaleString(locale, 'noData');
    }
    return result;
};

TC.Feature.prototype.clone = function () {
    var self = this;
    var nativeClone = self.wrap.cloneFeature();
    nativeClone._wrap = self.wrap;
    return new self.constructor(nativeClone, self.options);
};

TC.Feature.prototype.getStyle = function () {
    return this.wrap.getStyle();
};

TC.Feature.prototype.showPopup = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;
        var popup = control || self.popup;
        if (!popup) {
            // Buscamos un popup existente que no esté asociado a un control.
            var popups = map.getControlsByClass('TC.control.Popup');
            for (var i = 0, len = popups.length; i < len; i++) {
                var p = popups[i];
                if (!p.caller) {
                    popup = p;
                    break;
                }
            }
        }
        if (popup) {
            popup.currentFeature = self;
            ctlPromise = Promise.resolve(popup);
        }
        else {
            ctlPromise = map.addControl('popup');
        }
        ctlPromise.then(function (ctl) {            
            ctl.currentFeature = self;
            map.getControlsByClass(TC.control.Popup).forEach(function (p) {
                if (p.isVisible()) {
                    p.hide();
                }
            });
            self.wrap.showPopup(ctl);
            // Ajustamos el ancho del título al de la tabla de atributos
            const attrTable = ctl.contentDiv.querySelector("table.tc-attr");
            const headers = ctl.contentDiv.querySelectorAll("h1,h2,h3,h4,h5");
            if (attrTable && headers.length) {
                const maxWidth = attrTable.getBoundingClientRect().width + 'px';
                headers.forEach(function (h) {
                    h.style.maxWidth = maxWidth;
                });
            }
            map.trigger(TC.Consts.event.POPUP, { control: ctl });
            ctl.fitToView(true);
        });
    }
};

TC.Feature.prototype.showResultsPanel = function (control) {
    const self = this;
    const map = (self.layer && self.layer.map) || (control && control.map);
    if (map) {
        var ctlPromise;
        var panel = control;
        if (!panel) {
            // Buscamos un resultsPanel existente que no esté asociado a un control.
            var resultsPanels = map.getControlsByClass('TC.control.ResultsPanel').filter(function (ctrl) { return ctrl.options.content === "table" });
            for (var i = 0, len = resultsPanels.length; i < len; i++) {
                var p = resultsPanels[i];
                if (!p.caller) {
                    panel = p;
                    break;
                }
            }
        }
        if (panel) {
            panel.currentFeature = self;
            ctlPromise = Promise.resolve(panel);
        }
        else {
            var resultsPanelOptions = {
                content: "table"
            };            
            var controlContainer = map.getControlsByClass('TC.control.ControlContainer')[0];
            if (controlContainer) {
                resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
            } else {
                resultsPanelOptions.div = document.createElement('div');
                map.div.appendChild(resultsPanelOptions.div);
                ctlPromise = map.addControl('resultsPanel', resultsPanelOptions);
            }
        }
        ctlPromise.then(function (ctl) {            
            ctl.currentFeature = self;

            // GLS: si contamos con el contenedor de controles no es necesario cerra el resto de paneles ya que no habrá solape excepto los paneles
            if (map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctrl) { return ctrl.options.content === "table" }).forEach(function (p) {
                    p.close();
                });
            }

            // cerramos los paneles con feature asociada
            const panels = map.getControlsByClass('TC.control.ResultsPanel');
            panels.forEach(function (p) {
                if (p.currentFeature) {
                    p.close();
                }
            });

            if (ctl.div.querySelector('.tc-ctl-print-btn')) {
                ctl.div.querySelector('.tc-ctl-print-btn').remove();
            }
            ctl.menuDiv.innerHTML = '';
            ctl.open(self.getInfo({ locale: map.options.locale }), ctl.getInfoContainer());            

            var onViewChange = function (e) {
                map.off(TC.Consts.event.VIEWCHANGE, onViewChange);

                ctl.close();
            };
            map.on(TC.Consts.event.VIEWCHANGE, onViewChange);
        });
    }
};


TC.Feature.prototype.select = function () {
    var self = this;
    self._selected = true;
    if (self.layer) {
        self.layer.selectedFeatures.push(self);
    }
    var selectionOptions = self.options.selection || {};
    self.setStyle($.extend({}, TC.Cfg.styles.selection[self.STYLETYPE], selectionOptions[self.STYLETYPE]));
};

TC.Feature.prototype.unselect = function () {
    var self = this;
    self._selected = false;
    // Volvemos al estilo por defecto
    self.setStyle(self.options);

    if (self.layer) {
        var idx = $.inArray(self, self.layer.selectedFeatures);
        if (idx >= 0) {
            self.layer.selectedFeatures.splice(idx, 1);
        }
    }
};

TC.Feature.prototype.isSelected = function () {
    return this._selected;
};

TC.Feature.prototype.toGML = function (version, srsName) {
    return this.wrap.toGML(version, srsName);
};



﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/**
 * <p>Opciones de estilo de punto. Esta clase no tiene constructor.</p>
 * @class TC.cfg.PointStyleOptions
 * @static
 */
/**
 * Radio en píxeles del símbolo del punto.
 * @property radius
 * @type number
 * @default 8
 */
/**
 * Color de relleno del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property fillColor
 * @type string
 */
/**
 * Opacidad de relleno del símbolo del punto. Número entre 0 (transparente) y 1 (opaco).
 * @property fillOpacity
 * @type number
 */
/**
 * Color de línea del símbolo del punto. Cadena en formato <code>#rgb</code>, <code>#rrggbb</code>, <code>rgb(r,g,b)</code> o <code>rgba(r,g,b,a)</code>.
 * @property strokeColor
 * @type string
 */
/**
 * Ancho de línea en píxeles del símbolo del punto.
 * @property strokeWidth
 * @type number
 * @default 2
 */
/**
 * Nombre del grupo en el que incluir el punto. Los grupos de puntos son entidades para facilitar la organización de estos, 
 * ya que un grupo se mostrará en la tabla de contenidos y en la leyenda.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Point = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.point, options);
        self.wrap.createPoint(coords, opts);
    }
};

TC.inherit(TC.feature.Point, TC.Feature);

TC.feature.Point.prototype.STYLETYPE = TC.Consts.geom.POINT;

TC.feature.Point.prototype.CLASSNAME = 'TC.feature.Point';

TC.feature.Point.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [coords];
    }
    return coords;
};
﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

TC.feature.Circle = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createCircle(coords, opts);
    }
};

TC.inherit(TC.feature.Circle, TC.Feature);

(function () {
    var featProto = TC.feature.Circle.prototype;

    featProto.STYLETYPE = TC.Consts.geom.POLYGON;

    featProto.CLASSNAME = 'TC.feature.Circle';

    featProto.getCoords = function () {
        return this.wrap.getGeometry();
    };

    featProto.setCoords = function (coords) {
        return this.wrap.setGeometry(coords);
    };

})();
﻿TC.feature = TC.feature || {};

if (!TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}

/**
 * <p>Opciones de estilo de marcador (punto de mapa con icono). Esta clase no tiene constructor.</p>
 * @class TC.cfg.MarkerStyleOptions
 * @static
 */
/**
 * URL de la imagen del icono del marcador.
 * @property url
 * @type string
 */
/**
 * Clase CSS de la que obtener el icono del marcador, extrayendo la URL de la imagen del atributo <code>background-image</code> asociado a la clase.
 * @property cssClass
 * @type string
 * @default "tc-marker1"
 */
/**
 * Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo <code>background-image</code> asociado a la clase.
 * @property classes
 * @type array
 * @default ["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]
 */
/**
 * Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono.
 * @property anchor
 * @type array
 * @default [.5, 1]
 */
/**
 * Anchura en píxeles del icono.
 * @property width
 * @type number
 * @default 32
 */
/**
 * Altura en píxeles del icono.
 * @property height
 * @type number
 * @default 32
 */
/**
 * Nombre del grupo en el que incluir el marcador. Los grupos de marcadores son entidades para facilitar la organización de estos: 
 * por un lado, un grupo se mostrará en la tabla de contenidos y en la leyenda, por otro, si no se especifica explícitamente un icono para el marcador, 
 * todos los marcadores del mismo grupo tendrán el mismo icono. La asignación de icono a grupo se hará rotando entre los elementos de la propiedad 
 * {{#crossLink "TC.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
 * @property group
 * @type string
 * @default 32
 */

/*
 * Map marker, with icon
 * Parameters: coords, 2 element array of numbers or OpenLayers vector; options, object
 * available options: url, cssClass, group, width, height, anchor
 */
TC.feature.Marker = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        var opts = self.options = $.extend(true, self.options, TC.Cfg.styles.marker, options);
        var locale = self.layer && self.layer.map ? self.layer.map.options.locale: TC.Cfg.locale;
        self.title = opts.title || TC.i18n[locale][TC.Consts.MARKER];
        self.wrap.createMarker(coords, opts);
    }
};

TC.inherit(TC.feature.Marker, TC.feature.Point);

TC.feature.Marker.prototype.STYLETYPE = 'marker';

TC.feature.Marker.prototype.CLASSNAME = 'TC.feature.Marker';
﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * MultiPolygon
 * Parameters: coords, array of array of array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolygon = function (coords, options) {
    var self = this;
    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createMultiPolygon(coords, opts);
    }
};

TC.inherit(TC.feature.MultiPolygon, TC.Feature);

TC.feature.MultiPolygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.MultiPolygon.prototype.CLASSNAME = 'TC.feature.MultiPolygon';

TC.feature.MultiPolygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], [].concat.apply([], coords));
    }
    return coords;
};

TC.feature.MultiPolygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.MultiPolyline = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.line, options);
        self.wrap.createMultiPolyline(coords, opts);
    }
};

TC.inherit(TC.feature.MultiPolyline, TC.Feature);

TC.feature.MultiPolyline.prototype.STYLETYPE = "line";

TC.feature.MultiPolyline.prototype.CLASSNAME = 'TC.feature.MultiPolyline';

TC.feature.MultiPolyline.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.MultiPolyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polygon
 * Parameters: coords, array of array of 2 element arrays of numbers; options, object
 */
TC.feature.Polygon = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.polygon, options);
        self.wrap.createPolygon(coords, opts);
    }
};

TC.inherit(TC.feature.Polygon, TC.Feature);

TC.feature.Polygon.prototype.STYLETYPE = TC.Consts.geom.POLYGON;

TC.feature.Polygon.prototype.CLASSNAME = 'TC.feature.Polygon';

TC.feature.Polygon.prototype.getCoords = function (options) {
    options = options || {};
    const coords = TC.Feature.prototype.getCoords.call(this, options);
    if (options.pointArray) {
        return [].concat.apply([], coords);
    }
    return coords;
};

TC.feature.Polygon.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};

TC.feature.Polygon.prototype.getArea = function (options) {
    return this.wrap.getArea(options);
};
﻿TC.feature = TC.feature || {};

if (!TC.Feature) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
}

/*
 * Polyline
 * Parameters: coords, array of 2 element arrays of numbers; options, object
 */
TC.feature.Polyline = function (coords, options) {
    var self = this;

    TC.Feature.apply(self, arguments);

    var opts;
    if (self.wrap.isNative(coords)) {
        coords._wrap = self.wrap;
        self.wrap.feature = coords;
    }
    else {
        opts = self.options = $.extend(true, self.options, TC.Cfg.styles.line, options);
        self.wrap.createPolyline(coords, opts);
    }
};

TC.inherit(TC.feature.Polyline, TC.Feature);

TC.feature.Polyline.prototype.STYLETYPE = "line";

TC.feature.Polyline.prototype.CLASSNAME = 'TC.feature.Polyline';

TC.feature.Polyline.prototype.getLength = function (options) {
    return this.wrap.getLength(options);
};
﻿TC.filter = {};

TC.filter.Filter = function (tagName) {
    this.tagName_ = tagName;
    
    this._defaultNSURL = "http://www.opengis.net/ogc";
    this._defaultPrefixNS = this._wfsPrefixNS = "ogc";
    this._fieldTitle = "PropertyName";

    this._defaultNSURL = this._wfsNSURL = "http://www.opengis.net/ogc";
    this._wfs2prefixNS = "fes";
    this._wfs2NSURL = "http://www.opengis.net/fes/2.0";
    this._wfs2FieldTitle = "ValueReference";
};

TC.filter.Filter.prototype.getTagName = function () {
    return this.tagName_;
};

TC.filter.Filter.prototype.writeFilterCondition_ = function () {

    //return '<{prefix}:{tag}>{childs}</{prefix}:{tag}>'.format({prefix:"ogc",tag:filter.getTagName(),childs:""});
    var filter = this;
    return '<{prefix}:Filter xmlns:{prefix}=\"{NSURL}">{inner}</{prefix}:Filter>'.format({
        prefix: this._defaultPrefixNS,
        NSURL: this._defaultNSURL,
        tag: filter.getTagName(),
        inner: this.writeInnerCondition_(filter)
    });

    /*ol.xml.pushSerializeAndPop(item,
        ol.format.WFS.GETFEATURE_SERIALIZERS_,
        ol.xml.makeSimpleNodeFactory(filter.getTagName()),
        [filter], objectStack);*/
}
TC.filter.Filter.prototype.writeInnerCondition_ = function (filter) {
    if (filter != this) {
        filter._defaultNSURL = this._defaultNSURL;
        filter._defaultPrefixNS = this._defaultPrefixNS
    }

    if (filter instanceof TC.filter.LogicalNary) {
        return filter.write()
    }
    else if (filter instanceof TC.filter.ComparisonBinary) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Comparison) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Spatial) {
        return filter.write();
    }
    else if (filter instanceof TC.filter.Function) {
        return filter.write();
    }
    else
        return filter.write();
};
TC.filter.Filter.prototype.writeInnerArrayCondition_ = function (filters) {
    return filters.reduce(function (vi, va, index) {
        return (vi instanceof TC.filter.Filter ? vi.writeInnerCondition_(vi) : vi) + va.writeInnerCondition_(va);
    });
}

TC.filter.Filter.prototype.getText = function (wfsVersion) {
    if (wfsVersion && parseFloat(wfsVersion,10) >= 2) {
        this._defaultPrefixNS = this._wfs2prefixNS;
        this._defaultNSURL = this._wfs2NSURL;
        this._fieldTitle = this._wfs2FieldTitle;
    }
    return this.writeFilterCondition_();
};

TC.filter.and = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.And, params));
};

TC.filter.or = function (conditions) {
    var params = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(TC.filter.Or, params));
};

TC.filter.not = function (condition) {
    return new TC.filter.Not(condition);
};

TC.filter.bbox = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Bbox(null, arguments[0], arguments[1]);
    else        
        return new TC.filter.Bbox(arguments[0], arguments[1], arguments[2]);
};

TC.filter.intersects = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Intersects(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Intersects(arguments[0], arguments[1], arguments[2]);
};


TC.filter.within = function () {
    if (Object.prototype.toString.call(arguments[0]) !== "[object String]")
        return new TC.filter.Within(null, arguments[0], arguments[1]);
    else
        return new TC.filter.Within(arguments[0], arguments[1], arguments[2]);
};


TC.filter.equalTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.EqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.notEqualTo = function (propertyName, expression, opt_matchCase) {
    return new TC.filter.NotEqualTo(propertyName, expression, opt_matchCase);
};

TC.filter.lessThan = function (propertyName, expression) {
    return new TC.filter.LessThan(propertyName, expression);
};

TC.filter.lessThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.LessThanOrEqualTo(propertyName, expression);
};

TC.filter.greaterThan = function (propertyName, expression) {
    return new TC.filter.GreaterThan(propertyName, expression);
};

TC.filter.greaterThanOrEqualTo = function (propertyName, expression) {
    return new TC.filter.GreaterThanOrEqualTo(propertyName, expression);
};

TC.filter.isNull = function (propertyName) {
    return new TC.filter.IsNull(propertyName);
};

TC.filter.between = function (propertyName, lowerBoundary, upperBoundary) {
    return new TC.filter.IsBetween(propertyName, lowerBoundary, upperBoundary);
};

TC.filter["function"] = function (functionName, params) {
    return new TC.filter.Function(functionName, params);
};

TC.filter.like = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    return new TC.filter.IsLike(propertyName, pattern,
        opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
};

TC.filter.LogicalNary = function (tagName, conditions) {

    TC.filter.Filter.call(this, tagName);

    this.conditions = Array.prototype.slice.call(arguments, 1);
};
TC.inherit(TC.filter.LogicalNary, TC.filter.Filter);

TC.filter.And = function (conditions) {
    var params = ['And'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.And, TC.filter.LogicalNary);

TC.filter.Or = function (conditions) {
    var params = ['Or'].concat(Array.prototype.slice.call(arguments));
    TC.filter.LogicalNary.apply(this, params);
};
TC.inherit(TC.filter.Or, TC.filter.LogicalNary);

TC.filter.LogicalNary.prototype.write = function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerArrayCondition_(this.conditions)
    });
}

TC.filter.Not = function (condition) {
    this.condition = condition;
    TC.filter.Filter.call(this, 'Not');
    
};
TC.inherit(TC.filter.Not, TC.filter.Filter);

TC.filter.Filter.prototype.write=function () {
    return '<{prefix}:{tag}>{inner}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: this.writeInnerCondition_(this.condition)
    });
}


TC.filter.Bbox = function (geometryName, extent, opt_srsName) {

    TC.filter.Filter.call(this, 'BBOX');

    this.geometryName = geometryName;

    this.extent = extent;

    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Bbox, TC.filter.Filter);

TC.filter.Comparison = function (tagName, propertyName) {

    TC.filter.Filter.call(this, tagName);

    this.propertyName = propertyName;
};
TC.inherit(TC.filter.Comparison, TC.filter.Filter);

TC.filter.Comparison.prototype.write = function () {
    var values = '';
    //isbetween
    if (this.lowerBoundary && this.upperBoundary)
        values = '<{prefix}:LowerBoundary><{prefix}:Literal>{LowerBoundary}</{prefix}:Literal></{prefix}:LowerBoundary><{prefix}:UpperBoundary><{prefix}:Literal>{UpperBoundary}</{prefix}:Literal></{prefix}:UpperBoundary>'.format({
            prefix:this._defaultPrefixNS,
            LowerBoundary: this.lowerBoundary,
            UpperBoundary: this.upperBoundary
        });
    if (this.pattern)
        values = '<{prefix}:Literal>{Pattern}</{prefix}:Literal>'.format({
            prefix: this._defaultPrefixNS,
            Pattern: this.pattern
        });
    if (this.params)
        if ($.isArray(this.params))
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (text) {
                    return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: text });
                }
                return (i > 0 ? a : fmt(a)) + fmt(b);
            });
        else
            values = '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: this._defaultPrefixNS, value: this.params });

    return '<{prefix}:{tag}{matchCase}{escape}{singleChar}{wildCard}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{values}</{prefix}:{tag}>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        escape: (typeof (this.escapeChar) !== "undefined" ? " escape=\"" + this.escapeChar + "\"" : ""),
        singleChar: (typeof (this.singleChar) !== "undefined" ? " singleChar=\"" + this.singleChar + "\"" : ""),
        wildCard: (typeof (this.wildCard) !== "undefined" ? " wildCard=\"" + this.wildCard + "\"" : ""),
        name: this.propertyName,
        values: values,
        fieldTitle: this._fieldTitle
    });
}

TC.filter.ComparisonBinary = function (
    tagName, propertyName, expression, opt_matchCase) {

    TC.filter.Comparison.call(this, tagName, propertyName);

    this.expression = expression;

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.ComparisonBinary, TC.filter.Comparison);

TC.filter.ComparisonBinary.prototype.write = function () {
    var _str = '<{prefix}:{tag}{matchCase}>' + (this.propertyName instanceof TC.filter.Filter ? '{name}' : '<{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>') + '<{prefix}:Literal>{value}</{prefix}:Literal></{prefix}:{tag}>';
    return _str.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        matchCase: (typeof (this.matchCase) !== "undefined" ? " matchCase=\"" + this.matchCase + "\"" : ""),
        //escape:(typeof(this.escapeChar)!=="undefined"? " escape=\"" + this.escapeChar+ "\"":""),
        //singleChar:(typeof(this.singleChar)!=="undefined"? " singleChar=\"" + this.singleChar+ "\"":""),
        //wildCard:(typeof(this.wildCard)!=="undefined"? " wildCard=\"" + this.wildCard+ "\"":""),
        name: this.propertyName instanceof TC.filter.Filter ? this.propertyName.write() : this.propertyName,
        value: this.expression,
        fieldTitle: this._fieldTitle
    });
}
TC.filter.EqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.EqualTo, TC.filter.ComparisonBinary);

TC.filter.GreaterThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThan', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThan, TC.filter.ComparisonBinary);

TC.filter.GreaterThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.GreaterThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.LessThan = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThan', propertyName, expression);
};
TC.inherit(TC.filter.LessThan, TC.filter.ComparisonBinary);

TC.filter.LessThanOrEqualTo = function (propertyName, expression) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression);
};
TC.inherit(TC.filter.LessThanOrEqualTo, TC.filter.ComparisonBinary);

TC.filter.NotEqualTo = function (propertyName, expression, opt_matchCase) {
    TC.filter.ComparisonBinary.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);
};
TC.inherit(TC.filter.NotEqualTo, TC.filter.ComparisonBinary);

TC.filter.IsLike = function (propertyName, pattern,
    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    TC.filter.Comparison.call(this, 'PropertyIsLike', propertyName);

    this.pattern = pattern;

    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';

    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';

    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';

    this.matchCase = opt_matchCase;
};
TC.inherit(TC.filter.IsLike, TC.filter.Comparison);

TC.filter.IsNull = function (propertyName) {
    TC.filter.Comparison.call(this, 'PropertyIsNull', propertyName);
};
TC.inherit(TC.filter.IsNull, TC.filter.Comparison);

TC.filter.IsBetween = function (propertyName, lowerBoundary, upperBoundary) {
    TC.filter.Comparison.call(this, 'PropertyIsBetween', propertyName);
    this.lowerBoundary = lowerBoundary;
    this.upperBoundary = upperBoundary;
};
TC.inherit(TC.filter.IsBetween, TC.filter.Comparison);

TC.filter.Function = function (functionName, params) {
    TC.filter.Filter.call(this, functionName);
    this.params = params
};
TC.inherit(TC.filter.Function, TC.filter.Filter);

TC.filter.Function.prototype.write = function () {
    var values = '';
    if (this.params) {
        var _paramsToText = function (param, prefix) {
            if (typeof (param) === "string") {
                return '<{prefix}:Literal>{value}</{prefix}:Literal>'.format({ prefix: prefix, value: param });
            }
            if (typeof (param) === "object") {
                var _text = '';
                for (var attr in param) {
                    _text = _text + '<{prefix}:{key}>{value}</{prefix}:{key}>'.format({ prefix: prefix, value: param[attr], key: attr })
                }
                return _text;
            }
        }
        if ($.isArray(this.params)) {
            var prefix = this._defaultPrefixNS;
            values = this.params.reduce(function (a, b, i) {
                var fmt = function (param) {
                    return _paramsToText(param, prefix);
                }
                return (i > 1 ? a : fmt(a)) + fmt(b);
            });
        }
        else
            values = _paramsToText(this.params, this._defaultPrefixNS);
    }
    return '<{prefix}:Function name="{tag}">{inner}</{prefix}:Function>'.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        inner: values
    });
};

TC.filter.Spatial = function (tagName, geometryName, geometry, opt_srsName) {
    TC.filter.Filter.call(this, tagName);
    this.geometryName = geometryName;
    this.geometry = geometry;
    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Spatial, TC.filter.Filter);

TC.filter.Spatial.prototype.write = function () {
    var pattern = null;
    if (this.geometryName)
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{geometry}</{prefix}:{tag}>';
    else
        pattern = '<{prefix}:{tag}><{prefix}:{fieldTitle}/>{geometry}</{prefix}:{tag}>';
    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        name: this.geometryName,
        geometry: (this.geometry instanceof TC.filter.Function ? this.writeInnerCondition_(this.geometry) : this.geometry.wrap.toGML(undefined, this.srsName)),
        fieldTitle: this._fieldTitle
    });
};

TC.filter.Bbox = function (geometryName, extent, opt_srsName) {
    TC.filter.Filter.call(this, 'BBOX');
    this.geometryName = geometryName;
    this.extent = extent;
    this.srsName = opt_srsName;
};
TC.inherit(TC.filter.Bbox, TC.filter.Filter);

TC.filter.Bbox.prototype.write = function () {
    var bbox = '<gml:Envelope{srsName}><gml:lowerCorner>{lowerCorner}</gml:lowerCorner><gml:upperCorner>{upperCorner}</gml:upperCorner></gml:Envelope>'
	.format({
	    srsName: (typeof (this.srsName) !== "undefined" ? " srsName=\"" + this.srsName + "\"" : ""),
	    lowerCorner: (this.extent[0] + ' ' + this.extent[1]),
	    upperCorner: (this.extent[2] + ' ' + this.extent[3])
	});
    var pattern = null;
    if (this.geometryName)
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}>{name}</{prefix}:{fieldTitle}>{BBOX}</{prefix}:{tag}>';
    else
        pattern='<{prefix}:{tag}><{prefix}:{fieldTitle}/>{BBOX}</{prefix}:{tag}>';
    return pattern.format({
        prefix: this._defaultPrefixNS,
        tag: this.getTagName(),
        fieldTitle:  this._fieldTitle,
        name: this.geometryName,
        BBOX: bbox
    });
};

TC.filter.Intersects = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Intersects', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Intersects, TC.filter.Spatial);

TC.filter.Within = function (geometryName, geometry, opt_srsName) {
    TC.filter.Spatial.call(this, 'Within', geometryName, geometry, opt_srsName);
};
TC.inherit(TC.filter.Within, TC.filter.Spatial);
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapContents = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.layerTrees = {};
};

TC.inherit(TC.control.MapContents, TC.Control);

(function () {
    var ctlProto = TC.control.MapContents.prototype;

    ctlProto.CLASS = 'tc-ctl-mc';

    var _dataKeys = {
        layer: 'tcLayer',
        img: 'tcImg'
    };

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? $.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            if (typeof callback === 'function') {
                callback();
            }
        }) : Promise.reject());
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                for (var i = 0, len = map.layers.length; i < len; i++) {
                    self.updateLayerTree(map.layers[i]);
                }

                map
                    .on(TC.Consts.event.ZOOM + ' ' + TC.Consts.event.PROJECTIONCHANGE, function () {
                        self.updateScale();
                    })
                    .on(TC.Consts.event.UPDATEPARAMS, function (e) {
                        const layer = e.layer;
                        var names = layer.names;
                        var containsName = function containsName(node) {
                            var result = false;
                            if (node) {
                                if ($.inArray(node.name, names) >= 0) {
                                    result = true;
                                }
                                else {
                                    for (var i = 0; i < node.children.length; i++) {
                                        if (containsName(node.children[i])) {
                                            result = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            return result;
                        };
                        if (containsName(self.layerTrees[layer.id]) || names.length === 0) {
                            self.update();
                        }
                        else {
                            self.updateLayerTree(layer);
                        }
                    })
                    .on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                        self.updateLayerVisibility(e.layer);
                    })
                    .on(TC.Consts.event.LAYERADD, function (e) {
                        self.updateLayerTree(e.layer);
                    })
                    .on(TC.Consts.event.VECTORUPDATE + ' ' + TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                        const layer = e.layer;
                        // Se introduce un timeout porque pueden venir muchos eventos de este tipo seguidos y no tiene sentido actualizar con cada uno
                        if (self._updateLayerTreeTimeout) {
                            clearTimeout(self._updateLayerTreeTimeout);
                        }
                        self._updateLayerTreeTimeout = setTimeout(function () {
                            if (self.map.workLayers.indexOf(layer) > -1) {
                                // GLS: Validamos si la capa que ha provocado el evento sigue en worklayers, si es borrada debido a la espera del timeout el TOC puede reflejar capas que ya no están
                                self.updateLayerTree(layer);
                                delete self._updateLayerTreeTimeout;
                            }
                        }, 100);
                    })
                    .on(TC.Consts.event.LAYERREMOVE, function (e) {
                        self.removeLayer(e.layer);
                    })
                    .on(TC.Consts.event.LAYERORDER, function (e) {
                        self.updateLayerOrder(e.layer, e.oldIndex, e.newIndex);
                    })
                    .on(TC.Consts.event.LAYERERROR, function (e) {
                        self.onErrorLayer(e.layer);                                                    
                    });

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        });
    };

    ctlProto.updateScale = function () {
    };

    ctlProto.updateLayerVisibility = function (layer) {
    };

    ctlProto.updateLayerTree = function (layer) {
        this.layerTrees[layer.id] = layer.getTree();
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx, collection) {
        const self = this;
        if (oldIdx >= 0 && oldIdx !== newIdx) {
            var currentElm, previousElm;
            const elms = self.getLayerUIElements();

            collection = collection || self.map.workLayers;

            for (var i = collection.length - 1; i >= 0; i--) {
                const l = collection[i];
                previousElm = currentElm;
                for (var j = 0, jj = elms.length; j < jj; j++) {
                    const elm = elms[j];
                    if ($(elm).data(_dataKeys.layer) === l) {
                        currentElm = elm;
                        break;
                    }
                }
                if (l === layer) {
                    if (previousElm) {
                        previousElm.insertAdjacentElement('afterend', currentElm);
                    }
                    else {
                        currentElm.parentElement.firstChild.insertAdjacentElement('beforebegin', currentElm);
                    }
                    break;
                }
            }
        }
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        const liCollection = self.getLayerUIElements();
        for (var i = 0, len = liCollection.length; i < len; i++) {
            const li = liCollection[i];
            if ($(li).data(_dataKeys.layer) === layer) {
                li.parentElement.removeChild(li);
                break;
            }
        }
        if (self.getLayerUIElements().length === 0) {
            self.div.querySelector('.' + self.CLASS + '-empty').classList.remove(TC.Consts.classes.HIDDEN);
        }
    };

    ctlProto.onErrorLayer = function (layer) { };

    ctlProto.getLayerUIElements = function () {
        return this.div.querySelector('ul').children;
    };

    var isGetLegendGraphic = function (url) {
        return /[&?]REQUEST=getLegendGraphic/i.test(url);
    };

    /**
     * Carga y le da estilo a la imagen de la leyenda.
     * @param {string} requestMethod Si queremos pedir la imagen de la leyenda por POST, podemos especificarlo utilizando el parámetro requestMethod.
     */
    ctlProto.styleLegendImage = function (img, layer) {
        if (!img.getAttribute('src')) {
            var imgSrc = $(img).data(_dataKeys.img);

            const toolProxification = new TC.tool.Proxification(TC.proxify);

            if (layer && layer.options.method && layer.options.method === "POST") {
                layer.getLegendGraphicImage()
                    .then(function (src) {
                        img.src = src; // ya se ha validado en getLegendGraphicImage
                    }).catch(function (err) {
                        TC.error(err);
                    });
            } else {
                if (isGetLegendGraphic(imgSrc)) {
                    const watch = img.parentElement;
                    // A\u00f1adimos el par\u00e1metro que define el estilo de los textos en la imagen
                    var colorStr = watch.style.color;
                    // Convertimos el color de formato rgb(r,g,b) a 0xRRGGBB
                    var openIdx = colorStr.indexOf('(');
                    var closeIdx = colorStr.indexOf(')');
                    if (openIdx >= 0 && closeIdx > openIdx) {
                        color = colorStr
                            .substr(0, closeIdx)
                            .substr(openIdx + 1)
                            .split(',');
                        colorStr = '0x';
                        for (var i = 0; i < 3; i++) {
                            var component = parseInt(color[i]).toString(16);
                            colorStr += component.length === 1 ? '0' + component : component;
                        }
                    }
                    else {
                        colorStr.replace('#', '0x');
                    }
                    imgSrc += '&LEGEND_OPTIONS=fontName:' + watch.style.fontFamily +
                        ';fontSize:' + parseInt(watch.style.fontSize) +
                        ';fontColor:' + colorStr +
                        ';fontAntiAliasing:true';
                    if (layer.params && layer.params.sld_body) {
                        imgSrc = TC.Util.addURLParameters(imgSrc, { sld_body: layer.params.sld_body });
                    }

                    toolProxification.fetchImage(imgSrc).then(function (img) {
                        $(img).data(_dataKeys.img, img.src);
                    }).catch(function (err) {
                        TC.error(err);
                    });
                }

                toolProxification.fetchImage(imgSrc).then(function (i) {
                    img.src = i.src;
                }).catch(function (err) {
                    TC.error(err.statusText);
                });                
            }
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.MapInfo = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.MapInfo, TC.Control);

(function () {
    var ctlProto = TC.control.MapInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-mi';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.QR_MAX_URL_LENGTH = 150;
        self.SHORTEN_URL_LENGTH = 32715;

        self.exportsState = false;

        self.includeControls = self.options.includeControls === undefined || self.options.includeControls;

        map.ready(function () {
            const controlStates = map.state && map.state.ctl;
            if (controlStates) {
                if (!map._controlStatesLoaded) { // Para evitar que si hay varios controles Share cargados, cada uno importe por su cuenta.
                    self.importControlStates(controlStates);
                    map._controlStatesLoaded = true;
                }
            }
        });

        return result;
    }

    ctlProto.exportControlStates = function () {
        const self = this;
        if (self.map) {
            return self.map.controls
                .map(function (ctl) {
                    return ctl.exportState();
                })
                .filter(function (state) {
                    // Quitamos los estados nulos o vacíos
                    if (state) {
                        for (var key in state) {
                            if (state.hasOwnProperty(key)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
        }
        return [];
    };

    ctlProto.importControlStates = function (stateArray) {
        const self = this;
        if (self.map) {
            stateArray.forEach(function (state) {
                const ctl = self.map.getControlById(state.id);
                if (ctl) {
                    self.map.loaded(function () {
                        ctl.importState(state);
                    });
                }
            });
        }
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.featureToShare || self.sharedFeaturesLayer) {
                var layerState;
                state.id = self.id;
                if (self.featureToShare) {
                    const featureToShare = self.featureToShare.clone();
                    featureToShare.showsPopup = true;
                    layerState = self.featureToShare.layer.exportState({
                        features: [featureToShare]
                    });
                }
                else {
                    layerState = self.sharedFeaturesLayer.exportState();
                }
                state.features = layerState.features;
                if (layerState.crs) {
                    state.crs = layerState.crs;
                }
            }
            return state;
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map && state.features.length) {
            self.map.addLayer({
                id: self.getUID(),
                type: TC.Consts.layerType.VECTOR,
                title: self.getLocaleString('foi'),
                stealth: true
            }).then(function (layer) {
                self.sharedFeaturesLayer = layer;
                layer.importState({ features: state.features, crs: state.crs }).then(function () {
                    self.map.zoomToFeatures(layer.features);
                });
            });
        }
    };

    ctlProto.manageMaxLengthExceed = function () {
        throw "Falta implementación del método manageMaxLengthExceed";
    };

    ctlProto.generateLink = function () {
        var self = this;

        var currentUrl = window.location.href;
        var hashPosition = currentUrl.indexOf('#');
        if (hashPosition > 0) {
            currentUrl = currentUrl.substring(0, hashPosition);
        }

        if (self.extraParams) {
            // Hacemos merge de parámetros de URL
            var params = TC.Util.getQueryStringParams(currentUrl);
            $.extend(params, self.extraParams);
            var qsPosition = currentUrl.indexOf('?');
            if (qsPosition >= 0) {
                currentUrl = currentUrl.substring(0, qsPosition);
            }
            currentUrl = currentUrl.concat('?', $.param(params));
        }

        // eliminamos el parámetro del idioma, si no lo arrastramos al compartir
        if (TC.Util.getParameterByName('lang').length > 0) {
            if (currentUrl.indexOf('&') > -1) { // tenemos más parámetros en la url
                currentUrl = currentUrl.replace("lang" + "=" + TC.Util.getParameterByName('lang') + '&', '');
            } else {
                currentUrl = currentUrl.replace('?' + "lang" + "=" + TC.Util.getParameterByName('lang'), '');
            }
        }

        const controlStates = self.includeControls ? self.exportControlStates() : [];
        if (self.exportsState && (self.featureToShare || self.sharedFeaturesLayer)) {
            controlStates.push(self.exportState());
        }
        const extraStates = controlStates.length ? { ctl: controlStates } : undefined;

        var hashState = self.map.getMapState(extraStates);

        var url = currentUrl.concat("#", hashState);
        self.manageMaxLengthExceed({ browser: url.length > TC.Consts.URL_MAX_LENGTH, qr: url.length > self.SHORTEN_URL_LENGTH });
        return url;
    };

    ctlProto.shortenedLink = function () {
        const self = this;
        var wait;

        const generateLinkWithoutParams = function () {
            var url = self.generateLink();
            var start = url.indexOf('?');
            var end = url.indexOf('#');

            //Borramos los parámetros de la URL y dejamos sólo el hash
            if (start > 0) {
                if (start < end) {
                    url = url.replace(url.substring(start, end), '');
                } else {
                    url = url.replace(url.substring(start, url.length - 1), '');
                }
            }

            return url;
        };
        const shortenUrl = function (url) {
            var shortenServiceUrl = "https://tinyurl.com/api-create.php";

            if (!TC.tool || !TC.tool.Proxification) {
                TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
            }

            var data = new FormData();
            data.append("url", url);

            var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: false });
            return toolProxification.fetch(shortenServiceUrl, {
                type: 'POST',
                data: data
            }).then(function (data) {
                return data;
            }).catch(function (error) {
                return null;
            });
        };

        return new Promise(function (resolve, reject) {
            const onError = function () {
                self.map.toast(self.getLocaleString("urlTooLongForShortener"), { type: TC.Consts.msgType.ERROR });
                self.map.getLoadingIndicator().removeWait(wait);
                resolve("");
            };

            var url = generateLinkWithoutParams();

            if (url.length > self.QR_MAX_URL_LENGTH && url.length < self.SHORTEN_URL_LENGTH) {

                wait = self.map.getLoadingIndicator().addWait();

                shortenUrl(url).then(function (response) {
                    if (response && response.responseText) {
                        self.map.getLoadingIndicator().removeWait(wait);
                        resolve(response.responseText.replace('http://', 'https://'));
                    } else {
                        onerror();
                    }
                }, onerror);
            } else {
                if (url.length >= self.SHORTEN_URL_LENGTH) {
                    onError();
                }

                resolve("");
            }
        });
    };

    ctlProto.makeQRCode = function (codeContainer, width, height) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.loadJS(
                typeof QRCode === 'undefined',
                [TC.apiLocation + 'lib/qrcode/qrcode.min.js'],
                function () {
                    self.shortenedLink().then(function (url) {
                        url = url || "";
                        if (url.length > 0) {
                            var options = {
                                text: url
                            };

                            if (width && height) {
                                options.width = width;
                                options.height = height;
                            }

                            var config = { attributes: true, childList: true, subtree: true };
                            var observer = new MutationObserver(function (mutationsList, observer) {
                                var srcMutation = mutationsList.filter(function (mutation) {
                                    return mutation.type === "attributes"
                                }).filter(function (mutation) {
                                    return mutation.attributeName.indexOf('src') > -1;
                                });

                                if (srcMutation.length > 0) {
                                    observer.disconnect();
                                    resolve(srcMutation[0].target.src);
                                }
                            });
                            observer.observe(codeContainer, config);
                            new QRCode(codeContainer, options);
                        } else {
                            resolve();
                        }
                    });
                });
        });
    };

    ctlProto.drawScaleBarIntoCanvas = function (options) {
        const self = this;
        var canvas;
        var sb = self.map.getControlsByClass(TC.control.ScaleBar);
        if (sb.length == 0) {
            return null;
        }

        options = options || {};

        const drawFill = function (ctx, width, height) {
            var elem = document.getElementsByClassName(sb[0].CLASS);
            var fillnode = elem.item(0);
            var fillBoundingCR = $.extend({}, fillnode.getBoundingClientRect());

            fillBoundingCR.left = (options.left || 15) - 2;

            fillBoundingCR.top = options.top || 15;
            fillBoundingCR.top--;

            ctx.globalAlpha = 0.5;
            ctx.fillStyle = window.getComputedStyle(fillnode).backgroundColor;
            width += 4;
            height += 4;
            ctx.fillRect(fillBoundingCR.left, fillBoundingCR.top, width, height);
        };

        if (!options.canvas) {
            canvas = document.createElement('CANVAS');
        } else {
            canvas = options.canvas;
        }

        var ctx = canvas.getContext("2d");
        ctx.save();

        var elem = document.getElementsByClassName("ol-scale-line-inner");
        var node = elem.item(0);
        var boundingCR = $.extend({}, node.getBoundingClientRect());

        var text = node.textContent;

        ctx.beginPath();
        ctx.strokeStyle = window.getComputedStyle(node).borderColor;

        var width, height;

        if (boundingCR.width > boundingCR.height) {

            width = boundingCR.width;
            height = boundingCR.height;
        }
        else {

            width = boundingCR.height;
            height = boundingCR.width;
        }

        if (options.setSize) {
            canvas.width = width;
            canvas.height = height;
        }        

        boundingCR.left = options.left != undefined ? options.left : 15;
        boundingCR.top = options.top != undefined ? options.top : 15;

        ctx.moveTo(boundingCR.left, boundingCR.top);
        ctx.lineTo(boundingCR.left, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top + height);
        ctx.lineTo(boundingCR.left + width, boundingCR.top);

        ctx.stroke();

        var textMetrics = ctx.measureText(text);
        var textPosition = {
            x: boundingCR.left + width / 2,
            y: boundingCR.top + height / 2
        };

        if (options.fill) {
            drawFill(ctx, width, height);
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = options.textColor != undefined ? options.textColor : window.getComputedStyle(node).color;

        ctx.font = options.font != undefined ? options.font : window.getComputedStyle(node).fontSize + " " + window.getComputedStyle(node).fontFamily;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, textPosition.x, textPosition.y);

        return canvas;
    };

    ctlProto.registerListeners = function () {
        const self = this;

        if (!self.registeredListeners) {
            self.map.on(TC.Consts.event.LAYERADD, self.generateLink.bind(self))
                .on(TC.Consts.event.LAYERREMOVE, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREADD, self.generateLink.bind(self))
                .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, self.generateLink.bind(self));

            self.registeredListeners = true;
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.TOC = function () {
    var self = this;

    TC.control.MapContents.apply(self, arguments);
};

TC.inherit(TC.control.TOC, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.TOC.prototype;

    ctlProto.CLASS = 'tc-ctl-toc';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/TOC.html";
        ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/TOCBranch.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/TOCNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "worklayers" }).w("</h2><div class=\"tc-ctl-toc-tree\"><div class=\"tc-ctl-toc-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</div><ul class=\"tc-ctl-toc-branch tc-ctl-toc-wl\">").s(ctx.get(["workLayers"], false), ctx, { "block": body_1 }, {}).w("</ul></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-toc-wlbranch", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-branch'] = function () { dust.register(ctlProto.CLASS + '-branch', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><button class=\"tc-ctl-toc-collapse-btn\"></button><input type=\"checkbox\" class=\"tc-ctl-toc-branch-cb\" name=\"toc\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["isVisible"], false), ctx, { "block": body_3 }, {}).w(" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-toc-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_4 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node tc-ctl-toc-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" checked"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.p("tc-ctl-toc-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_4.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\">").x(ctx.get(["children"], false), ctx, { "block": body_3 }, {}).w("<input type=\"checkbox\" name=\"toc\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["isVisible"], false), ctx, { "block": body_4 }, {}).w(" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-toc-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_5 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node tc-ctl-toc-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-toc-node\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<button class=\"tc-ctl-toc-collapse-btn\"></button>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w(" checked"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.p("tc-ctl-toc-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_5.__dustBody = !0; return body_0 };
    }

    var _dataKeys = {
        layer: 'tcLayer',
        layerUid: 'tcLayerUid'
    };

    var CLICKEVENT = 'click';

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapContents.prototype.register.call(self, map);

        map.on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
            self.onExternalServiceAdded.call(self, e, this);
        });

        return result;
    };

    ctlProto.onExternalServiceAdded = function (e, map) {
        const self = this;
        if (e && e.layer) {
            e.layer.map = map;
            map.addLayer(e.layer).then(function (layer) {
                self.updateLayerTree(e.layer);
            });
        }
    };

    ctlProto.addUIEventListeners = function () {
        var self = this;
        self.div.addEventListener(CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) { // No usamos TC.Consts.event.CLICK porque en iPad los eventos touchstart no van bien en los checkbox
            const checkbox = e.target;
            var ul = checkbox;
            while (ul && !ul.matches('ul.' + self.CLASS + '-wl')) {
                ul = ul.parentElement;
            }
            const lis = [];
            for (var i = 0, len = ul.children.length; i < len; i++) {
                child = ul.children[i];
                if (child.tagName === 'LI') {
                    lis.push(child);
                }
            }
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.contains(checkbox)) {
                    const layer = $(li).data(_dataKeys.layer);
                    var parent = checkbox;
                    do {
                        parent = parent.parentElement;
                    }
                    while (parent && parent.tagName !== 'LI');
                    const uid = $(parent).data(_dataKeys.layerUid)
                    layer.setNodeVisibility(uid, checkbox.checked);
                    break;
                }
            }

            e.stopPropagation();
        }));
        self.div.addEventListener(TC.Consts.event.MOUSEUP, TC.EventTarget.listenerBySelector('button.' + self.CLASS + '-collapse-btn', function (e) {
            e.target.blur();
            const li = e.target.parentElement;
            if (!li.classList.contains(self.CLASS + '-leaf')) {
                if (li.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    li.classList.remove(TC.Consts.classes.COLLAPSED);
                }
                else {
                    li.classList.add(TC.Consts.classes.COLLAPSED);
                }
                const ul = li.querySelector('ul');
                if (ul.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    ul.classList.remove(TC.Consts.classes.COLLAPSED);
                }
                else {
                    ul.classList.add(TC.Consts.classes.COLLAPSED);
                }
                e.stopPropagation();
            }
        }));
    };

    ctlProto.update = function () {
        var self = this;

        var _getCheckbox = function (li) {
            for (var i = 0, len = li.children.length; i < len; i++) {
                const child = li.children[i];
                if (child.matches('input[type=checkbox]')) {
                    return child;
                }
            }
            return null;
        };

        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);
            if (layer) {
                _getCheckbox(li).checked = layer.getVisibility();

                layer.tree = null;

                li.querySelectorAll('li').forEach(function (l) {
                    const checkbox = _getCheckbox(l);
                    var uid = $(l).data(_dataKeys.layerUid);
                    switch (layer.getNodeVisibility(uid)) {
                        case TC.Consts.visibility.VISIBLE:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.NOT_VISIBLE_AT_RESOLUTION:
                            checkbox.checked = true;
                            checkbox.indeterminate = false;
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            checkbox.checked = false;
                            checkbox.indeterminate = true;
                            break;
                        default:
                            checkbox.checked = false;
                            checkbox.indeterminate = false;
                    }
                });
            }
        });

        self.updateScale();
    };

    ctlProto.updateScale = function () {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);
            li.querySelectorAll('li').forEach(function (i, e) {
                var $_li = $(e);
                $_li.toggleClass(self.CLASS + '-node-notvisible', !layer.isVisibleByScale($_li.data(_dataKeys.layerUid)));
            });
        });
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);

            var template = self.CLASS + '-branch';
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(template, self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        const uid = $(newLi).data(_dataKeys.layerUid);
                        const li = self.div.querySelector('.' + self.CLASS + '-wl li[data-tc-layer-uid="' + uid + '"]');
                        if (li) {
                            li.innerHTML = newLi.innerHTML;
                            li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                            if (!$(li).data(_dataKeys.layer)) {
                                $(li).data(_dataKeys.layer, layer);
                            }
                        }
                        else {
                            $(newLi).data(_dataKeys.layer, layer);
                            const ul = self.div.querySelector('.' + self.CLASS + '-wl');
                            ul.insertBefore(newLi, ul.firstChild);
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    var wl = 'ul.' + self.CLASS + '-wl';
                    var branch = 'ul.' + self.CLASS + '-branch';
                    var node = 'li.' + self.CLASS + '-node';
                    var leaf = 'li.' + self.CLASS + '-leaf';
                    self.div.querySelectorAll(wl + ' ' + branch + ' ' + branch + ',' + wl + ' ' + branch + ' ' + node).forEach(function (node) {
                        if (!node.matches(leaf)) {
                            node.classList.add(TC.Consts.classes.COLLAPSED);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if ($(li).data(_dataKeys.layer) === layer) {
                var isHidden = !layer.getVisibility();
                li.querySelectorAll('input[type=checkbox]').forEach(function (checkbox) {
                    if (checkbox.matches('.' + self.CLASS + '-branch-cb')) {
                        checkbox.checked = !isHidden;
                    }
                    else {
                        checkbox.disabled = isHidden;
                    }
                });
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // Este control no tiene que hacer nada
    };

    ctlProto.render = function (callback) {
        const self = this;

        return TC.Control.prototype.render.call(self, function () {

            var controlOptions = self.options.controls || [];

            if (controlOptions.length > 0) {
                var ctl = controlOptions[0];
                var newDiv = document.createElement("div");
                self.div.appendChild(newDiv);
                self.map.addControl(ctl.name, $.extend({ 'div': newDiv }, ctl.options));
            }

            if ($.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        const result = [];
        const children = self.div.querySelector('ul.' + self.CLASS + '-wl').children;
        for (var i = 0, len = children.length; i < len; i++) {
            child = children[i];
            if (child.tagName === 'LI') {
                result[result.length] = child;
            }
        }
        return result;
    };
})();

﻿TC.control = TC.control || {};

if (!TC.control.TOC) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TOC');
}

TC.control.WorkLayerManager = function (options) {
    var self = this;
    TC.control.TOC.apply(self, arguments);
    self.layers = [];
    self.queries = self.options.queries;
};

TC.inherit(TC.control.WorkLayerManager, TC.control.TOC);

(function () {
    var ctlProto = TC.control.WorkLayerManager.prototype;

    ctlProto.CLASS = 'tc-ctl-wlm';
    ctlProto.CLICKEVENT = 'click';

    TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
    TC.Consts.classes.DRAGEND = TC.Consts.classes.DRAGEND || 'tc-dragend';

    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/WorkLayerManager.html";
        ctlProto.template[ctlProto.CLASS + '-elm'] = TC.apiLocation + "TC/templates/WorkLayerManagerElement.html";
        ctlProto.template[ctlProto.CLASS + '-type-sgl'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipSingle.html";
        ctlProto.template[ctlProto.CLASS + '-type-grp'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroup.html";
        ctlProto.template[ctlProto.CLASS + '-type-grp-node'] = TC.apiLocation + "TC/templates/WorkLayerManagerTooltipGroupNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "loadedLayers" }).w("<span class=\"tc-ctl-wlm-n\"></span><button class=\"tc-ctl-wlm-del-all tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "removeAllLayersFromMap" }).w("\"></button></h2><div class=\"tc-ctl-wlm-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</div><div class=\"tc-ctl-wlm-content tc-hidden\"><form><ul>").s(ctx.get(["workLayers"], false), ctx, { "block": body_1 }, {}).w("</ul></form></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-elm", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-elm'] = function () { dust.register(ctlProto.CLASS + '-elm', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-wlm-elm\" tabindex=\"-1\"><div class=\"tc-ctl-wlm-lyr\">").x(ctx.get(["path"], false), ctx, { "block": body_1 }, {}).w("</div><div class=\"tc-ctl-wlm-type\"></div><div class=\"tc-ctl-wlm-path\" title=\"").s(ctx.get(["path"], false), ctx, { "else": body_2, "block": body_3 }, {}).w("\">").s(ctx.get(["path"], false), ctx, { "else": body_5, "block": body_6 }, {}).w("</div><div class=\"tc-ctl-wlm-buttons\"><div class=\"tc-ctl-wlm-btn-info\" title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\"></div><input type=\"range\" value=\"").f(ctx.get(["opacity"], false), ctx, "h").w("\" title=\"").h("i18n", ctx, {}, { "$key": "transparencyOfThisLayer" }).w("\" /><input type=\"checkbox\" ").nx(ctx.get(["hide"], false), ctx, { "block": body_8 }, {}).w(" title=\"").h("i18n", ctx, {}, { "$key": "visibilityOfThisLayer" }).w("\" /></div><div class=\"tc-ctl-wlm-info tc-hidden\">").x(ctx.get(["abstract"], false), ctx, { "block": body_9 }, {}).x(ctx.get(["customLegend"], false), ctx, { "else": body_10, "block": body_13 }, {}).x(ctx.get(["metadata"], false), ctx, { "block": body_14 }, {}).w("</div><div class=\"tc-ctl-wlm-dd ").x(ctx.get(["hide"], false), ctx, { "block": body_16 }, {}).w("\" title=\"").h("i18n", ctx, {}, { "$key": "dragToReorder" }).w("\"></div><div class=\"tc-ctl-wlm-del ").x(ctx.get(["unremovable"], false), ctx, { "block": body_17 }, {}).w(" ").nx(ctx.get(["hide"], false), ctx, { "block": body_18 }, {}).w("\" ").nx(ctx.get(["unremovable"], false), ctx, { "block": body_19 }, {}).w("></div></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_4 }, {}); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w(" &bull; "); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_7 }, {}); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(" &bull; "); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("checked=\"checked\""); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-abstract\"><h4>").h("i18n", ctx, {}, { "$key": "abstract" }).w("</h4><div><pre>").f(ctx.get(["abstract"], false), ctx, "h", ["s"]).w("</pre></div></div>"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.x(ctx.get(["legend"], false), ctx, { "block": body_11 }, {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-legend\" data-tc-layer-name=\"").f(ctx.get(["layerNames"], false), ctx, "h").w("\"><h4>").h("i18n", ctx, {}, { "$key": "content" }).w("</h4>").s(ctx.get(["legend"], false), ctx, { "block": body_12 }, {}).w("</div>"); } body_11.__dustBody = !0; function body_12(chk, ctx) { return chk.w("<div><p>").f(ctx.get(["title"], false), ctx, "h").w("</p><img data-tc-img=\"").f(ctx.get(["src"], false), ctx, "h").w("\" /></div>"); } body_12.__dustBody = !0; function body_13(chk, ctx) { return chk.w("<ul class=\"tc-ctl-wlm-custom-legend\">").f(ctx.get(["customLegend"], false), ctx, "h", ["s"]).w("</ul>"); } body_13.__dustBody = !0; function body_14(chk, ctx) { return chk.w("<div class=\"tc-ctl-wlm-metadata\"><h4>").h("i18n", ctx, {}, { "$key": "metadata" }).w("</h4><ul>").s(ctx.get(["metadata"], false), ctx, { "block": body_15 }, {}).w("</ul></div>"); } body_14.__dustBody = !0; function body_15(chk, ctx) { return chk.w("<li><a href=\"").f(ctx.get(["url"], false), ctx, "h", ["s"]).w("\" type=\"").f(ctx.get(["format"], false), ctx, "h").w("\" title=\"").f(ctx.get(["formatDescription"], false), ctx, "h").w("\" target=\"_blank\">").f(ctx.get(["formatDescription"], false), ctx, "h").w("</a></li>"); } body_15.__dustBody = !0; function body_16(chk, ctx) { return chk.w("tc-hidden"); } body_16.__dustBody = !0; function body_17(chk, ctx) { return chk.w("disabled"); } body_17.__dustBody = !0; function body_18(chk, ctx) { return chk.w("tc-hidden"); } body_18.__dustBody = !0; function body_19(chk, ctx) { return chk.w("title=\"").h("i18n", ctx, {}, { "$key": "removeLayerFromMap" }).w("\""); } body_19.__dustBody = !0; return body_0; };
        ctlProto.template[ctlProto.CLASS + '-type-sgl'] = function () { dust.register(ctlProto.CLASS + '-type-sgl', body_0); function body_0(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "singleLayer" }); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-type-grp'] = function () { dust.register(ctlProto.CLASS + '-type-grp', body_0); function body_0(chk, ctx) { return chk.w("<div>").h("i18n", ctx, {}, { "$key": "groupLayerThatContains" }).w(":</div><ul>").s(ctx.get(["Layer"], false), ctx, { "block": body_1 }, {}).w("</ul>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-type-grp-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-type-grp-node'] = function () { dust.register(ctlProto.CLASS + '-type-grp-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-wlm-tip-grp-elm\"><span>").f(ctx.get(["Title"], false), ctx, "h").w("</span><ul>").s(ctx.get(["Layer"], false), ctx, { "block": body_1 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-wlm-type-grp-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; return body_0 };
    }

    const _dataKeys = {
        layer: 'tcLayer'
    };

    const findLayerElement = function (ctl, layer) {
        return ctl.getLayerUIElements().filter(function (li) {
            return $(li).data(_dataKeys.layer) === layer;
        })[0];
    };

    var getElligibleLayersNumber = function (ctl) {
        return $.grep(ctl.map.workLayers, function (lyr) {
            return !lyr.stealth;
        }).length;
    };

    const shouldBeDelAllVisible = function (ctl) {
        return !ctl.layers.some(function (layer) { return layer.unremovable });
    };

    const moveLayer = function (ctl, listItem, oldIndex, newIndex, callback) {
        const layerItems = ctl.getLayerUIElements();
        var targetItem;
        if (newIndex > oldIndex) {
            targetItem = layerItems[newIndex - 1];
        }
        else if (newIndex < oldIndex) {
            targetItem = layerItems[newIndex + 1];
        }
        else {
            return;
        }
        const sourceLayer = $(listItem).data(_dataKeys.layer);
        const targetLayer = $(targetItem).data(_dataKeys.layer);
        var newIdx = -1;
        for (var i = 0; i < ctl.map.layers.length; i++) {
            if (targetLayer === ctl.map.layers[i]) {
                newIdx = i;
                break;
            }
        }
        if (newIdx >= 1 && newIdx < ctl.map.layers.length) {
            ctl.map.insertLayer(sourceLayer, newIdx, callback);
        }
    };

    ctlProto.render = function (callback, options) {
        const self = this;
        return self._set1stRenderPromise(self.map ? self.renderData(options ? $.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {
            self.addUIEventListeners();
            TC.loadJS(
                !window.Sortable,
                [TC.apiLocation + 'lib/sortable/Sortable.min.js'],
                function () {
                    self.map.workLayers
                        .filter(function (layer) {
                            return !layer.stealth;
                        })
                        .forEach(function (layer) {
                            self.updateLayerTree(layer);
                        });


                    const ul = self.div.querySelector('ul');
                    self._sortable = Sortable.create(ul, {
                        handle: '.' + self.CLASS + '-dd',
                        animation: 150,
                        onSort: function (e) {
                            moveLayer(self, e.item, e.oldIndex, e.newIndex);
                        }
                    });

                    ul.addEventListener('keydown', TC.EventTarget.listenerBySelector('li', function (e) {
                        // Para mover capas con el teclado.
                        var elm = e.target;
                        while (elm.tagName !== 'LI') {
                            elm = elm.parentElement;
                            if (!elm) {
                                return;
                            }
                        }
                        const swap = function (oldIdx, newIdx) {
                            const sortableItems = self._sortable.toArray();
                            const buffer = sortableItems[oldIdx];
                            sortableItems[oldIdx] = sortableItems[newIdx];
                            sortableItems[newIdx] = buffer;
                            self._sortable.sort(sortableItems);
                            moveLayer(self, elm, oldIdx, newIdx);
                        };
                        const listItems = self.getLayerUIElements();
                        const elmIdx = listItems.indexOf(elm);
                        switch (true) {
                            case /Up$/.test(e.key):
                                if (elmIdx > 0) {
                                    swap(elmIdx, elmIdx - 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Down$/.test(e.key):
                                if (elmIdx < listItems.length - 1) {
                                    swap(elmIdx, elmIdx + 1);
                                    elm.focus();
                                    e.stopPropagation();
                                }
                                break;
                            case /Enter$/.test(e.key):
                                elm.blur();
                                e.stopPropagation();
                                break;
                            default:
                                break;
                        }
                    }));

                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            );
        }) : Promise.reject());
    };

    ctlProto.register = function (map) {
        const self = this;

        return new Promise(function (resolve, reject) {
            TC.control.TOC.prototype.register.call(self, map).then(function () {

                map
                    .on(TC.Consts.event.LAYEROPACITY, function (e) {
                        const li = findLayerElement(self, e.layer);
                        if (li) {
                            li.querySelector('input[type=range]').value = Math.round(e.opacity * 100);
                        }
                    })
                    .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                        var fileName = e.fileName;
                        if (e.features && e.features.length > 0) { // GLS: Escuchamos al evento FEATURESIMPORT para poder desplegar el control de capas cargadas
                            // Ignoramos los GPX (se supone que los gestionará Geolocation)
                            var pattern = '.' + TC.Consts.format.GPX.toLowerCase();
                            if (e.fileName.toLowerCase().indexOf(pattern) === e.fileName.length - pattern.length) {
                                return;
                            }

                            map.one(TC.Consts.event.LAYERADD, function (e) {
                                if (e && e.layer && e.layer.title == fileName) {
                                    // Desplegamos el control capas cargadas
                                    if (self.map && self.map.layout && self.map.layout.accordion) {
                                        if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                            for (var i = 0; i < self.map.controls.length; i++) {
                                                if (self.map.controls[i] !== self) {
                                                    self.map.controls[i].div.classList.add(TC.Consts.classes.COLLAPSED);
                                                }
                                            }
                                        }
                                    }

                                    // abrimos el panel de herramientas
                                    self.map.trigger(TC.Consts.event.TOOLSOPEN);

                                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                                }
                            });
                        }
                    });
                if (self.queries) {
                    if (!TC.control.WFSQuery) {
                        TC.syncLoadJS(TC.apiLocation + 'TC/Control/WFSQuery');
                    }
                    ctlProto.queryControl = new TC.control.WFSQuery(null, self.queries instanceof Object ? self.queries : null);
                    self.map.addControl(ctlProto.queryControl);
                }
                resolve(self);
            });
        });
    };

    ctlProto.onExternalServiceAdded = function (e, map) {
        // Este control no tiene que aceptar servicios externos directamente
    };

    ctlProto.addUIEventListeners = function () {
        const self = this;

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
            // al estar en ipad el evento pasa a ser touchstart en la constante: TC.Consts.event.CLICK, los checkbox no funcionan bien con este evento
            const checkbox = e.target;
            var li = checkbox;
            do {
                li = li.parentElement;
            }
            while (li && !li.matches('li.' + self.CLASS + '-elm'));

            const layer = $(li).data(_dataKeys.layer);
            layer.setVisibility(checkbox.checked);
            e.stopPropagation();
        }));

        const inputRangeListener = function (e) {
            const range = e.target;
            var li = range;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');

            const layer = $(li).data(_dataKeys.layer);
            layer.setOpacity(range.value / 100);
        };
        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));
        self.div.addEventListener('input', TC.EventTarget.listenerBySelector('input[type=range]', inputRangeListener));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-del' + ':not(.disabled)', function (e) {
            var li = e.target;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const layer = $(li).data(_dataKeys.layer);
            self.map.removeLayer(layer);
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-del-all', function (e) {
            TC.confirm(self.getLocaleString('layersRemove.confirm'), function () {
                self.getLayerUIElements()
                    .map(function (li) {
                        return $(li).data(_dataKeys.layer);
                    })
                    .forEach(function (layer) {
                        self.map.removeLayer(layer);
                    });
            });
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn-info', function (e) {
            const a = e.target;
            var li = a;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const info = li.querySelector('.' + self.CLASS + '-info');
            const layer = $(li).data(_dataKeys.layer);
            // Cargamos la imagen de la leyenda
            info.querySelectorAll('.' + self.CLASS + '-legend img').forEach(function (img) {
                self.styleLegendImage(img, layer);
            });
            if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                info.classList.remove(TC.Consts.classes.HIDDEN);
            }
            else {
                info.classList.add(TC.Consts.classes.HIDDEN);
            }

            if (li.querySelector('input[type="checkbox"]').checked) {
                const dragHandle = li.querySelector('.' + self.CLASS + '-dd');
                if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                    dragHandle.classList.remove(TC.Consts.classes.HIDDEN);
                }
                else {
                    dragHandle.classList.add(TC.Consts.classes.HIDDEN);
                }
            }

            if (a.classList.contains(TC.Consts.classes.CHECKED)) {
                a.classList.remove(TC.Consts.classes.CHECKED);
            }
            else {
                a.classList.add(TC.Consts.classes.CHECKED);
            }
        }));

        self.div.addEventListener(self.CLICKEVENT, TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn-query', function (e) {
            if (e.target.classList.contains('tc-unavailable') || e.target.classList.contains('tc-loading')) {
                return;
            }
            const a = e.target;
            var li = a;
            do {
                li = li.parentElement;
            }
            while (li && li.tagName !== 'LI');
            const layer = $(li).data(_dataKeys.layer);
            self.queryControl.renderModalDialog(layer);
        }));
    };

    ctlProto.updateLayerVisibility = function (layer) {
        const self = this;
        const li = findLayerElement(self, layer);
        if (li) {
            const visible = layer.getVisibility();
            li.querySelector('input[type="checkbox"]').checked = visible;
            const delBtn = li.querySelector('.' + self.CLASS + '-del');
            const info = li.querySelector('.' + self.CLASS + '-info');
            const dragHandle = li.querySelector('.' + self.CLASS + '-dd');
            if (visible) {
                delBtn.classList.add(TC.Consts.classes.HIDDEN);
                if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                    dragHandle.classList.remove(TC.Consts.classes.HIDDEN);
                }
            }
            else {
                delBtn.classList.remove(TC.Consts.classes.HIDDEN);
                if (info.classList.contains(TC.Consts.classes.HIDDEN)) {
                    dragHandle.classList.add(TC.Consts.classes.HIDDEN);
                }
            }
        }
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;

        var getLegendImgByPost = function (layer) {
            return new Promise(function (resolve, reject) {
                if (layer && layer.options.method && layer.options.method === "POST") {
                    layer.getLegendGraphicImage()
                        .then(function (src) {
                            resolve(src);
                        })
                        .catch(function (err) { TC.error(err); });
                } else {
                    resolve();
                }
            });
        };

        if (!layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            var alreadyExists = false;
            for (var i = 0, len = self.layers.length; i < len; i++) {
                if (layer === self.layers[i]) {
                    alreadyExists = true;
                    break;
                }
            }

            if (!alreadyExists) {
                var template = self.CLASS + '-elm';
                self.layers.push(layer);

                TC.loadJSInOrder(
                    !window.dust,
                    TC.url.templating,
                    function () {
                        var domReadyPromise;
                        var layerTitle = layer.title || layer.wrap.getServiceTitle();
                        var layerData = {
                            title: layer.options.hideTitle ? '' : layerTitle,
                            hide: layer.renderOptions && layer.renderOptions.hide ? true : false,
                            opacity: layer.renderOptions && layer.renderOptions.opacity ? (layer.renderOptions.opacity * 100) : 100,
                            customLegend: layer.customLegend,
                            unremovable: layer.unremovable
                        };
                        var isRaster = layer.isRaster();
                        if (isRaster) {
                            layerData.layerNames = layer.layerNames;
                            var path = layer.getPath();
                            path.shift();
                            layerData.path = path;
                            var name = layer.names[0];
                            var info = layer.wrap.getInfo(name);
                            layerData.legend = info.legend;
                            layerData['abstract'] = info['abstract'];
                            var hasInfo = (info.hasOwnProperty('abstract') || info.hasOwnProperty('legend') || info.hasOwnProperty('metadata'));
                            var metadata;
                            if (layer.tree && layer.tree.children && layer.tree.children.length && layer.tree.children[0].children && layer.tree.children[0].children.length) {
                                metadata = null;
                            }
                            else {
                                metadata = info.metadata;
                                if (metadata) {
                                    for (var j = 0, len = metadata.length; j < len; j++) {
                                        var md = metadata[j];
                                        md.formatDescription = self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) || self.getLocaleString('viewMetadata');
                                    }
                                }
                            }
                            layerData.metadata = metadata;
                            if (self.queries) {
                                domReadyPromise = checkWFSAvailable(layer);
                            }
                        }


                        getLegendImgByPost(layer).then(function (src) {
                            if (src) {
                                legend.src = src; // ya se ha validado en getLegendImgByPost
                            }

                            dust.render(template, layerData, function (err, out) {
                                const parser = new DOMParser();
                                const li = parser.parseFromString(out, 'text/html').body.firstChild;
                                var layerNode;
                                var isGroup = false;
                                if (isRaster) {
                                    isGroup = layer.names.length > 1;
                                    if (!isGroup) {
                                        var layerNodes = layer.wrap.getAllLayerNodes();
                                        for (var i = 0; i < layerNodes.length; i++) {
                                            var node = layerNodes[i];
                                            if (layer.wrap.getName(node) === name) {
                                                layerNode = node;
                                                if (layer.wrap.getLayerNodes(node).length > 0) {
                                                    isGroup = true;
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }

                                const typeElm = li.querySelector('.' + self.CLASS + '-type');
                                const className = isGroup ? self.CLASS + '-type-grp' : self.CLASS + '-type-sgl';
                                typeElm.classList.add(className);

                                if (!hasInfo) {
                                    li.querySelector('.' + self.CLASS + '-btn-info').classList.add(TC.Consts.classes.HIDDEN);
                                }

                                if (layerNode) {
                                    layer.wrap.normalizeLayerNode(layerNode);

                                    dust.render(className, layerNode, function (err, out) {
                                        var tip;
                                        
                                        typeElm.addEventListener('mouseover', function (e) {
                                            const mapDiv = self.map.div;
                                            const typeElmRect = typeElm.getBoundingClientRect();
                                            tip = document.createElement('div');
                                            tip.classList.add(self.CLASS + '-tip');
                                            tip.innerHTML = out;
                                            tip.style.top = (typeElmRect.top - mapDiv.offsetTop) + 'px';
                                            tip.style.right = mapDiv.offsetWidth - (typeElmRect.left - mapDiv.offsetLeft) + 'px';
                                            mapDiv.appendChild(tip);
                                        });
                                        typeElm.addEventListener('mouseout', function (e) {
                                            tip.parentElement.removeChild(tip);
                                        });
                                    });
                                }
                                const ul = self.div.querySelector('ul');
                                $(li).data(_dataKeys.layer, layer);

                                const lis = self.getLayerUIElements();
                                const layerList = self.map.workLayers
                                    .filter(function (l) {
                                        return !l.stealth;
                                    });
                                const layerIdx = layerList.indexOf(layer);
                                var inserted = false;
                                for (var i = 0, ii = lis.length; i < ii; i++) {
                                    const referenceLi = lis[i];
                                    const referenceLayer = $(referenceLi).data(_dataKeys.layer);
                                    const referenceLayerIdx = layerList.indexOf(referenceLayer);
                                    if (referenceLayerIdx < layerIdx) {
                                        referenceLi.insertAdjacentElement('beforebegin', li);
                                        inserted = true;
                                        break;
                                    }
                                }
                                if (!inserted) {
                                    ul.appendChild(li);
                                }
                                if (domReadyPromise) domReadyPromise(li);
                                self.updateScale();
                            });
                        });
                    }
                );

                var elligibleLayersNum = getElligibleLayersNumber(self);
                const numElm = self.div.querySelector('.' + self.CLASS + '-n');
                const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
                const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
                numElm.textContent = elligibleLayersNum;
                if (elligibleLayersNum > 0) {
                    numElm.classList.add(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.add(TC.Consts.classes.HIDDEN);
                    contentElm.classList.remove(TC.Consts.classes.HIDDEN);
                }
                else {
                    numElm.classList.remove(TC.Consts.classes.VISIBLE);
                    emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
                    contentElm.classList.add(TC.Consts.classes.HIDDEN);
                }

                const deleteAllElm = self.div.querySelector('.' + self.CLASS + '-del-all');
                if (shouldBeDelAllVisible(self)) {
                    deleteAllElm.classList.remove(TC.Consts.classes.HIDDEN);
                } else {
                    deleteAllElm.classList.add(TC.Consts.classes.HIDDEN);
                }
            }
        }
    };

    ctlProto.updateScale = function () {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);
            if (layer.names) {
                var isVisible = false;
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        isVisible = true;
                        break;
                    }
                }
                const notVisibleClass = self.CLASS + '-elm-notvisible';
                if (isVisible) {
                    li.classList.remove(notVisibleClass);
                }
                else {
                    li.classList.add(notVisibleClass);
                }
            }
        });
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        //TC.control.MapContents.prototype.updateLayerOrder.call(this, layer, oldIdx, newIdx);
        const self = this;
        self.map.workLayers
            .filter(function (layer) {
                return !layer.stealth;
            })
            .forEach(function (layer) {
                const li = findLayerElement(self, layer);
                if (li) {
                    li.parentElement.firstChild.insertAdjacentElement('beforebegin', li);
                }
            });
    };

    ctlProto.removeLayer = function (layer) {
        var self = this;
        var idx = self.layers.indexOf(layer);
        if (idx >= 0) {
            self.layers.splice(idx, 1);
        }
        self.getLayerUIElements().forEach(function (li) {
            if ($(li).data(_dataKeys.layer) === layer) {
                li.parentElement.removeChild(li);
            }
        });
        const contentElm = self.div.querySelector('.' + self.CLASS + '-content');
        const emptyElm = self.div.querySelector('.' + self.CLASS + '-empty');
        const numberElm = self.div.querySelector('.' + self.CLASS + '-n');
        var nChildren = getElligibleLayersNumber(self);
        numberElm.textContent = nChildren;
        if (nChildren > 0) {
            contentElm.classList.remove(TC.Consts.classes.HIDDEN);
            emptyElm.classList.add(TC.Consts.classes.HIDDEN);
            numberElm.classList.add(TC.Consts.classes.VISIBLE);
        }
        else {
            if (shouldBeDelAllVisible(self)) {
                self.div.querySelector('.' + self.CLASS + '-del-all').classList.add(TC.Consts.classes.HIDDEN);
            }
            contentElm.classList.add(TC.Consts.classes.HIDDEN);
            emptyElm.classList.remove(TC.Consts.classes.HIDDEN);
            numberElm.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        const result = [];
        const children = self.div.querySelector('ul').children;
        for (var i = 0, len = children.length; i < len; i++) {
            child = children[i];
            if (child.matches('li.' + self.CLASS + '-elm')) {
                result[result.length] = child;
            }
        }
        return result;
    };

    //analiza la nueva capa añadida si tiene habilitado o no el WFS
    const checkWFSAvailable = function (layer) {
        var fncResolve = null;
        var domReadyPromise = new Promise(function (resolve, reject) {
            fncResolve = resolve;
        })
        var cssClassUnavailable = 'tc-unavailable';
        
        var queryButton;
        domReadyPromise.then(function (li) {
            queryButton = document.createElement('div');
            queryButton.classList.add(ctlProto.CLASS + '-btn-query');
            queryButton.classList.add(TC.Consts.classes.LOADING);
            queryButton.setAttribute('title', ctlProto.getLocaleString('query.tooltipMagnifBtn'));
            li.querySelector('.' + ctlProto.CLASS + '-btn-info').insertAdjacentElement('afterend', queryButton);
        });
        var getCapProm = layer.getWFSCapabilitiesPromise()
        const noWFSAvailabeManage = function () {
            if (queryButton) {
                queryButton.classList.remove(TC.Consts.classes.LOADING);
                queryButton.classList.add(cssClassUnavailable);
            }
            //queryButton.attr("title", getLocaleString("query.tooltipMagnifBtnDisabled"));
            console.log("El servicio " + (layer.title || layer.tree.title) + " no tiene disponible el WFS");
        }
        Promise.all([getCapProm, domReadyPromise]).then(function () {
            var capabilities = arguments[0][0];
            //comprobamos que la solo es una capa y existe en el capabilities del WFS                        
            if (queryButton) {
                queryButton.classList.remove(TC.Consts.classes.LOADING)
                var layers = layer.getDisgregatedLayerNames();
                if (layers.length === 1 && !capabilities.FeatureTypes.hasOwnProperty(layers[0].substring(layers[0].indexOf(":") + 1))) {
                    queryButton.classList.add(cssClassUnavailable);
                    //queryButton.attr("title", getLocaleString("query.tooltipMagnifBtnDisabled"));
                    console.log("El servicio WFS de " + (layer.title || layer.tree.title) + " no dispone de la capa " + layers[0]);
                }
            }

        }).catch(noWFSAvailabeManage);
        getCapProm.catch(noWFSAvailabeManage);
        return fncResolve;
    }
})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Click = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if (self.options && self.options.callback) {
        self.callback = self.options.callback;
    }

    self.wrap = new TC.wrap.control.Click(self);
};

TC.inherit(TC.control.Click, TC.Control);

(function () {
    var ctlProto = TC.control.Click.prototype;

    ctlProto.CLASS = 'tc-ctl-click';

    ctlProto.register = function (map) {
        var self = this;
        self.wrap.register(map);
        return TC.Control.prototype.register.call(self, map);
    };

    ctlProto.activate = function () {
        var self = this;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate();
    };

    ctlProto.deactivate = function () {
        var self = this;
        self.wrap.deactivate();
        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.callback = function (coord, point) {
        console.log('[Click][' + coord[0] + ', ' + coord[1] + '][' + point[0] + ', ' + point[1] + ']');
    };
})();
﻿TC.control = TC.control || {};

if (!TC.control.Click) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Click');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';
TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';

TC.control.FeatureInfoCommons = function () {
    const self = this;
    TC.control.Click.apply(self, arguments);

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        LIST_ITEM: 'ul' + cs + '-features li'
    };

    self.resultsLayer = null;
    self.filterLayer = null;
    self._layersPromise = null;
    self.filterFeature = null;
    self.info = null;
    self.popup = null;
    self.resultsPanel = null;
    self.lastFeatureCount = null;
    self.exportsState = true;
};

TC.control.FeatureInfoCommons.displayMode = {
    POPUP: 'popup',
    RESULTS_PANEL: 'resultsPanel'
};

(function () {

    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) { return 0; }
                if (number === 0 || !isFinite(number)) { return number; }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };

            // La propiedad length del método from es 1.
            return function from(arrayLike/*, mapFn, thisArg */) {
                // 1. Deje a C ser el este valor.
                var C = this;

                // 2. Deje que los elementos sean ToObject(arrayLike).
                var items = Object(arrayLike);

                // 3. Retornar IfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError("Array.from requiere un objeto array-like - not null or undefined");
                }

                // 4. Si mapfn no está definida, entonces deja que sea false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. si no
                    // 5. a If IsCallable(mapfn) es false, lanza una excepción TypeError.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: si hay mapFn, el segundo argumento debe ser una función');
                    }

                    // 5. b. Si thisArg se suministró, deje que T sea thisArg; si no, deje que T esté indefinido.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }

                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);

                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);

                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    } else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }

    var layerCount = function (ctl) {
        return ctl.info.services ?
            ctl.info.services.reduce(function (sCount, service) {
                return sCount + service.layers.reduce(function (lCount, layer) {
                    return lCount + 1;
                }, 0);
            }, 0) : 0;
    };

    TC.inherit(TC.control.FeatureInfoCommons, TC.control.Click);

    var ctlProto = TC.control.FeatureInfoCommons.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

    ctlProto.TITLE_SEPARATOR = ' • ';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FeatureInfo.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["elevation"], false), ctx, { "block": body_1 }, {}).w("<ul class=\"tc-ctl-finfo-services\">").s(ctx.get(["services"], false), ctx, { "else": body_4, "block": body_6 }, {}).w("</ul>").x(ctx.get(["featureCount"], false), ctx, { "block": body_30 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-finfo-coords\"><span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-crs\">CRS: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.get(["crs"], false), ctx, "h").w("</span></span> ").x(ctx.get(["isGeo"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" <span class=\"tc-ctl-finfo-coords-pair\">").h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.get(["elevation"], false), ctx, "h").w(" m</span></span></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-x\">x: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "0"]), ctx, "h").w("</span></span> <span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-x\">y: <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "1"]), ctx, "h").w("</span></span> "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-lat\">").h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "1"]), ctx, "h").w("</span></span> <span class=\"tc-ctl-finfo-coords-pair tc-ctl-finfo-coords-lon\">").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-finfo-coords-val\">").f(ctx.getPath(false, ["coords", "0"]), ctx, "h").w("</span></span> "); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.nx(ctx.get(["elevation"], false), ctx, { "block": body_5 }, {}); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</li>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<li><h3>").x(ctx.get(["title"], false), ctx, { "else": body_7, "block": body_10 }, {}).w("</h3><div class=\"tc-ctl-finfo-service-content\">").s(ctx.get(["hasLimits"], false), ctx, { "else": body_11, "block": body_29 }, {}).w("</div></li>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.x(ctx.getPath(false, ["layers", "0", "title"]), ctx, { "else": body_8, "block": body_9 }, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.f(ctx.getPath(false, ["layer", "name"]), ctx, "h"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.f(ctx.getPath(false, ["layers", "0", "title"]), ctx, "h"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.f(ctx.get(["title"], false), ctx, "h"); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.w("<ul class=\"tc-ctl-finfo-layers\">").s(ctx.get(["layers"], false), ctx, { "else": body_12, "block": body_13 }, {}).w("</ul>"); } body_11.__dustBody = !0; function body_12(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noDataAtThisService" }).w("</li>"); } body_12.__dustBody = !0; function body_13(chk, ctx) { return chk.w("<li><h4><span class=\"tc-ctl-finfo-layer-n\">").f(ctx.getPath(false, ["features", "length"]), ctx, "h").w("</span> ").s(ctx.get(["path"], false), ctx, { "block": body_14 }, {}).w("</h4> <div class=\"tc-ctl-finfo-layer-content\"><ul class=\"tc-ctl-finfo-features\">").s(ctx.get(["features"], false), ctx, { "else": body_16, "block": body_17 }, {}).w("</ul></div></li>"); } body_13.__dustBody = !0; function body_14(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_15 }, {}); } body_14.__dustBody = !0; function body_15(chk, ctx) { return chk.w(" &bull; "); } body_15.__dustBody = !0; function body_16(chk, ctx) { return chk.w("<li class=\"tc-ctl-finfo-empty\">").h("i18n", ctx, {}, { "$key": "noDataInThisLayer" }).w("</li>"); } body_16.__dustBody = !0; function body_17(chk, ctx) { return chk.w("<li>").x(ctx.get(["rawContent"], false), ctx, { "else": body_18, "block": body_23 }, {}).w("</li>"); } body_17.__dustBody = !0; function body_18(chk, ctx) { return chk.x(ctx.get(["error"], false), ctx, { "else": body_19, "block": body_22 }, {}); } body_18.__dustBody = !0; function body_19(chk, ctx) { return chk.w("<h5>").f(ctx.get(["id"], false), ctx, "h").w("</h5><table").x(ctx.get(["geometry"], false), ctx, { "block": body_20 }, {}).w("><tbody>").s(ctx.get(["attributes"], false), ctx, { "block": body_21 }, {}).w("</tbody></table>"); } body_19.__dustBody = !0; function body_20(chk, ctx) { return chk.w(" title=\"").h("i18n", ctx, {}, { "$key": "clickToShowOnMap" }).w("\""); } body_20.__dustBody = !0; function body_21(chk, ctx) { return chk.w("<tr><th class=\"tc-ctl-finfo-attr\">").f(ctx.get(["name"], false), ctx, "h").w("</th><td class=\"tc-ctl-finfo-val\">").f(ctx.get(["value"], false), ctx, "h").w("</td></tr>"); } body_21.__dustBody = !0; function body_22(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-errors\">").h("i18n", ctx, {}, { "$key": "fi.error" }).w("<span class=\"tc-ctl-finfo-error-text\">").f(ctx.get(["error"], false), ctx, "h").w("</span></span>"); } body_22.__dustBody = !0; function body_23(chk, ctx) { return chk.w("<h5>").h("i18n", ctx, {}, { "$key": "feature" }).w("</h5>").h("eq", ctx, { "else": body_24, "block": body_25 }, { "key": ctx.get(["rawFormat"], false), "value": "text/html" }); } body_23.__dustBody = !0; function body_24(chk, ctx) { return chk.w("<pre>").f(ctx.get(["rawContent"], false), ctx, "h").w("</pre>"); } body_24.__dustBody = !0; function body_25(chk, ctx) { return chk.w(" ").x(ctx.get(["expandUrl"], false), ctx, { "block": body_26 }, {}); } body_25.__dustBody = !0; function body_26(chk, ctx) { return chk.h("ne", ctx, { "else": body_27, "block": body_28 }, { "key": ctx.get(["expandUrl"], false), "value": "" }); } body_26.__dustBody = !0; function body_27(chk, ctx) { return chk.w("<iframe src=\"").f(ctx.get(["rawUrl"], false), ctx, "h").w("\"></iframe>"); } body_27.__dustBody = !0; function body_28(chk, ctx) { return chk.w("<div class=\"tc-ctl-finfo-features-iframe-cnt\"><iframe src=\"").f(ctx.get(["rawUrl"], false), ctx, "h").w("\"></iframe><a class=\"tc-ctl-finfo-open\" onclick=\"window.open('").f(ctx.get(["expandUrl"], false), ctx, "h").w("', '_blank')\" title=\"").h("i18n", ctx, {}, { "$key": "expand" }).w("\"></a></div>"); } body_28.__dustBody = !0; function body_29(chk, ctx) { return chk.w("<span class=\"tc-ctl-finfo-errors\">").f(ctx.get(["hasLimits"], false), ctx, "h").w("</span>"); } body_29.__dustBody = !0; function body_30(chk, ctx) { return chk.h("gt", ctx, { "block": body_31 }, { "key": ctx.get(["featureCount"], false), "value": "1", "type": "number" }); } body_30.__dustBody = !0; function body_31(chk, ctx) { return chk.w("<a class=\"tc-ctl-btn tc-ctl-finfo-btn-prev\">").h("i18n", ctx, {}, { "$key": "previous" }).w("</a><div class=\"tc-ctl-finfo-counter\"><span class=\"tc-ctl-finfo-counter-current\"></span>/").f(ctx.get(["featureCount"], false), ctx, "h").w("</div><a class=\"tc-ctl-btn tc-ctl-finfo-btn-next\">").h("i18n", ctx, {}, { "$key": "next" }).w("</a>"); } body_31.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.Click.prototype.register.call(self, map);

        self._createLayers();

        map.loaded(function () {
            const shareCtl = map.getControlsByClass('TC.control.Share')[0];
            if (shareCtl) {
                self.loadSharedFeature(shareCtl.loadParamFeature());
            }
        });

        self.displayMode = self.options.displayMode || TC.control.FeatureInfoCommons.displayMode.POPUP;
        self.setDisplayMode(self.displayMode);

        map
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                if (e.control === self.getDisplayControl() && self.resultsLayer) {
                    if (self.highlightedFeature) {
                        self.resultsLayer.removeFeature(self.highlightedFeature);
                        self.highlightedFeature = null;
                    }
                    if (!self.querying) {
                        self.filterLayer.clearFeatures();
                    }
                }
            })
            .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.highlightedFeature = null;
            })
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                const control = e.control;
                if (control.currentFeature !== self.filterFeature) {
                    self.highlightedFeature = control.currentFeature;
                }

                // GLS: si la feature es resultado de GFI decoramos
                if (e.control.currentFeature &&
                    e.control.currentFeature.layer &&
                    self.filterLayer &&
                    self.resultsLayer &&
                    [self.filterLayer.id, self.resultsLayer.id].indexOf(e.control.currentFeature.layer.id) > -1) {
                    self._decorateDisplay(control);
                }
            })
            .on(TC.Consts.event.DRAWCHART, function (e) {
                setTimeout(function () {
                    self.highlightedFeature = e.control.currentFeature;
                }, 50);
            })
            .on(TC.Consts.event.LAYERREMOVE, function () {
                if (self.info && self.info.services) {
                    const services = {};
                    self.map.workLayers
                        .filter(function (layer) {
                            return layer.type === TC.Consts.layerType.WMS;
                        })
                        .forEach(function (layer) {
                            const names = services[layer.url] || [];
                            services[layer.url] = names.concat(layer.getDisgregatedLayerNames())
                        });
                    for (var i = 0, len = self.info.services.length; i < len; i++) {
                        const service = self.info.services[i];
                        const mapNames = services[service.mapLayers[0].url] || [];
                        const infoNames = service.layers.reduce(function (arr, layer) {
                            return arr.concat(layer.name);
                        }, []);
                        if (!infoNames.every(function (name) {
                            return mapNames.indexOf(name) >= 0;
                        })) {
                            // En el objeto info hay capas que no están ya en el mapa: borramos resultados.
                            self.downplayFeatures();
                            self.info = null;
                            self.closeResults();
                            break;
                        }
                    }
                }
            })
            .on(TC.Consts.event.VIEWCHANGE, function (e) {                
                self.closeResults();
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        // Este div se usa como buffer, así que no debe ser visible.
        self.div.classList.add(TC.Consts.classes.HIDDEN);
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.responseCallback = function (options) {
        const self = this;
        self.querying = false;

        if (self.filterFeature) {
            self.info = { services: options.services };
        }

        if (!options.featureCount) {
            self.lastFeatureCount = 0;
            self.map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self });
            self.closeResults();
        }
        else {
            self._addSourceAttributes();
            self.lastFeatureCount = options.featureCount;
            self.map.trigger(TC.Consts.event.FEATUREINFO, $.extend({ control: self }, options));
        }
    };

    ctlProto.responseError = function (options) {
        const self = this;
        if (options.status === 404) {
            self.map.toast(self.getLocaleString("featureInfo.tooManyLayers"), { type: TC.Consts.msgType.ERROR });
        }
        self.responseCallback({});
    };

    ctlProto.markerStyle = {
        cssClass: TC.Consts.classes.POINT,
        anchor: [0.5, 0.5],
        width: 15,
        height: 15,
        noPrint: true
    };

    ctlProto.setDisplayMode = function (mode) {
        var self = this;
        self.displayMode = mode;
        var map = self.map;
        switch (mode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (!self.resultsPanel) {
                    var rp = map.getControlsByClass('TC.control.ResultsPanel').filter(function (ctrl) { return ctrl.options.content === "table" })[0];
                    if (rp) {
                        self.resultsPanel = rp;
                        rp.caller = self;
                    }
                    else {
                        var setResultsPanel = function setResultsPanel(e) {
                            const control = e.control;
                            if (TC.control.ResultsPanel && control instanceof TC.control.ResultsPanel) {
                                self.resultsPanel = control;
                                control.caller = self;
                                map.off(TC.Consts.event.CONTROLADD, setResultsPanel);
                            }
                        };
                        map.on(TC.Consts.event.CONTROLADD, setResultsPanel);
                    }
                }
                break;
            default:
                self.displayMode = TC.control.FeatureInfoCommons.displayMode.POPUP;
                if (!self.popup) {
                    map.addControl('popup', {
                        closeButton: true,
                        draggable: self.options.draggable
                    }).then(function (popup) {
                        self.popup = popup;
                        popup.caller = self;
                        map.on(TC.Consts.event.POPUP, function (e) {
                            self.onShowPopup(e);
                        });

                        map.on(TC.Consts.event.POPUPHIDE, function (e) {
                            if (e.control === popup) {
                                //restaurar el ancho automático
                                self._resetSize();
                            }
                        });
                    });
                }
                break;
        }
    };

    ctlProto.getDisplayControl = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel;
            default:
                return self.popup;
        }
    };

    ctlProto.getDisplayTarget = function (options) {
        var self = this;
        options = options || {};
        if (options.control) {
            switch (true) {
                case TC.control.Popup && options.control instanceof TC.control.Popup:
                    return options.control.getContainerElement();
                case TC.control.ResultsPanel && options.control instanceof TC.control.ResultsPanel:
                    return options.control.getTableContainer();
                default:
                    return null;
            }
        }
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getTableContainer();
            default:
                return self.popup.getContainerElement();
        }
    };

    ctlProto.getMenuTarget = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                return self.resultsPanel.getMenuElement();
            default:
                return self.popup.getMenuElement();
        }
    };

    ctlProto.displayResults = function () {
        var self = this;
        const clone = self.div.cloneNode(true);
        clone.classList.remove(TC.Consts.classes.HIDDEN);
        self.filterFeature.data = clone.outerHTML;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel) {

                    // GLS: si contamos con el control de controles no es necesario cerrar los paneles visibles ya que no habría solape
                    if (self.map.getControlsByClass(TC.control.ControlContainer).length === 0) {
                        self.map.getControlsByClass(TC.control.ResultsPanel).forEach(function (p) {
                            if (p.isVisible()) {
                                p.close();
                            }
                        });
                    } else {
                        // cerramos los paneles con feature asociada
                        const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                        panels.forEach(function (p) {
                            if (p !== self.resultsPanel && p.currentFeature) {
                                p.close();
                            }
                        });
                    }

                    self.resultsPanel.currentFeature = self.filterFeature;
                    self.resultsPanel.open(self.filterFeature.data, self.resultsPanel.getInfoContainer());
                    

                    self.displayResultsCallback();
                }

                break;
            default:
                if (self.popup) {
                    self.filterFeature.showPopup(self.popup);
                }
                break;
        }
    };

    const getElementIndex = function (elm) {
        return Array.from(elm.parentElement.childNodes).indexOf(elm);
    };

    const getParentElement = function (elm, tagName) {
        var result = elm;
        do {
            result = result.parentElement;
        }
        while (result && result.tagName !== tagName);
        return result;
    };

    ctlProto.getFeatureElement = function (feature) {
        const self = this;
        var result;
        const getIndex = function (elm) {
            return Array.from(elm.parentElement.childNodes).getIndex(elm);
        };
        self.getDisplayTarget().querySelectorAll(self._selectors.LIST_ITEM).forEach(function (li) {
            const currentFeatureLi = li;
            const currentLayerLi = getParentElement(li, 'LI');
            const currentServiceLi = getParentElement(currentLayerLi, 'LI');
            var feat = self.getFeature(getElementIndex(currentServiceLi), getElementIndex(currentLayerLi), getElementIndex(currentFeatureLi));
            if (feat === feature) {
                result = currentFeatureLi;
            }
        });
        return result;
    };

    ctlProto.getNextFeatureElement = function (delta) {
        const self = this;
        const lis = self.getDisplayTarget().querySelectorAll('ul.' + self.CLASS + '-features > li');
        const length = lis.length;
        for (var i = 0; i < length; i++) {
            if (lis[i].matches('.' + TC.Consts.classes.CHECKED)) {
                return lis[(i + delta + length) % length]
            }
        }
        return null;
    };

    ctlProto.getFeaturePath = function (feature) {
        const self = this;
        if (self.info && self.info.services) {
            for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                const service = self.info.services[i];
                for (var j = 0, jj = service.layers.length; j < jj; j++) {
                    const layer = service.layers[j];
                    for (var k = 0, kk = layer.features.length; k < kk; k++) {
                        if (layer.features[k] === feature) {
                            return {
                                service: service.title || service.mapLayers.reduce(function (prev, cur) {
                                    return prev || cur.title;
                                }, ''),
                                layer: layer.path
                            };
                        }
                    }
                }
            }
        }
        return null;
    };

    ctlProto.closeResults = function () {
        var self = this;
        switch (self.displayMode) {
            case TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL:
                if (self.resultsPanel && self.resultsPanel.isVisible()) {
                    self.resultsPanel.close();
                }
                break;
            default:
                if (self.popup && self.popup.isVisible()) {
                    self.popup.hide();
                }
                break;
        }
    };

    ctlProto.displayResultsCallback = function () {
        var self = this;
        const content = self.getDisplayTarget().querySelector('.' + self.CLASS);

        var selector;
        // Evento para resaltar una feature
        var eventType = 'click'; // En iPad se usa click en vez de touchstart para evitar que se resalte una feature al hacer scroll
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(self._selectors.LIST_ITEM, function (e) {
            self.highlightFeature(e.target);
        }));

        // Evento para ir a la siguiente feature
        eventType = TC.Consts.event.CLICK;
        selector = '.' + self.CLASS + '-btn-next';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(1), 1);
            return false;
        }));

        // Evento para ir a la feature anterior
        selector = '.' + self.CLASS + '-btn-prev';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.highlightFeature(self.getNextFeatureElement(-1), -1);
            return false;
        }));

        // Evento para desplegar/replegar features de capa
        selector = 'ul.' + self.CLASS + '-layers h4';

        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            const li = getParentElement(e.target, 'LI');
            if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                // Si no está en modo móvil ocultamos la capa (si hay más de una)
                if (content.querySelector('.tc-ctl-finfo-btn-next') && content.querySelector('.tc-ctl-finfo-btn-next').style.display === 'none') {
                    if (layerCount(self) > 1) {
                        self.downplayFeatures();
                    }
                }
            }
            else {
                self.highlightFeature(li.querySelector(self._selectors.LIST_ITEM));
                if (self.displayMode === TC.control.FeatureInfoCommons.displayMode.POPUP) {
                    self.popup.fitToView(true);
                }
            }
        }));

        // Evento para borrar la feature resaltada
        selector = '.' + self.CLASS + '-del-btn';
        content.addEventListener(eventType, TC.EventTarget.listenerBySelector(selector, function (e) {
            self.downplayFeatures();
            self.closeResults();
        }));

        if (self.info) {
            if (self.info.defaultFeature && self.getFeatureElement(self.info.defaultFeature)) {
                self.getFeatureElement(self.info.defaultFeature).classList.add(TC.Consts.classes.DEFAULT);
                self.highlightFeature(self.info.defaultFeature);
            }
            else if (content.querySelector(self._selectors.LIST_ITEM)) {
                self.highlightFeature(content.querySelector(self._selectors.LIST_ITEM));
            }
        }

        content.querySelectorAll('table').forEach(function (table) {
            table.addEventListener(TC.Consts.event.CLICK, function (e) {                
                const li = this.parentElement;
                if (li.classList.contains(TC.Consts.classes.DISABLED)) {
                    return;
                }
                if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                    // Si ya está seleccionada hacemos zoom
                    if (self.resultsLayer.features[0] && window.getSelection() && window.getSelection().toString().trim().length === 0) {
                        // Proceso para desactivar highlightFeature mientras hacemos zoom
                        var zoomHandler = function zoomHandler() {
                            self._zooming = false;
                            self.map.off(TC.Consts.event.ZOOM, zoomHandler);
                        };
                        self.map.on(TC.Consts.event.ZOOM, zoomHandler);
                        self._zooming = true;
                        ///////
                        
                        self.map.zoomToFeatures([self.resultsLayer.features[0]], { animate: true });
                    }
                }
                else {
                    // Si no está seleccionada la seleccionamos
                    self.highlightFeature(li);
                }
                e.stopPropagation();
            });
        });
        content.querySelectorAll('table a').forEach(function (a) {
            a.addEventListener("click", function (e) {
                e.stopPropagation();
            });
        });

        if (Modernizr.touch && self.displayMode === TC.control.FeatureInfoCommons.displayMode.RESULTS_PANEL) {
            if (content.querySelector('.' + self.CLASS + '-btn-prev') && content.querySelector('.' + self.CLASS + '-btn-prev').style.display !== 'none') { // Si los botones de anterior/siguiente están visibles, montamos el swipe
                if (self.resultsPanel) {
                    TC.Util.swipe(self.resultsPanel.div, 'disable');
                }

                if (layerCount(self) > 1) {
                    TC.Util.swipe(content, {
                        left: function () {
                            self.highlightFeature(self.getNextFeatureElement(1), 1);
                        },
                        right: function () {
                            self.highlightFeature(self.getNextFeatureElement(-1), -1);
                        }
                    });
                }
            }
        }
    };

    ctlProto.onShowPopup = function (e) {
        var self = this;
        var map = self.map;
        var transitionEnd = 'transitionend.tc';
        if (e.control === self.popup) {

            self.displayResultsCallback();

            //ajustar el ancho para que no sobre a la derecha
            self._fitSize();
        }
    };

    ctlProto.loadSharedFeature = function (featureObj) {

    };

    ctlProto.insertLinks = function () {
        var self = this;
        const linkText = self.getLocaleString('open');
        const titleText = self.getLocaleString('linkInNewWindow');
        self.div.querySelectorAll('td.' + self.CLASS + '-val').forEach(function (td) {
            const text = td.textContent;
            if (TC.Util.isURL(text)) {
                td.innerHTML = '<a href="' + text + '" target="_blank" title="' + titleText + '">' + linkText + '</a>';
            }
        });
    };

    ctlProto.highlightFeature = function (featureOrElement, delta) {
        const self = this;
        var feature;
        if (!self._zooming) {
            var featureLi;
            // this puede ser o el elemento HTML de la lista correspondiente a la feature o la feature en sí
            if (featureOrElement instanceof TC.Feature) {
                feature = featureOrElement;
                featureLi = self.getFeatureElement(feature);
            }
            else {
                featureLi = featureOrElement;
                while (featureLi && featureLi.tagName !== 'LI') {
                    featureLi = featureLi.parentElement;
                }
            }
            const layerLi = getParentElement(featureLi, 'LI');
            const serviceLi = getParentElement(layerLi, 'LI');

            const serviceIdx = getElementIndex(serviceLi);
            const layerIdx = getElementIndex(layerLi);
            const featureIdx = getElementIndex(featureLi);
            feature = feature || self.getFeature(serviceIdx, layerIdx, featureIdx);

            self.downplayFeatures({ exception: feature });
            featureLi.classList.add(TC.Consts.classes.CHECKED);
            layerLi.classList.add(TC.Consts.classes.CHECKED);
            serviceLi.classList.add(TC.Consts.classes.CHECKED);
            if (delta > 0) {
                featureLi.classList.add(TC.Consts.classes.FROMLEFT);
                layerLi.classList.add(TC.Consts.classes.FROMLEFT);
                serviceLi.classList.add(TC.Consts.classes.FROMLEFT);
            }
            else if (delta < 0) {
                featureLi.classList.add(TC.Consts.classes.FROMRIGHT);
                layerLi.classList.add(TC.Consts.classes.FROMRIGHT);
                serviceLi.classList.add(TC.Consts.classes.FROMRIGHT);
            }

            if (featureLi.querySelector('table')) {
                featureLi.querySelector('table').setAttribute('title', self.getLocaleString('clickToCenter'));
            }

            self.highlightedFeature = feature;

            if (self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current')) {
                self.getDisplayTarget().querySelector('.' + self.CLASS + '-counter-current').innerHTML = self.getFeatureIndex(serviceIdx, layerIdx, featureIdx) + 1;
            }


            var features = self.resultsLayer.features.slice();
            var featureAlreadyHighlighted = features.filter(function (item) {
                return feature && feature.id === item.id;
            });

            //Si la feature a resaltar ya está resaltada, no hacemos nada. Así evitamos parpadeo
            if (featureAlreadyHighlighted.length > 0) {
                return;
            }

            for (var i = 0; i < features.length; i++) {
                var f = features[i];
                if (f !== self.filterFeature) {
                    self.resultsLayer.removeFeature(f);
                }
            }
            if (feature && feature.geometry) {
                self.resultsLayer.addFeature(feature);
            }
            else {
                featureLi.classList.add(TC.Consts.classes.DISABLED);
            }
        }
    };

    ctlProto.downplayFeatures = function (options) {
        const self = this;
        options = options || {};
        if (self.highlightedFeature !== options.exception) {
            self.highlightedFeature = null;
        }
        const exceptionFLi = options.exception ? self.getFeatureElement(options.exception) : undefined;
        var exceptionLLi, exceptionSLi;
        if (exceptionFLi) {
            exceptionLLi = getParentElement(exceptionFLi, 'LI');
            exceptionSLi = getParentElement(exceptionLLi, 'LI');
        }

        self.resultsLayer.clearFeatures();
        const target = self.getDisplayTarget();
        Array.from(target.querySelectorAll('ul.' + self.CLASS + '-services li'))
            .filter(function (li) {
                return li !== exceptionFLi && li !== exceptionLLi && li !== exceptionSLi;
            })
            .forEach(function (li) {
                li.classList.remove(TC.Consts.classes.CHECKED);
                li.classList.remove(TC.Consts.classes.DISABLED);
                li.classList.remove(TC.Consts.classes.FROMLEFT);
                li.classList.remove(TC.Consts.classes.FROMRIGHT);
            })
        target.querySelectorAll('.' + self.CLASS + '-features table').forEach(function (table) {
            table.setAttribute('title', self.getLocaleString('clickToShowOnMap'));
        });
    };

    ctlProto._fitSize = function () {
        const self = this;
        const target = self.getDisplayTarget();
        var max = 0;
        //medir la máxima anchura de <ul>
        target.querySelectorAll(".tc-ctl-finfo-features li").forEach(function (elm) {
            max = Math.max(max, elm.offsetLeft + elm.offsetWidth);
        });

        //alert("max=" + max);
        if (max) {
            target.style.width = max + 50 + 'px';
        }
    };

    ctlProto._resetSize = function () {
        const self = this;
        self.getDisplayTarget().style.removeProperty('width');
    };

    ctlProto.getFeature = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result;
        const info = self.info;
        if (info && info.services) {
            result = info.services[serviceIdx];
            if (result) {
                result = result.layers[layerIdx];
                if (result) {
                    result = result.features[featureIdx];
                }
            }
        }
        return result;
    };

    ctlProto.getFeatureIndex = function (serviceIdx, layerIdx, featureIdx) {
        const self = this;
        var result = -1;
        const info = self.info;
        if (info) {
            for (var i = 0; i <= serviceIdx; i++) {
                var service = info.services[i];
                var maxj = i === serviceIdx ? layerIdx : service.layers.length - 1;
                for (var j = 0; j <= maxj; j++) {
                    var layer = service.layers[j];
                    var maxk = j === layerIdx ? featureIdx : layer.features.length - 1;
                    for (var k = 0; k <= maxk; k++) {
                        result = result + 1;
                    }
                }
            }
        }
        return result;
    };

    ctlProto.beforeRequest = function (options) {
        var self = this;
        self.querying = true;
        self.map.trigger(TC.Consts.event.BEFOREFEATUREINFO, {
            xy: options.xy,
            control: self
        });
        self.closeResults();
        if (self.map && self.resultsLayer) {
            self.lastFeatureCount = null;

            self.resultsLayer.features.forEach(function (feature) {
                self.resultsLayer.removeFeature(feature);
            });
            self.info = null;
        }
    };

    ctlProto.activate = function () {
        var self = this;
        if (self.wrap) {
            self.wrap.activate();
        }
        TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function (stopChain) {
        var self = this;
        if (self.popup) {
            self.popup.hide();
        }
        self.resultsLayer.clearFeatures();
        self.filterLayer.clearFeatures();
        if (self.wrap) {
            self.wrap.deactivate();
        }
        TC.Control.prototype.deactivate.call(self, stopChain);
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.resultsLayer) {
            return {
                id: self.id,
                layer: self.resultsLayer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self._layersPromise.then(function () {
            self.resultsLayer.importState(state.layer);
        });
    };

    ctlProto._createLayers = function () {
        const self = this;

        var resultsLayer;
        if (self.options.resultsLayer) { // En caso de que se haya indicado una capa por configuración, la utilizamos
            resultsLayer = self.options.resultsLayer;
        } else {
            resultsLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Results layer',
                type: TC.Consts.layerType.VECTOR,
                stealth: true
            };
        }
        var filterLayer;
        if (self.options.filterLayer) {
            filterLayer = self.options.filterLayer;
        }
        else {
            filterLayer = {
                id: self.getUID(),
                title: self.CLASS + ': Filter layer',
                stealth: true,
                type: TC.Consts.layerType.VECTOR
                , styles: {
                    line: { strokeColor: self.lineColor, strokeWidth: 2 },
                    polygon: { strokeColor: self.lineColor, strokeWidth: 2, fillColor: "#000", fillOpacity: 0.3 }
                }
            };
        }

        const map = self.map;
        self._layersPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                Promise.all([map.addLayer(resultsLayer), map.addLayer(filterLayer)]).then(function (layers) {
                    self.resultsLayer = layers[0];
                    self.filterLayer = layers[1];
                    resolve();
                });
            });
        });

        return self._layersPromise;
    };

    ctlProto._decorateDisplay = function (ctl) {
        const self = this;        

        const resultsContainer = self.getDisplayTarget({ control: ctl });

        // Añadimos botón de imprimir
        TC.loadJS(
            !TC.control.Print,
            [TC.apiLocation + 'TC/control/Print'],
            function () {
                if (!resultsContainer.querySelectorAll('.' + TC.control.Print.prototype.CLASS + '-btn').length) {
                    var printTitle = self.getLocaleString("feature");
                    if (ctl === self.getDisplayControl()) {
                        if (TC.feature.Point && self.filterFeature instanceof TC.feature.Point) {
                            const geom = self.filterFeature.geometry;
                            printTitle = self.getLocaleString('featuresAt', {
                                crs: self.map.crs,
                                x: TC.Util.formatNumber(geom[0], self.map.locale),
                                y: TC.Util.formatNumber(geom[1], self.map.locale)
                            });
                        }
                        else {
                            printTitle = self.getLocaleString('spatialQueryResults');
                        }
                    }
                    else if (ctl.currentFeature) {
                        printTitle = ctl.currentFeature.id;
                    }
                    // Si hay datos porque el popup es de un GFI con éxito o es de una feature resaltada damos la opción de imprimirlos
                    if (self.lastFeatureCount || (ctl.currentFeature && ctl.currentFeature.showsPopup === true)) {
                        new TC.control.Print({
                            target: resultsContainer,
                            title: printTitle
                        });
                    }
                }
            }
        );
    };

    ctlProto._addSourceAttributes = function () {
        const self = this;
        const serviceAttrName = 'h3_' + self.getLocaleString('service');
        const layerAttrName = 'h4_' + self.getLocaleString('layer');
        // Añadimos como atributos los títulos de servicio y capa
        if (self.info && self.info.services) {
            self.info.services.forEach(function (service) {
                service.layers.forEach(function (layer) {
                    layer.features.forEach(function (feature) {
                        if (feature instanceof TC.Feature) {
                            const path = self.getFeaturePath(feature);
                            if (path) {
                                const newData = {};
                                newData[serviceAttrName] = path.service;
                                if (path.layer) {
                                    newData[layerAttrName] = path.layer.join(self.TITLE_SEPARATOR);
                                }
                                const allData = $.extend(newData, feature.getData());
                                feature.clearData();
                                feature.setData(allData);
                            }
                        }
                    });
                });
            });
        }
    };

})();

﻿TC.control = TC.control || {};
TC.Consts = TC.Consts || {};
TC.Consts.SCREEN_SIZE_KEY = 'TC.Map.screenSize';

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Scale = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.Scale, TC.Control);

(function () {
    var ctlProto = TC.control.Scale.prototype;

    ctlProto.CLASS = 'tc-ctl-scl';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Scale.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"ol-scale-line ol-unselectable\"><span>1:").h("math", ctx, {}, { "key": body_1, "method": "round" }).w("</span> <input type=\"button\" value=\"").f(ctx.get(["screenSize"], false), ctx, "h").w("''\" title=\"").h("i18n", ctx, {}, { "$key": "estimatedMapSize" }).w("\" /></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.f(ctx.get(["scale"], false), ctx, "h"); } body_1.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize }, function () {

            const span = self.div.querySelector('span');
            span.textContent = '1:' + self.format(span.textContent.substr(2));

            self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

            if ($.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        var screenSize = TC.Util.storage.getLocalValue(TC.Consts.SCREEN_SIZE_KEY);
        if (screenSize) {
            TC.Cfg.screenSize = screenSize;
        }
        self.render(function () {
            map.on(TC.Consts.event.ZOOM, function () {
                delete self.metersPerDegree;
                self.update();
            });
        });

        return result;
    };

    ctlProto.update = function () {
        this.render();
    };

    /*
     *  setScreenSize: Prompts for screen size in inches, updates and stores value
     */
    ctlProto.setScreenSize = function () {
        var self = this;
        TC.prompt(self.getLocaleString('selectScreenSize'), TC.Cfg.screenSize, function (value) {
            if (value) {
                TC.Cfg.screenSize = parseFloat(value);
                TC.Util.storage.setLocalValue(TC.Consts.SCREEN_SIZE_KEY, TC.Cfg.screenSize);
                self.update();
            }
        });
    };

    /*
     *  getScale: Gets scale denominator with a resolution or current map resolution and estimated screen DPI
     *  Parameters: number (optional), the resolution to get scale from. If no parameter is given, current map resolution is used
     *  Returns: number
     */
    ctlProto.getScale = function (resolution) {
        var self = this;
        var result = 0;
        var res = (!resolution && self.map) ? self.map.wrap.getResolution() : resolution;
        if (res) {
            result = res * self.getDpi(TC.Cfg.screenSize) / .0254;
            if (window.devicePixelRatio) {
                result = result * window.devicePixelRatio;
            }
        }
        if (self.map && self.map.wrap.isGeo()) {
            if (!self.metersPerDegree) {
                var extent = self.map.getExtent();
                if (extent) {
                    self.metersPerDegree = TC.Util.getMetersPerDegree(extent);
                }
            }
            if (self.metersPerDegree) {
                result = result * self.metersPerDegree;
            }
        }
        return result;
    };

    /*
     *  getDpi: Gets estimated DPI based on screen resolution and screenSize value
     *  Returns: number
     */
    ctlProto.getDpi = function (screenSize) {
        var self = this;
        self.dpi = Math.sqrt(screen.width * screen.width + screen.height * screen.height) / screenSize;
        return self.dpi;
    };


    ctlProto.format = function (number) {
        var n = (new Number(number)).toFixed(0);
        var a = [];
        while (n.length > 3) {
            var l = n.length - 3;
            a.unshift(n.substr(l));
            n = n.substr(0, l);
        }
        if (n) {
            a.unshift(n);
        }
        return a.join('.');
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.SWCacheClient = function () {
        const self = this;
        TC.Control.apply(this, arguments);
        self.serviceWorkerEnabled = false;
    };

    TC.inherit(TC.control.SWCacheClient, TC.Control);

    var ctlProto = TC.control.SWCacheClient.prototype;

    ctlProto.CLASS = 'tc-ctl-swcc';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        // Si el navegador es compatible, añadimos el service worker.
        self._swPromise = new Promise(function (resolve, reject) {
            if (navigator.serviceWorker) {

                navigator.serviceWorker.register('tc-cb-service-worker.js', {
                    scope: './'
                }).then(
                    function (reg) {
                        self.serviceWorkerEnabled = true;
                        if (reg.installing) {
                            resolve(reg.installing);
                        } else if (reg.waiting) {
                            resolve(reg.waiting);
                        } else if (reg.active) {
                            resolve(reg.active);
                        }
                        console.log(reg.scope, 'register');
                    },
                    function (reason) {
                        self.serviceWorkerEnabled = false;
                        reject();
                        console.error('Could not register service worker: ' + reason);
                    });
            }
            else {                
                reject(new Error("Browser does not support service workers"));
            }
        });

        return result;
    };

    ctlProto.getServiceWorker = function () {
        if (!this._swPromise) {
            return Promise.reject(new Error('No service worker available'));
        }
        return this._swPromise;
    };

    var addMessageEventListener = function (resolve, reject, cacheName, action, eventName) {
        var MESSAGE = 'message';
        var messageHandler = function messageHandler(event) {
            if (event.data.name === cacheName) {
                if (event.data.action === action && event.data.event === eventName) {
                    resolve(cacheName);
                }
                else if (event.data.event === 'error') {
                    reject();
                }
                navigator.serviceWorker.removeEventListener(MESSAGE, messageHandler);
            }
        };
        navigator.serviceWorker.addEventListener(MESSAGE, messageHandler);
    };

    ctlProto.createCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'create';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'cached');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    list: opts.urlList || [],
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

    ctlProto.deleteCache = function (name, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.getServiceWorker().then(function (sw) {
                var ACTION = 'delete';
                var opts = options || {};
                addMessageEventListener(resolve, reject, name, ACTION, 'deleted');
                sw.postMessage({
                    action: ACTION,
                    name: name,
                    silent: opts.silent
                });
            }, function () {
                resolve(false);
            });
        });
    };

})();

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POINT = 'point.tc';

TC.control.Measure = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.drawControls = [];
    self.persistentDrawControls = false;
    self.NOMEASURE = '-';

    self.exportsState = true;

    this.renderPromise().then(function () {
        self.measureMode = self.options.mode;

        self.history = [];
        self.historyIndex = 0;
        self.reset = true;

        self.wrap = new TC.wrap.control.Measure(self);

        self._len = self.div.querySelector('.tc-ctl-meas-val-len');
        self._area = self.div.querySelector('.tc-ctl-meas-val-area');
        self._peri = self.div.querySelector('.tc-ctl-meas-val-peri');

        self.setMode(self.options.mode);
    });
};

TC.inherit(TC.control.Measure, TC.Control);

(function () {
    var ctlProto = TC.control.Measure.prototype;

    ctlProto.CLASS = 'tc-ctl-meas';

    if (TC.isDebug)
        ctlProto.template = TC.apiLocation + "TC/templates/Measure.html";
    else
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "measure" }).w("</h2><div class=\"tc-ctl-meas-select\"><form><label class=\"tc-ctl-meas-btn-len\"><input type=\"radio\" name=\"mode\" value=\"polyline\" /><span>").h("i18n", ctx, {}, { "$key": "length" }).w("</span></label><label class=\"tc-ctl-meas-btn-area\"><input type=\"radio\" name=\"mode\" value=\"polygon\" /><span>").h("i18n", ctx, {}, { "$key": "areaAndPerimeter" }).w("</span></label></form></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-len tc-hidden\"><div class=\"tc-ctl-meas-line\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "length" }).w(": <span class=\"tc-ctl-meas-val-len\"></span></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-area tc-hidden\"><div class=\"tc-ctl-meas-polygon\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "area" }).w(": <span class=\"tc-ctl-meas-val-area\"></span>, ").h("i18n", ctx, {}, { "$key": "perimeter" }).w(": <span class=\"tc-ctl-meas-val-peri\"></span></div></div>"); } body_0.__dustBody = !0; return body_0 };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(TC.Control.prototype.render.call(self, function () {
            TC.loadJS(
                !TC.control.Draw,
                TC.apiLocation + 'TC/control/Draw',
                function () {
                    if (self.options.mode) {
                        self.div.querySelector('.tc-ctl-meas-select').classList.add(TC.Consts.classes.HIDDEN);
                    }

                    self.div.querySelectorAll('span').forEach(function (span) {
                        span.addEventListener(TC.Consts.event.CLICK, function (e) {
                            var label = this;
                            while (label && label.tagName !== 'LABEL') {
                                label = label.parentElement;
                            }
                            var checkbox = label.querySelector('input[type=radio][name=mode]');
                            var newMode = checkbox.value;

                            checkbox.checked = true;
                            self.setMode(newMode, true);
                        });
                    });

                    if ($.isFunction(callback)) {
                        callback();
                    }
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map).then(function () {
                self.map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (self.map.view === TC.Consts.view.PRINTING) {
                        self.trigger(TC.Consts.event.DRAWEND);
                    }
                });

                const layerId = self.getUID();
                const drawLinesId = self.getUID();
                const drawPolygonsId = self.getUID();

                self.layerPromise = map.addLayer({
                    id: layerId,
                    title: self.getLocaleString('measure'),
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR,
                    styles: {
                        point: map.options.styles.point,
                        line: map.options.styles.line,
                        polygon: map.options.styles.polygon
                    }
                });

                Promise.all([self.layerPromise, self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);

                    self._drawLinesPromise = map.addControl('draw', {
                        id: drawLinesId,
                        div: self.div.querySelector('.tc-ctl-meas-line'),
                        mode: TC.Consts.geom.POLYLINE,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });
                    self._drawPolygonsPromise = map.addControl('draw', {
                        id: drawPolygonsId,
                        div: self.div.querySelector('.tc-ctl-meas-polygon'),
                        mode: TC.Consts.geom.POLYGON,
                        measure: true,
                        persistent: self.persistentDrawControls,
                        styleTools: self.persistentDrawControls,
                        layer: self.layer
                    });

                    Promise.all([self._drawLinesPromise, self._drawPolygonsPromise]).then(function (controls) {
                        self.drawLines = controls[0];
                        self.drawPolygons = controls[1];
                        controls.forEach(function (ctl) {
                            ctl.containerControl = self;
                            self.drawControls.push(ctl);
                            ctl
                                .on(TC.Consts.event.MEASURE + ' ' + TC.Consts.event.MEASUREPARTIAL, function (e) {
                                    self.showMeasures(e);
                                })
                                .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                    // Alerta de condición de carrera si no ponemos un timeout:
                                    // 1- Se llama a cancel de un control Draw.
                                    // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                    // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                    // 4- Se llama a cancel desde aquí.
                                    // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                    // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                    // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                    setTimeout(function () {
                                        self.cancel();
                                    }, 100);
                                });
                            // Desactivamos el método exportState que ya se encarga el control padre de ello
                            ctl.exportsState = false;
                        });

                        resolve(self);
                        self.setMode(self.options.mode);
                    }).catch(reject);
                }).catch(reject);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;

        const modes = [];
        self.div.querySelectorAll('.tc-ctl-meas-mode').forEach(function (elm) {
            modes.push(elm);
        });
        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-len');
                })[0];
                break;
            case TC.Consts.geom.POLYGON:
                self._activeMode = modes.filter(function (elm) {
                    return elm.matches('.tc-ctl-meas-area');
                })[0];
                break;
            case null:
            case undefined:
                self._activeMode = null;
                break;
            default:
                break;
        }

        const hiddenModes = modes.filter(function (elm) {
            return elm !== self._activeMode;
        });

        // Class TC.Consts.classes.CHECKED is for IE8 support
        if (mode) {
            const radio = self.div.querySelector('input[type=radio][name=mode][value=' + mode + ']');
            radio.checked = true;
            radio.classList.add(TC.Consts.classes.CHECKED);
            radio.nextSibling.classList.add(TC.Consts.classes.CHECKED);
        }
        else {
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.checked = false;
                radio.classList.remove(TC.Consts.classes.CHECKED);
                radio.nextSibling.classList.remove(TC.Consts.classes.CHECKED);
            });
        }
        if (self._activeMode) {
            self._activeMode.classList.remove(TC.Consts.classes.HIDDEN);
            self._activeMode.querySelector('.tc-ctl').classList.remove(TC.Consts.classes.COLLAPSED);
        }
        hiddenModes.forEach(function (elm) {
            elm.classList.add(TC.Consts.classes.HIDDEN);
        });
        return self;
    };

    ctlProto.setMode = function (mode) {
        const self = this;

        self.mode = mode;
        self.displayMode(mode);

        var event;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
                self.drawLines.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case TC.Consts.geom.POLYGON:
                self.drawPolygons.activate();
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
            case null:
            case undefined:
                self.drawControls.forEach(function (ctl) {
                    if (ctl.isActive) {
                        ctl.cancel();
                    }
                });
                event = TC.Consts.event.CONTROLDEACTIVATE;
                break;
            default:
                event = TC.Consts.event.CONTROLACTIVATE;
                break;
        }

        self.resetValues();

        if (event && self.map) {
            self.map.trigger(event, { control: self });
        }
        return self;
    };

    ctlProto.cancel = function () {
        this.setMode(null, false);
        return this;
    }

    ctlProto.showMeasures = function (options) {
        const self = this;
        options = options || {};
        var units = options.units;
        var precision;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.area) {
            var area = options.area;
            if (area > 10000) {
                area = area / 1000000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._area.innerHTML = TC.Util.formatNumber(area.toFixed(precision), locale) + ' ' + units + '&sup2;';
        }
        if (options.perimeter) {
            var perimeter = options.perimeter;
            if (perimeter > 1000) {
                perimeter = perimeter / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._peri.innerHTML = TC.Util.formatNumber(perimeter.toFixed(precision), locale) + ' ' + units;
        }
        if (options.length) {
            var length = options.length;
            if (length > 1000) {
                length = length / 1000;
                units = 'km';
            }
            precision = units === 'm' ? 0 : 3;
            self._len.innerHTML = TC.Util.formatNumber(length.toFixed(precision), locale) + ' ' + units;
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        if (self._len) {
            self._len.textContent = self.NOMEASURE;
            self._area.textContent = self.NOMEASURE;
            self._peri.textContent = self.NOMEASURE;
        }
        return self;
    };

    ctlProto.getDrawLines = function () {

    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.layer) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.layerPromise.then(function (layer) {
            layer.importState(state.layer);
        });
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {

    TC.control.ProjectionSelector = function () {
        const self = this;

        TC.Control.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code',
            CHANGE: self.CLASS + '-change',
            NO_CHANGE: self.CLASS + '-no-change'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        self._$dialogDiv = $(self._dialogDiv);
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.' + self._cssClasses.LOAD_CRS_BUTTON + ')', function (e) {
            const crs = e.target.dataset.crsCode;
            if (crs) {
                self.setProjection({
                    crs: crs,
                    allowFallbackLayer: true
                });
            }
        }));

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON, function (e) {
            self.loadFallbackProjections();
        }));
    };

    TC.inherit(TC.control.ProjectionSelector, TC.Control);

    const ctlProto = TC.control.ProjectionSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-projs';

    const _dataKeys = {
        LAYER: 'tcLayer',
        FALLBACK_LAYER: 'tcFallbackLayer'
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        });
        return result;
    };

    ctlProto.getAvailableCRS = function (options) {
        return this.map.getCompatibleCRS({ includeFallbacks: true })
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self._cssClasses.CRS_DIALOG);
        const body = dialog.querySelector('.tc-modal-body');
        body.classList.add(TC.Consts.classes.LOADING);
        const ul = body.querySelector('ul.' + self._cssClasses.CRS_LIST);
        ul.innerHTML = '';
        const blFirstOption = self.map.baseLayer.firstOption || self.map.baseLayer;
        const blFallback = blFirstOption.getFallbackLayer();
        const blCRSList = blFirstOption.getCompatibleCRS();

        const loadProjs = function () {
            self.map.loadProjections({
                crsList: self.getAvailableCRS(options),
                orderBy: 'name'
            }).then(function (projList) {
                var hasFallbackCRS = false;
                projList
                    .forEach(function (projObj) {
                        if (TC.Util.CRSCodesEqual(self.map.crs, projObj.code)) {
                            dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_NAME).textContent = projObj.name;
                            dialog.querySelector('.' + self._cssClasses.CURRENT_CRS_CODE).textContent = projObj.code;
                        }
                        else {
                            const button = document.createElement('button');
                            button.textContent = projObj.name + ' (' + projObj.code + ')';
                            button.dataset.crsCode = projObj.code;
                            const li = document.createElement('li');
                            li.appendChild(button);
                            if (blCRSList.filter(function (crs) {
                                return TC.Util.CRSCodesEqual(crs, projObj.code)
                            }).length === 0) {
                                // Es un CRS del fallback
                                hasFallbackCRS = true;
                                li.classList.add(TC.Consts.classes.HIDDEN);
                                button.classList.add(TC.Consts.classes.WARNING);
                            }
                            ul.appendChild(li);
                        }
                    });
                if (hasFallbackCRS) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                    button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                    li.appendChild(button);
                    ul.appendChild(li);
                }

                // Mostramos un aviso si no hay CRS compatibles
                if (ul.querySelectorAll('li').length === 0) {
                    const li = document.createElement('li');
                    li.innerHTML = self.getLocaleString('thereAreNoCompatibleCRS');
                    ul.appendChild(li);
                }
                const visibleLi = ul.querySelectorAll('li:not(.' + TC.Consts.classes.HIDDEN + ')');
                dialog.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? '' : 'none';
                });
                dialog.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
                    elm.style.display = visibleLi.length > 1 ? 'none' : '';
                });
                dialog.querySelector('ul.' + self._cssClasses.CRS_LIST).style.display = visibleLi.length > 0 || hasFallbackCRS ? '' : 'none';
                body.classList.remove(TC.Consts.classes.LOADING);
            });
        };

        if (blFallback) {
            blFallback.getCapabilitiesPromise().then(loadProjs);
        }
        else {
            loadProjs();
        }
        TC.Util.showModal(dialog, options);
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options);
            }
        });
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
        self._dialogDiv.querySelectorAll('p.' + TC.Consts.classes.WARNING).forEach(function (p) {
            p.classList.remove(TC.Consts.classes.HIDDEN);
        })
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? '' : 'none';
        });
        self._dialogDiv.querySelectorAll('.' + self._cssClasses.NO_CHANGE).forEach(function (elm) {
            elm.style.display = lis.length > 1 ? 'none' : '';
        });
    };

})();

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Container = function () {
    var self = this;

    TC.Control.apply(self, arguments);    

    self.controlOptions = self.options.controls || [];

    self.ctlCount = self.controlOptions instanceof Array ? self.controlOptions.length : Object.keys(self.controlOptions).length;    
    self.defaultSelection = self.options.defaultSelection;
};

TC.inherit(TC.control.Container, TC.Control);

(function () {
    var ctlProto = TC.control.Container.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.uids = new Array(self.ctlCount);
        self.uids.forEach(function (elm, idx, arr) {
            arr[idx] = self.getUID();
        });

        return new Promise(function (resolve, rejetc) {
            Promise.all([result, self.renderPromise()]).then(function () {
                self.onRenderPromise();

                resolve();
            });
        });        
    };

    ctlProto.onRenderPromise = function () { };

    ctlProto.render = function (callback) { };

    ctlProto.getControl = function (idx) {
        var promise = this._ctlPromises[idx];
        if (!promise) {
            return new Promise(function (resolve, reject) {
                reject();
            });            
        }

        return promise;
    };

})();

﻿TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.TabContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        TAB: cs + '-tab',
        RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
        ELEMENT: cs + '-elm'
    };    
};

TC.inherit(TC.control.TabContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.TabContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-tctr';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/TabContainer.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").f(ctx.get(["title"], false), ctx, "h").w("</h2><div class=\"tc-ctl-tctr-select\"><form>").s(ctx.get(["controls"], false), ctx, { "block": body_1 }, {}).w("</form></div>").s(ctx.get(["controls"], false), ctx, { "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<label class=\"tc-ctl-tctr-tab tc-ctl-tctr-tab-").f(ctx.get(["$idx"], false), ctx, "h").w("\" style=\"width:calc(100%/").f(ctx.get(["$len"], false), ctx, "h").w(" - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"").f(ctx.get(["$idx"], false), ctx, "h").w("\" /><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-tctr-elm tc-ctl-tctr-elm-").f(ctx.get(["$idx"], false), ctx, "h").w(" tc-hidden\"></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.onRenderPromise = function () {
        const self = this;

        self.title = self.title || self.getLocaleString(self.options.title || 'moreControls');
        self.div.querySelector('h2').innerHTML = self.title;

        var bufferPromises = new Array(self.ctlCount);
        for (var i = 0, len = self.controlOptions.length; i < len; i++) {
            var ctl = self.controlOptions[i];
            bufferPromises[i] = self.map.addControl(ctl.name, $.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i)
            }, ctl.options));
        }
        var writeTitle = function (ctl, idx) {
            ctl.renderPromise().then(function () {
                const title = self.getLocaleString(self.controlOptions[idx].title) || ctl.div.querySelector('h2').innerHTML;
                var parent = ctl.div;
                do {
                    parent = parent.parentElement;
                }
                while (parent && !parent.matches(self._classSelector));
                parent.querySelector(self._selectors.TAB + '-' + idx + ' span').innerHTML = title;
            });
        };
        Promise.all(bufferPromises).then(function (controls) {
            for (var i = 0, len = controls.length; i < len; i++) {
                var ctl = controls[i];
                ctl.containerControl = self;
                writeTitle(ctl, i);                
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ title: self.title, controls: self.controlOptions }, function () {

            var clickHandler = function (e) {
                var closest = this;
                while (closest && !closest.matches(self._selectors.TAB)) {
                    closest = closest.parentElement;
                }
                var active, hidden = [];
                const checkbox = closest.querySelector(self._selectors.RADIOBUTTON);
                const newValue = checkbox.value;
                const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                if (self._oldValue === newValue && self.options.deselectable) {
                    setTimeout(function () {
                        checkbox.checked = false;
                    }, 0);
                    self._oldValue = null;
                    active = null;
                    hidden = elms;
                }
                else {
                    elms.forEach(function (elm) {
                        if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                            active = elm;
                        }
                        else {
                            hidden.push(elm);
                        }
                    });
                    self._oldValue = newValue;
                }

                if (active) {
                    active.classList.remove(TC.Consts.classes.HIDDEN);
                }
                hidden.forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
                checkbox.checked = true;
            };

            self.div.querySelectorAll('span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, clickHandler);
            });

            // GLS: Si en el register de control se llama a render, ¿por qué volvemos a llamarlo aquí?
            //for (var i = 0, len = self._ctlPromises.length; i < len; i++) {
            //    self.getControl(i).then(function (ctl) {
            //        ctl.render();
            //    });
            //}

            if (typeof self.defaultSelection === 'number') {
                clickHandler.call(self.div.querySelectorAll(self._selectors.RADIOBUTTON)[self.defaultSelection]);
            }
        }));
    };

})();

﻿; (function (root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(['../../lib/ol/build/ol-debug'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../../lib/ol/build/ol-debug'));
    } else {
        root.ol = factory(root.ol);
    }

})(this, function (ol) {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };

    // requestAnimationFrame polyfill
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };

    // ol patches
    var MOUSEMOVE = 'mousemove';
    var MOUSEOUT = 'mouseout';
    var MOUSEOVER = 'mouseover';
    var MOUSEENTER = 'mouseenter';

    var cssUrl = TC.url.ol.substr(0, TC.url.ol.lastIndexOf('/'));
    cssUrl = cssUrl.substr(0, cssUrl.lastIndexOf('/') + 1) + 'css/ol.css';
    //TC.loadCSS(cssUrl);

    // OpenLayers usa para las proyecciones geográficas un valor ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES], calculado con una esfera, salvo
    // EPSG:4326, en la que usa ol.proj.EPSG4326.METERS_PER_UNIT, calculado con el geoide. Esto hace que las proyecciones en EPSG:4258 salgan desplazadas,
    // pese a que para todos los efectos son iguales a las EPSG:4326. Para evitar eso, introducimos en las 4258 el valor ol.proj.EPSG4326.METERS_PER_UNIT.
    ol.proj.get('EPSG:4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('urn:ogc:def:crs:EPSG::4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;
    ol.proj.get('http://www.opengis.net/gml/srs/epsg.xml#4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;

    // Reescribimos la obtención de proyección para que soporte códigos tipo EPSG:X, urn:ogc:def:crs:EPSG::X y http://www.opengis.net/gml/srs/epsg.xml#X
    ol.proj.oldGet = ol.proj.get;
    ol.proj.get = function (projectionLike) {
        if (typeof projectionLike === 'string') {
            projectionLike = projectionLike.trim();
            TC.loadProjDef({ crs: projectionLike, sync: true });
        }
        return ol.proj.oldGet.call(this, projectionLike);
    };

    // Reescritura de código para transformar las geometrías de getFeatureInfo que están en un CRS distinto
    ol.format.GMLBase.prototype.readGeometryElement = function (node, objectStack) {
        var context = /** @type {Object} */ (objectStack[0]);
        context['srsName'] = node.firstElementChild.getAttribute('srsName');
        /** @type {ol.geom.Geometry} */

        // Parche para poder leer coordenadas en EPSG:4326 con orden incorrecto (las crea QGIS, por ejemplo)
        if (this instanceof ol.format.GML2CRS84 || this instanceof ol.format.GML3CRS84) {
            if (context.srsName !== 'EPSG:4326' || !context.srsName) {
                throw new Error("Conflicto de CRS");
            }
        }
        if (!context.srsName) {
            context.srsName = this.srsName;
        }
        context.dataProjection = ol.proj.get(context.srsName);
        var geometry = ol.xml.pushParseAndPop(null,
            this.GEOMETRY_PARSERS_, node, objectStack, this);
        if (geometry) {
            return /** @type {ol.geom.Geometry} */ (
                ol.format.Feature.transformWithOptions(geometry, false, context));
        } else {
            return undefined;
        }
    };

    // Reescritura de código para hacerlo compatible con GML generado por inspire:
    // No se puede considerar geometría cualquier cosa que tenga elementos anidados.
    ol.format.GMLBase.prototype.readFeatureElement = function (node, objectStack) {
        var n;
        var fid = node.getAttribute('fid') ||
            ol.xml.getAttributeNS(node, ol.format.GMLBase.GMLNS, 'id');
        var values = {}, geometryName;
        for (n = node.firstElementChild; n; n = n.nextElementSibling) {
            var localName = n.localName;
            // Assume attribute elements have one child node and that the child
            // is a text or CDATA node (to be treated as text).
            // Otherwise assume it is a geometry node.
            if (n.childNodes.length === 0 ||
                (n.childNodes.length === 1 &&
                    (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {
                var value = ol.xml.getAllTextContent(n, false);
                if (ol.format.GMLBase.ONLY_WHITESPACE_RE_.test(value)) {
                    value = undefined;
                }
                values[localName] = value;
            } else {
                values[localName] = this.readGeometryElement(n, objectStack);
                // boundedBy is an extent and must not be considered as a geometry
                // Tampoco referencePoint
                if (localName !== 'boundedBy' && localName !== 'referencePoint') {
                    geometryName = localName;
                }
            }
        }
        var feature = new ol.Feature(values);
        if (geometryName) {
            feature.setGeometryName(geometryName);
        }
        if (fid) {
            feature.setId(fid);
        }
        return feature;
    };

    // Añadimos el atributo srsDimension para soportar 3D
    ol.format.GML3.prototype._writePosList_ = ol.format.GML3.prototype.writePosList_;
    ol.format.GML3.prototype.writePosList_ = function (node, value, objectStack) {
        this._writePosList_(node, value, objectStack);
        const point = value.getCoordinates()[0];
        if (point && point.length > 2) {
            node.setAttribute('srsDimension', point.length);
        }
    };

    // Cambiamos getCoords_ para que soporte 3D
    ol.format.GML3.prototype._getCoords_ = ol.format.GML3.prototype.getCoords_;
    ol.format.GML3.prototype.getCoords_ = function (point, opt_srsName) {
        var result = this._getCoords_(point, opt_srsName);
        if (point.length > 2) {
            result += ' ' + point[2];
        }
        return result;
    };

    // Cambiamos writePos_ para que soporte 3D
    ol.format.GML3.prototype._writePos_ = ol.format.GML3.prototype.writePos_;
    ol.format.GML3.prototype.writePos_ = function (node, value, objectStack) {
        this._writePos_(node, value, objectStack);
        const point = value.getCoordinates();
        if (point.length > 2) {
            ol.format.XSD.writeStringTextNode(node, ' ' + point[2]);
        }
    };



    // Añadido el espacio de nombres de GML 3.2 al parser
    var gmlNamespace = 'http://www.opengis.net/gml';
    var gml32Namespace = 'http://www.opengis.net/gml/3.2';
    ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gml32Namespace] = ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_[gmlNamespace];
    ol.format.GMLBase.prototype.RING_PARSERS[gml32Namespace] = ol.format.GMLBase.prototype.RING_PARSERS[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.GEOMETRY_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.MULTICURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTICURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.MULTISURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SURFACE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SURFACE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.CURVE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.CURVE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.ENVELOPE_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.ENVELOPE_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.PATCHES_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.PATCHES_PARSERS_[gmlNamespace];
    ol.format.GML3.prototype.SEGMENTS_PARSERS_[gml32Namespace] = ol.format.GML3.prototype.SEGMENTS_PARSERS_[gmlNamespace];

    // Rehacemos los estilos por defecto de KML para que se adecúen al de la API
    ol.format.KML._createStyleDefaults_ = ol.format.KML.createStyleDefaults_;
    ol.format.KML.createStyleDefaults_ = function () {
        ol.format.KML._createStyleDefaults_();

        ol.format.KML.DEFAULT_FILL_STYLE_.color_ = getRGBA(TC.Cfg.styles.polygon.fillColor, TC.Cfg.styles.polygon.fillOpacity);
        ol.format.KML.DEFAULT_TEXT_STYLE_.fill_ = new ol.style.Fill({
            color: ol.format.KML.DEFAULT_COLOR_
        });
        ol.format.KML.DEFAULT_STROKE_STYLE_.color_ = getRGBA(TC.Cfg.styles.line.strokeColor, 1);
        ol.format.KML.DEFAULT_STROKE_STYLE_.width_ = TC.Cfg.styles.line.strokeWidth;

        return ol.format.KML.DEFAULT_STYLE_ARRAY_;
    };


    // Reescritura de código para leer las carpetas del KML
    ol.format.KML.prototype._readDocumentOrFolder_ = ol.format.KML.prototype.readDocumentOrFolder_;
    ol.format.KML.prototype.readDocumentOrFolder_ = function (node, objectStack) {
        var result = ol.format.KML.prototype._readDocumentOrFolder_.apply(this, arguments);
        if (node.localName == "Folder") {
            for (var i = 0; i < result.length; i++) {
                var feature = result[i];
                if (!$.isArray(feature._folders)) {
                    feature._folders = [];
                }
                var nameElm = node.getElementsByTagName('name')[0];
                if (nameElm) {
                    //feature._folders.unshift(nameElm.innerHTML || nameElm.textContent);
                    // Versión rápida de unshift
                    TC.Util.fastUnshift(feature._folders, nameElm.innerHTML || nameElm.textContent);
                }
            }
        }
        return result;
    };

    // Creamos un parser para interpretar la plantilla de los bocadillos
    ol.format.KML.readText_ = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'text');
        var s = ol.xml.getAllTextContent(node, false);
        return s.trim();
    };

    //ol.format.KML.DEFAULT_BALLOON_STYLE_ = new ol.style.Text();

    ol.format.KML.BALLOON_STYLE_PARSERS_ = ol.xml.makeStructureNS(
        ol.format.KML.NAMESPACE_URIS_, {
            'text': ol.xml.makeObjectPropertySetter(ol.format.KML.readText_),
        });

    ol.format.KML.BalloonStyleParser_ = function (node, objectStack) {
        ol.asserts.assert(node.nodeType == Node.ELEMENT_NODE);
        ol.asserts.assert(node.localName == 'BalloonStyle');
        // FIXME colorMode
        var object = ol.xml.pushParseAndPop(
            {}, ol.format.KML.BALLOON_STYLE_PARSERS_, node, objectStack);
        if (!goog.isDef(object)) {
            return;
        }
        var styleObject = objectStack[objectStack.length - 1];
        ol.asserts.assert(goog.isObject(styleObject));
        var textStyle = new ol.style.Text({
            text: (object['text'])
        });
        styleObject['balloonStyle'] = textStyle;
    };

    for (var key in ol.format.KML.STYLE_PARSERS_) {
        var parser = ol.format.KML.STYLE_PARSERS_[key];
        parser['BalloonStyle'] = ol.format.KML.BalloonStyleParser_;
    }

    // Parche a esta función para meter la lectura de balloonStyle
    ol.format.KML.readStyle_ = function (node, objectStack) {
        var styleObject = ol.xml.pushParseAndPop(
            {}, ol.format.KML.STYLE_PARSERS_, node, objectStack);
        if (!styleObject) {
            return null;
        }
        var fillStyle = /** @type {ol.style.Fill} */
            ('fillStyle' in styleObject ?
                styleObject['fillStyle'] : ol.format.KML.DEFAULT_FILL_STYLE_);
        var fill = /** @type {boolean|undefined} */ (styleObject['fill']);
        if (fill !== undefined && !fill) {
            fillStyle = null;
        }
        var imageStyle = /** @type {ol.style.Image} */
            ('imageStyle' in styleObject ?
                styleObject['imageStyle'] : ol.format.KML.DEFAULT_IMAGE_STYLE_);
        if (imageStyle == ol.format.KML.DEFAULT_NO_IMAGE_STYLE_) {
            imageStyle = undefined;
        }
        var textStyle = /** @type {ol.style.Text} */
            ('textStyle' in styleObject ?
                styleObject['textStyle'] : ol.format.KML.DEFAULT_TEXT_STYLE_);
        var strokeStyle = /** @type {ol.style.Stroke} */
            ('strokeStyle' in styleObject ?
                styleObject['strokeStyle'] : ol.format.KML.DEFAULT_STROKE_STYLE_);
        var balloonStyle =
            ('balloonStyle' in styleObject ?
                styleObject['balloonStyle'] : ol.format.KML.DEFAULT_BALLOON_STYLE_);

        // GLS: Comento el machaque del estilo de línea por que no haya outline, según la documentación (https://developers.google.com/kml/documentation/kmlreference#style) 
        // es opcional indicar outline
        // Corregimos el bug 25306 No se carga el estilo de VV-del-Irati.kml
        //var outline = /** @type {boolean|undefined} */
        //    (styleObject['outline']);
        //if (outline !== undefined && !outline) {
        //    strokeStyle = null;
        //}

        var style = new ol.style.Style({
            fill: fillStyle,
            image: imageStyle,
            stroke: strokeStyle,
            text: textStyle,
            zIndex: undefined // FIXME
        });
        style._balloon = balloonStyle;
        return [style];
    };

    // flacunza: Parche para evitar peticiones HTTP desde una página HTTPS
    ol.format.KML._readURI_ = ol.format.KML.readURI_;
    ol.format.KML.readURI_ = function (node) {
        var result = ol.format.KML._readURI_(node);
        if (location.protocol === 'https:' && result.indexOf('http://') === 0) {
            result = result.substr(5);
        }
        return result;
    };
    for (var key in ol.format.KML.ICON_PARSERS_) {
        ol.format.KML.ICON_PARSERS_[key].href = ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_);
    }

    // GLS: La expresión regular que valida el formato de fecha ISO no contempla que la fecha contenga fracción de segundo, según https://www.w3.org/TR/NOTE-datetime 
    ol.format.KML.whenParser_ = function (a, b) {
        ol.asserts.assert(a.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
        ol.asserts.assert("when" == a.localName, "localName should be when");
        var c = b[b.length - 1];
        ol.asserts.assert(goog.isObject(c), "gxTrackObject should be an Object");
        var c = c.whens
            , d = ol.xml.getAllTextContent(a, !1);
        if (d = /^\s*(\d{4})($|-(\d{2})($|-(\d{2})($|T(\d{2}):(\d{2}):(\d{2})(?:.?\d{3})?(Z|(?:([+\-])(\d{2})(?::(\d{2}))?)))))\s*$/.exec(d)) {
            var e = parseInt(d[1], 10)
                , f = d[3] ? parseInt(d[3],
                    10) - 1 : 0
                , g = d[5] ? parseInt(d[5], 10) : 1
                , h = d[7] ? parseInt(d[7], 10) : 0
                , k = d[8] ? parseInt(d[8], 10) : 0
                , l = d[9] ? parseInt(d[9], 10) : 0
                , e = Date.UTC(e, f, g, h, k, l);
            d[10] && "Z" != d[10] && (f = "-" == d[11] ? -1 : 1,
                e += 60 * f * parseInt(d[12], 10),
                d[13] && (e += 3600 * f * parseInt(d[13], 10)));
            c.push(e)
        } else
            c.push(0)
    };

    ol.format.KML.GX_TRACK_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {
        when: ol.format.KML.whenParser_
    }, ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {
        coord: ol.format.KML.gxCoordParser_
    }));

    var namespaceURISmanage = function (source, format) {
        var xml = ol.xml.parse(source);
        var tag = xml.getElementsByTagName(format.toLowerCase());
        if (tag && tag.length > 0) {
            var value = tag[0].getAttribute('xmlns');
            if (value && value.indexOf(' ') > -1 && customKMLNameSpaceURIS.indexOf(value) > -1) {
                var values = value.split(' ');
                var namespaces = [];
                for (var i = 0; i < values.length; i++) {
                    namespaces.push(('xmlns:' + format.toLowerCase() + i) + "=\"" + values[i].trim() + "\"");
                }
            }
        }

        return source;
    };

    // flacunza: Parcheo para poder leer KMLs generados por Google Earth. En ellos falta el atributo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    // que se utiliza luego en xsi:schemaLocation, haciendo que el DOMParser no lea el elemento Placemark.
    ol.format.KML.prototype.readFeatures = function (source, opt_options) {
        if (typeof source === 'string') {
            var kmlTag = '<kml';
            var startIdx = source.indexOf(kmlTag);
            if (startIdx >= 0) {
                startIdx += kmlTag.length;
                var endIdx = source.indexOf('>', startIdx);
                if (source.indexOf('xmlns:xsi=') < 0) {
                    source = source.substr(0, startIdx) + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' + source.substr(startIdx);
                }

                source = namespaceURISmanage(source, 'KML');
            }
        }
        return ol.format.XMLFeature.prototype.readFeatures.call(this, source, opt_options);
    };

    // GLS: La expresión regular que valida el formato de fecha ISO no contempla que la fecha contenga fracción de segundo, según https://www.w3.org/TR/NOTE-datetime 
    ol.format.XSD.readDateTime = function (a) {
        a = ol.xml.getAllTextContent(a, !1);
        if (a = /^\s*(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(Z|(?:([+\-])(\d{2})(?::(\d{2}))?))\s*$/.exec(a)) {
            var b = parseInt(a[1], 10)
                , c = parseInt(a[2], 10) - 1
                , d = parseInt(a[3], 10)
                , e = parseInt(a[4], 10)
                , f = parseInt(a[5], 10)
                , g = parseInt(a[6], 10)
                , b = Date.UTC(b, c, d, e, f, g); // GLS quito el paso a segundos / 1E3
            "Z" != a[7] && (c = "-" == a[8] ? -1 : 1,
                b += 60 * c * parseInt(a[9], 10),
                void 0 !== a[10] && (b += 3600 * c * parseInt(a[10], 10)));
            return b
        };
    };

    ol.format.GPX.RTEPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {
        ele: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        time: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)
    });
    ol.format.GPX.TRKPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {
        ele: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        time: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)
    });
    ol.format.GPX.WPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {
        ele: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        time: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime),
        magvar: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        geoidheight: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        name: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        cmt: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        desc: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        src: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        link: ol.format.GPX.parseLink_,
        sym: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        type: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        fix: ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),
        sat: ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),
        hdop: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        vdop: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        pdop: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        ageofdgpsdata: ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),
        dgpsid: ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),
        extensions: ol.format.GPX.parseExtensions_
    });

    ol.format.XSD.writeDateTimeTextNode = function (node, dateTime) {
        var date = new Date(dateTime);
        var string = date.getUTCFullYear() + '-' +
            ol.string.padNumber(date.getUTCMonth() + 1, 2) + '-' +
            ol.string.padNumber(date.getUTCDate(), 2) + 'T' +
            ol.string.padNumber(date.getUTCHours(), 2) + ':' +
            ol.string.padNumber(date.getUTCMinutes(), 2) + ':' +
            ol.string.padNumber(date.getUTCSeconds(), 2) + 'Z';
        node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
    };

    ol.format.GPX.WPT_TYPE_SERIALIZERS_ = ol.xml.makeStructureNS(
        ol.format.GPX.NAMESPACE_URIS_, {
            'ele': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
            'time': ol.xml.makeChildAppender(ol.format.XSD.writeDateTimeTextNode),
            'magvar': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
            'geoidheight': ol.xml.makeChildAppender(
                ol.format.XSD.writeDecimalTextNode),
            'name': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'cmt': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'desc': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'src': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'link': ol.xml.makeChildAppender(ol.format.GPX.writeLink_),
            'sym': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'type': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'fix': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),
            'sat': ol.xml.makeChildAppender(
                ol.format.XSD.writeNonNegativeIntegerTextNode),
            'hdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
            'vdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
            'pdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),
            'ageofdgpsdata': ol.xml.makeChildAppender(
                ol.format.XSD.writeDecimalTextNode),
            'dgpsid': ol.xml.makeChildAppender(
                ol.format.XSD.writeNonNegativeIntegerTextNode)
        });

    const hitTolerance = TC.Util.detectMouse() ? 3 : 10;

    // GLS: Obtenemos las combinaciones posibles
    var getAllCombinations = function (array) {
        var combi = [];
        var temp = [];

        var len = Math.pow(2, array.length);

        for (var i = 0; i < len; i++) {
            temp = [];
            for (var j = 0; j < array.length; j++) {
                if ((i & Math.pow(2, j))) {
                    if (temp.indexOf(array[j]) == -1)
                        temp.push(array[j]);
                }
            }
            if (temp.length > 0) {
                if (combi.indexOf(temp.join(' ')) == -1)
                    combi.push(temp.join(' '));
            }
        }

        return combi;
    }

    // GLS: Limpiamos de los nuevos los URIS ya disponibles en el formato
    var cleanCombinationsByFormat = function (customURIS, formatURIS) {
        if (customURIS && customURIS.length > 0) {
            for (var i = 0; i < formatURIS.length; i++) {
                var index = customURIS.indexOf(formatURIS[i]);
                if (index > -1)
                    customURIS.splice(index, 1);
            }
        }
    };

    // GLS: Establecemos los parser por formato para los nuevos URIS
    var setNewParsersByFormat = function (parsers, customURIS) {
        for (var i = 0; i < parsers.length; i++) {
            var parser = parsers[i];
            for (var j = 0; j < customURIS.length; j++) {
                var analogFormat = customURIS[j].split(' ')[0];
                parser[customURIS[j]] = parser[analogFormat];
            }
        }
    };

    var KML_PARSERS = [
        ol.format.KML.DATA_PARSERS_,
        ol.format.KML.EXTENDED_DATA_PARSERS_,
        ol.format.KML.REGION_PARSERS_,
        ol.format.KML.LAT_LON_ALT_BOX_PARSERS_,
        ol.format.KML.LOD_PARSERS_,
        ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_,
        ol.format.KML.FLAT_LINEAR_RING_PARSERS_,
        ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_,
        ol.format.KML.GX_TRACK_PARSERS_,
        ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_,
        ol.format.KML.ICON_PARSERS_,
        ol.format.KML.ICON_STYLE_PARSERS_,
        ol.format.KML.INNER_BOUNDARY_IS_PARSERS_,
        ol.format.KML.LABEL_STYLE_PARSERS_,
        ol.format.KML.LINE_STYLE_PARSERS_,
        ol.format.KML.MULTI_GEOMETRY_PARSERS_,
        ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_,
        ol.format.KML.NETWORK_LINK_PARSERS_,
        ol.format.KML.LINK_PARSERS_,
        ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_,
        ol.format.KML.PAIR_PARSERS_,
        ol.format.KML.PLACEMARK_PARSERS_,
        ol.format.KML.POLY_STYLE_PARSERS_,
        ol.format.KML.SCHEMA_DATA_PARSERS_,
        ol.format.KML.STYLE_PARSERS_,
        ol.format.KML.STYLE_MAP_PARSERS_
    ];

    // GLS: Obtenemos los nuevos URIS para KML
    var customKMLNameSpaceURIS = getAllCombinations(ol.format.KML.NAMESPACE_URIS_.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(customKMLNameSpaceURIS, ol.format.KML.NAMESPACE_URIS_);
    // GLS: Añadimos los nuevos URIS al KML
    ol.format.KML.NAMESPACE_URIS_ = ol.format.KML.NAMESPACE_URIS_.concat(customKMLNameSpaceURIS);
    // GLS: Establecemos los parsers del KML para los nuevos URIS
    setNewParsersByFormat(KML_PARSERS, customKMLNameSpaceURIS);


    var GPX_PARSERS = [
        ol.format.GPX.GPX_PARSERS_,
        ol.format.GPX.LINK_PARSERS_,
        ol.format.GPX.RTE_PARSERS_,
        ol.format.GPX.RTEPT_PARSERS_,
        ol.format.GPX.TRK_PARSERS_,
        ol.format.GPX.TRKSEG_PARSERS_,
        ol.format.GPX.TRKPT_PARSERS_,
        ol.format.GPX.WPT_PARSERS_,
        ol.format.GPX.LINK_SERIALIZERS_,
        ol.format.GPX.RTE_SEQUENCE_,
        ol.format.GPX.RTE_SERIALIZERS_,
        ol.format.GPX.RTEPT_TYPE_SEQUENCE_,
        ol.format.GPX.TRK_SEQUENCE_,
        ol.format.GPX.TRK_SERIALIZERS_,
        ol.format.GPX.TRKSEG_SERIALIZERS_,
        ol.format.GPX.WPT_TYPE_SEQUENCE_,
        ol.format.GPX.WPT_TYPE_SERIALIZERS_,
        ol.format.GPX.GPX_SERIALIZERS_
    ];

    // GLS: Obtenemos los nuevos URIS para GPX
    var customGPXNameSpaceURIS = getAllCombinations(ol.format.GPX.NAMESPACE_URIS_.slice().slice(1));
    // GLS: Nos quedamos con las combinaciones nuevas
    cleanCombinationsByFormat(customGPXNameSpaceURIS, ol.format.GPX.NAMESPACE_URIS_);
    // GLS: Añadimos los nuevos URIS al GPX
    ol.format.GPX.NAMESPACE_URIS_ = ol.format.GPX.NAMESPACE_URIS_.concat(customGPXNameSpaceURIS);
    // GLS: Establecemos los parsers del GPX para los nuevos URIS
    setNewParsersByFormat(GPX_PARSERS, customGPXNameSpaceURIS);

    // Bug de OpenLayers hasta 4.1.0 como mínimo:
    // ol.format.GMLBase no lee varias features dentro de featureCollection, se queda solo con la última.
    // Esto es porque utiliza ol.xml.makeReplacer en vez de ol.xml.makeArrayPusher para leerlas.
    // Curiosamente en ol.format.GML2 está corregido, pero no en ol.format.GML3.
    // El siguiente constructor parchea ese bug
    ol.format.GML3Patched = function (options) {
        var result = new ol.format.GML(options);
        result.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS][
            'featureMember'] =
            ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);
        return result;
    };

    // Bug de OpenLayers hasta 3.5.0 como mínimo:
    // El parser de GML2 no lee las siguientes features del GML si tienen un featureType distinto del primero.
    // Esto pasa porque genera el objeto de featureTypes con la primera y en las siguientes iteraciones si el objeto existe no se regenera.
    // Entre comentarios /* */ se elimina lo que sobra.
    //
    // Más: se añade para FeatureCollection un parser por cada namespaceURI del nodo. 
    // Esto es porque QGIS genera GML cuyo nodo FeatureCollection tiene namespace = http://ogr.maptools.org/.
    ol.format.GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {
        ol.DEBUG && console.assert(node.nodeType == Node.ELEMENT_NODE,
            'node.nodeType should be ELEMENT');
        var localName = node.localName;
        var features = null;
        if (localName == 'FeatureCollection') {
            // Ñapa para leer GML de https://catastro.navarra.es/ref_catastral/gml.ashx?C=217&PO=5&PA=626
            // y demás GMLs obtenidos de un WFS de GeoServer.
            var gmlnsCollectionParser = this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS];
            if (!gmlnsCollectionParser['member']) {
                gmlnsCollectionParser['member'] = ol.xml.makeArrayPusher(
                    ol.format.GMLBase.prototype.readFeaturesInternal);
            };
            //////
            if (node.namespaceURI === 'http://www.opengis.net/wfs') {
                features = ol.xml.pushParseAndPop([],
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            } else {
                this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] =
                    this.FEATURE_COLLECTION_PARSERS[node.namespaceURI] || this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS];
                features = ol.xml.pushParseAndPop(/*null*/[], // Cambiado null por [] porque si no, no crea el array de features
                    this.FEATURE_COLLECTION_PARSERS, node,
                    objectStack, this);
            }
        } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
            var context = objectStack[0];
            var featureType = context['featureType'];
            var featureNS = context['featureNS'];
            var i, ii, prefix = 'p', defaultPrefix = 'p0';
            if (/*!featureType && */node.childNodes) {
                featureType = [], featureNS = {};
                for (i = 0, ii = node.childNodes.length; i < ii; ++i) {
                    var child = node.childNodes[i];
                    if (child.nodeType === 1) {
                        var ft = child.nodeName.split(':').pop();
                        if (featureType.indexOf(ft) === -1) {
                            var key = '';
                            var count = 0;
                            var uri = child.namespaceURI;
                            for (var candidate in featureNS) {
                                if (featureNS[candidate] === uri) {
                                    key = candidate;
                                    break;
                                }
                                ++count;
                            }
                            if (!key) {
                                key = prefix + count;
                                featureNS[key] = uri;
                            }
                            featureType.push(key + ':' + ft);
                        }
                    }
                }
                if (localName != 'featureMember' && localName != 'member') {
                    // recheck featureType for each featureMember
                    context['featureType'] = featureType;
                    context['featureNS'] = featureNS;
                }
            }
            if (typeof featureNS === 'string') {
                var ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
            }
            var parsersNS = {};
            var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
            for (var p in featureNS) {
                var parsers = {};
                for (i = 0, ii = featureTypes.length; i < ii; ++i) {
                    var featurePrefix = featureTypes[i].indexOf(':') === -1 ?
                        defaultPrefix : featureTypes[i].split(':')[0];
                    if (featurePrefix === p) {
                        parsers[featureTypes[i].split(':').pop()] =
                            (localName == 'featureMembers') ?
                                ol.xml.makeArrayPusher(this.readFeatureElement, this) :
                                ol.xml.makeReplacer(this.readFeatureElement, this);
                    }
                }
                parsersNS[featureNS[p]] = parsers;
            }
            if (localName == 'featureMember' || localName == 'member') { // Elemento solo
                features = ol.xml.pushParseAndPop(undefined, parsersNS, node, objectStack);
            } else { // Colección de elementos
                features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack);
            }
        }
        if (features === null) {
            features = [];
        }
        // Revisamos que todas las features tienen geometría válida o no tienen geometría definida. Evitamos así que cuele un GML 2 parseado con el parser GML 3.
        var checkFeatureGeometry = function (feat) {
            var geom = feat.getGeometry();
            if (feat.getProperties().hasOwnProperty(feat.getGeometryName()) && (!geom || !geom.flatCoordinates.length)) {
                throw 'Geometría no válida. ¿Posible versión incorrecta de GML?';
            }
        };
        if (features instanceof ol.Feature) {
            checkFeatureGeometry(features);
        }
        else {
            for (var i = 0, len = features.length; i < len; i++) {
                checkFeatureGeometry(features[i]);
            }
        }
        return features;
    };

    ol.format.GML3CRS84 = function () {
        ol.format.GML3.call(this, {
            srsName: 'CRS:84'
        });
    };
    ol.inherits(ol.format.GML3CRS84, ol.format.GML3);

    ol.format.GML2CRS84 = function () {
        ol.format.GML2.call(this, {
            srsName: 'CRS:84'
        });
    };
    ol.inherits(ol.format.GML2CRS84, ol.format.GML2);

    // Parche para evitar el error AssertionError: Assertion failed: calculated value (1.020636810790192) ouside allowed range (0-1)
    ol.View.prototype.getValueForResolutionFunction = function (opt_power) {
        var power = opt_power || 2;
        var maxResolution = this.maxResolution_;
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
            /**
                 * @param {number} resolution Resolution.
                 * @return {number} Value.
             */
            function (resolution) {
                var value =
                    (Math.log(maxResolution / resolution) / Math.log(power)) / max;
                value = Math.max(Math.min(1, value), 0);
                return value;
            });
    };

    // Modificación para cambiar el comportamiento de ol.control.OverviewMap:
    // Mantener la caja del extent siempre centrada.
    ol.control.OverviewMap.prototype._validateExtent_ = ol.control.OverviewMap.prototype.validateExtent_;
    ol.control.OverviewMap.prototype.validateExtent_ = function () {
        var self = this;
        self._validateExtent_();
        if (self._wrap && self._wrap.parent.options.alwaysCentered) {
            self.recenter_();
        }
    };

    // En modo 3D, cambiar la lógica de la escala para que siempre muestre área de visión.
    ol.control.OverviewMap.prototype._resetExtent_ = ol.control.OverviewMap.prototype.resetExtent_;
    ol.control.OverviewMap.prototype.resetExtent_ = function () {
        var self = this;
        self._resetExtent_.call(self);
        var wrap = self._wrap;
        if (wrap.is3D) {
            var ovmap = self.ovmap_;
            var ovview = ovmap.getView();
            var extent = ovview.calculateExtent();
            var feature = wrap.get3DCameraLayer().getSource().getFeatures()[0];
            if (feature) {
                coordinates = feature.getGeometry().getCoordinates();
                var coord1 = coordinates[0][0];
                var coord2 = coordinates[0][1];
                if (!ol.extent.containsCoordinate(extent, coord1) || !ol.extent.containsCoordinate(extent, coord2)) {
                    var buffer = Math.max(
                        extent[0] - coord1[0],
                        extent[1] - coord1[1],
                        coord1[0] - extent[2],
                        coord1[1] - extent[3],
                        extent[0] - coord2[0],
                        extent[1] - coord2[1],
                        coord2[0] - extent[2],
                        coord2[1] - extent[3]
                    );
                    ovview.fit(ol.extent.buffer(extent, buffer));
                }
            }
        }
    };

    // Parche a mantener hasta que se actualize cartoteca
    const oldImage = ol.Image;
    ol.Image = function () {
        if (arguments.length === 7) {
            Array.prototype.splice.call(arguments, 3, 1);
        }
        return oldImage.apply(this, arguments);
    }
    TC.inherit(ol.Image, oldImage);

    if (!TC.Util.detectMobile()) {
        // Parche para situar el ancla del popup cuando tenemos zoom in/out de navegador o pantalla
        ol.Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
            var style = this.element.style;
            var offset = this.getOffset();

            var positioning = this.getPositioning();

            this.setVisible(true);

            var offsetX = offset[0];
            var offsetY = offset[1];
            if (positioning == ol.OverlayPositioning.BOTTOM_RIGHT ||
                positioning == ol.OverlayPositioning.CENTER_RIGHT ||
                positioning == ol.OverlayPositioning.TOP_RIGHT) {
                if (this.rendered.left_ !== '') {
                    this.rendered.left_ = style.left = '';
                }
                var right = Math.round(mapSize[0] - pixel[0] - offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.right_ != right) {
                    this.rendered.right_ = style.right = right;
                }
            } else {
                if (this.rendered.right_ !== '') {
                    this.rendered.right_ = style.right = '';
                }
                if (positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.TOP_CENTER) {
                    offsetX -= this.element.offsetWidth / 2;
                }
                var left = Math.round(pixel[0] + offsetX) / window.devicePixelRatio + 'px';
                if (this.rendered.left_ != left) {
                    this.rendered.left_ = style.left = left;
                }
            }
            if (positioning == ol.OverlayPositioning.BOTTOM_LEFT ||
                positioning == ol.OverlayPositioning.BOTTOM_CENTER ||
                positioning == ol.OverlayPositioning.BOTTOM_RIGHT) {
                if (this.rendered.top_ !== '') {
                    this.rendered.top_ = style.top = '';
                }
                var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.bottom_ != bottom) {
                    this.rendered.bottom_ = style.bottom = bottom;
                }
            } else {
                if (this.rendered.bottom_ !== '') {
                    this.rendered.bottom_ = style.bottom = '';
                }
                if (positioning == ol.OverlayPositioning.CENTER_LEFT ||
                    positioning == ol.OverlayPositioning.CENTER_CENTER ||
                    positioning == ol.OverlayPositioning.CENTER_RIGHT) {
                    offsetY -= this.element.offsetHeight / 2;
                }
                var top = Math.round(pixel[1] + offsetY) / window.devicePixelRatio + 'px';
                if (this.rendered.top_ != top) {
                    this.rendered.top_ = style.top = top;
                }
            }
        };
    }

    /////////////////////////////////////////////////////

    var getRGBA = function (color, opacity) {
        var result;
        if (color) {
            result = ol.color.asArray(color);
            result = result.slice();
            if (opacity !== undefined) {
                result[3] = opacity;
            }
        }
        else {
            result = [0, 0, 0, 1];
        }
        return result;
    };

    /**
     * Obtiene el objeto de opciones de una vista que restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
     * el mapa base activo.
     */
    var getResolutionOptions = function (mapWrap, layer) {
        var view = mapWrap.map.getView();
        var prevRes = view.getResolution();

        var pms = {
            projection: view.getProjection(),
            center: view.getCenter(),
            resolution: prevRes,
            enableRotation: false
        };

        if (mapWrap.parent.maxExtent) {
            pms.extent = mapWrap.parent.maxExtent;
        }

        // GLS 06/03/2019 Corregimos bug 24832, si el mapa de fondo es el mapa en blanco, asignamos las resoluciones del mapa de fondo actual
        var layerForResolutions = layer;
        if (layer.type === TC.Consts.layerType.VECTOR && mapWrap.parent.getBaseLayer()) {
            layerForResolutions = mapWrap.parent.getBaseLayer();
        }

        var res = layerForResolutions.getResolutions ? layerForResolutions.getResolutions() : [];
        var maxRes;
        var minRes;

        if (res && res.length) {
            maxRes = layerForResolutions.maxResolution || res[0];
            minRes = layerForResolutions.minResolution || res[res.length - 1];

            var minResIx = res.indexOf(minRes);
            var maxResIx = res.indexOf(maxRes);

            pms.resolutions = res.slice(maxResIx, minResIx + 1);
        }
        else {
            maxRes = layerForResolutions.maxResolution;
            minRes = layerForResolutions.minResolution;
        }
        if (minRes) {
            pms.minResolution = minRes;
            if (prevRes < minRes) {
                pms.resolution = minRes;
            }
        }
        if (maxRes) {
            pms.maxResolution = maxRes;
            if (prevRes > maxRes) {
                pms.resolution = maxRes;
            }
        }

        return pms;
    };


    TC.wrap.Map.prototype.setMap = function () {
        var self = this;
        var center = [
            (self.parent.initialExtent[0] + self.parent.initialExtent[2]) / 2,
            (self.parent.initialExtent[1] + self.parent.initialExtent[3]) / 2
        ];

        var proj4Obj = proj4(self.parent.crs);
        var addEquivalentProjections = function () {
            // Añadimos proyecciones equivalentes y transformaciones necesarias.
            var crsCode = self.parent.crs.substr(self.parent.crs.lastIndexOf(':') + 1);

            var projOptions = {
                units: proj4Obj.oProj.units,
                global: true
            };

            var equivalentProjections = [];
            if (crsCode !== '4326') { // Este código ya está metido, no lo machacamos
                projOptions.code = 'EPSG:' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));
                projOptions.code = 'urn:ogc:def:crs:EPSG::' + crsCode;
                equivalentProjections.push(new ol.proj.Projection(projOptions));

                ol.proj.addEquivalentProjections(equivalentProjections);
            }
            var doTransform = function (fn, input, opt_output, opt_dimension) {
                var result = [];
                var dimension = opt_dimension || 2;
                for (var i = 0; i < input.length; i += dimension) {
                    var transformed = Array.prototype.slice.call(fn(input.slice(i, i + dimension)));
                    if (dimension === 3 || dimension === 4) {
                        transformed = transformed.slice(0, 2).concat(input.slice(i + 2, (i + 2) + (dimension - 2)));
                    }

                    result = result.concat(transformed);
                }
                if ($.isArray(opt_output)) {
                    opt_output.length = 0;
                    for (var i = 0; i < result.length; i++) {
                        opt_output[i] = result[i];
                    }
                    result = opt_output;
                }
                return result;
            };
            var fromEPSG4326 = function (input, opt_output, opt_dimension) {
                return doTransform(proj4Obj.forward, input, opt_output, opt_dimension);
            };
            var toEPSG4326 = function (input, opt_output, opt_dimension) {
                return doTransform(proj4Obj.inverse, input, opt_output, opt_dimension);
            };

            ol.proj.addEquivalentTransforms(
                ol.proj.EPSG4326.PROJECTIONS,
                equivalentProjections,
                fromEPSG4326,
                toEPSG4326);
        };

        addEquivalentProjections();

        var projOptions = {
            code: self.parent.crs,
            units: proj4Obj.oProj.units
        };
        if (self.parent.crs === 'EPSG:4326') {
            projOptions.axisOrientation = 'neu';
        }
        var projection = new ol.proj.Projection(projOptions);

        var interactions = ol.interaction.defaults({ constrainResolution: true });

        var viewOptions = {
            projection: projection,
            center: center,
            enableRotation: false
        };
        if (self.parent.maxExtent) {
            var maxExtent = self.parent.maxExtent;
            viewOptions.extent = maxExtent;
            var rect = self.parent.div.getBoundingClientRect();
            var ratio = rect.width / rect.height;
            var dx = maxExtent[2] - maxExtent[0];
            var dy = maxExtent[3] - maxExtent[1];
            if (rect.width / rect.height > dx / dy) {
                viewOptions.resolution = dx / rect.width;
            }
            else {
                viewOptions.resolution = dy / rect.height;
            }
        }
        else {
            viewOptions.zoom = 2;
        }

        self.map = new ol.Map({
            target: self.parent.div,
            renderer: ol.renderer.Type.CANVAS,
            view: new ol.View(viewOptions),
            controls: [],
            interactions: interactions,
            pixelRatio: 1 /* 08/02/2019 GLS: 
            Establecemos el pixelRatio siempre a uno, porque OL sólo atiende al valor al principio, 
            si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso,
            click se sitúa mal, popup se sitúa entre otros efectos.
            Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                Bug 25976:Mapa situación en blanco
                Bug 25954:Canvas en blanco con zoom mayor al 100%
                Bug 23855:Mapa de situación se muestra en blanco
            */
        });

        if (!TC.Util.detectMobile()) {
            // Parche para corregir https://github.com/openlayers/openlayers/issues/2904
            // saben que tienen un bug cuando se trabaja sobre un mapa con zoom
            self.map.getEventPixel = function (event) {
                var viewportPosition = this.viewport_.getBoundingClientRect();
                var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
                eventPosition = eventPosition.clientX ? eventPosition : (eventPosition.pointerEvent ? eventPosition.pointerEvent : eventPosition);
                return [
                    (eventPosition.clientX - viewportPosition.left) * window.devicePixelRatio,
                    (eventPosition.clientY - viewportPosition.top) * window.devicePixelRatio
                ];
            };
        }

        self.map._wrap = self;
        self._promise = Promise.resolve(self.map);

        // mantenemos el ancho y alto del canvas en números enteros
        self.manageSize.call(self.map);

        // Para evitar estiramientos en canvas
        var updateSize = function () {
            self.map.updateSize();
        };
        self.parent.div.addEventListener(ol.events.EventType.RESIZE, updateSize);
        self.parent.one(TC.Consts.event.MAPLOAD, updateSize);

        self.map.on(ol.MapBrowserEventType.SINGLECLICK, function (e) {

            if (self.parent.view === TC.Consts.view.PRINTING) {
                return;
            }

            self.parent.workLayers.forEach(function (wl) {
                delete wl._noFeatureClicked;
            });
            var featuresInLayers = $.map(self.parent.workLayers, function () {
                return false;
            });
            self.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        for (var i = 0; i < self.parent.workLayers.length; i++) {
                            var wl = self.parent.workLayers[i];
                            if (wl.wrap.layer === layer) {
                                featuresInLayers[i] = true;
                                break;
                            }
                        }
                        self.parent.trigger(TC.Consts.event.FEATURECLICK, { feature: feature._wrap.parent });
                        return feature;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            for (var i = 0; i < featuresInLayers.length; i++) {
                if (!featuresInLayers[i]) {
                    self.parent.trigger(TC.Consts.event.NOFEATURECLICK, { layer: self.parent.workLayers[i] });
                }
            }
        });


        // GLS: 13/02/2019 cambiamos el orden de las suscripciones a eventos de cambio de resolución y moveend
        // para gestionar el borrado del estado inicial. Si no lo hacemos el cambio al extent inicial se registra como evento de usuario
        // porque la carga inicial del mapa con promesas nativas es más rápido que antes.
        // Bug:26001 Borrar estado inicial al entrar
        const addMoveEndListener = function () {
            self.map.on(ol.MapEventType.MOVEEND, function () {
                self.parent.trigger(TC.Consts.event.ZOOM);
            });
        };
        var olView = self.map.getView();
        olView.on('change:resolution', function () {
            if (!self.map.hasListener(ol.MapEventType.MOVEEND)) {
                self.map.once(ol.MapEventType.MOVEEND, function () {
                    addMoveEndListener();
                });
            }

            self.parent.trigger(TC.Consts.event.BEFOREZOOM);
        }, self.parent);

        const onChangeView = function () {
            if (!self.map.hasListener(ol.MapEventType.MOVEEND)) {
                self.map.un('change:view', onChangeView);
                addMoveEndListener();
            }
        };
        self.map.on('change:view', onChangeView);

        /**
         * Restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre
         * el mapa base activo.
         */
        var limitZoomLevels = function (layer) {
            var prevRes = self.map.getView().getResolution();
            var prevZoom = self.map.getView().getZoom();

            var pms = getResolutionOptions(self, layer);

            var view = new ol.View(pms);
            self.map.setView(view);
            self.map.render();
        };

        self.parent.on(TC.Consts.event.BASELAYERCHANGE, function (e) {
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            if (self.parent.crs === self.parent.options.crs && !self.parent.on3DView && e.layer.type !== TC.Consts.layerType.VECTOR) {
                limitZoomLevels(e.layer);
            }
        });
        self.parent.on(TC.Consts.event.MAPLOAD, function (e) {
            limitZoomLevels(self.parent.getBaseLayer());
        });

        const olMapViewport = self.map.getViewport();

        olMapViewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
            var mapTarget = self.map.getTarget();
            var hit = false;
            var feature;

            if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {

                if (self.parent.view === TC.Consts.view.PRINTING) {
                    return;
                }

                var pixel = self.map.getEventPixel(e);
                hit = self.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
                    var result = true;
                    if (feature._wrap && !feature._wrap.parent.showsPopup && !feature._wrap.parent.options.selectable) {
                        result = false;
                    }

                    if (result && feature._wrap) {
                        self.parent.trigger(TC.Consts.event.FEATUREOVER, {
                            feature: feature._wrap.parent
                        });
                    }

                    return result;
                }, { hitTolerance: hitTolerance });
            }

            if (hit) {
                mapTarget.style.cursor = 'pointer';
            } else {
                mapTarget.style.cursor = '';
                //self.parent.trigger(TC.Consts.event.FEATUREOUT);
            }
        });
    };

    var getMetersPerUnit = function (proj, extentInDegrees) {
        var units = proj.getUnits();
        if (!units || units === ol.proj.Units.DEGREES) {
            return TC.Util.getMetersPerDegree(extentInDegrees);
        }
        return ol.proj.METERS_PER_UNIT[units];
    };

    TC.wrap.Map.prototype.getMetersPerUnit = function () {
        var self = this;
        return getMetersPerUnit(ol.proj.get(self.parent.crs), self.getExtent());
    };

    var getUnitRatio = function (options) {
        var self = this;
        options = options || {};
        var defaultCrs = self.parent.options.crs || TC.Cfg.crs;
        var defaultProj = ol.proj.get(defaultCrs);
        var newProj = ol.proj.get(options.crs);
        return getMetersPerUnit(newProj, options.extentInDegrees) / getMetersPerUnit(defaultProj, options.extentInDegrees);
    };

    var normalizeProjection = function (options) {
        var result;
        if (options.axisOrientation) {
            result = new ol.proj.Projection({
                code: options.crs,
                axisOrientation: options.axisOrientation
            });
        }
        else {
            result = ol.proj.get(options.crs);
        }
        if (!result.getUnits()) {
            result.units_ = ol.proj.Units.DEGREES;
        }
        return result;
    };

    TC.wrap.Map.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};
        const baseLayer = options.baseLayer || self.parent.baseLayer;
        var extent;
        if (options.extent) {
            extent = options.extent;
        }
        else {
            extent = ol.proj.transformExtent(self.getExtent(), self.parent.crs, options.crs);
        }
        const extentInDegrees = ol.proj.transformExtent(extent, options.crs, 'EPSG:4326');
        const unitRatio = getUnitRatio.call(self, {
            crs: options.crs,
            extentInDegrees: extentInDegrees
        });
        const projection = normalizeProjection(options);
        const oldView = self.map.getView();
        const viewOptions = {
            projection: projection,
            enableRotation: false
        };
        const resolutions = baseLayer.getResolutions();

        if (resolutions && resolutions.length) {
            viewOptions.resolutions = resolutions;
        }
        else {
            viewOptions.minZoom = oldView.getMinZoom();
            viewOptions.maxZoom = oldView.getMaxZoom();
            const minResolution = baseLayer.wrap.layer.getMinResolution();
            const maxResolution = baseLayer.wrap.layer.getMaxResolution();
            var transformFactor = 1;
            if (minResolution === 0 || maxResolution === Number.POSITIVE_INFINITY) {
                const oldUnitRatio = getUnitRatio.call(self, {
                    crs: self.parent.crs,
                    extentInDegrees: extentInDegrees
                });
                transformFactor = oldUnitRatio / unitRatio;
            }
            if (minResolution === 0) {
                viewOptions.minResolution = oldView.getMinResolution() * transformFactor;
            }
            else {
                viewOptions.minResolution = minResolution;
            }
            if (maxResolution === Number.POSITIVE_INFINITY) {
                viewOptions.maxResolution = oldView.getMaxResolution() * transformFactor;
            }
            else {
                viewOptions.maxResolution = maxResolution;
            }
        }

        // GLS: transformamos también el centro     
        viewOptions.center = ol.proj.transform(self.getCenter(), self.parent.crs, options.crs);

        var newView = new ol.View(viewOptions);
        self.map.setView(newView);
        self.parent.initialExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.initialExtent, self.parent.crs, options.crs) : self.parent.options.initialExtent;        
        if (self.parent.options.maxExtent) {            
            self.parent.options.maxExtent = self.parent.maxExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.maxExtent, self.parent.crs, options.crs) : self.parent.options.maxExtent;
        }
        newView.fit(extent, { nearest: true });
    };

    /*
     *  insertLayer: inserts OpenLayers layer at index
     *  Parameters: OpenLayers.Layer, number
     */
    TC.wrap.Map.prototype.insertLayer = function (olLayer, idx) {
        var self = this;
        var layers = self.map.getLayers();
        var alreadyExists = false;
        for (var i = 0; i < layers.getLength(); i++) {
            if (layers.item(i) === olLayer) {
                alreadyExists = true;
                break;
            }
        }
        if (alreadyExists) {
            layers.remove(olLayer);
            layers.insertAt(idx, olLayer);
        }
        else {
            if (idx < 0) {
                layers.push(olLayer);
            }
            else {
                layers.insertAt(idx, olLayer);
            }
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            var view = self.map.getView();
            if (self.parent.crs === self.parent.options.crs) {
                if (olLayer instanceof ol.layer.Tile) {
                    var resolutions = olLayer.getSource().getResolutions();
                    view.maxResolution_ = resolutions[0];
                    view.minResolution_ = resolutions[resolutions.length - 1];
                }
            }
            else {
                // Cambiamos los límites de resolución de la capa a los de la vista. Esto lo hacemos porque su resolución está en otro CRS.
                if (olLayer instanceof ol.layer.Tile) {
                    olLayer.setMaxResolution(view.getMaxResolution());
                    olLayer.setMinResolution(view.getMinResolution());
                }
            }

            var wrap = olLayer._wrap;
            var loadingTileCount = 0;

            var beforeTileLoadHandler = function (e) {
                wrap.parent.state = TC.Layer.state.LOADING;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    self.parent.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: wrap.parent });
                }
                olLayer._loadingTileCount = olLayer._loadingTileCount + 1;
            };
            if (wrap.parent.state === TC.Layer.state.LOADING && wrap.parent.isRaster()) {
                beforeTileLoadHandler();
            }
            wrap.$events.on(TC.Consts.event.BEFORETILELOAD, beforeTileLoadHandler);

            wrap.$events.on(TC.Consts.event.TILELOAD, function (e) {
                loadingTileCount = loadingTileCount - 1;
                if (loadingTileCount <= 0) {
                    loadingTileCount = 0;
                    wrap.parent.state = TC.Layer.state.IDLE;
                    self.parent.trigger(TC.Consts.event.LAYERUPDATE, { layer: wrap.parent });
                }
            });
        }
    };

    TC.wrap.Map.prototype.removeLayer = function (olLayer) {
        this.map.removeLayer(olLayer);
    };

    TC.wrap.Map.prototype.getLayerCount = function () {
        return this.map.getLayerGroup().getLayers().getLength();
    };

    TC.wrap.Map.prototype.indexOfFirstVector = function () {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (l, i) {
            if (l instanceof ol.layer.Vector && result === -1) {
                result = i;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.getLayerIndex = function (olLayer) {
        var result = -1;
        this.map.getLayerGroup().getLayers().forEach(function (elm, idx) {
            if (elm === olLayer) {
                result = idx;
            }
        });
        return result;
    };

    TC.wrap.Map.prototype.setLayerIndex = function (olLayer, index) {
        var layers = this.map.getLayers();
        var list = layers.getArray();
        var ix = list.indexOf(olLayer);

        if (ix > -1 && ix != index) {
            this.map.removeLayer(olLayer);
            this.insertLayer(olLayer, index);
            //layers.setAt(index, olLayer);
        }
        else {
            //no está el layer, así que no hago nada
        }

    };

    TC.wrap.Map.prototype.setBaseLayer = function (olLayer) {
        var self = this;
        return new Promise(function (resolve, reject) {
            var setLayer = function (curBl) {
                // GLS: si se llega después de una animación el valor de self.parent.getBaseLayer() ya es el definitivo y no el actual lo que provoca efectos indeseados. 
                // ir a línea 1313: paso como parámetro el baseLayer actual en el caso de animación.
                var curBl = curBl || self.parent.getBaseLayer();
                if (curBl) {
                    self.map.removeLayer(curBl.wrap.layer);
                    if (olLayer instanceof ol.layer.Image) { // Si es imagen no teselada
                        var unitRatio = getUnitRatio.call(self, {
                            crs: self.parent.crs,
                            extent: self.parent.getExtent()
                        });
                        olLayer._wrap.setProjection({
                            crs: self.parent.crs
                        });
                    }

                    if (olLayer._wrap.parent.type === TC.Consts.layerType.WMTS) {
                        var layerProjectionOptions = { crs: self.parent.crs, oldCrs: olLayer.getSource().getProjection().getCode() };

                        if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                            olLayer._wrap.parent.setProjection(layerProjectionOptions);
                        }
                    }

                    //if (olLayer instanceof ol.layer.Tile) { // Si es imagen teselada
                    //    const view = self.map.getView();
                    //    const resolutions = olLayer.getSource().getResolutions();
                    //    if (resolutions) {
                    //        view.options_.resolutions = resolutions;
                    //        view.applyOptions_(view.options_);
                    //    }
                    //}
                }
                self.insertLayer(olLayer, 0);
                resolve();
            };

            // Toda esta lógica antes de llamar a setLayer() es para hacer un zoom a la nueva resolución
            // cuando la nueva capa no llega a la resolución actual
            var viewOptions = getResolutionOptions(self, olLayer._wrap.parent);
            var view = self.map.getView();
            var currentResolution = view.getResolution();
            // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas
            if (self.parent.crs === self.parent.options.crs && viewOptions.resolutions) {
                //buscamos la nueva resolución: o una que sea similar a la actual dentro de los márgenes admitidos, o la inmediata superior
                var newRes = viewOptions.resolutions
                    .sort(function (a, b) { return a - b })
                    .reduce(function (prev, elm) {
                        if (prev === 0 &&
                            (elm > currentResolution || Math.abs(1 - (currentResolution / elm)) < self.parent.options.maxResolutionError)) {
                            return elm;
                        }
                        return prev;
                    }, 0);
                if (newRes !== currentResolution) {
                    if (self.parent.isLoaded) {
                        view.animate({ resolution: newRes, duration: TC.Consts.ZOOM_ANIMATION_DURATION }, setLayer.bind(self, self.parent.getBaseLayer()));
                    }
                    else { // Primera carga, no animamos
                        view.setResolution(newRes);
                        setLayer();
                    }
                }
                else {
                    setLayer();
                }
            }
            else {
                setLayer();
            }
        });
    };

    TC.wrap.Map.prototype.setExtent = function (extent, options) {
        const self = this;
        options = options || {};

        const applyExtent = function (view, mapSize, resolve, reject) {
            var res = view.getResolutionForExtent(extent, mapSize);
            // URI: Esta logica está fusilada de la función fit de un objeto view de OL3
            if (view.constrainResolution) {
                var constrainedResolution = view.constrainResolution(res, 0, 0);
                if (constrainedResolution < res) {
                    if (constrainedResolution / res < TC.Consts.EXTENT_TOLERANCE) {
                        constrainedResolution = view.constrainResolution(
                            constrainedResolution, -1, 0);
                    }
                }
                res = constrainedResolution;
            }

            // flacunza: No animamos si la duración va a ser 0, porque a veces el zoom no se completa
            // GLS: antes de resolver la promesa validamos si existe animación
            // URI: si la animacion no existe ponemos duracion 0
            // flacunza: en caso de que animate=undefined, se anima
            const center = [((extent[0] + extent[2]) / 2), ((extent[1] + extent[3]) / 2)];
            if (options.animate === void (0) || options.animate) {
                view.animate({
                    resolution: res,
                    center: center,
                    duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, resolve);
            }
            else {
                view.setCenter(center);
                view.setResolution(res);
                resolve();
            }
        };

        const setPromise = function (extent, options) {
            self._setExtentPromise = new Promise(function (resolve, reject) {
                // Timeout porque OL3 no tiene evento featuresadded, por tanto cuando se activa map.options.zoomToMarkers
                // se lanza un setExtent por marcador. El timeout evita ejecuciones a lo tonto.
                clearTimeout(self._timeout);
                self._timeout = setTimeout(function () {
                    var mapSize = self.map.getSize();
                    var view = self.map.getView();

                    if (self.parent.baseLayer) {
                        self.parent.baseLayer.wrap.getLayer().then(function (olLayer) {
                            // Todo esto para evitar que haga más zoom que el admisible por la capa base
                            var olSource = olLayer.getSource();
                            if (olSource.getResolutions != goog.abstractMethod) {
                                var res = view.getResolutionForExtent(extent, mapSize);
                                var resolutions = self.map.getView().getResolutions();

                                if (resolutions && resolutions.length > 0) {
                                    var minRes = Math.min.apply(self, resolutions);
                                    if (minRes > res) {
                                        var factor = 0.5 * (minRes / res - 1);
                                        var dx = ol.extent.getWidth(extent) * factor;
                                        var dy = ol.extent.getHeight(extent) * factor;
                                        extent = extent.slice(0);
                                        extent[0] = extent[0] - dx;
                                        extent[1] = extent[1] - dy;
                                        extent[2] = extent[2] + dx;
                                        extent[3] = extent[3] + dy;
                                    }
                                }
                            }

                            applyExtent(view, mapSize, resolve, reject);

                        });
                    }
                    else {
                        applyExtent(view, mapSize, resolve, reject);
                    }
                }, 50);
            });
        };
        Promise.resolve(self._setExtentPromise).finally(function () {
            setPromise(extent, options);
        });

        return self._setExtentPromise;
    };

    TC.wrap.Map.prototype.getExtent = function () {
        return this.map.getView().calculateExtent(this.map.getSize());
    };

    TC.wrap.Map.prototype.setCenter = function (coords, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const callback = function () {
                resolve();
            };

            const opts = options || {};
            const view = self.map.getView();

            if (opts.animate) {
                view.animate({
                    center: coords, duration: TC.Consts.ZOOM_ANIMATION_DURATION
                }, callback);
            }
            else {
                view.setCenter(coords);
                resolve();
            }
        });
    };

    TC.wrap.Map.prototype.getCenter = function () {
        return this.map.getView().getCenter();
    };

    TC.wrap.Map.prototype.getResolution = function () {
        return this.map.getView().getResolution();
    };

    TC.wrap.Map.prototype.setResolution = function (resolution) {
        this.getMap().then(function (olMap) {
            olMap.getView().setResolution(resolution);
        });
    };

    TC.wrap.Map.prototype.setRotation = function (rotation) {
        this.getMap().then(function (olMap) {
            olMap.getView().setRotation(rotation);
        });
    };

    TC.wrap.Map.prototype.getRotation = function () {
        return this.map.getView().getRotation();
    };

    TC.wrap.Map.prototype.getResolutions = function () {
        return this.map.getView().getResolutions() || [];
    };

    TC.wrap.Map.prototype.getCoordinateFromPixel = function (xy) {
        return this.map.getCoordinateFromPixel(xy);
    };

    TC.wrap.Map.prototype.getPixelFromCoordinate = function (coord) {
        return this.map.getPixelFromCoordinate(coord);
    };

    TC.wrap.Map.prototype.getViewport = function (options) {
        const self = this;
        var result;
        var opts = options || {
        };
        if (opts.synchronous) {
            result = self.map.getViewport();
        }
        else {
            result = new Promise(function (resolve, reject) {
                self.getMap().then(function (olMap) {
                    resolve(olMap.getViewport());
                });
            });
        }
        return result;
    };

    TC.wrap.Map.prototype.isNative = function (map) {
        return map instanceof ol.Map;
    };

    TC.wrap.Map.prototype.isGeo = function () {
        var units = this.map.getView().getProjection().getUnits();
        return !units || units === ol.proj.Units.DEGREES;
    };

    TC.wrap.Map.prototype.addPopup = function (popupCtl) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var draggable = popupCtl.options.draggable === undefined || popupCtl.options.draggable;
            TC.loadJS(
                draggable && !window.Draggabilly,
                [TC.apiLocation + 'lib/draggabilly/draggabilly.pkgd.min.js'],
                function () {
                    self.getMap().then(function (olMap) {
                        if (!popupCtl.popupDiv) {
                            // No popups yet
                            const popupDiv = TC.Util.getDiv();
                            popupCtl.popupDiv = popupDiv;
                            popupCtl.$popupDiv = $(popupDiv);
                            popupDiv.classList.add(TC.control.Popup.prototype.CLASS);
                            popupCtl.contentDiv = TC.Util.getDiv();
                            popupCtl.contentDiv.classList.add(TC.control.Popup.prototype.CLASS + '-content');
                            popupCtl.popupDiv.appendChild(popupCtl.contentDiv);
                            popupCtl.menuDiv = TC.Util.getDiv();
                            popupCtl.menuDiv.classList.add(TC.control.Popup.prototype.CLASS + '-menu');
                            popupCtl.popupDiv.appendChild(popupCtl.menuDiv);
                            self.parent.div.appendChild(popupDiv);

                            var popup = new ol.Overlay({
                                element: popupDiv,
                                positioning: ol.OverlayPositioning.BOTTOM_LEFT
                            });
                            olMap.addOverlay(popup);
                            popupCtl.wrap.popup = popup;

                            //popupCtl._firstRender.resolve();
                            //popupCtl.trigger(TC.Consts.event.CONTROLRENDER);
                            const olMapViewport = olMap.getViewport();

                            if (draggable) {
                                const container = popupCtl.popupDiv.parentElement;
                                popupCtl.popupDiv.classList.add(TC.Consts.classes.DRAGGABLE);


                                container.addEventListener('touchmove', function (e) {
                                    var parent = e.target;
                                    while (parent) {
                                        parent = parent.parentElement;
                                        if (parent  && parent.matches('.tc-ctl-finfo-layer-content')) {
                                            e.stopPropagation();
                                            break;
                                        }
                                    }
                                });

                                // Tuneamos Draggabilly para que acepte excepciones a los asideros del elemento.
                                const drag = new Draggabilly(container, {
                                    not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                });
                                drag.handleEvent = function (event) {
                                    if (this.options.not && event.target && event.target.matches(this.options.not)) {
                                        return;
                                    }
                                    Draggabilly.prototype.handleEvent.call(this, event);
                                };
                                drag.on('pointerDown', function (e, pointer) {
                                    var bcr = e.target.getBoundingClientRect();
                                    // Si estamos pulsando sobre una barra de scroll abortamos drag
                                    if (bcr.left + e.target.clientWidth < pointer.pageX || bcr.top + e.target.clientHeight < pointer.pageY) {
                                        drag._pointerCancel(e, pointer);
                                        return false;
                                    }
                                });
                                drag.on('dragStart', function (e, pointer) {
                                    popupCtl.setDragging(true);
                                    popupCtl._currentOffset = popup.getOffset();
                                    if (popupCtl._previousContainerPosition) {
                                        var mapSize = olMap.getSize();
                                        popup.setPosition(olMap.getCoordinateFromPixel([popupCtl._previousContainerPosition[0], mapSize[1] - popupCtl._previousContainerPosition[1]]));
                                        popupCtl._currentOffset = [0, 0];
                                        popup.setOffset(popupCtl._currentOffset);
                                        delete popupCtl._previousContainerPosition;
                                    }
                                    else {
                                        popupCtl._currentOffset = popup.getOffset();
                                    }
                                });
                                drag.on('dragEnd', function (e) {
                                    popupCtl.setDragging(false);
                                    var coord1 = olMap.getCoordinateFromPixel([0, 0]);
                                    var coord2 = olMap.getCoordinateFromPixel(popup.getOffset());
                                    var coordDelta = [coord2[0] - coord1[0], coord2[1] - coord1[1]];
                                    var position = popup.getPosition();
                                    popup.setPosition([position[0] + coordDelta[0], position[1] + coordDelta[1]]);
                                    popup.setOffset([0, 0]);
                                    popupCtl._currentOffset = [0, 0];

                                    const containerRect = container.getBoundingClientRect();
                                    popupCtl._previousContainerPosition = [containerRect.left, containerRect.bottom];
                                });
                                drag.on('dragMove', function (e, pointer, moveVector) {
                                    //popup.setOffset([popupCtl._currentOffset[0] + moveVector.x, popupCtl._currentOffset[1] + moveVector.y]);
                                });
                                //.drag(function (ev, dd) {
                                //    if (!ev.buttons && !Modernizr.touch) { // Evitamos que se mantenga el drag si no hay botón pulsado (p.e. en IE pulsando una scrollbar)
                                //        return false;
                                //    }
                                //    popup.setOffset([popupCtl._currentOffset[0] + dd.deltaX, popupCtl._currentOffset[1] + dd.deltaY]);
                                //}, {
                                //    not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'
                                //    })                                
                            }

                            const mouseMoveHandler = function (e) {
                                var mapTarget = olMap.getTarget();
                                var hit = false;
                                if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {
                                    var pixel = olMap.getEventPixel(e);
                                    hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                                        var result = true;
                                        if (feature._wrap && !feature._wrap.parent.showsPopup) {
                                            result = false;
                                        }
                                        return result;
                                    },
                                    {
                                        hitTolerance: hitTolerance
                                    });
                                }
                                if (hit) {
                                    mapTarget.style.cursor = 'pointer';
                                } else {
                                    mapTarget.style.cursor = '';
                                }
                            };

                            // change mouse cursor when over marker
                            olMapViewport.removeEventListener(MOUSEMOVE, mouseMoveHandler);
                            olMapViewport.addEventListener(MOUSEMOVE, mouseMoveHandler);
                        }
                    });
                    resolve();
                }
            );
        });
    };

    TC.wrap.Map.prototype.hidePopup = function (popupCtl) {
        var self = this;
        self.parent.currentFeature = null;
        if (popupCtl.popupDiv) {
            popupCtl.popupDiv.classList.remove(TC.Consts.classes.VISIBLE);
        }
    };

    TC.wrap.Map.prototype.manageSize = function () {
        const self = this;

        // Para controlar que el mapa no se vea borroso porque no encajan el width y height con los width y height de CSS
        const manageSize = function (event) {
            var pixelRatio = window.devicePixelRatio || 1;
            var canvas = event.context.canvas;
            var bounding = canvas.getBoundingClientRect();

            var idealWidth = pixelRatio * bounding.width;
            var idealHeight = pixelRatio * bounding.height;

            if (idealWidth !== bounding.width || !Number.isInteger(idealWidth)) {
                idealWidth = Math.round(idealWidth);
            }

            if (idealHeight !== bounding.height || !Number.isInteger(idealHeight)) {
                idealHeight = Math.round(idealHeight);
            }

            if (idealWidth !== bounding.width || idealHeight !== bounding.height) {
                var newSize = [idealWidth, idealHeight];
                event.target.setSize(newSize);
            }
        };

        if (!TC.Util.detectMobile()) {
            self.on(ol.render.EventType.POSTCOMPOSE, manageSize);
        }
    };

    var getFormatFromName = function (name) {
        switch (name) {
            case TC.Consts.layerType.KML:
            case TC.Consts.mimeType.KML:
                return new ol.format.KML({
                    showPointNames: false
                });
            case TC.Consts.layerType.GPX:
            case TC.Consts.mimeType.GPX:
                return new ol.format.GPX();
            case TC.Consts.layerType.GEOJSON:
            case TC.Consts.mimeType.GEOJSON:
            case TC.Consts.mimeType.JSON:
            case TC.Consts.format.JSON:
                return new ol.format.GeoJSON();
            case TC.Consts.format.GML2:
                return new ol.format.GML2();
            case TC.Consts.format.GML3:
                return new ol.format.GML3Patched();
            case TC.Consts.mimeType.GML:
            case TC.Consts.format.GML:
                return new ol.format.GML();
            case TC.Consts.format.TOPOJSON:
                return new ol.format.TopoJSON();
            case TC.Consts.format.WKT:
                return new ol.format.WKT();
            default:
                return null;
        }
    };

    TC.wrap.Map.prototype.exportFeatures = function (features, options) {
        var self = this;
        options = options || {};
        var nativeStyle = createNativeStyle({
            styles: self.parent.options.styles
        });
        var olFeatures = features.map(function (elm) {
            var result = elm.wrap.feature;
            // Si la feature no tiene estilo propio le ponemos el definido por la API
            if (!result.getStyle()) {
                result.setStyle(nativeStyle);
            }
            // Miramos si tiene texto, en cuyo caso la features se clona para no contaminar la feature orignal 
            // y al clon se le añade el texto como atributo (necesario para exportar etiquetas en KML y GPX)
            const text = getFeatureStyle.call(result).getText();
            if (text) {
                result = result.clone();
                result.setProperties({
                    name: text.getText()
                });
            }
            return result;
        });
        var format = getFormatFromName(options.format);

        if (format instanceof ol.format.KML) {
            // KML no tiene estilo para puntos aparte del de icono. Para puntos sin icono creamos uno en SVG.
            olFeatures = olFeatures
                .map(function (feature) {
                    const geom = feature.getGeometry();
                    if (geom instanceof ol.geom.Point) {
                        // Si el punto no tiene icono, creamos uno nuevo con un icono generado como data URI a partir del estilo
                        var style = getFeatureStyle.call(feature);
                        const shape = style.getImage();
                        if (shape instanceof ol.style.RegularShape) {
                            const radius = shape.getRadius();
                            const stroke = shape.getStroke();
                            const fill = shape.getFill();
                            const strokeWidth = stroke.getWidth();
                            const diameter = (2 * radius) + strokeWidth + 1;
                            const position = diameter / 2;
                            const canvas = document.createElement('canvas');
                            canvas.width = diameter;
                            canvas.height = diameter;
                            const vectorContext = ol.render.toContext(canvas.getContext('2d'), {
                                size: [diameter, diameter]
                            });
                            const text = style.getText();
                            style = style.clone();
                            style.setText(); // Quitamos el texto para que no salga en el canvas
                            vectorContext.setStyle(style);
                            vectorContext.drawGeometry(new ol.geom.Point([position, position]));
                            const newFeature = new ol.Feature(geom);
                            newFeature.setProperties(feature.getProperties());
                            newFeature.setStyle(new ol.style.Style({
                                image: new ol.style.Icon({
                                    src: canvas.toDataURL('image/png')
                                }),
                                text: text
                            }));
                            return newFeature;
                        }
                    }
                    return feature;
                });
            // KML no pone etiquetas a líneas y polígonos. En esos casos ponemos un punto con la etiqueta.
            const pointsToAdd = [];
            olFeatures.forEach(function (feature) {
                var style = getFeatureStyle.call(feature);
                const geometry = feature.getGeometry();
                const text = style.getText();
                var point;
                if (text) {
                    switch (true) {
                        case geometry instanceof ol.geom.LineString:
                            point = new ol.geom.Point(geometry.getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.Polygon:
                            point = geometry.getInteriorPoint();
                            break;
                        case geometry instanceof ol.geom.MultiLineString:
                            // Seleccionamos la línea más larga
                            const lineStrings = geometry.getLineStrings();
                            var maxLength = -1;
                            point = new ol.geom.Point(lineStrings[lineStrings
                                .map(function (line) {
                                    return line.getLength();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxLength) {
                                        maxLength = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getCoordinateAt(0.5));
                            break;
                        case geometry instanceof ol.geom.MultiPolygon:
                            // Seleccionamos el polígono más grande
                            const polygons = geometry.getPolygons();
                            var maxArea = -1;
                            point = polygons[polygons
                                .map(function (polygon) {
                                    return polygon.getArea();
                                })
                                .reduce(function (prev, cur, idx) {
                                    if (cur > maxArea) {
                                        maxArea = cur;
                                        return idx;
                                    }
                                    return prev;
                                }, -1)].getInteriorPoint();
                            break;
                        default:
                            break;
                    }
                    if (point) {
                        const newFeature = new ol.Feature(point);
                        newFeature.setStyle(new ol.style.Style({
                            text: text.clone(),
                            image: new ol.style.Icon({
                                crossOrigin: 'anonymous',
                                src: TC.apiLocation + 'TC/css/img/transparent.gif'
                            })
                        }));
                        pointsToAdd.push(newFeature);
                    }
                }
            });
            if (pointsToAdd.length) {
                olFeatures = olFeatures.concat(pointsToAdd);
            }
        }

        if (format instanceof ol.format.GMLBase) {

            // Quitamos los espacios en blanco de los nombres de atributo en las features: no son válidos en GML.
            olFeatures = olFeatures.map(function (f) {
                return f.clone();
            });
            olFeatures.forEach(function (f) {
                const values = f.values_
                const keysToChange = [];
                for (var key in values) {
                    if (key.indexOf(' ') >= 0) {
                        keysToChange.push(key);
                    }
                }
                keysToChange.forEach(function (key) {
                    // Quitamos espacios en blanco y evitamos que empiece por un número
                    var newKey = key.replace(/ /g, '_');
                    if (/^\d/.test(newKey)) {
                        newKey = '_' + newKey;
                    }
                    if (key !== newKey) {
                        while (values[newKey] !== undefined) {
                            newKey += '_';
                        }
                    }
                    values[newKey] = values[key];
                    delete values[key];
                });
            });

            //Apañamos para que el GML sea válido. Si no lo hacemos, con IE, en ol-debug.js:36514 da un error porque node.localName no existe.
            format.featureNS = "sitna";
            format.featureType = "feature";
            var featuresNode = format.writeFeaturesNode(olFeatures, {
                featureProjection: self.parent.crs
            });

            var featureCollectionNode = ol.xml.createElementNS('http://www.opengis.net/gml',
                'FeatureCollection');
            ol.xml.setAttributeNS(featureCollectionNode, 'http://www.w3.org/2001/XMLSchema-instance',
                'xsi:schemaLocation', format.schemaLocation);
            featuresNode.removeAttribute('xmlns:xsi');
            featuresNode.removeAttribute('xsi:schemaLocation');
            featureCollectionNode.appendChild(featuresNode);
            //ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',
            //    'xsi:schemaLocation', this.schemaLocation);
            //return featureCollectionNode.outerHTML;
        }

        if (format instanceof ol.format.GPX) {
            // Queremos exportar tracks en vez de routes. OpenLayers exporta LineStrings como routes y MultiLineStrings como tracks.
            olFeatures = olFeatures.map(function (f) {
                const geom = f.getGeometry();
                if (geom instanceof ol.geom.LineString) {
                    f = f.clone();
                    f.setGeometry(new ol.geom.MultiLineString([geom.getCoordinates()]));
                }
                return f;
            });
        }

        var result = format.writeFeatures(olFeatures, {
            dataProjection: 'EPSG:4326',
            featureProjection: self.parent.crs
        });
        if (format instanceof ol.format.GPX) {
            // Este formato no procesa bien las elevaciones cuando son nulas. Hemos hecho un preproceso para transformarlas en NaN y ahora hay que eliminarlas.
            result = result.replace(/<ele>NaN<\/ele>/g, '');
        }
        return result;
    };

    var isFileDrag = function (e) {
        for (var i = 0, len = e.dataTransfer.types.length; i < len; i++) {
            if (e.dataTransfer.types[i] === 'Files') {
                return true;
            }
        }
        return false;
    };

    var handleDragEnter = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            self.getMap()._wrap.parent.div.classList.add(TC.Consts.classes.DROP);
            e.preventDefault();
            e.stopPropagation();
        }
    };

    var handleDragExit = function (e) {
        var self = this;
        if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
            var map = self.getMap()._wrap.parent;
            if (e.target === self.target) {
                map.div.classList.remove(TC.Consts.classes.DROP);
            }
        }
    };

    TC.wrap.Map.prototype.enableDragAndDrop = function (options) {
        var self = this;
        var opts = options || {};
        var ddOptions = {
            formatConstructors: [
                ol.format.KML,
                ol.format.GPX,
                ol.format.GML3CRS84,
                ol.format.GML2CRS84,
                ol.format.GML3Patched,
                ol.format.GML2,
                ol.format.GeoJSON,
                function () {
                    return new ol.format.WKT({
                        splitCollection: true
                    });
                },
                ol.format.TopoJSON
            ]
        };
        if (opts.dropTarget) {
            ddOptions.target = TC.getDiv(opts.dropTarget);
        }
        else {
            ddOptions.target = self.parent.div;
        }
        var ddInteraction = new ol.interaction.DragAndDrop(ddOptions);
        ddInteraction.on(ol.interaction.DragAndDrop.EventType_.ADD_FEATURES, function (e) {
            var featurePromises = e.features ? e.features.map(function (elm) {
                return TC.wrap.Feature.createFeature(elm);
            }) : [];
            Promise.all(featurePromises).then(function (features) {
                var li = self.parent.getLoadingIndicator();
                if (li) {
                    li.removeWait(self._featureImportWaitId);
                }
                if (features.length && !(features.some(function (feature) {
                    return !feature.geometry
                }))) {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORT, {
                        features: features, fileName: e.file.name, dropTarget: e.target.target
                    });
                }
                else {
                    self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {
                        file: e.file
                    });
                }
            });
        });
        if (opts.once) {
            ddInteraction.map_ = self.map;
        }
        else {
            self.map.addInteraction(ddInteraction);
            var dropArea = ddInteraction.target ? ddInteraction.target : self.map.getViewport();
            // Añadidos gestores de eventos para mostrar el indicador visual de drop.
            var handleDrop = function (e) {
                if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo
                    var map = self.parent;
                    if (ddInteraction.target === e.target) {
                        var li = map.getLoadingIndicator();
                        if (li) {
                            self._featureImportWaitId = li.addWait();
                        }
                        e.stopPropagation();
                    }
                    else {
                        e.preventDefault();
                    }
                    map.div.classList.remove(TC.Consts.classes.DROP);
                }
            };
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, ol.events.EventType.DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, ol.events.EventType.DRAGENTER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, ol.events.EventType.DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, ol.events.EventType.DRAGOVER,
                    handleDragEnter, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(dropArea, ol.events.EventType.DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, ol.events.EventType.DROP,
                    handleDrop, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragleave',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragend',
                    handleDragExit, ddInteraction)
            );
            ddInteraction.dropListenKeys_.push(
                ol.events.listen(document.body, 'dragexit',
                    handleDragExit, ddInteraction)
            );
            document.addEventListener('mouseenter', function (e) {
                if (!e.buttons) {
                    self.parent.div.classList.remove(TC.Consts.classes.DROP);
                }
            }, false);
            self.ddEnabled = true;
        }
        return ddInteraction;
    };

    TC.wrap.Map.prototype.loadFiles = function (files, options) {
        var self = this;
        var ddInteraction;
        if (self.ddEnabled) {
            self.map.getInteractions().forEach(function (elm) {
                if (elm instanceof ol.interaction.DragAndDrop) {
                    ddInteraction = elm;
                }
            });
        }
        else {
            ddInteraction = self.enableDragAndDrop({
                once: true
            });
        }

        if (ddInteraction && options) {
            var currentTarget = ddInteraction.target;
            ddInteraction.target = options.control;
            const undoTarget = function (e) {
                ddInteraction.target = currentTarget;

                self.parent.off(TC.Consts.event.FEATURESIMPORT, undoTarget);
            };
            self.parent.on(TC.Consts.event.FEATURESIMPORT, undoTarget);
        }

        var li = self.parent.getLoadingIndicator();
        if (li) {
            self._featureImportWaitId = li.addWait();
        }
        ol.interaction.DragAndDrop.handleDrop_.call(ddInteraction, {
            dataTransfer: {
                files: files
            }
        });
    };

    /*
     *  getVisibility: gets the OpenLayers layer visibility
     *  Result: boolean
     */
    TC.wrap.Layer.prototype.getVisibility = function (visible) {
        var self = this;
        var result = false;
        if (self.layer) {
            result = self.layer.getVisible();
        }
        return result;
    };

    /*
     *  setVisibility: Sets the OpenLayers layer visibility
     *  Parameter: boolean
     */
    TC.wrap.Layer.prototype.setVisibility = function (visible) {
        var self = this;
        self.getLayer().then(function (layer) {
            layer.setVisible(visible);
        });
    };

    TC.wrap.Layer.prototype.isNative = function (layer) {
        return layer instanceof ol.layer.Layer;
    };

    TC.wrap.Layer.prototype.setProjection = function (options) {
        const self = this;
        options = options || {};
        const layer = self.parent;
        if (layer.map) {
            const unitRatio = getUnitRatio.call(self, {
                crs: options.crs,
                extentInDegrees: ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326')
            });

            var resolutions = layer.getResolutions();
            if (resolutions && resolutions.length) {
                resolutions = resolutions.map(function (r) {
                    return r / unitRatio;
                });
                layer.wrap.layer.setMaxResolution(resolutions[0]);
                layer.wrap.layer.setMinResolution(resolutions[resolutions.length - 1]);
            }
            else {
                if (layer.minResolution) {
                    layer.minResolution = layer.minResolution / unitRatio;
                    self.layer.setMinResolution(layer.minResolution);
                }
                if (layer.maxResolution) {
                    layer.maxResolution = layer.maxResolution / unitRatio;
                    self.layer.setMaxResolution(layer.maxResolution);
                }
            }
        }
    };

    TC.wrap.layer.Raster.prototype.WmsParser = ol.format.WMSCapabilities;

    TC.wrap.layer.Raster.prototype.WmtsParser = ol.format.WMTSCapabilities;

    TC.wrap.Layer.prototype.addCommonEvents = function (layer) {
        var self = this;
        layer.on('change:visible', function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.LAYERVISIBILITY, {
                    layer: self.parent
                });
            }
        }, self.parent.map);
    };

    TC.wrap.layer.Raster.prototype.getGetMapUrl = function () {
        var result = null;
        var self = this;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                var dcpType = self.parent.capabilities.Capability.Request.GetMap.DCPType;
                for (var i = 0; i < dcpType.length; i++) {
                    if (dcpType[i].HTTP && dcpType[i].HTTP.Get) {
                        result = dcpType[i].HTTP.Get.OnlineResource;
                        break;
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = self.parent.capabilities.OperationsMetadata.GetTile.DCP.HTTP.Get[0].href;
                break;
            default:
                break;
        }
        const fragment = document.createDocumentFragment();
        const textarea = document.createElement('textarea');
        fragment.appendChild(textarea);
        textarea.innerHTML = result;
        result = textarea.textContent;
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfoFormats = function () {
        var result = null;
        var c = this.parent.capabilities;
        if (c.Capability && c.Capability.Request.GetFeatureInfo) {
            result = c.Capability.Request.GetFeatureInfo.Format;
        }
        return result;
    };

    TC.wrap.layer.Raster.infoFormatPreference = [
        'application/json',
        'application/vnd.ogc.gml/3.1.1',
        'application/vnd.ogc.gml',
        'application/vnd.esri.wms_featureinfo_xml',
        'text/html',
        'text/plain',
        'text/xml'
    ];

    TC.wrap.layer.Raster.prototype.getWMTSLayer = function () {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents) {
            for (var i = 0; i < capabilities.Contents.Layer.length; i++) {
                var layer = capabilities.Contents.Layer[i];
                for (var j = 0; j < layer.TileMatrixSetLink.length; j++) {
                    if (self.parent.options.matrixSet === layer.TileMatrixSetLink[j].TileMatrixSet) {
                        result = layer;
                        break;
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getTileMatrix = function (matrixSet) {
        var result = null;
        var self = this;
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Contents && capabilities.Contents.TileMatrixSet) {
            for (var i = 0; i < capabilities.Contents.TileMatrixSet.length; i++) {
                var tms = capabilities.Contents.TileMatrixSet[i];
                if (tms.Identifier === matrixSet) {
                    result = tms.TileMatrix;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getScaleDenominators = function (node) {
        var result = [];
        var self = this;
        if (node.ScaleDenominator) {
            result = [node.ScaleDenominator, node.ScaleDenominator];
        }
        else {
            if (node.MinScaleDenominator || node.MaxScaleDenominator) {
                result = [node.MaxScaleDenominator, node.MinScaleDenominator];
            }
        }
        // Contemplamos el caso de una capa sin nombre: sus escalas válidas serán las de sus hijas.
        if (!result.length && !self.getName(node)) {
            var children = self.getLayerNodes(node);
            var max = -Infinity, min = Infinity;
            for (var i = 0, len = children.length; i < len; i++) {
                var childDenominators = self.getScaleDenominators(children[i]);
                if (childDenominators[0] > max) {
                    max = childDenominators[0];
                }
                if (childDenominators[1] < min) {
                    min = childDenominators[1];
                }
            }
            if (max > -Infinity && min < Infinity) {
                result = [max, min];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAttribution = function () {
        const self = this;
        const result = {};
        const capabilities = TC.capabilities[self.parent.url];

        if (capabilities) {
            if (capabilities.ServiceProvider) {
                result.name = capabilities.ServiceProvider.ProviderName.trim();
                result.site = capabilities.ServiceProvider.ProviderSite;
                if (result.site.href && result.site.href.trim().length > 0) {
                    result.site = result.site.href;
                }
            }
            else if (capabilities.ServiceIdentification) {
                result.name = capabilities.ServiceIdentification.Title.trim();
            }
            else {
                result.name = capabilities.Service.Title.trim();
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getInfo = function (name) {
        var self = this;
        var result = {};
        var capabilities = self.parent.capabilities;
        if (capabilities && capabilities.Capability) {
            var layerNodes = self.getAllLayerNodes();
            for (var i = 0; i < layerNodes.length; i++) {
                var l = layerNodes[i];
                if (self.parent.compareNames(self.getName(l), name)) {
                    if (l.Title) {
                        result.title = l.Title;
                    }
                    if (l.Abstract) {
                        result['abstract'] = l.Abstract;
                    }
                    result.legend = [];

                    var _process = function (value) {
                        var legend = this.getLegend(value);

                        if (legend.src)
                            result.legend.push({
                                src: legend.src, title: value.Title
                            });
                    };

                    var _traverse = function (o, func) {
                        if (o.Layer && o.Layer.length > 0) {
                            for (var i in o.Layer) {
                                //bajar un nivel en el árbol
                                _traverse(o.Layer[i], func);
                            }
                        } else {
                            func.apply(self, [o]);
                        }
                    };

                    //Obtenemos todas las leyendas de la capa o grupo de capas
                    _traverse(l, _process);

                    if (l.MetadataURL && l.MetadataURL.length) {
                        result.metadata = [];
                        for (var j = 0; j < l.MetadataURL.length; j++) {
                            var md = l.MetadataURL[j];
                            result.metadata.push({
                                format: md.Format, type: md.type, url: md.OnlineResource
                            });
                        }
                    }
                    result.queryable = l.queryable;
                    break;
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceType = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Capability.Request && capabilities.Capability.Request.GetMap) {
            result = TC.Consts.layerType.WMS;
        }
        else if (capabilities.OperationsMetadata && capabilities.OperationsMetadata.GetTile) {
            result = TC.Consts.layerType.WMTS;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getServiceTitle = function () {
        var result = null;
        var capabilities = this.parent.capabilities;
        if (capabilities.Capability && capabilities.Service) {
            result = capabilities.Service.Title;
        }
        else if (capabilities.ServiceIdentification) {
            result = capabilities.ServiceIdentification.Title;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getRootLayerNode = function () {
        var self = this;
        var result;
        if (self.getServiceType() === TC.Consts.layerType.WMS) {
            result = self.parent.capabilities.Capability.Layer;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getName = function (node, ignorePrefix) {
        var result = node.Name;
        if (result && ignorePrefix) {
            var idx = result.indexOf(':');
            if (idx >= 0) {
                result = result.substr(idx + 1);
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getIdentifier = function (node) {
        return node.Identifier;
    };

    TC.wrap.layer.Raster.prototype.getLayerNodes = function (node) {
        var result = node.Layer;
        if (!$.isArray(result)) {
            if (result) {
                result = [result];
            }
            else {
                result = [];
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getAllLayerNodes = function () {
        var self = this;
        if (!self._layerList) {
            switch (self.getServiceType()) {
                case TC.Consts.layerType.WMS:
                    var getNodeArray = function getNodeArray(node) {
                        var r = [node];
                        var children = self.getLayerNodes(node);
                        for (var i = 0; i < children.length; i++) {
                            r = r.concat(getNodeArray(children[i]));
                        }
                        return r;
                    };
                    var root = self.getRootLayerNode();
                    self._layerList = root ? getNodeArray(root) : [];
                    break;
                case TC.Consts.layerType.WMTS:
                    self._layerList = self.parent.capabilities.Contents.Layer.slice();
                    break;
                default:
                    self._layerList = [];
                    break;
            }
        }
        return self._layerList;
    };

    TC.wrap.layer.Raster.prototype.normalizeLayerNode = function (node) {
        return node;
    };

    TC.wrap.layer.Raster.prototype.normalizeCapabilities = function (capabilities) {
        return capabilities;
    };


    TC.wrap.layer.Raster.prototype.getLegend = function (node) {
        var result = {};
        var styles = node.Style;
        if (styles && styles.length) {
            if (styles.length && styles[0].LegendURL && styles[0].LegendURL.length) {
                var legend = styles[0].LegendURL[0];

                const fragment = document.createDocumentFragment();
                const textarea = document.createElement('textarea');
                fragment.appendChild(textarea);
                textarea.innerHTML = legend.OnlineResource;
                result.src = textarea.textContent;
                // Eliminado porque GeoServer miente con el tamaño de sus imágenes de la leyenda
                //if (legend.size) {
                //    result.width = legend.size[0];
                //    result.height = legend.size[1];
                //}
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.isCompatible = function (crs) {
        var self = this;
        var result = true;
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        var names = layer.names.slice(0);
                        var _isCompatible = function _isCompatible(nodes, name, inCrs) {
                            var r = false;
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    var n = nodes[i];
                                    const itemCRS = n.CRS || n.SRS;
                                    const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                    var isIn = inCrs || $.inArray(crs, crsList) >= 0;
                                    if (layer.compareNames(self.getName(n), name)) {
                                        if (isIn) {
                                            r = true;
                                        }
                                        break;
                                    }
                                    else if (_isCompatible(n.Layer, name, isIn)) {
                                        r = true;
                                        break;
                                    }
                                }
                            }
                            return r;
                        };
                        while (names.length > 0) {
                            if (!_isCompatible([layer.capabilities.Capability.Layer], names.pop())) {
                                result = false;
                                break;
                            }
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                result = false;
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tms = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0; i < tms.length; i++) {
                        if (tms[i].Identifier === layer.options.matrixSet) {
                            result = TC.Util.CRSCodesEqual(crs, tms[i].SupportedCRS);
                            break;
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleCRS = function () {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    if (layer.names.length > 0) {
                        const crsLists = layer.names
                            .map(function (name) {
                                return layer
                                    .getNodePath(name) // array de nodos
                                    .map(function (node) {
                                        const itemCRS = node.CRS || node.SRS || [];
                                        const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];
                                        return $.isArray(crsList) ? crsList : [crsList];
                                    }) // array de arrays de crs
                                    .reduce(function (prev, cur) {
                                        if (prev.length === 0) {
                                            return cur;
                                        }
                                        cur.forEach(function (elm) {
                                            if (prev.indexOf(elm) < 0) {
                                                prev[prev.length - 1] = elm;
                                            }
                                        });// array con todos los crs
                                        return prev;
                                    }, []);
                            });

                        if (crsLists.length === 1) {
                            result = crsLists[0];
                        } else {
                            const otherCrsLists = crsLists.slice(1);
                            result = crsLists[0].filter(function (elm) {
                                return otherCrsLists.every(function (crsList) {
                                    return crsList.indexOf(elm) >= 0;
                                });
                            });
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents) {
                    layer.capabilities.Contents.Layer
                        .filter(function (l) {
                            return l.Identifier === layer.layerNames;
                        })  // La capa de interés
                        .forEach(function (l) {
                            const tileMatrixSets = l.TileMatrixSetLink
                                .map(function (tmsl) {
                                    return tmsl.TileMatrixSet;
                                });
                            result = layer.capabilities.Contents.TileMatrixSet
                                .filter(function (tms) {
                                    return tileMatrixSets.indexOf(tms.Identifier) >= 0;
                                }) // TileMatrixSets asociados a la capa de interés
                                .map(function (tms) {
                                    return tms.SupportedCRS;
                                });
                        });
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleLayers = function (crs) {
        var self = this;
        var result = [];
        var layer = self.parent;
        switch (self.getServiceType()) {
            case TC.Consts.layerType.WMS:
                if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {
                    var _fnrecursive = function (item, crs, inCrs) {
                        var crsToCheck = item.CRS || item.SRS;
                        var itemCRS = Array.isArray(crsToCheck) ? crsToCheck : [crsToCheck];
                        var isIn = inCrs || $.inArray(crs, itemCRS) >= 0;
                        if (isIn && item.Name) result[result.length] = item.Name;
                        if (item.Layer) {
                            for (var i = 0; i < item.Layer.length; i++) {
                                _fnrecursive(item.Layer[i], crs, isIn);
                            }
                        }
                    }
                    _fnrecursive(layer.capabilities.Capability.Layer, crs);
                }
                break;
            case TC.Consts.layerType.WMTS:
                if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {
                    var tmsList = layer.capabilities.Contents.TileMatrixSet;
                    for (var i = 0, ii = tmsList.length; i < ii; i++) {
                        var tms = tmsList[i];
                        if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                            var tmsIdentifier = tms.Identifier;
                            var layerList = layer.capabilities.Contents.Layer;
                            for (var j = 0, jj = layerList.length; j < jj; j++) {
                                var tmsLinkList = layerList[j].TileMatrixSetLink;
                                for (var k = 0, kk = tmsLinkList.length; k < kk; k++) {
                                    if (tmsLinkList[k].TileMatrixSet === tmsIdentifier) {
                                        result[result.length] = layerList[j].Identifier;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.getCompatibleMatrixSets = function (crs) {
        var self = this;
        var result = [];
        normalizeProjection({
            crs: crs
        });
        var layer = self.parent;
        if (self.getServiceType() === TC.Consts.layerType.WMTS) {
            var layerList = layer.capabilities.Contents.Layer;
            var tmsList = layer.capabilities.Contents.TileMatrixSet;
            for (var i = 0, ii = layerList.length; i < ii; i++) {
                if (layer.layerNames === layerList[i].Identifier) {
                    var tmsLinkList = layerList[i].TileMatrixSetLink;
                    for (var j = 0, jj = tmsLinkList.length; j < jj; j++) {
                        var tmsLink = tmsLinkList[j];
                        for (var k = 0, kk = tmsList.length; k < kk; k++) {
                            var tms = tmsList[k];
                            if (tms.Identifier === tmsLink.TileMatrixSet) {
                                if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {
                                    result[result.length] = tms.Identifier;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Raster.prototype.setWMTSUrl = function () {
        var self = this;

        self.getLayer().then(function (l) {
            self.parent.options = self.parent.options || {};
            var urls = l.getSource().getUrls();
            self.parent.options.urlPattern = urls[urls.length - 1];
        });
    };

    TC.wrap.layer.Raster.prototype.createWMSLayer = function (url, params, options) {
        const self = this;
        var result = null;

        var source = new ol.source.ImageWMS({
            url: url,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            params: params,
            extent: TC.Cfg.initialExtent,
            ratio: TC.Cfg.imageRatio,
            imageLoadFunction: $.proxy(self.parent.getImageLoad, self.parent)
        });

        source.on(ol.source.Image.EventType_.IMAGELOADSTART, function (e) {
            self.trigger(TC.Consts.event.BEFORETILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on(ol.source.Image.EventType_.IMAGELOADEND, function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });
        source.on(ol.source.Image.EventType_.IMAGELOADERROR, function (e) {
            self.trigger(TC.Consts.event.TILELOAD, {
                tile: e.image.getImage()
            });
        });


        var layerOptions = {
            visible: !!params.LAYERS.length || (options && options.method && options.method === 'POST'), //Las capas de temáticos cargadas por POST no tienen el atributo LAYERS
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }
        result = new ol.layer.Image(layerOptions);

        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    var createWmtsSource = function (options) {
        var self = this;
        var result = null;
        var sourceOptions = ol.source.WMTS.optionsFromCapabilities(self.parent.capabilities, {
            layer: options.layerNames,
            matrixSet: options.matrixSet,
            crossOrigin: options.map ? options.map.options.crossOrigin : undefined,
            requestEncoding: options.encoding,
            format: options.format,
        });
        var https = 'https:';

        if (sourceOptions) {
            if (location.protocol === https) {
                sourceOptions.urls = sourceOptions.urls.map(function (elm) {
                    return elm.replace('http:', https);
                });
            }

            sourceOptions.crossOrigin = options.map ? options.map.options.crossOrigin : undefined;

            result = new ol.source.WMTS(sourceOptions);
            result.setTileLoadFunction($.proxy(self.parent.getImageLoad, self.parent));

            result.on(ol.source.TileEventType.TILELOADSTART, function (e) {
                self.trigger(TC.Consts.event.BEFORETILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(ol.source.TileEventType.TILELOADEND, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });
            result.on(ol.source.TileEventType.TILELOADERROR, function (e) {
                self.trigger(TC.Consts.event.TILELOAD, {
                    tile: e.tile.getImage()
                });
            });

            var prevFn = $.proxy(result.getResolutions, result);
            result.getResolutions = function () {
                var resolutions = prevFn();
                var matrix = self.parent.getLimitedMatrixSet();
                //esto está mal, porque matrix podría empezar más abajo (tener recortado por ambos lados)
                if (matrix && matrix.length) {
                    var ix = matrix[0].matrixIndex;
                    resolutions = resolutions.slice(ix, matrix.length + ix);
                }

                return resolutions;
            };
        }

        return result;
    };

    TC.wrap.layer.Raster.prototype.createWMTSLayer = function (options) {
        const self = this;
        var result = null;

        var source = createWmtsSource.call(self, options);

        if (source) {
            var layerOptions = {
                source: source
            };
            if (options.minResolution) {
                layerOptions.minResolution = options.minResolution;
            }
            if (options.maxResolution) {
                layerOptions.maxResolution = options.maxResolution;
            }
            result = new ol.layer.Tile(layerOptions);
            result._wrap = self;

            self.addCommonEvents(result);

            var resolutions = source.getResolutions();
            //Este +1 tan chungo es porque, en el caso en que la resolución del mapa es igual a la máxima del layer, openLayers lo oculta
            result.setMaxResolution(resolutions[0] + 1);
            result.setMinResolution(resolutions[resolutions.length - 1]);
        }

        return result;
    };


    /*
     *  getParams: Gets the WMS layer getmap parameters
     *  Returns: object
     */
    TC.wrap.layer.Raster.prototype.getParams = function () {
        return this.layer.getSource().getParams();
    };

    /*
     *  setParams: Sets the WMS layer getmap parameters
     *  Parameter: object
     */
    TC.wrap.layer.Raster.prototype.setParams = function (params) {
        this.layer.getSource().updateParams(params);
    };

    TC.wrap.layer.Raster.prototype.setMatrixSet = function (matrixSet) {
        const self = this;
        const oldResolutions = self.layer.getSource().getResolutions();
        if (self.parent.type === TC.Consts.layerType.WMTS) {
            const newSource = createWmtsSource.call(self, $.extend({}, self.parent.options, { matrixSet: matrixSet }));
            const newResolutions = newSource.getResolutions();
            const newMaxResolution = newResolutions[0]
            const newMinResolution = newResolutions[newResolutions.length - 1];
            self.layer.setMaxResolution(newMaxResolution);
            self.layer.setMinResolution(newMinResolution);
            if (self.parent.minResolution) {
                self.parent.minResolution = newMinResolution;
            }
            if (self.parent.maxResolution) {
                self.parent.maxResolution = newMaxResolution;
            }
            self.layer.setSource(newSource);
        }
    };

    TC.wrap.layer.Raster.prototype.getResolutions = function () {
        if (this.layer.getSource) {
            var ts = this.layer.getSource();
            if (ts.getResolutions && ts.getResolutions != goog.abstractMethod) return ts.getResolutions();
            else return [];
        }
        else {
            return [];
        }
    };

    TC.wrap.Geometry = {
        getNearest: function (point, candidates) {
            var pline = new ol.geom.LineString(candidates);
            return pline.getClosestPoint(point);
        }
    };

    // En OL3 la imagen tiene el tamaño original. Escalamos si hace falta.
    var setScaleFunction = function (imageStyle, iconWidth, olFeat) {
        if (imageStyle) {
            var setScaleForWidth = function (imgWidth) {
                var markerWidth = (olFeat && olFeat._wrap ? olFeat._wrap.parent.options.width : null) || iconWidth;
                if (markerWidth < imgWidth) {
                    var factor = markerWidth / imgWidth;
                    imageStyle.setScale(factor);
                }
            };
            var imageSize = imageStyle.getSize();
            if (imageSize) {
                setScaleForWidth(imageSize[0]);
            }
            else {
                var img = imageStyle.getImage();
                if (img.naturalWidth) {
                    setScaleForWidth(img.naturalWidth);
                }
                else {
                    const fragment = document.createDocumentFragment();
                    const img = document.createElement('img');
                    img.src = imageStyle.getSrc();
                    img.addEventListener('load', function () {
                        setScaleForWidth(this.naturalWidth);
                    });
                    fragment.appendChild(img);
                }
            }
        }
    };

    var getStyleValue = function (property, feature) {
        var result = property;
        var olFeat = feature && feature.wrap && feature.wrap.feature;
        if (typeof property === 'string') {
            var match = property.match(/^\$\{(.+)\}$/);
            if (match && olFeat) {
                // Permitimos el formato ${prop.subprop.subsubprop}
                var m = match[1].split('.');
                var r = olFeat.getProperties();
                for (var i = 0; i < m.length && r !== undefined; i++) {
                    r = r[m[i]];
                }
                if (r === undefined) {
                    r = feature.data;
                    for (var i = 0; i < m.length && r !== undefined; i++) {
                        r = r[m[i]];
                    }
                }
                result = r;
            }
        }
        else if ($.isFunction(property)) {
            result = property(feature);
        }
        return result;
    };

    var getNativeStyle = function (olFeat) {
        var result = olFeat.getStyle();
        if ($.isFunction(result)) {
            result = result.call(olFeat);
        }
        if ($.isArray(result)) {
            result = result[0];
        }
        return result;
    };

    // Transformación de opciones de estilo en un estilo nativo OL3.
    var createNativeStyle = function (options, olFeat) {
        var nativeStyleOptions = {
        };

        var feature;
        var isPoint, isLine, isPolygon;
        if (olFeat) {
            switch (olFeat.getGeometry().getType()) {
                case 'Point':
                case 'MultiPoint':
                    isPoint = true;
                    break;
                case 'LineString':
                case 'MultiLineString':
                    isLine = true;
                    break;
                case 'Polygon':
                case 'MultiPolygon':
                    isPolygon = true;
                    break;
            }
            if (olFeat._wrap) {
                feature = olFeat._wrap.parent;
            }
            else {
                // Si la API SITNA no ha completado su feature, creamos un mock-up para que no fallen las funciones de estilo
                feature = {
                    id: TC.wrap.Feature.prototype.getId.call({
                        feature: olFeat
                    }), // GLS añado el id de la feature para poder filtrar por la capa a la cual pertenece                    
                    features: olFeat.get('features'),
                    getData: function () {
                        return TC.wrap.Feature.prototype.getData.call({
                            feature: olFeat
                        });
                    }
                };


            }
        }
        var isCluster = feature && $.isArray(feature.features) && feature.features.length > 1 && options.cluster;
        var styles;
        if (isCluster) {
            styles = $.extend(true, {}, TC.Cfg.styles.cluster, options.cluster.styles);
        }
        else {
            styles = options.styles || TC.Cfg.styles;
        }

        var styleOptions = {};
        if (styles.line && (isLine || !olFeat)) {
            styleOptions = styles.line;
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.line.strokeColor, feature),
                width: getStyleValue(styles.line.strokeWidth, feature),
                lineDash: styles.line.lineDash
            });
        }

        if (styles.polygon && (isPolygon || !olFeat)) {
            styleOptions = styles.polygon;
            nativeStyleOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styles.polygon.fillColor, feature), getStyleValue(styles.polygon.fillOpacity, feature))
            });
            nativeStyleOptions.stroke = new ol.style.Stroke({
                color: getStyleValue(styles.polygon.strokeColor, feature),
                width: getStyleValue(styles.polygon.strokeWidth, feature),
                lineDash: styles.polygon.lineDash
            });
        }

        if (styles.point && (isPoint || !olFeat)) {
            styleOptions = styles.point;
            var circleOptions = {
                radius: getStyleValue(styleOptions.radius, feature) ||
                (getStyleValue(styleOptions.height, feature) + getStyleValue(styleOptions.width, feature)) / 4
            };
            if (styleOptions.fillColor) {
                circleOptions.fill = new ol.style.Fill({
                    color: getRGBA(getStyleValue(styleOptions.fillColor, feature), getStyleValue(styleOptions.fillOpacity, feature))
                });
            }
            if (styleOptions.strokeColor) {
                circleOptions.stroke = new ol.style.Stroke({
                    color: getStyleValue(styleOptions.strokeColor, feature),
                    width: getStyleValue(styleOptions.strokeWidth, feature),
                    lineDash: styleOptions.lineDash
                });
            }

            if (!isNaN(circleOptions.radius))
                nativeStyleOptions.image = new ol.style.Circle(circleOptions);
        }

        if (styleOptions.label) {
            nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
        }

        if (styles.marker && (isPoint || !olFeat)) {
            styleOptions = styles.marker;
            var ANCHOR_DEFAULT_UNITS = 'fraction';
            if (styleOptions.url) {
                nativeStyleOptions.image = new ol.style.Icon({
                    crossOrigin: 'anonymous',
                    anchor: styleOptions.anchor,
                    anchorXUnits: styleOptions.anchorXUnits || ANCHOR_DEFAULT_UNITS,
                    anchorYUnits: styleOptions.anchorYUnits || ANCHOR_DEFAULT_UNITS,
                    src: styleOptions.url
                });
                nativeStyleOptions.text = createNativeTextStyle(styleOptions, feature);
            }
        }

        return [new ol.style.Style(nativeStyleOptions)];
    };

    const createNativeTextStyle = function (styleObj, feature) {
        if (!styleObj || !styleObj.label) {
            return;
        }

        const textOptions = {
            text: '' + getStyleValue(styleObj.label, feature),
        };
        //const olGeom = feature.wrap.feature.getGeometry();
        //if (olGeom instanceof ol.geom.LineString || olGeom instanceof ol.geom.MultiLineString) {
        //    textOptions.placement = ol.style.TextPlacement.LINE;
        //}
        if (styleObj.fontSize) {
            textOptions.font = getStyleValue(styleObj.fontSize, feature) + 'pt sans-serif';
        }
        if (styleObj.angle) {
            textOptions.rotation = -Math.PI * getStyleValue(styleObj.angle, feature) / 180;
        }
        if (styleObj.fontColor) {
            textOptions.fill = new ol.style.Fill({
                color: getRGBA(getStyleValue(styleObj.fontColor, feature), 1)
            });
        }
        if (styleObj.labelOutlineColor) {
            textOptions.stroke = new ol.style.Stroke({
                color: getRGBA(getStyleValue(styleObj.labelOutlineColor, feature), 1),
                width: getStyleValue(styleObj.labelOutlineWidth, feature)
            });
        }
        if (styleObj.labelOffset) {
            textOptions.offsetX = styleObj.labelOffset[0];
            textOptions.offsetY = styleObj.labelOffset[1];
        }
        return new ol.style.Text(textOptions);
    };

    var toHexString = function (number) {
        var result = number.toString(16);
        if (result.length === 1) {
            result = '0' + result;
        }
        return result;
    };

    var getHexColorFromArray = function (colorArray) {
        return '#' + toHexString(colorArray[0]) + toHexString(colorArray[1]) + toHexString(colorArray[2])
    };

    var getStyleFromNative = function (olStyle, olFeat) {
        var result = {
        };
        if ($.isFunction(olStyle)) {
            if (olFeat) {
                olStyle = olStyle(olFeat);
            }
        }
        if ($.isArray(olStyle)) {
            olStyle = olStyle[0];
        }
        if (!$.isFunction(olStyle)) {
            var color;
            var stroke;
            var fill;
            var image = olStyle.getImage();
            if (image) {
                if (image instanceof ol.style.RegularShape) {
                    stroke = image.getStroke();
                    color = ol.color.asArray(stroke.getColor());
                    result.strokeColor = getHexColorFromArray(color);
                    result.strokeWidth = stroke.getWidth();
                    fill = image.getFill();
                    if (fill) {
                        color = ol.color.asArray(fill.getColor());
                        result.fillColor = getHexColorFromArray(color);
                        result.fillOpacity = color[3];
                    }
                }
                else {
                    result.url = image.getSrc();
                    var size = image.getSize();
                    if (size) {
                        result.width = size[0];
                        result.height = size[1];
                        result.anchor = image.getAnchor();
                        if (result.anchor) {
                            result.anchor[0] = result.anchor[0] / result.width;
                            result.anchor[1] = result.anchor[1] / result.height;
                        }
                    }
                }
            }
            else {
                stroke = olStyle.getStroke();
                if (stroke) {
                    color = ol.color.asArray(stroke.getColor());
                    result.strokeColor = getHexColorFromArray(color);
                    result.strokeWidth = stroke.getWidth();
                    result.lineDash = stroke.getLineDash();
                }
                fill = olStyle.getFill();
                if (fill) {
                    color = ol.color.asArray(fill.getColor());
                    result.fillColor = getHexColorFromArray(color);
                    result.fillOpacity = color[3];
                }
            }
        }
        return result;
    };

    TC.wrap.layer.Vector.prototype.getStyle = function () {
        return getStyleFromNative(this.layer.getStyle());
    };

    TC.wrap.layer.Vector.prototype.reloadSource = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const layerOptions = self.createVectorSource(self.parent, self.createStyles(self.parent));

            if (self.parent.type === TC.Consts.layerType.WFS) {
                var listenerKey = layerOptions.source.on('change', function (e) {
                    if (layerOptions.source.getState() == 'ready') {
                        ol.Observable.unByKey(listenerKey);

                        resolve();
                    }
                });
            }

            var features = self.layer.getSource().getFeatures();
            self.layer.setSource(layerOptions.source);

            if (layerOptions.style)
                self.layer.setStyle(layerOptions.style);

            if (self.parent.type != TC.Consts.layerType.WFS) {
                layerOptions.source.addFeatures(features);
                resolve();
            }
        });
    };

    TC.wrap.layer.Vector.prototype.import = function (options) {
        var self = this;
        var opts = $.extend({
        }, options);
        opts.type = options.format;

        var oldFeatures = self.layer.getSource().getFeatures();
        var layerOptions = self.createVectorSource(opts, self.createStyles(self.parent));
        self.layer.setSource(layerOptions.source);
        if (layerOptions.style) {
            self.layer.setStyle(layerOptions.style);
        }

        layerOptions.source.addFeatures(oldFeatures);
    };

    const getIcon = function (olFeat) {
        var result = null;
        var style = getNativeStyle(olFeat);
        if (style) {
            var img = style.getImage();
            if (img instanceof ol.style.Icon) {
                result = img.getSrc();
            }
        }
        return result;
    };

    const createFeatureFromNative = function (olFeat) {
        if (!olFeat._wrapPromise) { // Si no se ha llamado antes a esta función para esta feature
            olFeat._wrapPromise = new Promise(function (resolve, reject) {
                var options;
                var geom = olFeat.getGeometry();
                const olStyle = olFeat.getStyle();
                if (olStyle) {
                    options = getStyleFromNative(olStyle, olFeat);
                }

                const resolveFn = function (ctorName) {
                    if (ctorName) {
                        TC.loadJS(
                            !TC.feature || !TC.feature[ctorName],
                            TC.apiLocation + 'TC/feature/' + ctorName,
                            function () {
                                resolve(new TC.feature[ctorName](olFeat, options));
                            }
                        );
                    }
                    else {
                        resolve(new TC.Feature(olFeat, options));
                    }
                };

                if (geom instanceof ol.geom.Point) {
                    if (getIcon(olFeat)) {
                        resolveFn('Marker');
                    }
                    else {
                        resolveFn('Point');
                    }
                }
                else if (geom instanceof ol.geom.LineString) {
                    resolveFn('Polyline');
                }
                else if (geom instanceof ol.geom.Polygon) {
                    resolveFn('Polygon');
                }
                else if (geom instanceof ol.geom.MultiLineString) {
                    resolveFn('MultiPolyline');
                }
                else if (geom instanceof ol.geom.MultiPolygon) {
                    resolveFn('MultiPolygon');
                }
                else {
                    resolveFn();
                }
            });
        }
        return olFeat._wrapPromise;
    };

    TC.wrap.layer.Vector.prototype.createVectorSource = function (options, nativeStyle) {
        var self = this;

        var createGenericLoader = function (url, format) {
            var internalLoader = ol.featureloader.xhr(url, format);
            return function (extent, resolution, projection) {
                self.parent.state = TC.Layer.state.LOADING;
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                        layer: self.parent
                    });
                }
                internalLoader.call(this, extent, resolution, projection);
            };
        };
        var usesGenericLoader = false;

        var source;
        var vectorOptions;

        var getMimeTypeFromUrl = function (url) {
            var idx = url.indexOf('?');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
            else {
                idx = url.indexOf('#');
                if (idx >= 0) {
                    url = url.substr(0, idx);
                }
            }
            switch (url.substr(url.lastIndexOf('.') + 1).toLowerCase()) {
                case 'kml':
                    return TC.Consts.mimeType.KML;
                case 'json':
                case 'geojson':
                    return TC.Consts.mimeType.GEOJSON;
                case 'gml':
                    return TC.Consts.mimeType.GML;
                case 'gpx':
                    return TC.Consts.mimeType.GPX;
                default:
                    return null;
            }
        };

        if ($.isArray(options.url) || options.urls) {
            var urls = options.urls || options.url;
            urls = $.map(urls, function (elm, idx) {
                return TC.proxify(elm);
            });
            vectorOptions = {
                url: urls,
                format: new ol.format.KML({
                    showPointNames: false
                }),
                projection: options.crs
            };
        }
        else if (options.url && options.type !== TC.Consts.layerType.WFS) {
            vectorOptions = {
                url: TC.proxify(options.url),
                projection: options.crs
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(getMimeTypeFromUrl(options.url)) || getFormatFromName(options.type);
            vectorOptions.loader = createGenericLoader(vectorOptions.url, vectorOptions.format);
            usesGenericLoader = true;
        }
        else if (options.data) {
            vectorOptions = {
                projection: options.crs,
                loader: function (extent, resolution, projection) {
                    self.parent.state = TC.Layer.state.LOADING;
                    if (self.parent.map) {
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });
                    }
                    var format = this.getFormat();
                    try {
                        var fs = format.readFeatures(options.data, {
                            featureProjection: projection
                        });
                        this.addFeatures(fs);
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                layer: self.parent, newData: data
                            });
                        }
                    }
                    catch (e) {
                        self.parent.state = TC.Layer.state.IDLE;
                        if (self.parent.map) {
                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, {
                                layer: self.parent, reason: e.message
                            });
                        }
                    }
                }
            };
            vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(options.type);
        }
        else if (options.type == TC.Consts.layerType.WFS) {
            var outputFormat;
            var mimeType;
            switch (options.outputFormat) {
                case TC.Consts.format.JSON:
                    outputFormat = new ol.format.GeoJSON({
                        geometryName: options.geometryName
                    });
                    mimeType = 'json';
                    break;
                case TC.Consts.format.GML3:
                    outputFormat = new ol.format.GML3Patched();
                    mimeType = TC.Consts.mimeType.GML;
                    break;
                default:
                    outputFormat = new ol.format.GML2();
                    mimeType = TC.Consts.mimeType.GML;
                    break;
            }
            vectorOptions = {
                format: outputFormat,
                loader: function (extent, resolution, projection) {
                    var sOrigin = this;
                    var serviceUrl = options.url;
                    if (serviceUrl) {
                        self.parent.state = TC.Layer.state.LOADING;
                        self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {
                            layer: self.parent
                        });
                        var ajaxOptions = {};
                        var crs = projection.getCode();
                        var version = options.version || '1.1.0';
                        var url = serviceUrl;
                        var featureType = $.isArray(options.featureType) ? options.featureType : [options.featureType];
                        if (!options.properties || (options.properties instanceof Array && !options.properties.length) || !(Object.keys(options.properties).length)) {
                            url = url + '?service=WFS&' +
                                'version=' + version + '&request=GetFeature&typename=' + featureType.join(',') + '&' +
                                'outputFormat=' + mimeType + '&srsname=' + crs;
                            if (extent[0] !== -Infinity && extent[1] !== -Infinity && extent[2] !== Infinity && extent[3] !== Infinity) {
                                url = url + '&bbox=' + extent.join(',') + ',' + crs;
                            }

                            if (options.maxFeatures)
                                url = url + "maxFeatures=" + options.maxFeatures;
                        }
                        else {
                            ajaxOptions.method = 'POST';
                            switch (mimeType) {
                                case 'json':
                                    ajaxOptions.responseType = TC.Consts.mimeType.JSON;
                                    break;
                                default:
                                    ajaxOptions.responseType = TC.Consts.mimeType.XML;
                                    break;

                            }
                            //ajaxOptions.contentType = TC.Consts.mimeType.XML;
                            //ajaxOptions.processData = false;
                            //var formatter = new ol.format.WFS();
                            //var doc = formatter.writeGetFeature({
                            //    featureNS: 'wfs',
                            //    featurePrefix: 'feature',
                            //    featureTypes: featureType,
                            //    srsName: crs
                            //});
                            //var filter = [];
                            //filter[0] = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">';
                            //if (options.properties.length > 1) {
                            //    filter[filter.length] = '<ogc:And>';
                            //}
                            //for (var j = 0; j < options.properties.length; j++) {
                            //    var prop = options.properties[j];
                            //    filter[filter.length] = '<ogc:PropertyIsEqualTo matchCase="true"><ogc:PropertyName>';
                            //    filter[filter.length] = prop.name;
                            //    filter[filter.length] = '</ogc:PropertyName><ogc:Literal>';
                            //    filter[filter.length] = prop.value;
                            //    filter[filter.length] = '</ogc:Literal></ogc:PropertyIsEqualTo>';
                            //}
                            //if (options.properties.length > 1) {
                            //    filter[filter.length] = '</ogc:And>';
                            //}
                            //filter[filter.length] = '</ogc:Filter>';
                            //filter = filter.join('');
                            //var $doc = $(doc);
                            //$doc.find('Query').each(function (idx, query) {
                            //    $(query).html(filter);
                            //});
                            //ajaxOptions.data = $('<div>').append($doc).html();
                            var gml = [];
                            gml[gml.length] = '<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" service="WFS" version="';
                            gml[gml.length] = version;
                            gml[gml.length] = '" outputFormat="';
                            gml[gml.length] = options.outputFormat;
                            if (options.maxFeatures) {
                                gml[gml.length] = '" maxFeatures="';
                                gml[gml.length] = options.maxFeatures;
                            }
                            gml[gml.length] = '" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/';
                            gml[gml.length] = version;
                            gml[gml.length] = '/wfs.xsd">';
                            for (var i = 0; i < featureType.length; i++) {
                                gml[gml.length] = '<wfs:Query typeName="feature:';
                                gml[gml.length] = featureType[i];
                                gml[gml.length] = '" srsName="';
                                gml[gml.length] = crs;
                                gml[gml.length] = '">';
                                if (options.propertynames) {
                                    var pPrefix = version === '1.1.0' ? 'wfs' : 'ogc';
                                    var _arrProperties = typeof (options.propertynames) === "string" ? options.propertynames.split(",") : options.propertynames
                                    if (options.geometryName)
                                        _arrProperties.push(options.geometryName)
                                    for (var i; i < _arrProperties.length; i++) {
                                        gml[gml.length] = '<' + pPrefix + ':PropertyName>' + _arrProperties[i].trim() + '</' + pPrefix + ':PropertyName>';
                                    }
                                }
                                gml[gml.length] = options.properties.getText();
                                gml[gml.length] = '</wfs:Query>';
                            }
                            gml[gml.length] = '</wfs:GetFeature>';

                            ajaxOptions.data = gml.join('');
                            ajaxOptions.contentType = TC.Consts.mimeType.XML;
                        }
                        ajaxOptions.url = url;
                        self._requestUrl = url;
                        TC.ajax(ajaxOptions).then(function (data) {
                            const feats = outputFormat.readFeatures(data);
                            const triggerLayerUpdate = function () {
                                self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                                    layer: self.parent, newData: data
                                });
                            };
                            const onFeaturesAdd = function (e) {
                                if (e.layer === self.parent) {
                                    self.parent.map.off(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                                    triggerLayerUpdate();
                                }
                            };
                            if (feats.length) {
                                sOrigin.addFeatures(feats);
                                self.parent.map.on(TC.Consts.event.FEATURESADD, onFeaturesAdd);
                            }
                            else {
                                triggerLayerUpdate();
                            }
                            self.parent.state = TC.Layer.state.IDLE;
                        });
                    }
                },
                //strategy: ol.loadingstrategy.all(),
                projection: options.crs
            };
        }

        source = new ol.source.Vector(vectorOptions);

        if (usesGenericLoader) {
            source.on(ol.events.EventType.CHANGE, function (e) {
                if (self.parent.map) {
                    self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {
                        layer: self.parent
                    });
                }
            });
        }

        source._tcLayer = self.parent;

        var markerStyle = options.style && options.style.marker ? options.style.marker : TC.Cfg.styles.marker;
        if (!options.style || !options.style.marker) {
            markerStyle = $.extend({}, markerStyle, {
                anchor: TC.Cfg.styles.point.anchor
            });
        }

        // Si habilitamos el clustering la fuente es especial
        if (options.cluster) {
            source = new ol.source.Cluster({
                projection: options.crs,
                distance: options.cluster.distance,
                source: source
            });

            // Animación
            if (options.cluster.animate) {
                var getCurrentCoordinates = function (fromCoords, toCoords, duration, start) {
                    var fraction = Math.min((Date.now() - start) / duration, 1);
                    var dx = (toCoords[0] - fromCoords[0]) * fraction;
                    var dy = (toCoords[1] - fromCoords[1]) * fraction;
                    return [fromCoords[0] + dx, fromCoords[1] + dy];
                };
                var animate = function (parent, child) {
                    var start = Date.now();
                    var pCoords = parent.getGeometry().getCoordinates();
                    var cCoords = child.getGeometry().getCoordinates();
                    child.setGeometry(new ol.geom.Point(pCoords));
                    var step = function step() {
                        var coords = getCurrentCoordinates(pCoords, cCoords, TC.Consts.CLUSTER_ANIMATION_DURATION, start);
                        child.setGeometry(new ol.geom.Point(coords));
                        if (coords[0] !== cCoords[0] && coords[1] !== cCoords[1]) {
                            requestAnimationFrame(step);
                        }
                        else {
                            clusterCache.splice($.inArray(parent, clusterCache), 1);
                        }
                    };
                    requestAnimationFrame(step);
                };
                var clusterCache = [];
                source.addEventListener(ol.source.VectorEventType.REMOVEFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features && features.length > 1) {
                        clusterCache.push(e.feature);
                    }
                });
                source.addEventListener(ol.source.VectorEventType.ADDFEATURE, function (e) {
                    var features = e.feature.get('features');
                    if (features) {
                        var coords = features[0].getGeometry().getCoordinates();
                        if (features.length > 1) {
                            var match = $.grep(clusterCache, function (elm) {
                                var elmCoords = elm.getGeometry().getCoordinates();
                                return elmCoords[0] === coords[0] && elmCoords[1] === coords[1];
                            });
                            if (match.length) {
                                clusterCache.splice($.inArray(match[0], clusterCache), 1);
                            }
                        }
                        var parent = $.grep(clusterCache, function (elm) {
                            var children = elm.get('features');
                            if (children && children.length > 0) {
                                var child = $.grep(children, function (cElm) {
                                    var cCoords = cElm.getGeometry().getCoordinates();
                                    return cCoords[0] === coords[0] && cCoords[1] === coords[1];
                                });
                                return child.length > 0;
                            }
                        });
                        if (parent.length) {
                            animate(parent[parent.length - 1], e.feature);
                        }
                    }
                });
            }
        }

        var s = source;
        do {
            s.addEventListener(ol.source.VectorEventType.ADDFEATURE, function (e) {
                var olFeat = e.feature;
                // OL3 dibuja el tamaño original del icono del marcador, lo escalamos si es necesario:
                var style = getNativeStyle(olFeat);
                if (style) {
                    setScaleFunction(style.getImage(), markerStyle.width, olFeat);
                }
            });
            if ($.isFunction(s.getSource)) {
                s = s.getSource();
            }
            else {
                s = null;
            }
        }
        while (s);

        source.addEventListener(ol.source.VectorEventType.ADDFEATURE, function (e) {
            const olFeat = e.feature;

            const addFeatureToLayer = function (feat) {
                var addFn;
                switch (true) {
                    case TC.feature.Point && feat instanceof TC.feature.Point:
                        addFn = self.parent.addPoint;
                        break;
                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:
                        addFn = self.parent.addPolyline;
                        break;
                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:
                        addFn = self.parent.addPolygon;
                        break;
                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:
                        addFn = self.parent.addMultiPolygon;
                        break;
                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:
                        addFn = self.parent.addMultiPolyline;
                        break;
                    default:
                        addFn = self.parent.addFeature;
                        break;
                }
                if (addFn) {
                    var _timeout;
                    addFn.call(self.parent, olFeat).then(function (f) {
                        var features = olFeat.get('features');
                        if ($.isArray(features)) {
                            // Es una feature de fuente ol.source.Cluster
                            f.features = $.map(features, function (elm) {
                                return new feat.constructor(elm);
                            });
                        }

                        // Timeout porque OL3 no tiene evento featuresadded. El timeout evita ejecuciones a lo tonto.
                        clearTimeout(_timeout);
                        _timeout = setTimeout(function () {
                            self.parent.map.trigger(TC.Consts.event.FEATURESADD, {
                                layer: self.parent, features: [f]
                            });
                        }, 50);
                    });
                }
            };

            if (!olFeat._wrap || !olFeat._wrap.parent.layer) { // Solo actuar si no es una feature añadida desde la API
                createFeatureFromNative(olFeat).then(addFeatureToLayer);
            }
        });

        source.addEventListener(ol.source.VectorEventType.REMOVEFEATURE, function (e) {
            var olFeat = e.feature;
            if (olFeat._wrap) {
                var idx = $.inArray(olFeat._wrap.parent, self.parent.features);
                if (idx > -1) {
                    self.parent.features.splice(idx, 1);
                    self.parent.map.trigger(TC.Consts.event.FEATUREREMOVE, {
                        layer: self.parent, feature: olFeat._wrap.parent
                    });
                }
            }
        });

        source.addEventListener(ol.source.VectorEventType.ADDFEATURE, function (e) {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(ol.source.VectorEventType.REMOVEFEATURE, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            }
        });

        source.addEventListener(ol.source.VectorEventType.CLEAR, function () {
            if (self.parent.map) {
                self.parent.map.trigger(TC.Consts.event.FEATURESCLEAR, {
                    layer: self.parent
                });
            }
        });

        var layerOptions = {
            source: source
        };

        if (options.minResolution) {
            layerOptions.minResolution = options.minResolution;
        }
        if (options.maxResolution) {
            layerOptions.maxResolution = options.maxResolution;
        }

        // En KML conservamos el estilo que viene con el archivo, así que no entramos aquí.
        // A no ser que tenga clusters, porque OL no soporta por defecto la combinación de estilo KML con clusters.
        if (!(vectorOptions && vectorOptions.format instanceof ol.format.KML) || options.cluster) {
            layerOptions.style = nativeStyle || options.styles;
        }

        return layerOptions;
    };

    TC.wrap.layer.Vector.prototype.createStyles = function (options) {
        var self = this;

        var dynamicStyle = false;

        if ($.isFunction(options)) {
            dynamicStyle = true;
            self.styleFunction = function (olFeat) {
                return createNativeStyle(options(olFeat));
            }
        }
        else {
            options = $.extend({}, options);
            options.crs = options.crs || TC.Cfg.crs;
            options.styles = options.styles || TC.Cfg.styles;
            var isDynamicStyle = function isDynamicStyle(obj) {
                for (var key in obj) {
                    var prop = obj[key];
                    switch (typeof prop) {
                        case 'string':
                            if (/^\$\{(.+)\}$/.test(prop)) {
                                return true;
                            }
                            break;
                        case 'object':
                            if (isDynamicStyle(prop)) {
                                return true;
                            }
                            break;
                        case 'function':
                            return true;
                            break;
                        default:
                            break;
                    }
                }
                return false;
            };

            dynamicStyle = !!(options.cluster && options.cluster.styles) || isDynamicStyle(options.styles);
            self.styleFunction = function (olFeat) {
                return createNativeStyle(self.parent.options, olFeat);
            };
        }

        var nativeStyle = dynamicStyle ? self.styleFunction : self.styleFunction();

        return nativeStyle;
    };

    TC.wrap.layer.Vector.prototype.setStyles = function (options) {
        const self = this;
        self.getLayer().then(function (olLayer) {
            olLayer.setStyle(self.createStyles(options));
        });
    };

    TC.wrap.layer.Vector.prototype.createVectorLayer = function () {
        const self = this;
        var result = null;

        var options = self.parent.options;

        var layerOptions = self.createVectorSource(options, self.createStyles(options));
        layerOptions.declutter = self.parent.options.declutter || false;
        result = new ol.layer.Vector(layerOptions);
        result._wrap = self;

        self.addCommonEvents(result);

        return result;
    };

    TC.wrap.layer.Vector.prototype.addFeatures = function (features) {
        const self = this;
        const commit = function (l) {
            var source = l;
            while ($.isFunction(source.getSource)) {
                source = source.getSource();
            }
            source.addFeatures(features);
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatures = function () {
        var olLayer = this.getLayer();
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatures();
        }
        else {
            return [];
        }
    };

    TC.wrap.layer.Vector.prototype.getFeatureById = function (id) {
        var olLayer = this.layer;
        if (olLayer instanceof ol.layer.Layer) {
            return olLayer.getSource().getFeatureById(id);
        }
        else {
            return null;
        }
    };

    TC.wrap.layer.Vector.prototype.removeFeature = function (feature) {
        const self = this;
        const commit = function (l) {
            if (feature.wrap.feature) {
                var source = l.getSource();
                source.removeFeature(feature.wrap.feature);
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.clearFeatures = function () {
        const self = this;
        const commit = function (l) {
            var source = l.getSource();
            if (source.clearFeatures) {
                source.clearFeatures();
            }
            else {
                source.clear();
            }
        };
        if (self.layer) {
            commit(self.layer);
        }
        else {
            self.getLayer().then(commit);
        }
    };

    TC.wrap.layer.Vector.prototype.setFeatureVisibility = function (feature, visible) {
        var self = this;

        var fillOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var strokeOptions = {
            color: 'rgba(0, 0, 0, 0)'
        };
        var displayNoneStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 0,
                fill: new ol.style.Fill(fillOptions),
                stroke: new ol.style.Stroke(strokeOptions)
            }),
            fill: new ol.style.Fill(fillOptions),
            stroke: new ol.style.Stroke(strokeOptions)
        });
        var idx = $.inArray(feature, self.parent.features);
        if (idx >= 0) {
            var olFeat = feature.wrap.feature;
            self.getLayer().then(function (olLayer) {
                if (visible && olFeat._originalStyle) {
                    olFeat.setStyle(olFeat._originalStyle);
                }
                else {
                    olFeat._originalStyle = olFeat.getStyle() || olLayer.getStyle();
                    olFeat.setStyle(displayNoneStyle);
                }
                self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {
                    layer: self.parent
                });
            });
        }
    };

    TC.wrap.layer.Vector.prototype.getRGBA = function (color, opacity) {
        return getRGBA(color, opacity);
    };

    TC.wrap.layer.Vector.prototype.findFeature = function (values) {
        // TODO: añadir ol.animation.zoom
    };

    TC.wrap.layer.Vector.prototype.getGetFeatureUrl = function () {
        return this._requestUrl;
    };

    TC.wrap.layer.Vector.prototype.getDescribeFeatureTypeUrl = function () {
        var self = this;
        var layer = self.parent;
        var version = layer.options.version || '1.1.0';
        var url = layer.url;
        var featureType = $.isArray(layer.options.featureType) ? layer.options.featureType : [layer.options.featureType];
        url = url + '?service=WFS&' + 'version=' + version + '&request=DescribeFeatureType&typename=' + featureType.join(',') + '&outputFormat=XMLSCHEMA';
        return url;
    };

    TC.wrap.layer.Vector.prototype.sendTransaction = function (inserts, updates, deletes) {
        const self = this;
        const getNativeFeature = function (feat) {
            return feat.wrap.feature;
        };
        return new Promise(function (resolve, reject) {
            const olInserts = inserts.map(getNativeFeature);
            const olUpdates = updates.map(getNativeFeature);
            const olDeletes = deletes.map(getNativeFeature);
            if (inserts.length || updates.length || deletes.length) {
                self.getLayer().then(function (olLayer) {
                    var source = olLayer.getSource();
                    var format = new ol.format.WFS();
                    var options = self.parent.options;
                    var transaction = format.writeTransaction(olInserts, olUpdates, olDeletes, {
                        featurePrefix: options.featurePrefix,
                        featureNS: options.featureNS,
                        featureType: options.featureType[0]
                    });
                    var ajaxOptions = {
                        url: self.parent.url,
                        method: 'POST',
                        responseType: TC.Consts.mimeType.XML,
                        data: transaction.outerHTML
                    };
                    TC.ajax(ajaxOptions)
                        .then(function (data) {
                            var er = data.getElementsByTagName('ExceptionReport')[0];
                            var errorObj = {
                                reason: ''
                            };
                            if (er) {
                                var e = er.getElementsByTagName('Exception')[0];
                                if (e) {
                                    errorObj.code = e.getAttribute('exceptionCode');
                                    var texts = e.getElementsByTagName('ExceptionText');
                                    for (var i = 0, len = texts.length; i < len; i++) {
                                        errorObj.reason += '\n' + texts[i].innerHTML;
                                    }
                                }
                                reject(errorObj);
                            }
                            else {
                                var response = format.readTransactionResponse(data);
                                resolve(response);
                            }
                        })
                        .catch(function () {
                            reject({
                                code: '', reason: 'unknown'
                            });
                        });
                });
            }
            else {
                resolve(self.parent);
            }
        });
    };

    TC.wrap.layer.Vector.prototype.setDraggable = function (draggable, onend, onstart) {
        var self = this;

        //tiene que estar a nivel de control para poder retirarla después
        //var interaction;
        Promise.all([self.parent.map.wrap.getMap(), self.getLayer()]).then(function (olObjects) {
            const olMap = olObjects[0];
            const olLayer = olObjects[1];
            if (draggable) {
                var interactionOptions = {
                    layers: [olLayer],
                    features: new ol.Collection(olLayer.getSource().getFeatures())
                };
                self.interaction = new ol.interaction.Translate(interactionOptions);
                if ($.isFunction(onend)) {
                    self.interaction.on(ol.interaction.TranslateEventType.TRANSLATEEND, function (e) {
                        if (e.features.getLength()) {
                            onend(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                if ($.isFunction(onstart)) {
                    self.interaction.on(ol.interaction.TranslateEventType.TRANSLATESTART, function (e) {
                        if (e.features.getLength()) {
                            onstart(e.features.item(0)._wrap.parent);
                        }
                    });
                }
                olMap.addInteraction(self.interaction);

                // GLS: En IE no muestra la manita en el over sobre marcadores trasladables.
                if (TC.Util.detectIE()) {
                    self._handlerDraggablePointerMove = function (e) {
                        if (e.dragging) {
                            return;
                        }

                        var pixel = olMap.getEventPixel(e);
                        var hit = olMap.hasFeatureAtPixel(pixel);
                        if (hit) {
                            olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                                if (layer._wrap && layer._wrap.parent && layer._wrap.parent.id === self.parent.id && feature) {
                                    olMap.getTarget().style.cursor = 'move';
                                } else {
                                    olMap.getTarget().style.cursor = '';
                                }
                            },
                                {
                                    hitTolerance: hitTolerance
                                });
                        } else {
                            olMap.getTarget().style.cursor = '';
                        }
                    };

                    olMap.on('pointermove', self._handlerDraggablePointerMove);
                }
            }
            else if (self.interaction) {
                olMap.removeInteraction(self.interaction);

                // GLS: En IE no muestra la manita en el over sobre marcadores trasladables.
                if (TC.Util.detectIE() && self._handlerDraggablePointerMove && $.isFunction(self._handlerDraggablePointerMove)) {
                    olMap.un('pointermove', self._handlerDraggablePointerMove);
                    delete self._handlerDraggablePointerMove;
                }
            }
        });
    };

    TC.wrap.layer.Vector.prototype.getFeaturesInExtent = function (extent, tolerance) {
        var self = this;
        var features = this.layer.getSource().getFeatures();
        var featuresInExtent = [];

        if (tolerance) {
            var leftCorner = self.parent.map.getPixelFromCoordinate([extent[0], extent[1]]);
            var rightCorner = self.parent.map.getPixelFromCoordinate([extent[2], extent[3]]);
            leftCorner[0] -= tolerance[0] / 2;
            leftCorner[1] += tolerance[1];
            rightCorner[0] += tolerance[0] / 2;
            extent = self.parent.map.getCoordinateFromPixel(leftCorner).concat(self.parent.map.getCoordinateFromPixel(rightCorner));
        }

        for (var i = 0; i < features.length; i++) {
            var feat = features[i];

            var geometry = feat.getGeometry();
            var coordinate = geometry.getCoordinates();

            if (ol.extent.containsCoordinate(extent, coordinate)) {
                featuresInExtent.push(feat._wrap.parent);
            }
        }

        return featuresInExtent;
    };

    TC.wrap.layer.Vector.prototype.getAttribution = function () {
        return null;
    };

    TC.wrap.control.Click.prototype.register = function (map) {
        var self = this;

        self._trigger = function (e) {
            if (map.view === TC.Consts.view.PRINTING) {
                return;
            }
            var featureCount = 0;
            map.wrap.map.forEachFeatureAtPixel(e.pixel,
                function (feature, layer) {
                    if (feature._wrap && feature._wrap.parent.showsPopup) {
                        featureCount++;
                    }
                },
                {
                    hitTolerance: hitTolerance
                });
            if (!featureCount) {
                // GLS: lanzo el evento click, para que los controles que no pueden heredar de click y definir un callback pueda suscribirse al evento
                self.parent.map.trigger(TC.Consts.event.CLICK, {
                    coordinate: e.coordinate, pixel: e.pixel
                });
                self.parent.callback(e.coordinate, e.pixel);
            }
            // Seguimos adelante si no se han pinchado featuers
            return featureCount === 0;
        };
    };

    TC.wrap.control.Click.prototype.activate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.on(ol.MapBrowserEventType.SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.Click.prototype.deactivate = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            olMap.un(ol.MapBrowserEventType.SINGLECLICK, self._trigger);
        });
    };

    TC.wrap.control.ScaleBar.prototype.render = function () {
        var self = this;
        if (!self.ctl) {
            self.ctl = new ol.control.ScaleLine({
                target: self.parent.div
            });
        }
        else {
            self.ctl.updateElement_();
        }
    };

    TC.wrap.control.ScaleBar.prototype.getText = function () {
        var self = this;
        if (self.ctl) {
            return self.ctl.renderedHTML_;
        }
    };

    TC.wrap.control.NavBar.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;
            self.zCtl = new ol.control.Zoom({
                target: div
            });
            // Ponemos para render una función modificada, para evitar que en los pinch zoom haya errores de este tipo:
            // AssertionError: Assertion failed: calculated value (1.002067782531452) ouside allowed range (0-1)

            self.zsCtl = new ol.control.ZoomSlider({
                render: function (e) {
                    if (!e.frameState || !e.frameState.viewState || olMap.getView().getMinResolution() <= e.frameState.viewState.resolution) {
                        // GLS: para evitar que el slider se configure en horizontal
                        var render = function () {
                            if (this.element.offsetWidth > this.element.offsetHeight) {
                                if (!self.requestSliderSize) {
                                    self.requestSliderSize = window.requestAnimationFrame(render.bind(this));
                                }

                                window.requestAnimationFrame(render.bind(this));
                            } else if (this.element.offsetWidth < this.element.offsetHeight) {
                                if (self.requestSliderSize) {
                                    window.cancelAnimationFrame(self.requestSliderSize);
                                    delete self.requestSliderSize;
                                }
                                ol.control.ZoomSlider.render.call(this, e);
                            }
                        };
                        render.call(this);
                    }
                }
            });
            self.zsCtl.setTarget(div);

            olMap.addControl(self.zsCtl);
            olMap.addControl(self.zCtl);

            div.querySelectorAll('button').forEach(function (button) {
                button.classList.add('tc-ctl-btn');
                button.classList.add(self.parent.CLASS + '-btn');
                button.style.display = 'block';
                button.innerHTML = '';
                if (button.matches('.ol-zoom-in')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomin');
                    button.setAttribute('title', self.parent.getLocaleString('zoomIn'));
                }
                if (button.matches('.ol-zoom-out')) {
                    button.classList.add(self.parent.CLASS + '-btn-zoomout');
                    button.setAttribute('title', self.parent.getLocaleString('zoomOut'));
                }
            });

            const zoomSlider = div.querySelector('.ol-zoomslider');
            zoomSlider.classList.add(self.parent.CLASS + '-bar');
            zoomSlider.querySelector('.ol-zoomslider-thumb').classList.add(self.parent.CLASS + '-slider');

            map.on(TC.Consts.event.BASELAYERCHANGE, $.proxy(self.refresh, self));
        });
    };

    TC.wrap.control.NavBar.prototype.refresh = function () {
        /*
        var map = this.parent.map;
        var olMap = map.wrap.map;

        olMap.removeControl(self.zsCtl);
        var res = map.getResolutions();
        self.zsCtl = new ol.control.ZoomSlider(
            {
                target: this.parent.div,
                "maxResolution": res[0],
                "minResolution": res[res.length - 1]
            });

        olMap.addControl(self.zsCtl);
        $(map.div).find('.ol-zoomslider').addClass(self.parent.CLASS + '-bar').find('.ol-zoomslider-thumb').addClass(self.parent.CLASS + '-slider');
        */
        var self = this;
        var map = self.parent.map.wrap.map;
        // Puede ser que se llame a refresh antes de que esté inicializado ol.control.ZoomSlider. En ese caso llamamos a render que lo inicializa.
        // Como render necesita un ol.MapEvent, esperamos al evento POSTRENDER.

        self.parent.renderPromise().then(function () {
            if (self.zsCtl.sliderInitialized_) {
                var res = map.getView().getResolution();
                self.zsCtl.setThumbPosition_(res);
            }
            else {
                map.once(ol.MapEventType.POSTRENDER, function (e) {
                    self.zsCtl.render(e);
                });
            }
        });
    };

    TC.wrap.control.NavBarHome.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            const div = self.parent.div;

            self.z2eCtl = new ol.control.ZoomToExtent({
                target: div, extent: map.initialExtent, tipLabel: ''
            });

            olMap.addControl(self.z2eCtl);

            div.querySelectorAll('button').forEach(function(button) {
                button.style.display = 'block';
                button.innerHTML = '';
            });
            const homeBtn = div.querySelector('.ol-zoom-extent button');
            homeBtn.classList.add('tc-ctl-btn');
            homeBtn.classList.add(self.parent.CLASS + '-btn');
            homeBtn.setAttribute('title', self.parent.getLocaleString('zoomToInitialExtent'));
        });
    };

    TC.wrap.control.NavBarHome.prototype.setInitialExtent = function (extent) {
        this.z2eCtl.extent = extent;
    };

    TC.wrap.control.Coordinates.prototype.register = function (map) {
        const self = this;
        self.map = map;

        return new Promise(function (resolve, reject) {

            self._coordsTrigger = function (e) {
                self.parent.coordsToClick(e);
            };

            map.wrap.getMap().then(function (olMap) {
                self.olMap = olMap;

                if (!self.parent.map.on3DView) {
                    var projection = olMap.getView().getProjection();
                    self.parent.crs = projection.getCode();
                    self.parent.units = projection.getUnits();
                } else {
                    self.parent.crs = self.parent.map.view3D.crs;
                    self.parent.units = TC.Consts.units.DEGREES;
                }

                self.parent.isGeo = self.parent.units === ol.proj.Units.DEGREES;

                //$(olMap.getViewport()).add(self.parent.div);
                resolve();
            });
        });
    };

    TC.wrap.control.Coordinates.prototype.onMouseMove = function (e) {
        var self = this;
        if (self.map.wrap.map) {
            var coords = self.map.wrap.map.getEventCoordinate(e);
            if (coords) {
                if (self.parent.isGeo) {
                    self.parent.latLon = coords.reverse();
                } else {
                    self.parent.xy = coords;
                }

                self.parent.update.apply(self.parent, arguments);
            }
        }
    };

    TC.wrap.control.Geolocation.prototype.register = function (map) {
        var self = this;
        self.map = map;

        self._snapTrigger = function (e) {
            if (e.dragging)
                return;

            self.initSnap(self.olMap.getEventCoordinate(e), e.pixel);
        };

        self._postcomposeTrigger = function (e) {
            self.duringTrackSnap(e);
        };

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    var getTrackingLine = function () {
        var self = this;

        return self.parent.layerTracking.features.filter(function (f) {
            return f instanceof TC.feature.Polyline;
        })[0];
    }

    TC.wrap.control.Geolocation.prototype.hasCoordinates = function () {
        var self = this;

        return self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length >= 1;
    };

    var getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {
            s: Math.floor((diff / 1000) % 60),
            m: Math.floor(((diff / (1000 * 60)) % 60)),
            h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
        };

        return $.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };
    TC.wrap.control.Geolocation.prototype.showElevationMarker = function (d) {
        var self = this;

        TC.wrap.control.ResultsPanel.prototype.showElevationMarker.call(self, {
            data: d,
            layer: self.parent.layerTrack,
            coords: self.parent.chart.coordinates
        })
    };

    TC.wrap.control.Geolocation.prototype.hideElevationMarker = function () {
        TC.wrap.control.ResultsPanel.prototype.hideElevationMarker.call(this);
    };

    TC.wrap.control.Geolocation.prototype.addWaypoint = function (position, properties) {
        var self = this;

        var waypoint = new ol.Feature({
            geometry: new ol.geom.Point([position[0], position[1], properties.ele, properties.time], ('XYZM'))
        });
        waypoint.setProperties(properties);

        self.parent.layerTracking.wrap.layer.getSource().addFeature(waypoint);
    };

    TC.wrap.control.Geolocation.prototype.addPosition = function (position, heading, m, speed, accuracy, altitudeAccuracy, altitude) {
        var self = this;

        var x = Math.round(position[0]);
        var y = Math.round(position[1]);

        var line = getTrackingLine.call(this);
        if (self.parent.layerTracking.features && line) {
            var last = line.geometry.length > 0 && line.geometry[line.geometry.length - 1];
            if (last && last.length == 0) {
                self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
            }
            else {
                var lx = Math.round(last[0]);
                var ly = Math.round(last[1]);

                if (x != lx || y != ly) {
                    self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);
                    line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);
                }
            }

            TC.Util.storage.setSessionLocalValue(self.parent.Const.LocalStorageKey.TRACKINGTEMP, self.formattedToStorage(self.parent.layerTracking).features);
        }

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && speed != undefined && speed > 0 && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.positionChangehandler = function (geoposition) {
        const self = this;
        var accuracy, heading, speed, altitude, altitudeAccuracy;

        if (!getTrackingLine.call(this)) {
            self.setTracking(false);
        }

        return new Promise(function (resolve, reject) {
            if (geoposition && geoposition.coords) {
                self.parent.layerGPS.clearFeatures();

                accuracy = (geoposition.coords.accuracy / self.parent.map.getMetersPerUnit()) || 0;
                heading = geoposition.coords.heading || geoposition[2] || 0;
                speed = geoposition.coords.speed ? geoposition.coords.speed * 3.6 : 0;
                altitude = geoposition.coords.altitude || 0;
                altitudeAccuracy = geoposition.coords.altitudeAccuracy || 0;

                if (self.parent.layerTracking) {
                    var position_ = [geoposition.coords && geoposition.coords.longitude || geoposition[0], geoposition.coords && geoposition.coords.latitude || geoposition[1]];
                    var projectedPosition = TC.Util.reproject(position_, 'EPSG:4326', self.parent.map.crs);

                    self.addPosition(projectedPosition, heading, new Date().getTime(), speed, accuracy, altitudeAccuracy, altitude);

                    var coords = getTrackingLine.call(self).geometry;
                    var len = coords.length;
                    if (len >= 2) {
                        self.parent.deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);
                    }

                    self.parent.trigger(self.parent.Const.Event.POSITIONCHANGE, {
                        pd: {
                            "position": projectedPosition,
                            "altitude": altitude,
                            "accuracy": accuracy,
                            "heading": TC.Util.radToDeg(heading),
                            "speed": speed
                        }
                    });

                    Promise.all([self.parent.layerGPS.addPoint(projectedPosition, {
                        radius: 4,
                        fillColor: '#00CED1',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWidth: 2,
                        showsPopup: false
                    }), self.parent.layerGPS.addCircle([projectedPosition, accuracy], {
                        strokeColor: '#00CED1',
                        strokeWidth: 0.4,
                        fillColor: '#ffffff',
                        fillOpacity: 0.2,
                        showsPopup: false
                    })]).then(function (features) {
                        const marker = features[0];
                        const accuracyCircle = features[1];
                        self.parent.geopositionTracking = true;

                        if (self.parent.firstPosition == false) {
                            self.parent.firstPosition = true;

                            if (!self.parent.trackCenterButton) {
                                self.parent.trackCenterButton = self.parent.div.querySelector('.' + self.parent.CLASS + '-track-center');
                                self.parent.trackCenterButton.querySelector('button').addEventListener('click', function () {
                                    self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);

                                    if (!self.parent.track.infoPanel.isVisible()) {
                                        self.parent.track.infoPanel.doVisible();
                                    }

                                    if (self.parent.track.infoPanel.isMinimized()) {
                                        self.parent.track.infoPanel.maximize();
                                    }
                                });

                                var controlContainer = self.parent.map.getControlsByClass('TC.control.ControlContainer')[0];
                                if (controlContainer) {
                                    self.parent.trackCenterButton = controlContainer.addElement({ side: controlContainer.SIDE.LEFT, htmlElement: self.parent.trackCenterButton });
                                } else {
                                    self.parent.map.div.appendChild(self.parent.trackCenterButton);
                                }

                            }
                            self.parent.trackCenterButton.classList.remove(TC.Consts.classes.HIDDEN);

                            self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);
                        }

                        resolve({
                            marker: marker, accuracy: accuracyCircle
                        });
                    });

                } else { resolve(null); }
            } else {
                resolve(null);
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.setTracking = function (tracking) {
        var self = this;

        if (tracking) {
            self.parent.firstPosition = false;
            var sessionwaypoint = [];

            var nativeTrackingFeature;

            if (self.parent.sessionTracking) {

                var JSONParser = new TC.wrap.parser.JSON();
                var features = JSONParser.parser.readFeatures(self.parent.sessionTracking);
                if (features && self.parent.storageCRS !== self.parent.map.crs) {
                    features = features.map(function (feature) {
                        var clone = feature.clone();
                        clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                        return clone;
                    });
                }

                var coordinates = features.filter(function (feature) {
                    var type = feature.getGeometry().getType().toLowerCase();
                    if (type === 'point') { sessionwaypoint.push(feature); }
                    return type === 'linestring' || type === 'multilinestring';
                })[0].getGeometry().getCoordinates();

                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(coordinates, ('XYZM')),
                    tracking: true
                });

            } else {
                nativeTrackingFeature = new ol.Feature({
                    geometry: new ol.geom.LineString([], ('XYZM')),
                    tracking: true
                });
            }

            if (nativeTrackingFeature) {

                TC.wrap.Feature.createFeature(nativeTrackingFeature).then(function (tcFeature) {
                    self.parent.layerTracking.addFeature(tcFeature);

                    if (tcFeature.geometry.length > 1) {
                        self.parent.map.zoomToFeatures(self.parent.layerTracking.features);
                    }

                    if (sessionwaypoint.length > 0) {
                        Promise.all(sessionwaypoint.map(function (waypoint) {
                            return TC.wrap.Feature.createFeature(waypoint);
                        })).then(function (features) {
                            if (features) {
                                features.forEach(function (feature) {
                                    self.parent.layerTracking.addFeature(feature);
                                });
                            }
                        });
                    }

                    self.parent.currentPositionWaiting = self.parent.getLoadingIndicator().addWait();

                    if (!self.currentPositionTrk) {
                        self.currentPositionTrk = [];
                    }

                    var getCurrentPositionInterval;
                    var getCurrentPositionRequest = 0;
                    var errorTimeout = 0;
                    var toast = false;
                    var options = {
                        enableHighAccuracy: true, timeout: 600000
                    };

                    function getCurrentPosition(errorCallback) {
                        var id = getCurrentPositionRequest++;
                        navigator.geolocation.getCurrentPosition(
                            function (data) {
                                clearInterval(getCurrentPositionInterval);
                                self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                                self.positionChangehandler(data).then(function (obj) {
                                    if (self.parent.geopositionTracking == true && obj && obj.marker && obj.accuracy) {
                                        self.currentPositionTrk.push(navigator.geolocation.watchPosition(self.positionChangehandler.bind(self), self.parent.onGeolocateError.bind(self.parent), options));
                                    }
                                });
                            },
                            errorCallback ? errorCallback :
                                function (error) {
                                    switch (error.code) {
                                        case error.TIMEOUT:
                                            if (errorTimeout > 10) {
                                                clearInterval(getCurrentPositionInterval);
                                                self.parent.onGeolocateError.call(self.parent, error);
                                            } else {
                                                errorTimeout++;
                                                getCurrentPosition(function () {
                                                    clearInterval(getCurrentPositionInterval);
                                                    if (!toast) {
                                                        toast = true;
                                                        self.parent.onGeolocateError.call(self.parent, error);
                                                    }
                                                });
                                            }
                                            break;
                                        default:
                                            clearInterval(getCurrentPositionInterval);
                                            self.parent.onGeolocateError.call(self.parent, error);
                                    }
                                }, {
                                timeout: 5000 + id,
                                maximumAge: 10,
                                enableHighAccuracy: true
                            }
                        );
                    }
                    getCurrentPositionInterval = setInterval(getCurrentPosition, 1000);

                    setTimeout(function () {
                        if (self.parent.layerTracking && self.parent.layerTracking.features && self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length == 0) {
                            clearInterval(getCurrentPositionInterval);

                            self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);
                            self.map.toast(self.parent.getLocaleString("geo.error.permission_denied"), {
                                type: TC.Consts.msgType.WARNING
                            });
                            self.parent.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
                            self.parent.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
                        }
                    }, options.timeout + 1000); // Wait extra second

                });
            }
        } else {
            self.parent.firstPosition = false;

            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }

            if (self.parent.trackCenterButton)
                self.parent.trackCenterButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    TC.wrap.control.Geolocation.prototype.activateSnapping = function () {
        var self = this;

        if (!TC.Util.detectMobile()) {
            self.olMap.on([ol.MapBrowserEventType.POINTERMOVE, ol.MapBrowserEventType.SINGLECLICK], self._snapTrigger);
            self.olMap.on(ol.render.EventType.POSTCOMPOSE, self._postcomposeTrigger);
        }
    };
    TC.wrap.control.Geolocation.prototype.deactivateSnapping = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            if (!TC.Util.detectMobile()) {
                olMap.un([ol.MapBrowserEventType.POINTERMOVE, ol.MapBrowserEventType.SINGLECLICK], self._snapTrigger);
                olMap.un(ol.render.EventType.POSTCOMPOSE, self._postcomposeTrigger);
            }

            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }

            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }

            if (self.snapLine) {
                delete self.snapLine;
                olMap.render();
            }
        });
    };
    TC.wrap.control.Geolocation.prototype.clear = function (layer) {
        var self = this;

        if (layer) {
            layer.clearFeatures();
        }

        attachedDTD = false;

        self.deactivateSnapping.call(self);
    };
    var vectorCtx;
    TC.wrap.control.Geolocation.prototype.duringTrackSnap = function (e) {
        var self = this;

        var vectorContext = vectorCtx = e.vectorContext;

        if (vectorContext && self.snapLine) {
            if (typeof (vectorContext.setFillStrokeStyle) === 'function')
                vectorContext.setFillStrokeStyle(null, new ol.style.Stroke({
                    color: 'rgba(197, 39, 55, 1)',
                    width: 1
                }));

            if (typeof (vectorContext.drawGeometry) === 'function')
                vectorContext.drawGeometry(self.snapLine.wrap.feature.getGeometry());
        }
    };

    TC.wrap.control.Geolocation.prototype.endSnap = function () {
        var self = this;

        self.parent.map.wrap.getMap().then(function (olMap) {
            /* cartel */
            if (self.snapInfo) {
                olMap.removeOverlay(self.snapInfo);
            }
            if (self.snapInfoElement) {
                self.snapInfoElement.style.display = 'none';
            }
            /* línea */
            if (self.snapLine) {
                delete self.snapLine;
            }
        });
    };

    TC.wrap.control.Geolocation.prototype.initSnap = function (coordinate, eventPixel) {
        var self = this;

        if (self.parent.layerTrack) {
            var vectorSource = self.parent.layerTrack.wrap.layer.getSource();
            var closestFeature = vectorSource.getClosestFeatureToCoordinate(coordinate);

            if (closestFeature !== null) {
                var geometry = closestFeature.getGeometry();
                var closestPoint = geometry.getClosestPoint(coordinate);

                const pixel = self.parent.map.getPixelFromCoordinate(closestPoint);
                const distance = Math.sqrt(
                    Math.pow(eventPixel[0] - pixel[0], 2) +
                    Math.pow(eventPixel[1] - pixel[1], 2));

                if (distance > self.parent.snappingTolerance) {
                    self.endSnap();
                } else {
                    var coordinates = [coordinate, [closestPoint[0], closestPoint[1]]];

                    if (!self.snapLine) self.snapLine = new TC.feature.Polyline(coordinates);
                    else self.snapLine.wrap.feature.getGeometry().setCoordinates(coordinates);

                    // información del punto
                    if (!self.snapInfoElement)
                        self.snapInfoElement = document.getElementsByClassName('tc-ctl-geolocation-track-snap-info')[0];

                    self.snapInfoElement.style.display = 'block';

                    if (!self.snapInfo) {
                        self.snapInfo = new ol.Overlay({
                            element: self.snapInfoElement,
                            offset: [5, 18]
                        });

                        self.olMap.addOverlay(self.snapInfo);
                    }

                    if (self.snapInfo.getMap() == undefined)
                        self.snapInfo.setMap(self.olMap);

                    self.snapInfo.setPosition(coordinate);

                    var data = {};
                    if (closestFeature.getGeometry().getType() != "LineString") {
                        if (closestFeature.getKeys().indexOf('name') > -1)
                            data.n = closestFeature.get('name');
                    }

                    var locale = self.parent.map.options.locale && self.parent.map.options.locale.replace('_', '-') || undefined;
                    data.x = self.map.wrap.isGeo() ? closestPoint[0].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[0]).toLocaleString(locale);
                    data.y = self.map.wrap.isGeo() ? closestPoint[1].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[1]).toLocaleString(locale);

                    if (self.map.wrap.isGeo()) {
                        data.isGeo = true;
                    }

                    var getZ = function (position) {
                        return closestPoint[position] ? (Math.round(closestPoint[position] * 100) / 100).toLocaleString(locale) : undefined;
                    };
                    var getM = function (position) {
                        return closestPoint[position] > 0 ? new Date(closestPoint[position]).toLocaleString(locale) : undefined;
                    };

                    if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZM) {
                        data.z = getZ(2);
                        data.m = getM(3);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZ) {
                        data.z = getZ(2);
                    } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYM) {
                        data.m = getM(2);
                    }

                    if (data) {
                        self.parent.getRenderedHtml(self.parent.CLASS + '-track-snapping-node', data, function (html) {
                            self.snapInfoElement.innerHTML = html;
                        });
                    }
                }
            }
        }

        self.olMap.render();
    };

    TC.wrap.control.Geolocation.prototype.drawTrackingData = function (track) {
        const self = this;

        return new Promise(function (resolve, reject) {
            const featurePromises = [];

            const JSONParser = new TC.wrap.parser.JSON();
            const features = JSONParser.parser.readFeatures(track.data);

            features.filter(function (feature) {
                return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
            }).forEach(function (feature) {
                feature.getGeometry().setCoordinates(feature.getGeometry().getCoordinates(), track.layout);
            });

            self.activateSnapping.call(self);

            for (var i = 0, len = features.length; i < len; i++) {
                featurePromises.push(TC.wrap.Feature.createFeature(features[i]));
            }

            Promise.all(featurePromises).then(function (feats) {
                feats.forEach(function (feat) {
                    if (feat) {
                        self.parent.layerTrack.addFeature(feat);
                    }
                });
                self.parent.map.zoomToFeatures(self.parent.layerTrack.features);

                resolve();
            });
        });
    };

    TC.wrap.control.Geolocation.prototype.formattedFromStorage = function (storageData) {
        const self = this;

        if (self.parent.storageCRS !== self.parent.map.crs) {
            var features = new ol.format.GeoJSON().readFeatures(storageData);
            if (features) {
                features = features.map(function (feature) {
                    var clone = feature.clone();
                    clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);
                    return clone;
                });

                return new ol.format.GeoJSON().writeFeatures(features);
            }
        }

        return storageData;
    };
    TC.wrap.control.Geolocation.prototype.formattedToStorage = function (layer, removeTrackingProperty, notReproject) {
        var self = this;

        var parser = new TC.wrap.parser.JSON();
        parser = parser.parser;

        var features = layer.wrap.layer.getSource().getFeatures();
        var layout;

        features = features.map(function (feature) {
            if (feature.getGeometry() instanceof ol.geom.LineString) {
                layout = feature.getGeometry().getLayout();
            }

            if (removeTrackingProperty && feature.getProperties().tracking) {
                feature.unset("tracking");
            }

            if (!notReproject && self.parent.map.crs !== self.parent.storageCRS) {
                var clone = feature.clone();
                clone.getGeometry().transform(self.parent.map.crs, self.parent.storageCRS);

                return clone;
            }

            return feature;
        }).sort(function (a, b) {

            if (a.getGeometry() instanceof ol.geom.Point &&
                !(b.getGeometry() instanceof ol.geom.Point)) {
                return -1;
            }

            if (b.getGeometry() instanceof ol.geom.Point &&
                !(a.getGeometry() instanceof ol.geom.Point)) {
                return 2;
            }

            if (a.getProperties().name < b.getProperties().name) { return -1; }
            if (a.getProperties().name > b.getProperties().name) { return 1; }

            return 0;
        });

        return {
            features: parser.writeFeatures(features), layout: layout
        };
    };

    TC.wrap.control.Geolocation.prototype.export = function (type, li) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var features = [];

            self.parent.getTrackingData(li).then(function (data) {
                if (data) {

                    var olFeatures = new ol.format.GeoJSON().readFeatures(data.data);

                    if (olFeatures.length === 0) {
                        var geoJSON = self.parent.getTrackingData(li);
                        olFeatures = new ol.format.GeoJSON().readFeatures(geoJSON);
                    }

                    features = olFeatures.map(function (feature) {
                        var clone = feature.clone();
                        clone.getGeometry().transform(self.parent.map.crs, 'EPSG:4326');

                        if (!(clone.getGeometry() instanceof ol.geom.LineString)) {
                            return clone;
                        } else {
                            return new ol.Feature({
                                geometry: new ol.geom.MultiLineString([clone.getGeometry().getCoordinates()], ('XYZM'))
                            });
                        }
                    });
                }

                switch (type) {
                    case 'GPX':
                        resolve(features ? new ol.format.GPX().writeFeatures(features) : null);
                        break;
                    case 'KML':
                        resolve(features ? new ol.format.KML().writeFeatures(features) : null);
                        break;
                }
            });
        });
    };

    var segmentsUnion = function (lineStrings) {
        var mergedIndex = [];
        var coords = [];
        if (lineStrings.length > 1) {

            if (lineStrings[0].length == 4) {
                lineStrings = lineStrings.sort(function (a, b) {
                    if (a[0][3] == b[0][3])
                        return 0;
                    else if (a[0][3] < b[0][3])
                        return -1;
                    else return 1;
                });
            }

            for (var ls = 0; ls < lineStrings.length; ls++) {
                var lineString = lineStrings[ls];
                var nextLineIndex = -1;
                var distance = Infinity;

                var last = lineString.getLastCoordinate();
                for (var nls = ls + 1; nls < lineStrings.length; nls++) {
                    var first = lineStrings[nls].getFirstCoordinate();
                    var d = Math.hypot(last[0] - first[0], last[1] - first[1]);
                    if (d < distance) {
                        nextLineIndex = nls;
                        distance = d;
                    }
                }

                if (mergedIndex.length < lineStrings.length) {
                    if (mergedIndex.indexOf(ls) == -1) {
                        mergedIndex.push(ls);
                        coords = coords.concat(lineString.getCoordinates());
                    }
                    if (mergedIndex.indexOf(nextLineIndex) == -1) {
                        mergedIndex.push(nextLineIndex);
                        coords = coords.concat(lineStrings[nextLineIndex].getCoordinates());
                    }
                }
            }

            //self.map.toast(self.parent.getLocaleString("geo.trk.simulateWarning"), { type: TC.Consts.msgType.WARNING });

            return coords;
        }

        return lineStrings[0].getCoordinates();
    };

    TC.wrap.control.Geolocation.prototype.processImportedFeatures = function (options) {
        var self = this;

        var source = self.parent.layerTrack.wrap.layer.getSource();
        var fileName = self.parent.importedFileName;
        var names = [];
        var toAdd = [];
        var toRemove = [];
        var maybeRemove = [];
        var features = source.getFeatures();

        var segments = [];
        var coord = [];

        var getName = function (feature) {
            if (feature.getProperties().hasOwnProperty("name")) {
                if (feature.getProperties().name.trim().length > 0)
                    names.push(feature.getProperties().name);
                else names.push(fileName);
            }
            else names.push(fileName);
        };

        for (var f = 0; f < features.length; f++) {
            var feature = features[f];

            if (feature instanceof TC.Feature)
                feature = features[f].wrap.feature;

            if (feature.getGeometry() instanceof ol.geom.Point) {
                coord.push(feature.getGeometry().getCoordinates());
                maybeRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.LineString) {
                // GLS: 31/01/2018 Routes (<rte>) are converted into LineString geometries, and tracks (<trk>) into MultiLineString, por tanto, las líneas las cargamos como N Rutas, no las unimos como hasta ahora: // segments.push(feature.getGeometry());                
                getName(feature);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(feature.getGeometry().getCoordinates(), feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
            else if (feature.getGeometry() instanceof ol.geom.MultiLineString) {
                var clone = feature.clone();
                getName(clone);

                var ls = clone.getGeometry().getLineStrings();

                var coords = segmentsUnion(ls);
                toAdd.push(new ol.Feature({
                    geometry: new ol.geom.LineString(coords, feature.getGeometry().getLayout())
                }));
                toRemove.push(feature);
            }
        }

        if (segments.length > 0) {
            var coords = segmentsUnion(segments);
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coords)
            }));
        }

        if (coord.length > 0 && maybeRemove.length == features.length) {
            toAdd.push(new ol.Feature({
                geometry: new ol.geom.LineString(coord)
            }));
        }

        if (toRemove.length > 0)
            for (var i = 0; i < toRemove.length; i++)
                source.removeFeature(toRemove[i]);

        if (toAdd.length > 0) {
            var sameName = function (array, element) {
                var indices = [];
                var idx = array.indexOf(element);
                while (idx != -1) {
                    indices.push(idx);
                    idx = array.indexOf(element, idx + 1);

                    if (indices.length > 1)
                        return true;
                }

                return indices.length > 1 ? true : false;
            };

            var featureToAdd;
            var index = 0;
            var processAdd = function () {
                const promises = toAdd.map(function (ta, idx) {
                    return new Promise(function (resolve, reject) {
                        if (featureToAdd) {
                            source.removeFeature(featureToAdd);
                        }

                        var name;
                        if (names.length > idx) {
                            var name = names[idx];
                            if (sameName(names, name))
                                name = '[' + (idx + 1) + ']' + ' ' + name;
                        }

                        self.parent.importedFileName = name ? name : fileName;

                        featureToAdd = toAdd[idx];
                        source.addFeature(featureToAdd);

                        self.parent.saveTrack({
                            message: self.parent.getLocaleString('geo.trk.upload.ok', { trackName: name ? name : fileName }),
                            importedFileName: name ? name : fileName,
                            notReproject: options.notReproject
                        }).then(function (importedIndex) {
                            if (idx == 0) {
                                index = importedIndex;
                            }
                            resolve();
                        });
                    });
                });
                return Promise.all(promises);
            };
            processAdd().then(function () {

                self.parent.layerTrack.setVisibility(false);
                self.parent.layerTrack.clearFeatures();

                self.parent.trigger(self.parent.Const.Event.IMPORTEDTRACK, { index: index });

                delete self.parent.importedFileName;
                self.parent.getLoadingIndicator().removeWait(options.wait);
            });
        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(options.wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    TC.wrap.control.Geolocation.prototype.import = function (wait, data, type) {
        var self = this;
        var vectorSource;
        var listenerKey;

        if (data && data.text) {

            var layerOptions = self.parent.layerTrack.wrap.createVectorSource({
                data: data.text,
                type: type
            });
            vectorSource = layerOptions.source;

            listenerKey = vectorSource.on('change', function (e) {
                if (vectorSource.getState() == 'ready') {
                    ol.Observable.unByKey(listenerKey);
                    self.processImportedFeatures(wait);
                }
            });

            var olLayer = self.parent.layerTrack.wrap.layer;
            olLayer.setSource(vectorSource);

        } else {

            if (self.parent.layerTrack) {
                self.parent.map.removeLayer(self.parent.layerTrack);
                self.parent.layerTrack = undefined;
            }

            delete self.parent.importedFileName;
            self.parent.getLoadingIndicator().removeWait(wait);
            TC.alert(self.parent.getLocaleString("geo.trk.upload.error4"));
        }
    };

    var idRequestAnimationFrame;
    TC.wrap.control.Geolocation.prototype.simulateTrackEnd = function () {
        var self = this;

        self.parent.chartProgressClear();

        if (self.simulateMarker) {
            window.cancelAnimationFrame(idRequestAnimationFrame);
            if (self.simulateMarker.layer.wrap.layer.getSource().getFeatures().length > 0)
                self.simulateMarker.layer.removeFeature(self.simulateMarker);

            delete self.simulateMarker;
        }
    };

    TC.wrap.control.Geolocation.prototype.simulateTrack = function () {
        var self = this;

        var coordinates;
        var features = self.parent.layerTrack.wrap.layer.getSource().getFeatures();
        for (var ls = 0; ls < features.length; ls++) {
            if (features[ls].getGeometry() instanceof ol.geom.LineString) {
                coordinates = features[ls].getGeometry().getCoordinates();
                break;
            }
        }

        if (coordinates && coordinates.length > 0) {
            var first = coordinates[0];

            var setSimulateMarker = function () {
                return new Promise(function (resolve, reject) {
                    if (!self.simulateMarker) {
                        self.parent.layerTrack.addPoint(first.slice(0, 2), {
                            radius: 7,
                            fillColor: '#ff0000',
                            fillOpacity: 0.5,
                            strokeColor: '#ffffff',
                            strokeWidth: 2
                        }).then(function (f) {
                            resolve(f);
                        });
                    } else {
                        self.simulateMarker.setCoords(first.slice(0, 2));
                        resolve(self.simulateMarker);
                    }
                });
            };
            setSimulateMarker().then(function (f) {
                self.simulateMarker = f;

                var animationFrameFraction = function () {
                    var trackLength = coordinates.length;
                    var start, finish;
                    var duration;
                    var fraction;
                    var hasTime = false;

                    const toLength = function (coords) {
                        if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                            return TC.Util.reproject(coords, self.parent.map.crs, self.parent.map.options.utmCrs);
                        }

                        return coords;
                    };

                    var arCoordinates = coordinates;
                    if (arCoordinates[0].length == 4 && arCoordinates[0][3] > 0) {
                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                        hasTime = true;
                    } else {
                        arCoordinates[0][3] = Date.now();

                        for (var i = 1; i < arCoordinates.length; i++) {
                            var done;
                            arCoordinates[i][3] = 0;

                            if (i + 1 < arCoordinates.length) {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1, i + 1))).getLength();
                            } else {
                                done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1))).getLength();
                            }

                            arCoordinates[i][3] = arCoordinates[i - 1][3] + (3600000 * done / self.parent.walkingSpeed);
                        }

                        start = arCoordinates[0][3];
                        finish = arCoordinates[arCoordinates.length - 1][3];
                    }

                    var trackFilm = new ol.geom.LineString(arCoordinates);
                    var timestamp = start;
                    var distance = 0;

                    if (self.parent.map.crs !== self.parent.map.options.utmCrs) {
                        distance = new ol.geom.LineString(toLength(JSON.parse(JSON.stringify(arCoordinates)))).getLength();
                    } else {
                        distance = trackFilm.getLength();
                    }

                    var done = 0;
                    var getDoneAtM = function (m) {
                        for (var i = 0; i < arCoordinates.length; i++) {
                            if (arCoordinates[i][3] > m)
                                return {
                                    d: new ol.geom.LineString(toLength(arCoordinates.slice(0, i))).getLength(),
                                    p: arCoordinates[i - 1].slice(0, 2)
                                };
                        }
                    };

                    var loopAtFraction = function () {

                        if (!self.parent.simulate_paused) {
                            var position = trackFilm.getCoordinateAtM(timestamp);
                            var d = getDoneAtM(timestamp);

                            if (fraction >= 1 || !position || !d) {
                                self.simulateTrackEnd();
                                var li = self.parent.getSelectedTrack();
                                if (li)
                                    self.parent.uiSimulate(false, li);

                                if (self.parent.hasElevation) {
                                    self.parent.chartProgressClear();
                                }

                                return;
                            } else {

                                if (self.parent.hasElevation) {
                                    self.parent.chartSetProgress(d, position, distance, (hasTime ? self.parent._getTime(arCoordinates[0][3], position[3]) : false));
                                }

                                if (self.simulateMarker) {
                                    var from = self.simulateMarker.getCoords();
                                    var to = position;
                                    var rotation = Math.atan2(to[1] - from[1], to[0] - from[0]) * 180 / Math.PI;

                                    self.simulateMarker.setCoords(position);
                                    //self.simulateMarker.setStyle({ angle: rotation });
                                }

                                if (self.parent.simulate_speed !== 1)
                                    timestamp = timestamp + (self.parent.delta * self.parent.simulate_speed);
                                else
                                    timestamp = timestamp + self.parent.delta;
                            }
                        }

                        idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);
                    };
                    idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);

                };

                const hasD3 = new Promise(function (resolve, reject) {
                    if (window.d3) {
                        resolve();
                    }
                    else {
                        TC.loadJS(!window.d3, [TC.Consts.url.D3C3], function () {
                            resolve();
                        });
                    }
                });
                hasD3.then(function () {
                    idRequestAnimationFrame = requestAnimationFrame(animationFrameFraction);
                });
            });
        }
    };

    TC.wrap.control.Geolocation.prototype.headingChangehandler = function (evt) {
        var self = this;
        if (!self.parent.track.infoOnMap) {
            self.parent.track.infoOnMap = document.createElement('div');
            const iomStyle = self.parent.track.infoOnMap.style;
            iomStyle.overFlowY = 'scroll';
            iomStyle.height = '200px';
            iomStyle.width = '200px';
            iomStyle.top = '0';
            iomStyle.left = '100px';
            iomStyle.backgroundColor = 'fuchsia';
            iomStyle.position = 'absolute';
            self.parent.map.div.appendChild(self.parent.track.infoOnMap);
        }

        self.parent.track.infoOnMap.style.display = '';

        self.heading = evt.target.getHeading();

        self.parent.track.infoOnMap.innerHTML = self.parent.track.infoOnMap.innerHTML +
            '<br> <p> salta headingChangehandler </p> <br> <p> evt.target.getHeading(): ' + self.heading + ' </p>';

        

        self.map.wrap.getMap().then(function (map) {
            map.getView().setRotation(-self.heading);
        });

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.orientationChangehandler = function (event) {
        var self = this;

        var view = self.map.wrap.map.getView();
        var center = view.getCenter();
        var resolution = view.getResolution();
        var beta = event.target.getBeta() || 0;
        var gamma = event.target.getGamma() || 0;

        center[0] -= resolution * gamma * 25;
        center[1] += resolution * beta * 25;

        view.setCenter(view.constrainCenter(center));

        self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {
            moving: (heading != undefined && heading > 0)
        });
    };

    TC.wrap.control.Geolocation.prototype.pulsate = function (circle) {
        var self = this;

        self.pulsated = true;

        var radius = circle.wrap.feature.getGeometry().getRadius();
        var start = new Date().getTime();

        var duration = 500;
        var listenerKey;

        var getRadius = function (elapsed) {
            switch (true) {
                case elapsed <= 50:
                    return radius;
                case elapsed > 50 && elapsed <= 100:
                    return radius * 1.02;
                case elapsed > 100 && elapsed <= 150:
                    return radius * 1.05;
                case elapsed > 150 && elapsed <= 200:
                    return radius * 1.02;
                case elapsed > 200 && elapsed <= 300:
                    return radius;
                case elapsed > 300 && elapsed <= 350:
                    return radius * 1.02;
                case elapsed > 350 && elapsed <= 400:
                    return radius * 1.05;
                case elapsed > 400 && elapsed <= 450:
                    return radius * 1.02;
                case elapsed > 450 && elapsed <= 500:
                    return radius * 1;
                default:
                    return radius;
            }
        };
        listenerKey = self.olMap.on(ol.render.EventType.POSTCOMPOSE, function (event) {
            var vectorContext = event.vectorContext;
            var frameState = event.frameState;

            var elapsed = frameState.time - start;

            var f = circle.wrap.feature.getGeometry().clone();
            var r = getRadius(elapsed);
            f.setRadius(r);

            vectorContext.setFillStrokeStyle(
                new ol.style.Fill({
                    color: 'rgba(0, 0, 0, 0.1)'
                }),
                new ol.style.Stroke({
                    color: 'rgba(255, 0, 0, .8)', width: 1
                })
            );
            vectorContext.drawCircleGeometry(f);

            if (elapsed > duration) {
                ol.Observable.unByKey(listenerKey);
                return;
            }

            frameState.animate = true;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.register = function (map) {
        const self = this;
        self.map = map;

        map.wrap.getMap().then(function (olMap) {
            self.olMap = olMap;
        });
    };

    TC.wrap.control.ResultsPanel.prototype.showElevationMarker = function (options) {
        const self = this;
        options = options || {};
        const data = options.data;
        const layer = options.layer;
        const coords = options.coords;

        if (!self.elevationMarker) {
            const elm = document.createElement('div');
            elm.style.display = 'none';
            elm.classList.add('tc-ctl-geolocation-trackMarker');
            elm.classList.add('elevation');
            self.elevationMarker = new ol.Overlay({
                element: elm,
                offset: [0, -11],
                positioning: ol.OverlayPositioning.CENTER_CENTER,
                stopEvent: false
            });
        }

        // GLS: si la capa del track está visible mostramos marcamos punto del gráfico en el mapa
        if (layer.getVisibility() && layer.getOpacity() > 0) {
            self.elevationMarker.getElement().style.display = '';
            self.olMap.addOverlay(self.elevationMarker);
            self.elevationMarker.setPosition(coords[data[0].index]);
        }

        // No centrar en el marker
        //var extent = self.map.getExtent();
        //var p = coords[data[0].index];
        //if (p[0] >= extent[0] && p[0] <= extent[2] && p[1] >= extent[1] && p[1] <= extent[3]) { }
        //else {
        //    self.map.setCenter(p.slice(0, 2), { animate: true });
        //}
    };

    TC.wrap.control.ResultsPanel.prototype.hideElevationMarker = function () {
        if (this.elevationMarker) {
            this.elevationMarker.getElement().style.display = 'none';
        }
    };

    TC.wrap.control.Coordinates.prototype.coordsActivate = function () {
        var self = this;

        self.olMap.on(ol.MapBrowserEventType.SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.control.Coordinates.prototype.coordsDeactivate = function () {
        var self = this;

        self.olMap.un(ol.MapBrowserEventType.SINGLECLICK, self._coordsTrigger);
    };

    TC.wrap.Parser = function () {
    };

    TC.wrap.Parser.prototype.read = function (data) {
        var result = [];
        var self = this;
        if (self.parser) {
            if (!TC.Feature) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Feature');
            }
            result = $.map(self.parser.readFeatures(data), function (feat) {
                return new TC.Feature(null, {
                    id: feat.getId(), data: feat.getProperties()
                });
            });
        }
        return result;
    };

    TC.wrap.parser = {
        WFS: function (options) {
            this.parser = new ol.format.WFS(options);
        },
        JSON: function (options) {
            this.parser = new ol.format.GeoJSON(options);
        }
    };
    TC.inherit(TC.wrap.parser.WFS, TC.wrap.Parser);
    TC.inherit(TC.wrap.parser.JSON, TC.wrap.Parser);

    TC.wrap.control.OverviewMap.prototype.register = function (map) {
        var self = this;

        self.parent.layer.wrap.getLayer().then(function (olLayer) {
            self.ovMap = new ol.control.OverviewMap({
                target: self.parent.div,
                collapsed: false,
                collapsible: false,
                className: self.parent.CLASS + ' ol-overviewmap',
                layers: [olLayer]
            });
            self.ovMap._wrap = self;

            /* 08/02/2019 GLS: 
                Establecemos el pixelRatio siempre a uno (aunque el control instancie un olMap internamente no admite el paso de la opción pixelRatio,
                imposible de entender, por eso lo hago directamente), porque OL sólo atiende al valor al principio,
                si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso, click se sitúa mal,
                popup se sitúa entre otros efectos.
                Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:
                    Bug 25976:Mapa situación en blanco
                    Bug 25954:Canvas en blanco con zoom mayor al 100%
                    Bug 23855:Mapa de situación se muestra en blanco
            */
            self.ovMap.getOverviewMap().pixelRatio_ = 1;

            // Quitamos el drag&drop añadido en OL 4.1.0 machacando el overlay
            self.ovMap.ovmap_.removeOverlay(self.ovMap.boxOverlay_);
            var box = document.createElement('DIV');
            box.className = 'ol-overviewmap-box';
            box.style.boxSizing = 'border-box';
            self.ovMap.boxOverlay_ = new ol.Overlay({
                position: [0, 0],
                positioning: ol.OverlayPositioning.BOTTOM_LEFT,
                element: box
            });
            self.ovMap.ovmap_.addOverlay(self.ovMap.boxOverlay_);

            // mantenemos el ancho y alto del canvas en números enteros
            self.manageSize.call(self.ovMap.ovmap_);

            self._boxElm = self.ovMap.boxOverlay_.getElement();

            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + 'lib/draggabilly/draggabilly.pkgd.min.js'],
                function () {
                    var ovmMap = self.ovMap.ovmap_;
                    const drag = new Draggabilly(self._boxElm);
                    // Parcheamos Draggabilly para que respete las otras transformaciones, por ejemplo rotación.
                    drag.positionDrag = function () {
                        const style = this.element.style;
                        const newTransform = 'translate3d( ' + this.dragPoint.x +
                            'px, ' + this.dragPoint.y + 'px, 0)';
                        if (style.transform.length) {
                            const idxStart = style.transform.indexOf('translate3d');
                            if (idxStart >= 0) {
                                const idxEnd = style.transform.indexOf(')', idxStart);
                                style.transform = style.transform.replace(style.transform.substring(idxStart, idxEnd + 1), newTransform);
                            }
                            else {
                                style.transform = newTransform + ' ' + style.transform;
                            }
                        }
                        else {
                            style.transform = newTransform;
                        }
                    };
                    drag.on('pointerDown', function (e) {
                        drag.dragged = self._boxElm.cloneNode();
                        drag.dragged.classList.add(TC.Consts.classes.ACTIVE);
                        drag.dragged.style.position = 'absolute';
                        self._boxElm.insertAdjacentElement('beforebegin', drag.dragged);
                        if (map.maxExtent) {
                            var bottomLeft = ovmMap.getPixelFromCoordinate([map.maxExtent[0], map.maxExtent[1]]);
                            var topRight = ovmMap.getPixelFromCoordinate([map.maxExtent[2], map.maxExtent[3]]);
                            var mapSize = ovmMap.getSize();
                            const container = document.createElement('div');
                            container.style.position = 'absolute';
                            container.style.bottom = Math.round(mapSize[1] - bottomLeft[1]) + 'px';
                            container.style.left = Math.round(bottomLeft[0]) + 'px';
                            container.style.top = Math.round(topRight[1]) + 'px';
                            container.style.right = Math.round(mapSize[0] - topRight[0]) + 'px';
                            const viewport = ovmMap.getViewport();
                            viewport.insertBefore(container, viewport.firstElementChild);
                            drag.options.containment = container;
                        }
                    });
                    drag.on('pointerUp', function (e) {
                        drag.dragged.parentElement.removeChild(drag.dragged);
                        if (map.maxExtent) {
                            ovmMap.getViewport().removeChild(drag.options.containment);
                            drag.options.containment = null;
                        }
                    });
                    drag.on('dragMove', function (e, pointer, moveVector) {
                        drag._delta = moveVector;
                    });
                    drag.on('dragEnd', function (e, pointer) {
                        var olMap = self.ovMap.getMap();
                        var view = olMap.getView();
                        var centerPixel = ovmMap.getPixelFromCoordinate(view.getCenter());
                        var newCenter = ovmMap.getCoordinateFromPixel([centerPixel[0] + drag._delta.x, centerPixel[1] + drag._delta.y]);
                        var extent = map.getExtent();
                        var halfWidth = (extent[2] - extent[0]) / 2;
                        var halfHeight = (extent[3] - extent[1]) / 2;

                        if (newCenter[0] + halfWidth > map.maxExtent[2]) {
                            newCenter[0] = map.maxExtent[2] - halfWidth;
                        }
                        else if (newCenter[0] - halfWidth < map.maxExtent[0]) {
                            newCenter[0] = map.maxExtent[0] + halfWidth;
                        }
                        if (newCenter[1] + halfHeight > map.maxExtent[3]) {
                            newCenter[1] = map.maxExtent[3] - halfHeight;
                        }
                        else if (newCenter[1] - halfHeight < map.maxExtent[1]) {
                            newCenter[1] = map.maxExtent[1] + halfHeight;
                        }

                        drag.setPosition(0, 0);
                        delete drag._delta;
                        map.setCenter(newCenter, { animate: true });
                    });
                });

            map.wrap.getMap().then(function (olMap) {

                // Modificamos mapa para que tenga la proyección correcta
                self.reset();

                const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.HIDDEN);
                    load.classList.add(TC.Consts.classes.VISIBLE);
                });
                olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                    load.classList.remove(TC.Consts.classes.VISIBLE);
                    load.classList.add(TC.Consts.classes.HIDDEN);
                });

                olMap.addControl(self.ovMap);

                self.parent.isLoaded = true;
                self.parent.trigger(TC.Consts.event.MAPLOAD);
            });
        });
    };

    TC.wrap.control.OverviewMap.prototype.reset = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const setLayer = function (layer, crs) {
                if (layer.type === TC.Consts.layerType.WMTS) {
                    var layerProjectionOptions = { crs: crs || self.parent.map.crs, oldCrs: layer.wrap.layer.getSource().getProjection().getCode() }; // , allowFallbackLayer: true

                    if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {
                        layer.setProjection(layerProjectionOptions);
                    }
                }

                layer.wrap.getLayer().then(function (olLayer) {

                    var olView = new ol.View(getResolutionOptions(self.parent.map.wrap, olLayer._wrap.parent));

                    if (olView.getResolutions()) {
                        olView.setResolution(olView.getResolutions().filter(function (res) {
                            return res > olView.getResolutionForExtent(self.parent.map.getExtent(), olMap.getSize())
                        }).reverse()[0]);

                        olMap.setView(olView);
                    } else if (olView.getProjection().getCode() !== olMap.getView().getProjection().getCode()) {
                        olMap.setView(olView);
                    }

                    // para controlar el mapa en blanco en IE en la carga inicial
                    olLayer._wrap.$events.one(TC.Consts.event.TILELOAD, function () {
                        olMap.getLayers().getArray()[0].getSource().refresh();
                    });

                    if (layer !== self.parent.layer || olMap.getLayers().getArray().indexOf(layer) === -1) {

                        self.parent.map.trigger(TC.Consts.event.OVERVIEWBASELAYERCHANGE, { oldLayer: layer !== self.parent.layer ? self.parent.layer : null, newLayer: layer });
                        olMap.getLayers().forEach(function (l) {
                            if (l instanceof ol.layer.Image || l instanceof ol.layer.Tile) {
                                olMap.removeLayer(l);
                            }
                        });

                        const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');
                        olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.HIDDEN);
                            load.classList.add(TC.Consts.classes.VISIBLE);
                        });
                        olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {
                            load.classList.remove(TC.Consts.classes.VISIBLE);
                            load.classList.add(TC.Consts.classes.HIDDEN);
                        });

                        olMap.getLayers().insertAt(0, olLayer); // GLS: no usamos .addLayer(olLayer) para asegurar que la capa a añadir quede como fondo.
                    }

                    resolve(layer);
                });
            };

            options = options || {};
            var layer = options.layer || self.parent.layer;
            if (self.parent.map && layer && self.ovMap) {
                var olMap = self.ovMap.ovmap_;

                layer.getCapabilitiesPromise().then(function () {

                    var originalLayer = layer;

                    if (!layer.isCompatible(self.parent.map.crs) && layer.wrap.getCompatibleMatrixSets(self.parent.map.crs).length === 0) {
                        layer = layer.getFallbackLayer() || self.parent.defaultLayer;

                        layer.getCapabilitiesPromise().then(function () {
                            if (self.parent.map.on3DView && !layer.isCompatible(self.parent.map.crs)) {
                                self.parent.map.loadProjections({
                                    crsList: originalLayer.getCompatibleCRS(),
                                    orderBy: 'name'
                                }).then(function (projList) {
                                    setLayer(originalLayer, projList[0].code);
                                });
                            } else if (layer.isCompatible(self.parent.map.crs)) {
                                setLayer(layer);
                            }
                        });
                    } else {
                        setLayer(layer);
                    }
                });
            }
        });
    };

    TC.wrap.control.OverviewMap.prototype.get3DCameraLayer = function () {
        var self = this;
        var result = null;
        var camLayerId = '3DCamera';
        var ovMap;

        if (self.ovMap) {
            ovMap = self.ovMap.getOverviewMap();
            ovMap.getLayers().forEach(function (elm) {
                if (elm.get('id') === camLayerId) {
                    result = elm;
                }
            });

            if (!result) {
                var ovMap = self.ovMap.getOverviewMap();
                var fovStyle = createNativeStyle({});
                // Ponemos los cuadriláteros de fov sin relleno (por legibilidad)
                fovStyle[0].getFill().setColor([0, 0, 0, 0]);
                result = new ol.layer.Vector({
                    id: camLayerId,
                    source: new ol.source.Vector(),
                    style: fovStyle
                });
                ovMap.addLayer(result);
            }
        }
        return result;
    };

    TC.wrap.control.OverviewMap.prototype.draw3DCamera = function (options) {
        var self = this;

        if (this.parent.map.isLoaded) {
            self.is3D = !!options;
            var camLayer = self.get3DCameraLayer();
            if (camLayer) {
                var feature;
                options = options || {
                };
                var fov = options.fov;
                var source = camLayer.getSource();
                if (!fov || !fov.length) { // no vemos terreno o no estamos en vista 3D
                    source.clear();
                }
                else {
                    var features = source.getFeatures();
                    if (!features.length) {
                        feature = new ol.Feature();
                        source.addFeature(feature);
                    }
                    else {
                        feature = features[0];
                    }
                    feature.setGeometry(new ol.geom.Polygon([fov]));
                }
                var heading = (typeof options.heading === 'number') ? options.heading : 0;
                self._boxElm.style.transform = 'rotate(' + heading + 'rad)';
            }
        }
    };

    TC.wrap.control.OverviewMap.prototype.enable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(true);

            /* GLS: bug 23855: mapa de situación se muestra en blanco
                En el resize se valida el alto y el ancho y como el div padre (id = "ovmap") tiene display: none, 
                el ancho y el alto devuelven cero y por ello se muestra en blanco. 
                No vale con lanzar .trigger('resize') porque no utiliza los valores actuales del div, 
                sino los almacenados, por eso llamamos a updateSize que actualiza dichos valores.
                https://tfsapp.tracasa.es:8088/tfs/web/wi.aspx?pcguid=4819cc6e-400e-4f70-ba7c-c18a830405aa&id=23855                
            */
            self.parent.wrap.ovMap.ovmap_.updateSize();

            // Lo siguiente es para actualizar mapa de situación
            const resizeEvent = document.createEvent('HTMLEvents');
            resizeEvent.initEvent('resize', false, false);
            self.parent.map.div.dispatchEvent(resizeEvent);
        }
    };

    TC.wrap.control.OverviewMap.prototype.disable = function () {
        var self = this;
        if (self.parent.layer && self.parent.layer.setVisibility) {
            self.parent.layer.setVisibility(false);
        }
    };

    TC.wrap.control.OverviewMap.prototype.manageSize = function () {
        const self = this;

        TC.wrap.Map.prototype.manageSize.call(self);
    };

    TC.wrap.control.FeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                var result = _clickTrigger.call(self, e);
                if (result) {
                    self.parent.beforeRequest({ xy: e.pixel });
                }
                else {
                    map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self.parent });
                }
                return result;
            }
        });
    };

    var bufferElm;
    var getElementText = function (elm) {
        var text = elm.innerHTML || elm.textContent;
        bufferElm = bufferElm || document.createElement("textarea");
        bufferElm.innerHTML = text;
        return bufferElm.value;
    };

    var esriXmlParser = {
        readFeatures: function (text) {
            var result = [];
            var dom = (new DOMParser()).parseFromString(text, 'text/xml');
            if (dom.documentElement.tagName === 'FeatureInfoResponse') {
                var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
                for (var i = 0, len = fiCollections.length; i < len; i++) {
                    var fic = fiCollections[i];
                    var layerName = fic.getAttribute('layername');
                    var fInfos = fic.getElementsByTagName('FeatureInfo');
                    for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                        var fields = fInfos[j].getElementsByTagName('Field');
                        var attributes = {
                        };
                        for (var k = 0, lenk = fields.length; k < lenk; k++) {
                            var field = fields[k];
                            attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                        }
                        var feature = new ol.Feature(attributes);
                        feature.setId(layerName + '.' + TC.getUID());
                        result[result.length] = feature;
                    }
                }
            }
            return result;
        }
    };

    var addLayerToService = function (service, layer, name) {
        var path = layer.getPath(name);
        service.layers.push({
            name: name,
            title: path[path.length - 1],
            path: path.slice(1),
            features: []
        });
    };

    TC.wrap.control.FeatureInfo.prototype.getFeatureInfo = function (coords, resolution, options) {
        var self = this;
        var opts = options || {};
        var map = self.parent.map;
        map.wrap.getMap().then(function (olMap) {
            var targetServices = {};
            var auxInfo = {};
            const requestPromises = [];
            const requestDataArray = [];
            var featurePromises = [];
            var services = [];

            //var infoFormats = [];
            var layers = olMap.getLayers().getArray();

            // GLS: filtro el array de capas para quedarnos con las capas que son raster y visibles.
            layers = layers.filter(function (elem) { return elem instanceof ol.layer.Image && elem.getVisible(); });

            for (var j = 0; j < layers.length; j++) {
                var olLayer = layers[j];
                var layer = olLayer._wrap.parent;
                var source = olLayer.getSource();

                //console.log("Source: " + layer.layerNames.join(","));
                //Por qué en workLayers están el vectorial de medición, y cosas así?
                if (source.getGetFeatureInfoUrl && $.inArray(layer, map.workLayers) >= 0 && layer.names.length > 0
                    && (!opts.serviceUrl || opts.serviceUrl === layer.url)) { // Mirar si en las opciones pone que solo busque en un servicio

                    //
                    var targetService;
                    if (!targetServices[layer.url]) {
                        targetService = {
                            layers: [],
                            mapLayers: [],
                            title: layer.title,
                            request: null
                        };
                        targetServices[layer.url] = targetService;
                        auxInfo[layer.url] = {
                            "source": jQuery.extend(true, {}, source),
                            "layers": []
                        };
                    }
                    else {
                        targetService = targetServices[layer.url];
                        auxInfo[layer.url].source.updateParams(ol.obj.assign(auxInfo[layer.url].source.getParams(), source.getParams()));
                    }
                    targetService.mapLayers.push(layer);

                    //var targetService = {
                    //    layers: [], mapLayers: [layer]
                    //};
                    var disgregatedNames = layer.getDisgregatedLayerNames();
                    if (opts.layerName) { // Mirar si en las opciones pone que solo busque en una capa
                        if (disgregatedNames.indexOf(opts.layerName) >= 0 && olLayer._wrap.getInfo(opts.layerName).queryable) {
                            addLayerToService(targetService, layer, opts.layerName);
                            auxInfo[layer.url].layers.push(opts.layerName);
                        }
                    }
                    else {
                        for (var i = 0; i < disgregatedNames.length; i++) {
                            var name = disgregatedNames[i];
                            if (olLayer._wrap.getInfo(name).queryable) {
                                addLayerToService(targetService, layer, name);
                            }
                            else {
                                TC.Util.consoleRegister('Capa "' + disgregatedNames[i] + '" no queryable, la eliminamos de la petición GFI');
                                disgregatedNames.splice(i, 1);
                                i = i - 1;
                            }
                        }

                        // GLS: validamos si nos queda alguna capa a la cual consultar
                        if (disgregatedNames.length > 0) {
                            auxInfo[layer.url].layers = auxInfo[layer.url].layers.concat(disgregatedNames);
                        }
                    }
                }
            }

            for (var serviceUrl in targetServices) {
                services.push(targetServices[serviceUrl]);
                var targetService = targetServices[serviceUrl];
                var source = auxInfo[serviceUrl].source;
                var layers = auxInfo[serviceUrl].layers;

                // GLS: validamos si hay capas a las cuales consultar, si no hay continuamos con el siguiente servicio
                if (!layers || (layers && layers.length === 0)) {
                    continue;
                }

                var params = source.getParams();
                source.params_.LAYERS = layers.join(',');
                var gfiURL = source.getGetFeatureInfoUrl(coords, resolution, map.crs, {
                    'QUERY_LAYERS': layers.join(','),
                    'INFO_FORMAT': params.INFO_FORMAT,
                    'FEATURE_COUNT': 1000,
                    'radius': map.options.pixelTolerance,
                    'buffer': map.options.pixelTolerance
                });

                gfiURL = gfiURL.replace(/sld_body=[a-zA-Z%0-9._]*/); // Quitamos el parámetro sld_body


                var expUrl = gfiURL;
                const requestData = {
                    serviceUrl: serviceUrl,
                    requestedFormat: params.INFO_FORMAT,
                    expandUrl: expUrl
                };
                requestDataArray.push(requestData);
                requestPromises.push(new Promise(function (resolve, reject) {
                    const mapLayer = targetService.mapLayers[0];
                    mapLayer.toolProxification.fetch(gfiURL)
                        .then(function (data) {
                            mapLayer.toolProxification.cacheHost.getAction(requestData.expandUrl).then(function (cache) {
                                requestData.originalUrl = cache.action.call(mapLayer.toolProxification, requestData.expandUrl);
                                resolve($.extend({}, data, requestData));
                            });
                        })
                        .catch(function (error) {
                            reject(Error(error));
                        });
                }));
                TC.Util.consoleRegister("Lanzamos GFI");
            }

            if (requestPromises.length > 0) {
                Promise.all(requestPromises).then(function (responses) {
                    var someSuccess = false;
                    var featureCount = 0;
                    var featureInsertionPoints = [];
                    for (var i = 0; i < responses.length; i++) {
                        var featureInfo = responses[i];
                        var service = targetServices[requestDataArray[i].serviceUrl];
                        someSuccess = true;
                        service.text = featureInfo.responseText;
                        var format;
                        var iFormat = featureInfo.contentType;
                        if (iFormat && iFormat.indexOf(";") > -1)
                            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

                        if (!iFormat) iFormat = featureInfo.requestedFormat;

                        if (iFormat === featureInfo.requestedFormat) {
                            switch (iFormat) {
                                case 'application/json':
                                    format = new ol.format.GeoJSON();
                                    break;
                                case 'application/vnd.ogc.gml':
                                    if (featureInfo.responseText.indexOf("FeatureCollection") > -1) {
                                        format = new ol.format.WFS({
                                            gmlFormat: new ol.format.GML2({
                                                srsName: map.crs
                                            })
                                        });
                                    }
                                    else {
                                        format = new ol.format.WMSGetFeatureInfo();
                                    }
                                    break;
                                case 'application/vnd.ogc.gml/3.1.1':
                                    format = new ol.format.GML3Patched({
                                        srsName: map.crs
                                    });
                                    break;
                                case 'application/vnd.esri.wms_featureinfo_xml':
                                    format = esriXmlParser;
                                    break;
                                default:
                                    format = null;
                                    break;
                            }

                            if (format) {
                                var features = format.readFeatures(featureInfo.responseText, {
                                    featureProjection: ol.proj.get(map.crs)
                                });
                                featureCount = featureCount + features.length;
                                var isParentOrSame = function (layer, na, nb) {
                                    var result = false;
                                    if (na === nb) {
                                        result = true;
                                    }
                                    else {
                                        var pa = layer.getNodePath(na);
                                        var pb = layer.getNodePath(nb);
                                        if (pa.length > 0 && pb.length >= pa.length) {
                                            result = true;
                                            for (var i = 0; i < pa.length; i++) {
                                                if (layer.wrap.getName(pa[i]) !== layer.wrap.getName(pb[i])) {
                                                    result = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    return result;
                                };

                                var fakeLayers = {
                                };

                                for (var j = 0; j < features.length; j++) {
                                    var feature = features[j];
                                    if (feature instanceof ol.Feature) {
                                        var fid = feature.getId() || TC.getUID();
                                        var found = false;
                                        var layerName = fid.substr(0, fid.lastIndexOf('.'));
                                        for (var k = 0; k < service.layers.length; k++) {
                                            var l = service.layers[k];
                                            var lName = l.name.substr(l.name.indexOf(':') + 1);
                                            if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                                                found = true;
                                                if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                    featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                    featureInsertionPoints.push(l.features);
                                                }
                                                break;
                                            }
                                        }

                                        //si llegamos aquí y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                                        //esto pasa, p.ej, en cartociudad
                                        if (!found) {
                                            //así que creo un layer de palo para la respuesta del featInfo
                                            var fakeLayer;
                                            if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                                            else {
                                                fakeLayer = {
                                                    name: layerName, title: layerName, path: [layerName], features: []
                                                };
                                                fakeLayers[layerName] = fakeLayer;
                                                service.layers.push(fakeLayer);
                                            }

                                            if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                                                featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));
                                                featureInsertionPoints.push(fakeLayer.features);
                                            }
                                        }
                                    }
                                }//iteración sobre las features de esta respuesta


                            }
                            else {
                                //si no hay formato reconocido y parseable, metemos un iframe con la respuesta
                                //y prau
                                //para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent

                                var compoundLayer = {
                                    name: 'layer' + TC.getUID(), title: 'Datos en el punto', features: []
                                };

                                service.layers[service.layers.length] = compoundLayer;
                                compoundLayer.features[0] = {
                                    rawUrl: featureInfo.originalUrl, expandUrl: featureInfo.expandUrl, rawContent: featureInfo.responseText, rawFormat: iFormat
                                };
                                featureCount = featureCount + 1;
                            }
                        }
                        else { // iFormat !== featureInfo.requestedFormat

                            // GLS:
                            TC.Util.consoleRegister("Respuesta GFI: lo más probable es que el servidor esté devolviendo una excepción");
                            TC.Util.consoleRegister("Lanzamos los eventos que corresponde y mostramos tostada");

                            // En este caso lo más probable es que el servidor esté devolviendo una excepción
                            self.parent.responseError({
                                message: featureInfo.responseText,
                                status: featureInfo.status
                            });
                            // GLS: misma gestión de error que en ol.js - > function (a, b, c) { // error...
                            map.toast(self.parent.getLocaleString('featureInfo.error'), {
                                type: TC.Consts.msgType.ERROR
                            });
                        }

                    }
                    if (someSuccess) {
                        var finfoPromises = featurePromises;
                        if (featurePromises.length) {
                            finfoPromises = finfoPromises.concat(new Promise(function (resolve, reject) {
                                // Si hay features cargamos el módulo de geometria para encontrar una que se interseque con el punto
                                TC.loadJS(
                                    !TC.Geometry,
                                    TC.apiLocation + 'TC/Geometry',
                                    function () {
                                        resolve();
                                    }
                                );
                            }));
                        }
                        Promise.all(finfoPromises).then(function (features) {
                            var defaultFeature;
                            features.forEach(function (feat, idx) {
                                if (feat) {
                                    feat.attributes = [];
                                    for (var key in feat.data) {
                                        var value = feat.data[key];
                                        if (typeof value !== 'object') {
                                            feat.attributes.push({
                                                name: key,
                                                value: typeof (value) == "number" ? value.toLocaleString(TC.Util.getMapLocale(self.parent.map)) : value
                                            });
                                        }
                                    }
                                    if (!defaultFeature && TC.Geometry.isInside(coords, feat.geometry)) {
                                        defaultFeature = feat;
                                    }
                                    featureInsertionPoints[idx].push(feat);
                                }
                            });

                            var services = [];
                            for (var serviceUrl in targetServices) {
                                if (targetServices.hasOwnProperty(serviceUrl)) {
                                    services.push(targetServices[serviceUrl]);
                                }
                            }

                            self.parent.responseCallback({
                                coords: coords,
                                resolution: resolution,
                                services: services,
                                featureCount: featureCount,
                                defaultFeature: defaultFeature
                            });
                        });
                    }
                },
                    function (a, b, c) { // error
                        if (services && services.length == 0) {
                            for (var serviceUrl in targetServices) {
                                services.push(targetServices[serviceUrl]);
                            }
                        }

                        self.parent.responseCallback({
                            coords: coords, resolution: resolution, services: services, featureCount: 0
                        });
                        map.toast(self.parent.getLocaleString('featureInfo.error'), {
                            type: TC.Consts.msgType.ERROR
                        });
                    });
            }
            else {

                if (map.workLayers.filter(function (layer) {
                    return layer instanceof TC.layer.Raster;
                }).length > 0) {
                    map.toast(self.parent.getLocaleString('featureInfo.notQueryableLayers'), {
                        type: TC.Consts.msgType.INFO
                    });
                }

                if (services && services.length == 0) {
                    for (var serviceUrl in targetServices) {
                        services.push(targetServices[serviceUrl]);
                    }
                }

                // GLS: nos suscribimos TC.Consts.event.BEFOREFEATUREINFO y lanzamos el mismo evento de zero resultados ya que puede darse que la resolución se lance antes del before.
                map.on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                    self.parent.responseCallback({
                        coords: coords, resolution: resolution, services: services, featureCount: 0
                    });
                });

                self.parent.responseCallback({
                    coords: coords, resolution: resolution, services: services, featureCount: 0
                });
            }
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.register = function (map) {
        var self = this;
        map.wrap.getMap().then(function (olMap) {
            TC.wrap.control.Click.prototype.register.call(self, map);
            var _clickTrigger = self._trigger;
            self._trigger = function (e) {
                self.hasEligibleLayers().then(function (hasLayers) {
                    if (hasLayers) {
                        if (!self.parent._isSearching) {
                            if (e.type == ol.MapBrowserEventType.SINGLECLICK && !self.parent._isDrawing && !self.parent._isSearching) {
                                _clickTrigger.call(self, e);
                            }
                        }
                    }
                });
            }

        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.hasEligibleLayers = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            const map = self.parent.map;
            var ret = false;
            map.wrap.getMap().then(function (olMap) {
                olMap.getLayers().forEach(function (olLayer) {
                    var layer = olLayer._wrap.parent;
                    var source = olLayer.getSource();
                    //Por qué en workLayers están el vectorial de medición, y cosas así?
                    if (source.getGetFeatureInfoUrl && $.inArray(layer, map.workLayers) >= 0) {
                        ret = true;
                        return false;   //break del foreach
                    }
                });
                resolve(ret);
            });
        });
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.beginDraw = function (options) {
        var self = this;
        options = options || {};
        var xy = options.xy;
        var layer = options.layer;
        var callback = options.callback;
        var geometryType = options.geometryType;
        var semaforo = false;
        if (!self.drawCtrl) {
            layer.wrap.getLayer().then(function (olLayer) {
                var olGeometryType;
                switch (geometryType) {
                    case TC.Consts.geom.POLYLINE:
                        olGeometryType = ol.geom.GeometryType.LINE_STRING;
                        break;
                    default:
                        olGeometryType = ol.geom.GeometryType.POLYGON;
                        break;
                }
                self.drawCtrl = new ol.interaction.Draw({
                    source: olLayer.getSource(),
                    type: olGeometryType
                    , style: olLayer.getStyle()
                });
                var setShowsPopup = function (wrap) {
                    wrap.parent.showsPopup = false;
                };
                olLayer.getSource().on(ol.source.VectorEventType.ADDFEATURE, function (event) {
                    if (event.feature._wrap) {
                        setShowsPopup(event.feature._wrap);
                    }
                    else {
                        event.feature._wrapPromise.then(setShowsPopup);
                    }
                });
                self.drawCtrl.handleEvent = function (event) {
                    //esta ñapa para solucionar cuando haces un primer punto y acontinuación otro muy rápido
                    if (event.type == ol.MapBrowserEventType.SINGLECLICK) {
                        var points = olGeometryType === ol.geom.GeometryType.POLYGON ? this.sketchCoords_[0] : this.sketchCoords_;
                        if (semaforo && points.length == 2 && this.sketchFeature_ !== null) {// GLS: Añado la misma validación (this.sketchFeature_ !== null) que tiene el código de OL antes de invocar addToDrawing_ 
                            this.addToDrawing_(event);
                        }
                        else {
                            semaforo = true;
                        }
                    }
                    return ol.interaction.Draw.handleEvent.call(this, event)
                }
                const map = self.parent.map;
                const olMap = map.wrap.map;
                olMap.addInteraction(self.drawCtrl);
                self.drawCtrl.on(ol.interaction.DrawEventType.DRAWSTART, function (event) {
                    self.parent._isDrawing = true;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                });
                self.drawCtrl.startDrawing_({
                    coordinate: xy
                });
                self.drawCtrl.on(ol.interaction.DrawEventType.DRAWEND, function (event) {
                    self.parent._isDrawing = false;
                    olMap.getInteractions().forEach(function (item, i) {
                        if (item instanceof (ol.interaction.DoubleClickZoom))
                            item.setActive(false);
                    });
                    olMap.removeInteraction(self.drawCtrl);
                    this.setActive(false);
                    self.drawCtrl = null;
                    olLayer.getSource().clear();
                    self.parent._drawToken = true;
                    setTimeout(function () {
                        self.parent._drawToken = false;
                    }, 500);
                    if (callback) {
                        TC.wrap.Feature.createFeature(event.feature).then(function (feat) {
                            callback(feat);
                        });
                    }
                });
            });

        }
        else {
            self.drawCtrl.setActive(true);
            self.drawCtrl.startDrawing_({
                coordinate: xy
            });
        }
    };

    TC.wrap.control.GeometryFeatureInfo.prototype.cancelDraw = function (xy, layer, callback) {
        var self = this;
        if (self.drawCtrl && self.parent._isDrawing) {
            self.parent._isDrawing = false;
            self.drawCtrl.setActive(false);
            self.drawCtrl.source_.clear();

        }
    };


    var WFSGetFeatureBuilder = function (map, filter, outputFormat, download) {
        const arrPromises = [];
        var services = {};
        const _getServiceTitle = function (service) {
            const mapLayer = service.mapLayers[0];
            return service.title || service.mapLayers.reduce(function (prev, cur) {
                return prev || cur.title;
            }, '') || (mapLayer.tree && mapLayer.tree.title) || mapLayer.capabilities.Service.Title;
        };
        const olMap = map.wrap.map;
        olMap.getLayers().forEach(function (olLayer) {
            var layer = olLayer._wrap.parent;
            if (!olLayer.getVisible() || $.inArray(layer, map.workLayers) < 0 || layer.type !== TC.Consts.layerType.WMS)
                return;
            var availableLayers = layer.getDisgregatedLayerNames() || layer.availableNames;
            var serviceObj = services[layer.url.toLowerCase()];
            if (!serviceObj) {
                serviceObj = services[layer.url.toLowerCase()] = {
                    layers: [], mapLayers: [layer], layerNames: []
                };
            }
            for (var i = 0; i < availableLayers.length; i++) {
                var name = availableLayers[i];
                if (!layer.isVisibleByScale(name) && !download)
                    continue;
                if (!layer.wrap.getInfo(name).queryable)
                    continue;
                serviceObj.layerNames.push(name);
                var path = layer.getPath(name);
                serviceObj.layers.push({
                    name: name,
                    title: path[path.length - 1],
                    path: path.slice(1),
                    features: []
                });
            }
            if (serviceObj.layerNames.length == 0)
                return;
            if (typeof (serviceObj.request) !== "undefined") {
                return;
            }
            serviceObj.request = serviceObj.request || layer.getWFSCapabilitiesPromise(); //WFSCapabilities.Promises(url);
            arrPromises.push(new Promise(function (resolve, reject) {
                serviceObj.request.then(function (capabilities) {
                    var service = null;
                    var errors = [];
                    for (var url in services)
                        if (services[url].request && services[url].request == serviceObj.request) {
                            service = services[url];
                        }
                    var _numMaxFeatures = null;
                    var layerList = service.layerNames;
                    if (!(layerList instanceof Array) || !layerList.length) return;//condici\u00f3n de salida
                    //comprobamos que tiene el getfeature habilitado
                    if (typeof (capabilities.Operations.GetFeature) === "undefined") {
                        errors.push({ key: TC.Consts.WFSErrors.GetFeatureNotAvailable, params: { serviceTitle: _getServiceTitle(service) } })
                        resolve({ "errors": errors });
                        return;
                    }
                    var availableLayers = [];
                    for (var i = 0; i < layerList.length; i++) {
                        //Comprbamos si la capa en el WMS tiene el mimso nombre que en el WFS
                        var layer = layerList[i].substring(layerList[i].indexOf(":") + 1);
                        //quitamos los ultimos caracteres que sean "_" , cosas de Idena
                        while (layer[layer.length - 1] === "_") {
                            layer = layer.substring(0, layer.lastIndexOf("_"));
                        }
                        if (!capabilities.FeatureTypes.hasOwnProperty(layer)) {
                            var titles = service.mapLayers[0].getPath(layer);
                            errors.push({ key: TC.Consts.WFSErrors.LayersNotAvailable, params: { serviceTitle: _getServiceTitle(service), "layerName": titles[titles.length - 1] } });
                            continue;
                        }
                        if (availableLayers.indexOf(layer) < 0)
                            availableLayers.push(layer);
                    }
                    if (availableLayers.length == 0) {
                        errors.push({ key: TC.Consts.WFSErrors.NoValidLayers, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    if (capabilities.Operations.GetFeature.CountDefault)
                        _numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
                    //comprobamos si soporta querys    
                    if (
                        (capabilities.version === "1.0.0" && !capabilities.Operations.GetFeature.Operations.hasOwnProperty("Query"))
                        ||
                        ((capabilities.version === "2.0.0" || capabilities.version === "1.1.0") && capabilities.Operations.QueryExpressions.AllowedValues.Value.indexOf("wfs:Query") < 0)
                    ) {
                        errors.push({ key: TC.Consts.WFSErrors.QueryNotAvailable, params: { serviceTitle: _getServiceTitle(service) } });
                        resolve({ "errors": errors });
                        return;
                    }
                    var url = (capabilities.Operations.GetFeature.DCPType ? capabilities.Operations.GetFeature.DCPType[1].HTTP.Post.onlineResource : capabilities.Operations.GetFeature.DCP.HTTP.Post["xlink:href"]);

                    // var url2 = service.mapLayers[0].getFeatureUrl(url);
                    service.mapLayers[0].getFeatureUrl(url).then(function (url2) {
                        if (_numMaxFeatures) {
                            jQuery.ajax({
                                url: url2,
                                data: TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, true),
                                cache: false,
                                contentType: "application/xml",
                                type: "POST",
                            }).then(function () {
                                if (arguments[0] instanceof XMLDocument) {
                                    var responseAsJSON = xml2json(arguments[0]);
                                    if (responseAsJSON.Exception) {
                                        resolve({
                                            errors: [{
                                                key: TC.Consts.WFSErrors.Indeterminate,
                                                params: {
                                                    err: responseAsJSON.Exception.exceptionCode, errorThrown: responseAsJSON.Exception.ExceptionText, serviceTitle: service.mapLayers.reduce(function (prev, cur) {
                                                        return prev || cur.title;
                                                    }, '')
                                                }
                                            }]
                                        })
                                        return;
                                    }
                                }
                                var featFounds = parseInt(responseAsJSON.numberMatched || responseAsJSON.numberOfFeatures, 10)
                                if (isNaN(featFounds) || featFounds > parseInt(_numMaxFeatures, 10)) {
                                    resolve({
                                        errors: [{
                                            key: TC.Consts.WFSErrors.NumMaxFeatures, params: { limit: _numMaxFeatures, serviceTitle: _getServiceTitle(service) }
                                        }]
                                    });
                                    return;
                                }
                                else if (featFounds === 0) {
                                    resolve({
                                        errors: [{
                                            key: TC.Consts.WFSErrors.NoFeatures, params: { serviceTitle: _getServiceTitle(service) }
                                        }]
                                    });
                                }
                                else if (download) {
                                    resolve({
                                        url: url,
                                        data: TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, false),
                                        service: service,
                                        numFeatures: featFounds,
                                        errors: errors
                                    });
                                }

                            }
                                , function (xhr, textStatus, errorThrown) {
                                    resolve({
                                        errors: [{
                                            key: TC.Consts.WFSErrors.Indeterminate,
                                            params: { err: textStatus, errorThrown: errorThrown, serviceTitle: _getServiceTitle(service) }
                                        }]
                                    });
                                    return;
                                });
                        }
                        else {
                            if (!download) {
                                resolve({
                                    url: url2,
                                    data: TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, false),
                                    service: service,
                                    errors: errors
                                });
                            }
                        }
                        if (download && !_numMaxFeatures) {
                            resolve({
                                url: url,
                                data: TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, false),
                                service: service,
                                errors: errors
                            });
                        }
                        if (!download) {
                            jQuery.ajax({
                                url: url2,
                                data: TC.Util.WFSQueryBuilder(availableLayers, filter, capabilities, outputFormat, false),
                                cache: false,
                                contentType: "application/xml",
                                type: "POST",
                            }).then(function () {
                                if (arguments[1] == "success") {
                                    if (arguments[0] instanceof XMLDocument) {
                                        var responseAsJSON = xml2json(arguments[0]);
                                        if (responseAsJSON.Exception) {
                                            resolve({
                                                errors: [{
                                                    key: TC.Consts.WFSErrors.Indeterminate,
                                                    params: {
                                                        err: responseAsJSON.Exception.exceptionCode, errorThrown: responseAsJSON.Exception.ExceptionText, serviceTitle: service.mapLayers.reduce(function (prev, cur) {
                                                            return prev || cur.title;
                                                        }, '')
                                                    }
                                                }]
                                            })
                                            return;
                                        }
                                    }
                                    resolve({ service: service, response: arguments, errors: errors });
                                }
                                else {
                                    reject(arguments);
                                    return;
                                }
                            },
                                function (xhr, textStatus, errorThrown) {
                                    resolve({
                                        errors: [{
                                            key: TC.Consts.WFSErrors.Indeterminate,
                                            params: { err: textStatus, errorThrown: errorThrown, serviceTitle: _getServiceTitle(service) }
                                        }]
                                    });
                                    return;
                                });
                        }
                    });
                }, function (jqXHR, textStatus, errorThrown) {
                    var service = null;
                    for (var title in services)
                        if (services[title].request && services[title].request === serviceObj.request) {
                            service = services[title];
                        }
                    resolve({ errors: [{ key: TC.Consts.WFSErrors.GetCapabilities, params: { err: errorThrown, serviceTitle: _getServiceTitle(service) } }] });
                });
            }));
        });
        return arrPromises;
    };
    TC.WFSGetFeatureBuilder = WFSGetFeatureBuilder;

    var readFeaturesFromResponse = function (map, data, jqXHR) {
        var featureInsertionPoints = [];
        var format;
        var iFormat = jqXHR.getResponseHeader("Content-type");
        if (iFormat && iFormat.indexOf(";") > -1)
            iFormat = iFormat.substr(0, iFormat.indexOf(";")).trim();

        if (!iFormat) iFormat = data.requestedFormat;
        switch (iFormat) {
            case 'application/json':
                format = new ol.format.GeoJSON();
                break;
            case 'application/vnd.ogc.gml':
                if (data.responseText.indexOf("FeatureCollection") > -1)
                    format = new ol.format.WFS({
                        gmlFormat: new ol.format.GML2({
                            srsName: map.crs
                        })
                    });
                else
                    format = new ol.format.WMSGetFeatureInfo();
                break;
            case 'application/vnd.ogc.gml/3.1.1':
                format = new ol.format.GML3Patched({
                    srsName: map.crs
                });
                break;
            case "text/xml":
            case "application/xml":
                //posible error
                var jqXHR = xml2json(data);
                if (jqXHR.ServiceException)
                    TC.error(jqXHR.ServiceException);
                format = null;
                break;
            default:
                format = null;
                break;
        }
        if (format) {
            return format.readFeatures(jqXHR.responseText, {
                featureProjection: ol.proj.get(map.crs)
            });
        }
        else {
            return null;
            ////si no hay formato reconocido y parseable, metemos un iframe con la respuesta
            ////y prau
            ////para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent
            //var l = service.layers[0];
            //l.features.push({
            //    error: response.responseText
            //});
        }
    };
    var featureToServiceDistributor = function (features, service) {
        var featurePromises = [];
        var featureInsertionPoints = [];
        var isParentOrSame = function (layer, na, nb) {
            var result = false;
            if (na === nb || (na.indexOf(nb) === 0)) {
                result = true;
            }
            else {
                var pa = layer.getPath(na);
                var pb = layer.getPath(nb);
                if (pa.length > 0 && pb.length >= pa.length) {
                    result = true;
                    for (var i = 0; i < pa.length; i++) {
                        if (pa[i] !== pb[i]) {
                            result = false;
                            break;
                        }
                    }
                }
            }
            return result;
        };
        for (var j = 0; j < features.length; j++) {
            var feature = features[j];
            if (feature instanceof ol.Feature) {
                var fid = feature.getId() || TC.getUID();
                var found = false;
                var layerName = fid.substr(0, fid.lastIndexOf('.'));
                for (var k = 0; k < service.layers.length; k++) {
                    var l = service.layers[k];
                    var lName = l.name.substr(l.name.indexOf(':') + 1);
                    if (service.mapLayers.some(function (mapLayer) { return isParentOrSame(mapLayer, lName, layerName) })) {
                        found = true;
                        featurePromises.push(TC.wrap.Feature.createFeature(feature));

                        featureInsertionPoints[feature.id_] = (l.features);
                        break;
                    }
                }

                //si llegamos aqu\u00ed y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer
                //esto pasa, p.ej, en cartociudad
                if (!found) {
                    //as\u00ed que creo un layer de palo para la respuesta del featInfo
                    var fakeLayer;
                    if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];
                    else {
                        fakeLayer = {
                            name: layerName, title: layerName, features: []
                        };
                        fakeLayers[layerName] = fakeLayer;
                        service.layers.push(fakeLayer);
                    }

                    if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature
                        featurePromises.push(TC.wrap.Feature.createFeature(feature));
                        featureInsertionPoints.push(fakeLayer.features);
                    }
                }
            }
        }//iteraci\u00f3n sobre las features de esta respuesta

        return new Promise(function (resolve, reject) {
            Promise.all(featurePromises).then(function (features) {
                features.forEach(function (feat) {
                    feat.attributes = [];
                    //feat.showsPopup = false;
                    for (var key in feat.data) {
                        var value = feat.data[key];
                        if (typeof value !== 'object') {
                            feat.attributes.push({
                                name: key, value: value
                            });
                        }
                    }
                    featureInsertionPoints[feat.id].push(feat);
                });
                resolve({
                    service: service
                })
            });
        });
    }

    TC.wrap.control.GeometryFeatureInfo.prototype.getFeaturesByGeometry = function (feature, xy) {

        var self = this;
        var map = self.parent.map;
        self.parent.filterFeature = feature;
        feature.layer = self.parent.filterLayer;

        map.wrap.getMap().then(function (olMap) {

            var olGeometry = feature.wrap.feature.getGeometry();
            var stride = olGeometry.stride;
            var flatCoordinates = olGeometry.getFlatCoordinates();
            //calcular el punto mas alto
            if (!xy) {
                var bestPoint = null;
                for (var i = 1, len = flatCoordinates.length; i < len; i += stride) {
                    if (!bestPoint || bestPoint[1] < flatCoordinates[i]) {
                        bestPoint = [flatCoordinates[i - 1], flatCoordinates[i]];
                    }
                }
                xy = olMap.getPixelFromCoordinate(new ol.geom.Point(bestPoint).getCoordinates());
            }

            self.parent.beforeRequest({ xy: xy });

            var arrRequests = WFSGetFeatureBuilder(map, new TC.filter.intersects(feature, map.crs !== map.options.crs ? map.crs : undefined), "JSON");

            const arrPromises = [];
            Promise.all(arrRequests).then(function (responses) {
                var targetServices = [];
                var featureCount = 0;
                var hayError = false;

                for (var i = 0; i < responses.length; i++) {
                    const responseObj = responses[i];
                    if (!responseObj) continue;
                    arrPromises[arrPromises.length] = new Promise(function (resolve, reject) {
                        if (responseObj.errors && responseObj.errors.length) {
                            for (var j = 0; j < responseObj.errors.length; j++) {
                                var errorMsg, errorType = TC.Consts.msgType.WARNING;
                                hayError = true;
                                var error = responseObj.errors[j];
                                switch (error.key) {
                                    case TC.Consts.WFSErrors.NumMaxFeatures:
                                        errorMsg = self.parent.getLocaleString("wfs.tooManyFeatures", error.params);
                                        break;
                                        /*case TC.Consts.WFSErrors.NoLayers:
                                            errorMsg = self.parent.getLocaleString('noLayersLoaded');*/
                                        break;
                                    case TC.Consts.WFSErrors.GetCapabilities:
                                        errorMsg = self.parent.getLocaleString('wfsGFI.inValidService', error.params);
                                        break;
                                    case TC.Consts.WFSErrors.NoFeatures:
                                        //si no hay features nos callamos. Quizas en un futuro se muestre una alerta
                                        hayError = false;
                                        continue;
                                        break;
                                    case TC.Consts.WFSErrors.Indeterminate:
                                        errorMsg = self.parent.getLocaleString("wfs.IndeterminateError");
                                        TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                                        errorType = TC.Consts.msgType.ERROR;
                                        break;
                                    default:
                                        errorMsg = self.parent.getLocaleString("wfsGFI." + error.key, error.params);
                                        break;
                                }

                                map.toast(errorMsg, { type: errorType });
                            }
                            if (!responseObj.response) {
                                resolve();
                            }
                        }
                    });

                    // Puede no haber response porque la URL no es correcta, metemos un condicional
                    var featuresFound = responses[i].response ? readFeaturesFromResponse(map, responses[i].response[0], responses[i].response[2]) : [];
                    //ahora se distribuye la features por servicio y capa
                    arrPromises[arrPromises.length - 1] = featureToServiceDistributor(featuresFound, responses[i].service);
                    targetServices.push(responses[i].service);
                    featureCount = featureCount + featuresFound.length;
                }
                Promise.all(arrPromises).then(function () {
                    self.parent.responseCallback({
                        xy: xy || null, services: targetServices, featureCount: featureCount
                    });
                });
            }, function (e) {
                self.parent.responseCallback({});
            })
        });
    };

    TC.wrap.control.Popup.prototype = function () {
        this.popup = null;
    };

    TC.Consts.event.PANANIMATIONSTART = 'pananimationstart.tc';
    TC.Consts.event.PANANIMATIONEND = 'pananimationend.tc';
    TC.wrap.control.Popup.prototype.fitToView = function () {
        var self = this;
        var map = self.parent.map;
        var olMap = self.parent.map.wrap.map;

        var popupBoundingRect = self.parent.popupDiv.getBoundingClientRect();
        var mapBoundingRect = map.div.getBoundingClientRect();

        var topLeft = olMap.getCoordinateFromPixel([popupBoundingRect.left - mapBoundingRect.left, popupBoundingRect.top - mapBoundingRect.top]);
        var bottomRight = olMap.getCoordinateFromPixel([popupBoundingRect.right - mapBoundingRect.left, popupBoundingRect.bottom - mapBoundingRect.top]);
        var west = topLeft[0];
        var north = topLeft[1];
        var east = bottomRight[0];
        var south = bottomRight[1];

        var popupExt = [west, south, east, north];
        var mapExt = map.getExtent();

        if (!ol.extent.containsExtent(mapExt, popupExt)) {
            var overflows = {
                left: Math.max(mapExt[0] - popupExt[0], 0),
                bottom: Math.max(mapExt[1] - popupExt[1], 0),
                right: Math.max(popupExt[2] - mapExt[2], 0),
                top: Math.max(popupExt[3] - mapExt[3], 0)
            };

            if (self.parent.dragged) {
                // Movemos el popup
                var newPos = self.popup.getPosition();
                if (overflows.right) {
                    newPos[0] = newPos[0] - overflows.right;
                }
                else if (overflows.left) {
                    newPos[0] = newPos[0] + overflows.left;
                }
                if (overflows.top) {
                    newPos[1] = newPos[1] - overflows.top;
                }
                else if (overflows.bottom) {
                    newPos[1] = newPos[1] + overflows.bottom;
                }
                var newPixelPos = olMap.getPixelFromCoordinate(newPos);
                newPixelPos[1] = olMap.getSize()[1] - newPixelPos[1];
                self.parent._previousContainerPosition = newPixelPos;
                self.popup._oldUpdatePixelPosition(newPos);
            }
            else {
                if (self.parent.isVisible()) {
                    // Movemos el mapa
                    var view = olMap.getView();
                    var ct = view.getCenter().slice();

                    if (overflows.top) ct[1] += overflows.top;
                    else if (overflows.bottom) ct[1] -= overflows.bottom;
                    if (overflows.right) ct[0] += overflows.right;
                    else if (overflows.left) ct[0] -= overflows.left;

                    view.animate({
                        center: ct, easing: function (percent) {
                            if (percent === 0) self.parent.map.trigger(TC.Consts.event.PANANIMATIONSTART);
                            if (percent === 1) self.parent.map.trigger(TC.Consts.event.PANANIMATIONEND);
                            return percent;
                        }
                    });
                }
            }
        }
    };

    TC.wrap.control.Popup.prototype.setDragged = function (dragged) {
        var popup = this.popup;
        //var view = popup.getMap().getView();
        //var onViewChange = function () {
        //    console.log(this.getCenter());
        //};
        if (dragged) {
            // Parcheamos funciones para que el popup no se mueva cuando cambiamos el extent del mapa
            if (!popup._oldUpdatePixelPosition) {
                popup._oldUpdatePixelPosition = popup.updatePixelPosition;
                popup.updatePixelPosition = function () {
                };
            }
            if (!popup._newHandleOffsetChanged) {
                popup._newHandleOffsetChanged = function () {
                    this._oldUpdatePixelPosition();
                };
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),
                    popup.handleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),
                    popup._newHandleOffsetChanged, popup);
            }
            //view.on(['change:center','change:resolution'], onViewChange);
        }
        else {
            // Redefinimos las propiedades de posicionamiento porque al arrastrarlo, las hemos modificado.
            const containerStyle = popup.getElement().parentElement.style;
            containerStyle.setProperty('top', popup.rendered.top_);
            containerStyle.setProperty('bottom', popup.rendered.bottom_);
            containerStyle.setProperty('left', popup.rendered.left_);
            containerStyle.setProperty('right', popup.rendered.right_);

            delete this.parent._previousContainerPosition;
            // Deshacemos parcheo
            if (popup._oldUpdatePixelPosition) {
                popup.updatePixelPosition = popup._oldUpdatePixelPosition;
                delete popup._oldUpdatePixelPosition;
            }
            if (popup._newHandleOffsetChanged) {
                ol.events.unlisten(
                    popup, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),
                    popup._newHandleOffsetChanged, popup);
                ol.events.listen(
                    popup, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),
                    popup.handleOffsetChanged, popup);
                delete popup._newHandleOffsetChanged;
            }
            //view.un(['change:center', 'change:resolution'], onViewChange);
        }
    };

    TC.wrap.Feature.prototype.getLegend = function () {
        var self = this;
        var result = {
        };
        var style = getNativeStyle(self.feature);
        if (style) {
            var image = style.getImage();
            if (image) {
                if (image instanceof ol.style.Icon) {
                    result.src = image.getSrc();
                    var scale = image.getScale();
                    if (scale) {
                        result.scale = scale;
                        var img = image.getImage();
                        if (img.width) {
                            result.width = img.width * scale;
                            result.height = img.height * scale;
                        }
                    }
                }
                else if (image instanceof ol.style.Circle) {
                    result.src = image.canvas_.toDataURL();
                }
                if (self.parent.options.radius) {
                    result.height = result.width = self.parent.options.radius * 2;
                }
                else {
                    result.width = result.width || self.parent.options.width;
                    result.height = result.height || self.parent.options.height;
                }
            }
            else {
                // No image, find stroke and fill
                var stroke = style.getStroke();
                var fill = style.getFill();
                if (stroke) {
                    var strokeColor = stroke.getColor();
                    if (strokeColor) {
                        result.strokeColor = ol.color.asString(strokeColor);
                    }
                    var strokeWidth = stroke.getWidth();
                    if (strokeWidth) {
                        result.strokeWidth = strokeWidth;
                    }
                }
                if (fill) {
                    var fillColor = fill.getColor();
                    if (fillColor) {
                        result.fillColor = ol.color.asString(fillColor);
                    }
                }
            }
        }

        return result;
    };

    var createNativeFeature = function (coords, geometryConstructor, geometryName) {
        var result;
        var featureOptions = {};
        var gn = geometryName || 'geometry';
        featureOptions[gn] = new geometryConstructor(coords);
        result = new ol.Feature(featureOptions);
        if (geometryName) {
            result.setGeometryName(geometryName);
        }
        return result;
    };

    TC.wrap.Feature.prototype.createPoint = function (coords, options) {
        var self = this;

        if ($.isArray(coords)) {
            self.feature = createNativeFeature(coords, ol.geom.Point, options.geometryName);
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            self.parent.geometry = coords.getGeometry().getCoordinates();
        }
        self.feature._wrap = self;
        self.feature.setStyle(createNativeStyle({ styles: { point: options } }, self.feature));
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMarker = function (coords, options) {
        var self = this;

        var iconUrl = TC.Util.getPointIconUrl(options);
        if (iconUrl) {
            options.url = iconUrl;
            if ($.isArray(coords)) {
                self.feature = createNativeFeature(coords, ol.geom.Point, options.geometryName);
            }
            else if (self.isNative(coords)) {
                self.feature = coords;
                self.parent.geometry = coords.getGeometry().getCoordinates();
            }
            self.feature._wrap = self;
            self.feature.setStyle(createNativeStyle({ styles: { marker: options } }, self.feature));
            self.setData(self.parent.data);
        }
        else {
            self.createPoint(coords, options);
        }
    };

    TC.wrap.Feature.prototype.createPolyline = function (coords, options) {
        var self = this;

        if ($.isArray(coords)) {
            self.feature = createNativeFeature(coords, ol.geom.LineString, options.geometryName);
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            self.parent.geometry = coords.getGeometry().getCoordinates();
        }
        self.feature._wrap = self;
        if (options) {
            self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createPolygon = function (coords, options) {
        var self = this;

        if ($.isArray(coords)) {
            if (coords.length) {
                var ringCoords = coords[0];
                if ($.isArray(ringCoords) && ringCoords.length) {
                    var pointCoord = ringCoords[0];
                    if (!$.isArray(pointCoord)) {
                        // anillo solo, lo metemos dentro de un array de anillos
                        coords = [coords];
                    }
                    for (var i = 0; i < coords.length; i++) {
                        ringCoords = coords[i];
                        var startPoint = ringCoords[0];
                        var endPoint = ringCoords[ringCoords.length - 1];
                        if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
                            ringCoords[ringCoords.length] = startPoint;
                        }
                        self.parent.geometry = coords;
                        self.feature = createNativeFeature(coords, ol.geom.MultiLineString, options.geometryName);
                    }
                    self.parent.geometry = coords;
                    self.feature = createNativeFeature(coords, ol.geom.Polygon, options.geometryName);
                }
            }
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            self.parent.geometry = coords.getGeometry().getCoordinates();
        }
        self.feature._wrap = self;
        var opts = options || {};
        if (opts.strokeColor || opts.strokeWidth || opts.fillColor || opts.fillOpacity) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: opts } }, self.feature));
        }
        self.setData(self.parent.data);
    };


    TC.wrap.Feature.prototype.createMultiPolyline = function (coords, options) {
        var self = this;

        if ($.isArray(coords)) {
            if (coords.length) {
                var plnCoords = coords[0];
                if ($.isArray(plnCoords) && plnCoords.length) {
                    var pointCoord = plnCoords[0];
                    if (!$.isArray(pointCoord)) {
                        // polilínea sola, la metemos dentro de un array de polilíneas
                        coords = [coords];
                    }
                    self.parent.geometry = coords;
                    self.feature = createNativeFeature(coords, ol.geom.MultiLineString, options.geometryName);
                }
            }
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            self.parent.geometry = coords.getGeometry().getCoordinates();
        }
        self.feature._wrap = self;
        if (options) {
            self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createMultiPolygon = function (coords, options) {
        var self = this;

        if ($.isArray(coords)) {
            if (coords.length) {
                var pgnCoords = coords[0];
                if ($.isArray(pgnCoords) && pgnCoords.length) {
                    var ringCoords = pgnCoords[0];
                    if ($.isArray(ringCoords) && ringCoords.length) {
                        var pointCoord = ringCoords[0];
                        if (!$.isArray(pointCoord)) {
                            // polígono solo, lo metemos dentro de un array de polígonos
                            coords = [coords];
                        }
                    }
                    else {
                        // anillo solo, lo metemos de un array de anillos y este en un array de polígonos
                        coords = [[coords]];
                    }
                    // Close rings
                    for (var i = 0, ii = coords.length; i < ii; i++) {
                        pgnCoords = coords[i];
                        for (var j = 0, jj = pgnCoords.length; j < jj; j++) {
                            ringCoords = pgnCoords[j];
                            var startPoint = ringCoords[0];
                            var endPoint = ringCoords[ringCoords.length - 1];
                            if (startPoint[0] !== endPoint[0] || startPoint[1] !== endPoint[1]) {
                                ringCoords[ringCoords.length] = startPoint;
                            }
                        }
                    }
                    self.parent.geometry = coords;
                    self.feature = createNativeFeature(coords, ol.geom.MultiPolygon, options.geometryName);
                }
            }
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            self.parent.geometry = coords.getGeometry().getCoordinates();
        }
        self.feature._wrap = self;
        var opts = options || {};
        if (opts.strokeColor || opts.strokeWidth || opts.fillColor || opts.fillOpacity) {
            self.feature.setStyle(createNativeStyle({ styles: { polygon: opts } }, self.feature));
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.prototype.createCircle = function (coords, options) {
        var self = this;

        if ($.isArray(coords) &&
            $.isArray(coords[0])
            && typeof coords[0][0] === 'number' && typeof coords[0][1] === 'number'
            && typeof coords[1] === 'number') {

            var featureOptions = {};
            var geometryName = options.geometryName || 'geometry';
            featureOptions[geometryName] = new ol.geom.Circle(coords[0], coords[1]);
            self.feature = new ol.Feature(featureOptions);
            if (options.geometryName) {
                self.feature.setGeometryName(options.geometryName);
            }
        }
        else if (self.isNative(coords)) {
            self.feature = coords;
            var nativeGeometry = coords.getGeometry();
            self.parent.geometry = [nativeGeometry.getCenter(), nativeGeometry.getRadius()];
        }
        self.feature._wrap = self;
        if (options) {
            self.feature.setStyle(
                new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: options.strokeColor,
                        width: options.strokeWidth,
                        lineDash: options.lineDash
                    }),
                    fill: new ol.style.Fill({
                        color: getRGBA(options.fillColor, options.fillOpacity)
                    })
                })
            );
        }
        self.setData(self.parent.data);
    };

    TC.wrap.Feature.createFeature = function (olFeat, options) {
        return new Promise(function (resolve, reject) {
            var olGeometry = olFeat.getGeometry();
            options = options || {};
            options.id = olFeat.getId();

            // geometría
            var geomStr;
            switch (true) {
                case olGeometry instanceof ol.geom.Point:
                    var olStyle = olFeat.getStyle();
                    if ($.isFunction(olStyle)) {
                        olStyle = olStyle.call(olFeat);
                    }
                    var olStyles = olStyle ? ($.isArray(olStyle) ? olStyle : [olStyle]) : [];
                    for (var i = 0, len = olStyles.length; i < len; i++) {
                        olStyle = olStyles[i];
                        if (olStyle.getImage() instanceof ol.style.Icon) {
                            geomStr = 'Marker';
                            break;
                        }
                    }
                    geomStr = geomStr || 'Point';
                    break;
                case olGeometry instanceof ol.geom.LineString:
                    geomStr = 'Polyline';
                    break;
                case olGeometry instanceof ol.geom.Polygon:
                    geomStr = 'Polygon';
                    break;
                case olGeometry instanceof ol.geom.MultiLineString:
                    geomStr = 'MultiPolyline';
                    break;
                case olGeometry instanceof ol.geom.MultiPolygon:
                    geomStr = 'MultiPolygon';
                    break;
                default:
                    break;
            }
            if (geomStr) {
                TC.loadJS(
                    !TC.feature || (TC.feature && !TC.feature[geomStr]),
                    [TC.apiLocation + 'TC/feature/' + geomStr],
                    function () {
                        var feat = new TC.feature[geomStr](olFeat, options);
                        feat.data = feat.wrap.getData();
                        resolve(feat);
                    }
                );
            }
            else {
                TC.loadJS(
                    !TC.Feature,
                    [TC.apiLocation + 'TC/Feature'],
                    function () {
                        var feat = new TC.Feature(olFeat, options);
                        feat.data = feat.wrap.getData();
                        resolve(feat);
                    }
                );
            }
        });
    };

    TC.wrap.Feature.prototype.cloneFeature = function () {
        return this.feature.clone();
    };

    TC.wrap.Feature.prototype.getStyle = function () {
        var self = this;
        var result = {};
        var olStyle = self.feature.getStyle();
        if ($.isFunction(olStyle)) {
            olStyle = olStyle.call(self.feature);
        }
        var olStyles = olStyle ? ($.isArray(olStyle) ? olStyle : [olStyle]) : [];

        const getFill = function (style, obj) {
            if (style) {
                const fill = style.getFill();
                if (fill) {
                    obj.fillColor = fill.getColor();
                    if ($.isArray(obj.fillColor)) {
                        obj.fillOpacity = obj.fillColor[3];
                    }
                }
            }
        };
        const getStroke = function (style, obj) {
            if (style) {
                const stroke = style.getStroke();
                if (stroke) {
                    obj.strokeColor = stroke.getColor();
                    obj.strokeWidth = stroke.getWidth();
                }
            }
        };

        for (var i = 0, len = olStyles.length; i < len; i++) {
            olStyle = olStyles[i];
            getFill(olStyle, result);
            getStroke(olStyle, result);
            const image = olStyle.getImage();
            if (image instanceof ol.style.Icon) {
                result.url = image.getSrc();
                const size = image.getSize();
                const scale = image.getScale() || 1;
                if (size) {
                    result.width = size[0] * scale;
                    result.height = size[1] * scale;
                }
                var anchor = image.getAnchor();
                if (anchor) {
                    result.anchor = [anchor[0] * scale, anchor[1] * scale];
                    if (size) {
                        // getAnchor devuelve los valores en pixels, hay que transformar a fracción
                        result.anchor[0] = result.anchor[0] / result.width;
                        result.anchor[1] = result.anchor[1] / result.height;
                    }
                }
            }
            else {
                getFill(image, result);
                getStroke(image, result);
            }
            var text = olStyle.getText();
            if (text) {
                result.label = text.getText();
                var font = text.getFont();
                if (font) {
                    // A 96dpi 3pt = 4px
                    result.fontSize = parseInt(font.match(/\d+pt/)) || parseInt(font.match(/\d+px/)) * 0.75;
                }
                var rotation = text.getRotation();
                if (rotation) {
                    result.angle = -180 * rotation / Math.PI;
                }
                result.labelOffset = [text.getOffsetX(), text.getOffsetY()];
                fill = text.getFill();
                if (fill) {
                    result.fontColor = fill.getColor();
                }
                stroke = text.getStroke();
                if (stroke) {
                    result.labelOutlineColor = stroke.getColor();
                    result.labelOutlineWidth = stroke.getWidth();
                }
            }
        }
        $.extend(self.parent.options, result);
        return result;
    };

    TC.wrap.Feature.prototype.getGeometry = function () {
        var result;
        var self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            if (geom) {
                if (geom.getCoordinates) {
                    result = geom.getCoordinates();
                }
                else if (geom instanceof ol.geom.Circle) {
                    result = [geom.getCenter(), geom.getRadius()];
                }
            }
        }
        return result;
    };

    TC.wrap.Feature.prototype.setGeometry = function (geometry) {
        var result = false;
        var self = this;
        if (self.feature && self.feature.getGeometry) {
            var geom = self.feature.getGeometry();
            var point,
                points,
                ringsOrPolylines,
                polygons,
                isMultiPolygon,
                isPolygonOrLineString,
                isLineString;
            // punto: array de números
            // línea o anillo: array de puntos
            // multilínea o polígono: array de líneas o anillos
            // multipolígono: array de polígonos
            // Por tanto podemos recorrer los tipos en un switch sin breaks
            switch (true) {
                case (geom instanceof ol.geom.MultiPolygon):
                    isMultiPolygon = true;
                    polygons = geometry;
                    if ($.isArray(polygons)) {
                        ringsOrPolylines = geometry[0];
                    }
                case (geom instanceof ol.geom.Polygon || geom instanceof ol.geom.MultiLineString):
                    isPolygonOrLineString = true;
                    ringsOrPolylines = isMultiPolygon ? ringsOrPolylines : geometry;
                    if ($.isArray(ringsOrPolylines)) {
                        points = ringsOrPolylines[0];
                    }
                case (geom instanceof ol.geom.LineString):
                    isLineString = true;
                    points = isPolygonOrLineString ? points : geometry;
                    if ($.isArray(points)) {
                        point = points[0];
                    }
                case (geom instanceof ol.geom.Point):
                    point = isLineString ? point : geometry;
                    if ($.isArray(point) && typeof point[0] === 'number' && typeof point[1] === 'number') {
                        var layout;
                        switch (point.length) {
                            case 3:
                                layout = ol.geom.GeometryLayout.XYZ;
                                break;
                            case 4:
                                layout = ol.geom.GeometryLayout.XYZM;
                                break;
                            default:
                                layout = ol.geom.GeometryLayout.XY;
                                break;
                        }
                        geom.setCoordinates(geometry, layout);
                        result = true;
                    }
                    break;
                case (geom instanceof ol.geom.Circle):
                    if ($.isArray(geometry) &&
                        $.isArray(geometry[0])
                        && typeof geometry[0][0] === 'number' && typeof geometry[0][1] === 'number'
                        && typeof geometry[1] === 'number') {
                        geom.setCenterAndRadius(geometry[0], geometry[1]);
                        result = true;
                    }
                    break;
            }
        }
        return result;
    };

    TC.wrap.Feature.prototype.getId = function () {
        var result;
        var self = this;
        if (self.feature) {
            result = self.feature.getId();
        };
        return result;
    };

    TC.wrap.Feature.prototype.setId = function (id) {
        var self = this;
        if (self.feature) {
            self.feature.setId(id);
        };
    };

    const getPolygonLength = function (polygon, options) {
        const self = this;
        var result = 0;
        polygon.getLinearRings().forEach(function (ring) {
            coordinates = ring.getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            const newRing = polygon.getLinearRing(0);
            result = result + ol.geom.flat.length.linearRing(newRing.flatCoordinates, 0, newRing.flatCoordinates.length, newRing.stride);
        });
        return result;
    };

    const getLineStringLength = function (lineString, options) {
        const self = this;
        coordinates = lineString.getCoordinates();
        if (options.crs) {
            coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
        }
        const line = new ol.geom.LineString(coordinates);
        return line.getLength();
    };

    TC.wrap.Feature.prototype.getLength = function (options) {
        const self = this;
        options = options || {};
        var result = 0;

        const geom = self.feature.getGeometry();
        var coordinates;
        switch (true) {
            case geom instanceof ol.geom.Polygon:
                result = getPolygonLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.LineString:
                result = getLineStringLength.call(self, geom, options);
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getPolygons().forEach(function (polygon) {
                    result = result + getPolygonLength.call(self, polygon, options);
                });
                break;
            case geom instanceof ol.geom.MultiPolygon:
                geom.getLineStrings().forEach(function (lineString) {
                    result = result + getLineStringLength.call(self, lineString, options);
                });
                break;
        }

        return result;
    };

    TC.wrap.Feature.prototype.getArea = function (options) {
        const self = this;
        options = options || {};

        const geom = self.feature.getGeometry();
        var coordinates;
        if (geom instanceof ol.geom.Polygon) {
            coordinates = geom.getLinearRing(0).getCoordinates();
            if (options.crs) {
                coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);
            }
            const polygon = new ol.geom.Polygon([coordinates]);
            return polygon.getArea();
        }
    };

    const getFeatureStyle = function (readonly) {
        var style = this.getStyle();
        if ($.isFunction(style)) {
            style = style.call(this);
        }
        if ($.isArray(style)) {
            style = style[style.length - 1];
        }
        if (!style && !readonly) {
            style = new ol.style.Style();
            this.setStyle(style);
        }
        return style;
    };

    const getLayerStyle = function (feature) {
        var style = this.getStyle();
        if ($.isFunction(style)) {
            style = style(feature);
        }
        if ($.isArray(style)) {
            style = style[style.length - 1];
        }
        if (!style) {
            style = new ol.style.Style();
        }
        return style;
    };

    TC.wrap.Feature.prototype.setStyle = function (options) {
        const self = this;
        const olFeat = self.feature;
        if (options === null) {
            olFeat.setStyle(null);
            return;
        }
        const feature = self.parent;
        const geom = olFeat.getGeometry();
        var style = getFeatureStyle.call(olFeat);
        var layerStyle;
        if (feature.layer) {
            layerStyle = getLayerStyle.call(feature.layer.wrap.layer, feature.wrap.feature);
        }
        if (geom instanceof ol.geom.Point || geom instanceof ol.geom.MultiPoint) {

            var imageStyle;
            if (options.anchor || options.url || options.cssClass) { // Marcador
                imageStyle = style.getImage();
                const iconOptions = {};
                if (imageStyle instanceof ol.style.Icon) {
                    iconOptions.src = options.url || TC.Util.getBackgroundUrlFromCss(options.cssClass) || imageStyle.getSrc();

                    if (options.width && options.height) {
                        iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                    }
                    else {
                        iconOptions.size = imageStyle.getSize();
                    }
                    iconOptions.anchor = getStyleValue(options.anchor, feature) || imageStyle.getAnchor().map(function (elm, idx) {
                        return elm / iconOptions.size[idx];
                    });
                }
                else {
                    iconOptions.src = TC.Util.getPointIconUrl(options);
                    iconOptions.anchor = getStyleValue(options.anchor, feature);
                    iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];
                };
                if (options.angle) {
                    iconOptions.angle = options.angle;
                }

                imageStyle = new ol.style.Icon(iconOptions);
            }
            else if (!(style.getImage()) && style.getText()) { // Etiqueta

                if (options.label !== undefined) {
                    style = getFeatureStyle.call(olFeat);
                    if (options.label.length) {
                        style.setText(createNativeTextStyle(options, feature));
                    }
                    else {
                        style.setText();
                    }
                } else {
                    style.setText();
                }
            }
            else { // Punto sin icono
                imageStyle = style.getImage();
                if (!imageStyle) {
                    imageStyle = new ol.style.Circle();
                }
                const circleOptions = {
                    radius: getStyleValue(options.radius, feature) ||
                    (getStyleValue(options.height, feature) + getStyleValue(options.width, feature)) / 4
                };
                if (isNaN(circleOptions.radius)) {
                    circleOptions.radius = imageStyle.getRadius();
                }
                if (options.fillColor) {
                    circleOptions.fill = new ol.style.Fill({
                        color: getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature))
                    });
                }
                else {
                    circleOptions.fill = imageStyle.getFill();
                }
                circleOptions.stroke = imageStyle.getStroke();
                const layerStroke = layerStyle && layerStyle.getStroke();
                if (options.strokeColor || options.strokeWidth) {
                    if (!circleOptions.stroke) {
                        circleOptions.stroke = new ol.style.Stroke();
                    }
                    if (options.strokeColor) {
                        circleOptions.stroke.setColor(getStyleValue(options.strokeColor, feature));
                    }
                    else {
                        const strokeColor = circleOptions.stroke.getColor() || (layerStroke && layerStroke.getColor() || TC.Cfg.styles.point.strokeColor);
                        circleOptions.stroke.setColor(getStyleValue(strokeColor, feature));
                    }
                    if (options.strokeWidth) {
                        circleOptions.stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                    }
                    else {
                        const strokeWidth = circleOptions.stroke.getWidth() || (layerStroke && layerStroke.getWidth() || TC.Cfg.styles.point.strokeWidth);
                        circleOptions.stroke.setWidth(getStyleValue(strokeWidth, feature));
                    }
                }
                imageStyle = new ol.style.Circle(circleOptions);
            }
            style.setImage(imageStyle);
        }
        else {
            var stroke = style.getStroke();
            var strokeChanged = false;
            if (!stroke) {
                stroke = new ol.style.Stroke();
            }
            if (options.strokeColor) {
                stroke.setColor(getStyleValue(options.strokeColor, feature));
                strokeChanged = true;
            }
            if (options.strokeWidth) {
                stroke.setWidth(getStyleValue(options.strokeWidth, feature));
                strokeChanged = true;
                style.setStroke(stroke);
            }
            if (options.lineDash) {
                stroke.setLineDash(options.lineDash)
                strokeChanged = true;
                style.setStroke(stroke);
            }
            if (strokeChanged) {
                style.setStroke(stroke);
            }
            if (geom instanceof ol.geom.Polygon || geom instanceof ol.geom.MultiPolygon) {
                if (options.fillColor || options.fillOpacity) {
                    var fill = style.getFill() || new ol.style.Fill();
                    fill.setColor(getRGBA(getStyleValue(options.fillColor, feature), getStyleValue(options.fillOpacity, feature)));
                    style.setFill(fill);
                }
            }
        }

        if (options.label !== undefined) {
            style = getFeatureStyle.call(olFeat);
            if (options.label.length) {
                style.setText(createNativeTextStyle(options, feature));
            }
            else {
                style.setText();
            }
        }

        olFeat.changed();
    };

    TC.wrap.Feature.prototype.toggleSelectedStyle = function (condition) {
        const self = this;
        const feature = self.feature;
        const setStyle = condition === undefined ? !feature._originalStyle : condition;
        if (setStyle) {
            setSelectedStyle(feature);
        }
        else {
            removeSelectedStyle(feature);
        }
    };

    TC.wrap.Feature.prototype.getInnerPoint = function (options) {
        var result;
        var opts = options || {};
        // Funciones para hacer clipping con el extent actual. Así nos aseguramos de que el popup sale en un punto visible actualmente.
        var feature = this.feature;
        var geometry = feature.getGeometry();

        var clipCoord = function (coord) {
            var clipBox = opts.clipBox;
            coord[0] = Math.min(Math.max(coord[0], clipBox[0]), clipBox[2]);
            coord[1] = Math.min(Math.max(coord[1], clipBox[1]), clipBox[3]);
        };
        var clipGeometry = function clipGeometry(geom) {
            if (opts.clipBox) {
                if ($.isArray(geom)) {
                    if ($.isArray(geom[0])) {
                        for (var i = 0, len = geom.length; i < len; i++) {
                            clipGeometry(geom[i]);
                        }
                    }
                    else {
                        clipCoord(geom);
                    }
                }
            }
        };

        result = geometry.getFirstCoordinate();
        switch (geometry.getType()) {
            case ol.geom.GeometryType.MULTI_POLYGON:
                var area = 0;
                geometry = geometry.getPolygons().reduce(function (prev, cur) {
                    const curArea = cur.getArea();
                    const result = curArea > area ? cur : prev;
                    area = curArea;
                    return result;
                });
            case ol.geom.GeometryType.POLYGON:
                var isInsideRing = function (point, ring) {
                    var result = false;
                    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                        var xi = ring[i][0], yi = ring[i][1];
                        var xj = ring[j][0], yj = ring[j][1];
                        var intersect = ((yi > point[1]) != (yj > point[1])) &&
                            (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                        if (intersect) result = !result;
                    }
                    return result;
                };
                var coords = geometry.getCoordinates();
                clipGeometry(coords);
                geometry = new ol.geom.Polygon(coords);
                result = geometry.getInteriorPoint().getCoordinates();
                var rings = geometry.getLinearRings();
                // Miramos si el punto está dentro de un agujero
                for (var i = 1; i < rings.length; i++) {
                    if (isInsideRing(result, rings[i].getCoordinates())) {
                        result = geometry.getClosestPoint(result);
                        break;
                    }
                }
                break;
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                var length = 0;
                geometry = geometry.getLineStrings().reduce(function (prev, cur) {
                    const curLength = cur.getLength();
                    const result = curLength > length ? cur : prev;
                    length = curLength;
                    return result;
                });
            case ol.geom.GeometryType.LINE_STRING:
                var centroid = [0, 0];
                var coords = geometry.getCoordinates();
                clipGeometry(coords);
                geometry = new ol.geom.LineString(coords);
                for (var i = 0; i < coords.length; i++) {
                    centroid[0] += coords[i][0];
                    centroid[1] += coords[i][1];
                }
                centroid[0] /= coords.length;
                centroid[1] /= coords.length;
                result = geometry.getClosestPoint(centroid);
                break;
            default:
                break;
        }
        return result;
    };

    TC.wrap.Feature.prototype.showPopup = function (popupCtl) {
        var self = this;
        var map = popupCtl.map;

        if (map) {
            var feature = self.feature;
            if (feature) {
                map.currentFeature = self.parent;
                var currentExtent = map.getExtent();

                self._innerCentroid = self.getInnerPoint({ clipBox: currentExtent });

                popupCtl.contentDiv.innerHTML = self.parent.getInfo({ locale: map.options.locale });
                popupCtl.menuDiv.innerHTML = '';
                if (popupCtl.options.closeButton || popupCtl.options.closeButton === undefined) {
                    const btn = document.createElement('div');
                    btn.classList.add(popupCtl.CLASS + '-close');
                    btn.setAttribute('title', popupCtl.getLocaleString('close'));
                    popupCtl.menuDiv.appendChild(btn);
                    btn.addEventListener(TC.Consts.event.CLICK, function () {
                        popupCtl.hide();
                    });
                    popupCtl.contentDiv.classList.add(popupCtl.CLASS + '-has-btn');
                    // En OL2 los featureInfo en versión "baraja de cartas" salen sin tamaño.
                    // Para evitar esto, la clase tc-ctl-finfo tiene ancho y alto establecidos.
                    // Pero eso hace que en el popup salgan barras de scroll, porque contentDiv se crea demasiado pequeño.
                    // Rehacemos el tamaño de tc-ctl-finfo para eliminarlas.
                    const finfo = popupCtl.contentDiv.querySelector('.tc-ctl-finfo');
                    if (finfo) {
                        finfo.width = 'auto';
                        finfo.height = 'auto';
                    }
                }

                var options = self.parent.options;
                if (TC.Util.isEmptyObject(options) && self.parent.layer &&
                    self.parent.layer.options && self.parent.layer.options.styles) {

                    switch (self.parent.CLASSNAME) {
                        case "TC.feature.Point":
                            options = self.parent.layer.options.styles.point;

                            // 11/03/2019 Al crear las features del API desde las features nativas, 
                            // se valida si la feature tiene icono para definir si es punto o marcador
                            // el problema viene cuando la feature no tiene estilo propio sino que lo obtiene de la capa,
                            // en esos casos se define como punto lo que es un marcador y cuando llegamos aquí no se accede a las
                            // opciones de marcador sino de punto.
                            if (!options || TC.Util.isEmptyObject(options)) {
                                options = self.parent.layer.options.styles.marker;
                            }
                            break;
                        case "TC.feature.Marker":
                            options = self.parent.layer.options.styles.marker;
                            break;
                        case "TC.feature.Circle":
                            options = self.parent.layer.options.styles.circle;
                            break;
                        case "TC.feature.MultiPolygon":
                        case "TC.feature.Polygon":
                            options = self.parent.layer.options.styles.polygon;
                            break;
                        case "TC.feature.MultiPolyline":
                        case "TC.feature.Polyline":
                            options = self.parent.layer.options.styles.line;
                            break;
                    }
                }

                // Calcular anchor
                var anchor;
                if (options.anchor) {
                    anchor = options.anchor;
                }
                else {
                    var style;
                    var f = feature._wrap.parent;
                    for (var i = 0; i < map.workLayers.length; i++) {
                        var layer = map.workLayers[i];
                        if (!layer.isRaster()) {
                            if ($.inArray(f, layer.features) >= 0) {
                                style = layer.wrap.styleFunction(feature);
                                break;
                            }
                        }
                    }
                    if ($.isArray(style)) {
                        const image = style[0].getImage();
                        anchor = !image || image instanceof ol.style.Icon ? [0.5, 0] : [0.5, 0.5];
                    }
                }
                const offset = [0, 0];
                if (anchor) {
                    if (options.height) {
                        offset[1] = -options.height * anchor[1];
                    }
                    else {
                        var fStyle = getFeatureStyle.call(feature, true);
                        if (fStyle) {
                            const image = fStyle.getImage();
                            if (image instanceof ol.style.Icon) {
                                offset[1] = image.getImageSize()[1] * -image.getScale();
                            }
                        }
                    }
                }

                popupCtl.wrap.setDragged(false);
                popupCtl.wrap.popup.setOffset(offset);
                popupCtl.wrap.popup.setPosition(self._innerCentroid);
                popupCtl.popupDiv.classList.add(TC.Consts.classes.VISIBLE);
            }
            else {
                map.wrap.hidePopup(popupCtl);
            }
        }
    };

    TC.wrap.Feature.prototype.isNative = function (feature) {
        return feature instanceof ol.Feature;
    };

    TC.wrap.Feature.prototype.getPath = function () {
        var result = [];
        var self = this;
        if (self.feature && self.feature._folders) {
            result = self.feature._folders;
        }
        return result;
    };

    TC.wrap.Feature.prototype.getBounds = function () {
        var result = null;
        var self = this;
        if (self.feature) {
            result = self.feature.getGeometry().getExtent();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getTemplate = function () {
        var result = null;
        var self = this;
        var style = self.feature.getStyle();
        if (typeof style === 'function') {
            style = style.call(self.feature);
        }
        if ($.isArray(style)) {
            for (var i = 0; i < style.length; i++) {
                if (style[i]._balloon) {
                    var s = style[i]._balloon.getText();
                    if (s) {
                        style = style[i]._balloon;
                        break;
                    }
                }
            }
        }
        if (style && !$.isArray(style) && style.getText) {
            result = style.getText();
        }
        return result;
    };

    TC.wrap.Feature.prototype.getData = function () {
        var self = this;
        var result = self.feature.getProperties();
        // En caso de clusters
        if ($.isArray(result.features)) {
            if (result.features.length === 1) {
                result = result.features[0].getProperties();
            }
            else {
                result = result.features.length + ' elementos';
            }
        }
        var geometryName = self.feature.getGeometryName();
        if (result[geometryName]) {
            delete result[geometryName];
        }
        return result;
    };

    TC.wrap.Feature.prototype.setData = function (data) {
        this.feature.setProperties(data);
    };

    TC.wrap.Feature.prototype.clearData = function () {
        const feature = this.feature;
        const geometryName = feature.getGeometryName();
        feature.getKeys().forEach(function (key) {
            if (key !== geometryName) {
                feature.unset(key);
            }
        });
    };

    TC.wrap.control.Draw.prototype.mouseMoveHandler = function (evt) {
        const self = this;
        if (self.sketch) {
            self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());
        }
    };

    TC.wrap.control.Draw.prototype.mouseOverHandler = function (evt) {
        const self = this;
        if (self.sketch && self.hoverCoordinate) {
            self.pushCoordinate(self.hoverCoordinate);
            self.hoverCoordinate = null;
        }
    };

    TC.wrap.control.Draw.prototype.clickHandler = function (evt) {
        const self = this;
        if (self.parent.map.view === TC.Consts.view.PRINTING) {
            return;
        }
        if (self._mdPx) { // No operamos si el clic es consecuencia es en realidad un drag
            const dx = self._mdPx[0] - evt.clientX;
            const dy = self._mdPx[1] - evt.clientY;
            if (dx * dx + dy * dy > self.interaction.squaredClickTolerance_) {
                return;
            }
        }
        if (self.sketch) {
            var coords = self.sketch.getGeometry().getCoordinates();
            self.parent.trigger(TC.Consts.event.POINT, {
                point: coords[coords.length - 1]
            });
        }
    };

    TC.wrap.control.Draw.prototype.mousedownHandler = function (evt) {
        const self = this;
        self._mdPx = [evt.clientX, evt.clientY];
    };

    TC.wrap.control.Draw.prototype.getMeasureData = function () {
        var self = this;

        var formatLength = function (line, data) {
            line = new ol.geom.LineString(TC.Util.reproject(line.getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs));
            data.length = line.getLength();
        };

        var formatArea = function (polygon, data) {
            polygon = new ol.geom.Polygon([TC.Util.reproject(polygon.getLinearRing(0).getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs)]);
            data.area = polygon.getArea();
            var ring = polygon.getLinearRing(0);
            data.perimeter = ol.geom.flat.length.linearRing(ring.flatCoordinates, 0, ring.flatCoordinates.length, ring.stride);
        };

        var result = {
            units: ol.proj.Units.METERS
        };
        if (this.sketch) {
            var geom = (this.sketch.getGeometry());
            if (geom instanceof ol.geom.Polygon) {
                formatArea(geom, result);
            }
            else if (geom instanceof ol.geom.LineString) {
                formatLength(geom, result);
            }
        }

        return result;
    };

    // Función para reproyectar el dibujo actual
    const drawProjectionChangeHandler = function (ctl, e) {
        if (ctl.sketch) {
            const oldProj = e.oldValue.getProjection();
            const newProj = e.target.get(e.key).getProjection();
            if (oldProj.getCode() !== newProj.getCode()) {
                const geom = ctl.sketch.getGeometry();
                geom.transform(oldProj, newProj);
                ctl.interaction.sketchPoint_.getGeometry().transform(oldProj, newProj);
                const flatCoordinates = [];
                var sketchCoords;
                if (ctl.interaction.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
                    sketchCoords = ctl.interaction.sketchCoords_[0];
                }
                else {
                    sketchCoords = ctl.interaction.sketchCoords_;
                }
                ol.geom.flat.deflate.coordinates(flatCoordinates, 0, sketchCoords, geom.stride);
                const transformFn = ol.proj.getTransform(oldProj, newProj);
                transformFn(flatCoordinates, flatCoordinates, geom.stride);
                sketchCoords = ol.geom.flat.inflate.coordinates(flatCoordinates, 0, flatCoordinates.length, geom.stride);
                if (ctl.interaction.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
                    ctl.interaction.sketchCoords_ = [sketchCoords];
                }
                else {
                    ctl.interaction.sketchCoords_ = sketchCoords;
                }
            }
        }
    };

    TC.wrap.control.Draw.prototype.activate = function (mode) {
        var self = this;

        var type;
        switch (mode) {
            case TC.Consts.geom.POLYGON:
                type = ol.geom.GeometryType.POLYGON;
                break;
            case TC.Consts.geom.POINT:
                type = ol.geom.GeometryType.POINT;
                break;
            default:
                type = ol.geom.GeometryType.LINE_STRING;
                break;
        }
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (layer) {
                    layer.wrap.getLayer().then(function (olLayer) {

                        if (!self.viewport) self.viewport = olMap.getViewport();

                        if (self.interaction) {
                            olMap.removeInteraction(self.interaction);
                            if (self._mousedownHandler) {
                                self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                                self._mousedownHandler = null;
                            }
                            if (self._clickHandler) {
                                self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                                self._clickHandler = null;
                            }
                            if (self._mouseMoveHandler && self._mouseOverHandler) {
                                self.viewport.removeEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.removeEventListener(MOUSEOVER, self._mouseOverHandler);
                            }
                        }

                        if (self.snapInteraction) {
                            olMap.removeInteraction(self.snapInteraction);
                        }

                        if (mode) {
                            self._mousedownHandler = $.proxy(self.mousedownHandler, self);
                            self._clickHandler = $.proxy(self.clickHandler, self);
                            self.viewport.addEventListener('mousedown', self._mousedownHandler);
                            self.viewport.addEventListener(TC.Consts.event.CLICK, self._clickHandler);
                            if (self.parent.measure) {
                                self._mouseMoveHandler = self.mouseMoveHandler.bind(self);
                                self._mouseOverHandler = self.mouseOverHandler.bind(self);
                                self.viewport.addEventListener(MOUSEMOVE, self._mouseMoveHandler);
                                self.viewport.addEventListener(MOUSEOVER, self._mouseOverHandler);
                            }

                            var drawOptions = {
                                type: type,
                                snapTolerance: 0,
                                condition: function () {
                                    if (ol.events.condition.shiftKeyOnly(arguments[0])) {
                                        hole = olMap.forEachFeatureAtPixel(olMap.getPixelFromCoordinate(arguments[0].coordinate), function (feature) {
                                            if (ol.geom.GeometryType.POLYGON == feature.getGeometry().getType() ||
                                                ol.geom.GeometryType.MULTI_POLYGON == feature.getGeometry().getType()) {
                                                return feature;
                                            }
                                            return null;
                                        },
                                            {
                                                hitTolerance: hitTolerance
                                            });
                                    }

                                    if (self.parent.map.view === TC.Consts.view.PRINTING) {
                                        return null;
                                    }

                                    return true;
                                }
                            };
                            if (olLayer) {
                                drawOptions.source = olLayer.getSource();
                            }
                            switch (mode) {
                                case TC.Consts.geom.RECTANGLE:
                                    drawOptions.style = createNativeStyle({
                                        styles: { line: self.parent.styles.line }
                                    });
                                    drawOptions.type = ol.geom.GeometryType.LINE_STRING;
                                    drawOptions.maxPoints = 2;
                                    drawOptions.geometryFunction = function (coordinates, geometry) {
                                        if (!geometry) {
                                            geometry = new ol.geom.Polygon(null);
                                        }
                                        var start = coordinates[0];
                                        var end = coordinates[1];
                                        geometry.setCoordinates([
                                            [start, [start[0], end[1]], end, [end[0], start[1]], start]
                                        ]);
                                        return geometry;
                                    };
                                    break;
                                case TC.Consts.geom.POLYGON:
                                    drawOptions.style = createNativeStyle({
                                        styles: { polygon: self.parent.styles.polygon }
                                    });
                                    break;
                                case TC.Consts.geom.POINT:
                                    drawOptions.style = createNativeStyle({
                                        styles: { point: self.parent.styles.point }
                                    });
                                    break;
                                default:
                                    drawOptions.style = createNativeStyle({
                                        styles: { line: self.parent.styles.line }
                                    });
                                    break;
                            }

                            self.interaction = new ol.interaction.Draw(drawOptions);

                            self.interaction.on(ol.interaction.DrawEventType.DRAWSTART, function (evt) {
                                self.sketch = evt.feature;
                                self.parent.trigger(TC.Consts.event.DRAWSTART);
                            }, this);

                            self.interaction.on(ol.interaction.DrawEventType.DRAWEND, function (evt) {
                                evt.feature.setStyle(evt.target.overlay_.getStyle().map(function (style) {
                                    return style.clone();
                                }));
                                if (self.parent.measure) {
                                    self.parent.trigger(TC.Consts.event.MEASURE, self.getMeasureData());
                                }
                                createFeatureFromNative(self.sketch).then(function (feat) {
                                    self.parent.trigger(TC.Consts.event.DRAWEND, { feature: feat });
                                    self.sketch = null;
                                });
                            }, this);

                            self._projectionChangeHandler = function (e) {
                                drawProjectionChangeHandler(self, e);
                            };
                            olMap.on('change:view', self._projectionChangeHandler);

                            olMap.addInteraction(self.interaction);

                            if (self.parent.snapping) {
                                var snapOptions = {};
                                if (olLayer) {
                                    snapOptions.source = olLayer.getSource();
                                }
                                else if (self.parent.snapping instanceof TC.Layer) {
                                    snapOptions.source = self.parent.snapping.wrap.layer.getSource();
                                }
                                self.snapInteraction = new ol.interaction.Snap(snapOptions);
                                olMap.addInteraction(self.snapInteraction);
                            }
                        }

                        self.redoStack = [];
                    });
                }
            });
        }
    };

    TC.wrap.control.Draw.prototype.deactivate = function () {
        var self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {
                const olMap = objects[0];
                const layer = objects[1];
                if (self.viewport) {
                    if (self._mousedownHandler) {
                        self.viewport.removeEventListener('mousedown', self._mousedownHandler);
                        self._mousedownHandler = null;
                    }
                    if (self._clickHandler) {
                        self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);
                        self._clickHandler = null;
                    }
                }
                if (layer && !self.parent.persistent) {
                    layer.clearFeatures();
                }
                if (self.interaction) {
                    olMap.removeInteraction(self.interaction);
                    self.interaction = null;
                }
                olMap.un('change:view', self._projectionChangeHandler);
            });
        }
    };

    //El valor devuelto es lo que va al stack de redo
    TC.wrap.control.Draw.prototype.popCoordinate = function () {
        var self = this;
        var result = null;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                }
                else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                if (coords.length > 1) {

                    var puntos;
                    if (geom instanceof ol.geom.Polygon)
                        puntos = self.interaction.sketchCoords_[0];
                    else if (geom instanceof ol.geom.LineString)
                        puntos = self.interaction.sketchCoords_;

                    /*
                    Al menos con linestring, no necesariamente hay que quitar el último
                    Porque OL mete en coordinates del sketchFeature_ tanto el último marcado como el que flota detrás del cursor
                    Para comprobar que realmente es ése, podemos contrastarlo con self.interaction.sketchPoint_.getGeometry().getCoordinates()
                    */
                    var flyingPointContained = false;
                    if (self.interaction.sketchPoint_) {
                        var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                        for (var i = 0; i < coords.length; i++) {
                            if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                                flyingPointContained = true;
                                break;
                            }
                        }
                    }

                    var index;
                    if (flyingPointContained) index = puntos.length - 2;
                    else index = puntos.length - 1;

                    result = puntos[index];
                    puntos.splice(index, 1);

                    if (geom instanceof ol.geom.Polygon) {
                        geom.setCoordinates([puntos]);
                        self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    }
                    else {
                        geom.setCoordinates(puntos);
                    }


                    feature.setGeometry(geom);
                }
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.pushCoordinate = function (coord) {
        var self = this;
        var result = false;
        if (self.interaction) {
            var feature = self.interaction.sketchFeature_;
            if (feature) {
                var coords;
                var geom = feature.getGeometry();

                if (geom instanceof ol.geom.Polygon) {
                    coords = geom.getCoordinates()[0];
                } else if (geom instanceof ol.geom.LineString) {
                    coords = geom.getCoordinates();
                }
                var fullCoords = coords;
                //coords.push(coord);

                var puntos;
                if (geom instanceof ol.geom.Polygon) {
                    puntos = self.interaction.sketchCoords_[0];
                    //self.interaction.sketchCoords_[0].push(coord);
                    //geom.setCoordinates([fullCoords], ol.geom.GeometryLayout.XY);
                } else if (geom instanceof ol.geom.LineString) {

                    puntos = self.interaction.sketchCoords_;
                }

                //Si hay punto volador, hay que meter la coordenada justo antes
                var flyingPointContained = false;
                if (self.interaction.sketchPoint_) {
                    var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();
                    for (var i = 0; i < coords.length; i++) {
                        if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {
                            flyingPointContained = true;
                            break;
                        }
                    }
                }


                if (flyingPointContained) index = puntos.length - 1;
                else index = puntos.length;
                puntos.splice(index, 0, coord);

                if (geom instanceof ol.geom.LineString)
                    geom.setCoordinates(puntos, ol.geom.GeometryLayout.XY);
                else {
                    geom.setCoordinates([puntos], ol.geom.GeometryLayout.XY);
                    self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);
                    //feature.setGeometry(geom);
                }


                result = true;
            }
        }
        return result;
    };

    TC.wrap.control.Draw.prototype.undo = function () {
        var self = this;
        var result = false;

        var coord = self.popCoordinate();
        if (coord) {
            self.redoStack.push(coord);
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.redo = function () {
        var self = this;
        var result = false;

        if (self.redoStack.length > 0) {
            self.pushCoordinate(self.redoStack.pop());
            result = true;
        }

        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());

        return result;
    };

    TC.wrap.control.Draw.prototype.end = function () {
        var self = this;
        if (self.interaction && self.interaction.sketchFeature_)
            self.interaction.finishDrawing();
    };

    TC.wrap.control.Draw.prototype.setStyle = function (style) {
        const self = this;
        if (self.interaction) {
            self.interaction.overlay_.setStyle(createNativeStyle({
                styles: style
            }));
        }
    };

    TC.wrap.control.CacheBuilder.prototype.getRequestSchemas = function (options) {
        var self = this;
        var extent = options.extent;
        var layers = options.layers;
        var result = new Array(layers.length);
        for (var i = 0, len = result.length; i < len; i++) {
            var layer = layers[i];
            var schema = {
                layerId: layer.id
            };
            var olSource = layer.wrap.layer.getSource();
            if (olSource.getUrls) {
                schema.url = olSource.getUrls()[0];
            }
            if (olSource.getTileGrid) {
                var tileGrid = olSource.getTileGrid();
                var resolutions = tileGrid.getResolutions();
                var matrixIds = tileGrid.getMatrixIds();
                var node = layer.getLayerNodeByName(layer.layerNames);
                var tmsLimits = null;
                for (var j = 0, llen = node.TileMatrixSetLink.length; j < llen; j++) {
                    var tmsl = node.TileMatrixSetLink[j];
                    if (tmsl.TileMatrixSet === layer.matrixSet) {
                        tmsLimits = tmsl.TileMatrixSetLimits;
                        break;
                    }
                }
                schema.tileMatrixLimits = [];
                for (var j = 0, rlen = resolutions.length; j < rlen; j++) {
                    var origin = tileGrid.getOrigin(j);
                    var tileSize = tileGrid.getTileSize(j);
                    var resolution = resolutions[j];
                    var unitsPerTile = tileSize * resolution;
                    var tml = {
                        mId: matrixIds[j],
                        res: resolution,
                        origin: origin,
                        tSize: tileSize,
                        cl: Math.floor((extent[0] - origin[0]) / unitsPerTile),
                        cr: Math.floor((extent[2] - origin[0]) / unitsPerTile),
                        rt: Math.floor((origin[1] - extent[3]) / unitsPerTile),
                        rb: Math.floor((origin[1] - extent[1]) / unitsPerTile)
                    }
                    if (tmsLimits) {
                        var tmsLimit = tmsLimits[j];
                        if (tmsLimit) {
                            tml.cl = Math.max(tml.cl, tmsLimit.MinTileCol);
                            tml.cr = Math.min(tml.cr, tmsLimit.MaxTileCol);
                            tml.rt = Math.max(tml.rt, tmsLimit.MinTileRow);
                            tml.rb = Math.min(tml.rb, tmsLimit.MaxTileRow);
                        }
                    }
                    if (tml.cl <= tml.cr && tml.rt <= tml.rb) {
                        schema.tileMatrixLimits.push(tml);
                    }
                }
            }
            result[i] = schema;
        }
        return result;
    };

    TC.wrap.control.CacheBuilder.prototype.getGetTilePattern = function (layer) {
        var result = "";
        var olSource = layer.wrap.layer.getSource();
        if (olSource.getUrls) {
            result = olSource.getUrls()[0];
        }
        if (layer.options.encoding !== TC.Consts.WMTSEncoding.RESTFUL) {
            if (result.indexOf('?') < 0) {
                result = result + '?';
            }
            if (result.indexOf('?') === result.length - 1) {
                result = result + 'layer=' + layer.layerNames + '&style=default&tilematrixset=' + encodeURIComponent(layer.matrixSet) +
                    '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + encodeURIComponent(layer.format) +
                    '&TileMatrix={TileMatrix}&TileCol={TileCol}&TileRow={TileRow}';
            }
        }
        return result;
    };

    const createHaloStroke1 = function (width) {
        return new ol.style.Stroke({
            color: '#ffffff',
            width: width + 4,
        });
    };

    const createHaloStroke2 = function (width) {
        return new ol.style.Stroke({
            color: '#000000',
            width: width + 6,
        });
    };

    const addHaloToStyle = function (style) {
        if (style === undefined) {
            style = [];
        }
        if (style instanceof ol.style.Style) {
            style = [style];
        }
        style = style.slice();
        const mainStyle = style[0];
        if (mainStyle) {
            const image = mainStyle.getImage();
            var strokeWidth;
            if (image instanceof ol.style.RegularShape) {
                strokeWidth = image.getStroke().getWidth();
                const radius = image.getRadius();
                const haloPart1 = mainStyle.clone();
                haloPart1.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(haloPart1);
                const haloPart2 = mainStyle.clone();
                haloPart2.setImage(new ol.style.Circle({
                    radius: radius,
                    stroke: createHaloStroke2(strokeWidth)
                }));
                style.unshift(haloPart2);
            }
            else {
                strokeWidth = mainStyle.getStroke().getWidth();
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke1(strokeWidth)
                }));
                style.unshift(new ol.style.Style({
                    stroke: createHaloStroke2(strokeWidth)
                }));
            }
            return style;
        }
        return null;
    };

    const createSelectedStyle = function (feat) {
        feat._originalStyle = feat._originalStyle || feat.getStyle();
        if ($.isFunction(feat._originalStyle)) {
            return function (f, r) {
                return addHaloToStyle(feat._originalStyle(f, r));
            };
        }
        return addHaloToStyle(feat._originalStyle);
    };

    const setSelectedStyle = function (feat) {
        updateSelectedStyle.call(feat);
        feat.changed();
        ol.events.listen(feat, ol.events.EventType.CHANGE, updateSelectedStyle, feat);
    };

    const removeSelectedStyle = function (feat) {
        ol.events.unlisten(feat, ol.events.EventType.CHANGE, updateSelectedStyle, feat);
        if (feat._originalStyle) {
            feat.setStyle(null);
            feat.setStyle(feat._originalStyle);
        }
        feat._originalStyle = null;
    };

    const updateSelectedStyle = function () {
        this.style_ = createSelectedStyle(this);
        this.styleFunction_ = !this.style_ ? undefined : ol.Feature.createStyleFunction(this.style_);
    };

    TC.wrap.control.Modify.prototype.activate = function () {
        const self = this;
        if (self.parent.map) {
            Promise.all([self.parent.map.wrap.getMap(), self.parent.layer.wrap.getLayer()]).then(function (olObjects) {
                const olMap = olObjects[0];
                const olLayer = olObjects[1];
                if (self.selectInteraction) {
                    olMap.removeInteraction(self.selectInteraction);
                }
                var select = new ol.interaction.Select({
                    layers: [olLayer],
                    hitTolerance: hitTolerance
                });
                self.selectInteraction = select;
                olMap.addInteraction(select);
                var getWrapperFeature = function (elm) {
                    return elm._wrap.parent;
                };
                select.on('select', function (event) {
                    if (event.selected.length > 0) {
                        self.parent.trigger(TC.Consts.event.FEATURESSELECT, { ctrl: self, features: event.selected.map(getWrapperFeature) });
                    }
                    if (event.deselected.length > 0) {
                        if (event.selected.length == 0) {
                            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, features: event.deselected.map(getWrapperFeature) });
                        }
                    }
                });
                if (self.modifyInteraction) {
                    olMap.removeInteraction(self.modifyInteraction);
                }
                var modify = new ol.interaction.Modify({
                    features: select.getFeatures()
                });
                modify.on(ol.interaction.ModifyEventType.MODIFYEND, function (e) {
                    e.features.forEach(function (feature) {
                        feature._wrap.parent.geometry = feature._wrap.getGeometry();
                        self.parent.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature._wrap.parent, layer: self.parent.layer });
                    });
                });
                self.modifyInteraction = modify;
                olMap.addInteraction(modify);

                if (self.snapInteraction) {
                    olMap.removeInteraction(self.snapInteraction);
                }
                if (self.parent.snapping) {
                    self.snapInteraction = new ol.interaction.Snap({
                        source: olLayer.getSource()
                    });
                    olMap.addInteraction(self.snapInteraction);
                }

                if (!self._onMouseMove) {
                    self._onMouseMove = function (e) {
                        const mapTarget = olMap.getTarget();
                        var hit = false;
                        var feature;

                        var pixel = olMap.getEventPixel(e);
                        hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {
                            if (layer === self.parent.layer.wrap.layer) {
                                return true;
                            }
                            return false;
                        },
                            {
                                hitTolerance: hitTolerance
                            });

                        if (hit) {
                            mapTarget.style.cursor = 'pointer';
                        } else {
                            mapTarget.style.cursor = '';
                            //self.parent.trigger(TC.Consts.event.FEATUREOUT);
                        }
                    };
                }

                olMap.getViewport().addEventListener(MOUSEMOVE, self._onMouseMove);
            });
        }
    };

    TC.wrap.control.Modify.prototype.deactivate = function () {
        const self = this;
        if (self.modifyInteraction) {
            self.modifyInteraction.setActive(false);
            self.selectInteraction.setActive(false);
            self.parent.map.wrap.getMap().then(function (olMap) {
                olMap.getViewport().removeEventListener(MOUSEMOVE, self._onMouseMove);
                olMap.removeInteraction(self.modifyInteraction);
                olMap.removeInteraction(self.selectInteraction);
                self.modifyInteraction = null;
                self.selectInteraction = null;
            });
        }
    };

    TC.wrap.control.Modify.prototype.getSelectedFeatures = function () {
        var self = this;
        var result = [];
        if (self.selectInteraction) {
            self.selectInteraction.getFeatures().forEach(function (elm) {
                result[result.length] = elm._wrap.parent;
            });
        }
        return result;
    };

    TC.wrap.control.Modify.prototype.setSelectedFeatures = function (features) {
        var self = this;
        if (self.selectInteraction) {
            var source = self.selectInteraction.featureOverlay_.getSource();
            source.clear();
            source.addFeatures(features.map(function (elm) {
                return elm.wrap.feature;
            }));
        }
    };

    TC.wrap.control.Modify.prototype.unselectFeatures = function (features) {
        features = features || [];
        const self = this;
        const selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
        if (selectedFeatures) {
            const unselectedFeatures = [];
            selectedFeatures.getArray().slice().forEach(function (olFeature) {
                if (!features.length || features.indexOf(olFeature) >= 0) {
                    selectedFeatures.remove(olFeature);
                    unselectedFeatures[unselectedFeatures.length] = olFeature._wrap.parent;
                }
            });
            if (unselectedFeatures.length) {
                self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { features: unselectedFeatures });
            }
        }
    };

    TC.wrap.control.Edit.prototype.activate = function (mode) {
        var self = this;
        self.cancel(true);
        //if (!self.session) {
        //    self.session = {
        //        features: []
        //        , featuresAdded: []
        //        , featuresRemoved: []
        //        , featuresModified: []
        //    };
        //}
        if (mode === TC.Consts.editMode.SELECT) {
            TC.wrap.control.Modify.prototype.activate.call(self);
        }
    };

    TC.wrap.control.Edit.prototype.deactivate = function () {
        var self = this;
        TC.wrap.control.Modify.prototype.deactivate.call(self);

        if (self.drawInteraction) {
            self.drawInteraction.abortDrawing_();
            self.drawInteraction.setActive(false);
            //self.drawInteraction.destroy();
            self.parent.map.wrap.getMap().then(function (olMap) {
                olMap.removeInteraction(self.drawInteraction);
                self.drawInteraction = null;
            });
            //    self.control.layer.events.un("sketchcomplete");
            //    self.control.deactivate();
            //    self.control.destroy();
            //    self.control = null;
        }
        self.parent.trigger(TC.Consts.event.CONTROLDEACTIVATE, { ctrl: self });
        //self.session = null;        
    };

    TC.wrap.control.Edit.prototype.cancel = function (deactivate, cancelTxt) {
        var self = this;
        self.points = [];
        self.histPoints = [];
        var layer = (self.control && self.control.layer) || (self.modifyInteraction && self.modifyInteraction.layer);
        //if (!self.session || ((self.modifyInteraction && self.modifyInteraction.modified) || (self.session.featuresAdded && self.session.featuresAdded.length)) && cancelTxt && !confirm(cancelTxt))
        //    return;
        if (self.selectInteraction) {
            var features = self.selectInteraction.getFeatures();
            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, feature: features.get(0) });
            features.clear();
            self.selectInteraction.setActive(false);
        }
        //if (self.drawInteraction) {
        //    self.drawInteraction.abortDrawing_();
        //    if (deactivate) {
        //        self.drawInteraction.setActive(false);
        //    }
        //}
        //if(self.modifyInteraction)
        //{
        //    if (self.modifyInteraction.feature)
        //        self.modifyInteraction.unselectFeature(self.modifyInteraction.feature);
        //    if (deactivate)
        //    {
        //        self.modifyInteraction.deactivate();
        //    }   
        //}
        ////if (self.session.featuresAdded && self.session.featuresAdded.length > 0) {
        ////    layer.removeFeatures(self.session.featuresAdded);
        ////    self.session.featuresAdded = [];
        ////}
        //self.parent.trigger(TC.Consts.event.EDITIONCANCEL, { ctrl: self });
        ////no se por que hostias se cambia el renderIntent a las features
        //$.each(layer.features, function (i, feat) {
        //    feat.renderIntent = "";
        //});    
        //layer.removeAllFeatures();
        //layer.addFeatures(self.session.features);        
        //self.clearSession();
    };

    TC.wrap.control.Edit.prototype.getSelectedFeatures = function () {
        return TC.wrap.control.Modify.prototype.getSelectedFeatures.call(this);
    };

    TC.wrap.control.Edit.prototype.setSelectedFeatures = function (features) {
        TC.wrap.control.Modify.prototype.setSelectedFeatures.call(this, features);
    };

    TC.wrap.control.Edit.prototype.deleteFeatures = function (features) {
        var self = this;
        if ($.isArray(features)) {
            var olFeatures = features.map(function (elm) {
                return elm.wrap.feature;
            });
            self.parent.layer.wrap.getLayer().then(function (olLayer) {
                var selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;
                for (var i = 0, len = olFeatures.length; i < len; i++) {
                    var olFeature = olFeatures[i];
                    if (selectedFeatures) {
                        selectedFeatures.remove(olFeature);
                        self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { feature: olFeature._wrap.parent });
                    }
                    olLayer.getSource().removeFeature(olFeature);
                    self.parent.trigger(TC.Consts.event.FEATUREREMOVE, { feature: olFeature._wrap.parent });
                }
            });
        }
    };

    //TC.wrap.control.Edit.prototype.clearSession = function () {
    //    var self = this;
    //    delete self.session;
    //};

    TC.wrap.Feature.prototype.toGML = function (version, srsName) {
        var parser = new ol.format.GML();
        var xml = parser.writeGeometryNode(this.feature.getGeometry(), {
            dataProjection: srsName
        });
        //reemplazo todos los <loquesea por <gml:loquesea y </loquesea por </gml:loquesea
        return new XMLSerializer().serializeToString(xml.firstChild).replace(/\<\/?\w/gm, function (str) { var pos = str.indexOf("/") > 0 ? str.indexOf("/") + 1 : 1; return str.substring(0, pos) + "gml:" + str.substring(pos) })
        //return new XMLSerializer().serializeToString(xml.firstChild).replace(/\</gm, "<gml:");
    };


    TC.wrap.Feature.prototype.toGeoJSON = function () {
        var parser = new ol.format.GeoJSON();
        return parser.writeGeometry(this.feature.getGeometry());
    };

    TC.wrap.Geometry.write = function (options) {
        options = options || {};
        var geometry;
        switch (options.format) {
            default:
                options.parser = new ol.format.GeoJSON();
        };
        switch (options.type) {
            case TC.Consts.geom.POLYLINE:
                geometry = new ol.geom.LineString(options.coordinates);
                break;
            case TC.Consts.geom.POLYGON:
                geometry = new ol.geom.Polygon(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOINT:
                geometry = new ol.geom.MultiPoint(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYLINE:
                geometry = new ol.geom.MultiLineString(options.coordinates);
                break;
            case TC.Consts.geom.MULTIPOLYGON:
                geometry = new ol.geom.MultiPolygon(options.coordinates);
                break;
            case TC.Consts.geom.POINT:
            default:
                geometry = new ol.geom.Point(options.coordinates);
                break;
        };
        return options.parser.writeGeometry(geometry);
    };

    TC.wrap.Geometry.toGeoJSON = function (options) {
        return TC.wrap.Geometry.write(options);
    };

    return ol;
});

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Attribution = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self.apiAttribution = '';
    self.mainDataAttribution = null;
    self.dataAttributions = [];
    if (self.options.dataAttributions) {
        self.dataAttributions = self.options.dataAttributions instanceof Array ? self.options.dataAttributions : [self.options.dataAttributions];
    }
};

TC.inherit(TC.control.Attribution, TC.Control);

(function () {
    var ctlProto = TC.control.Attribution.prototype;

    ctlProto.CLASS = 'tc-ctl-attrib';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Attribution.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div><span>&copy; ").f(ctx.get(["api"], false), ctx, "h", ["s"]).w("</span>").x(ctx.get(["mainData"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["otherData"], false), ctx, { "block": body_5 }, {}).w("<div class=\"tc-ctl-attrib-other ").x(ctx.get(["isCollapsed"], false), ctx, { "block": body_6 }, {}).w("\">").s(ctx.get(["otherData"], false), ctx, { "block": body_7 }, {}).w("</div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" - ").h("i18n", ctx, {}, { "$key": "data" }).w(":").x(ctx.getPath(false, ["mainData", "site"]), ctx, { "else": body_2, "block": body_4 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.x(ctx.getPath(false, ["mainData", "name"]), ctx, { "block": body_3 }, {}); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<span> &copy; ").f(ctx.getPath(false, ["mainData", "name"]), ctx, "h").w("</span>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<span> &copy; <a href=\"").f(ctx.getPath(false, ["mainData", "site"]), ctx, "h").w("\" target=\"_blank\">").f(ctx.getPath(false, ["mainData", "name"]), ctx, "h").w("</a></span>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w(" - <span class=\"tc-ctl-attrib-cmd\">").h("i18n", ctx, {}, { "$key": "others" }).w("...</span>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w(" tc-collapsed "); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.x(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "site"]), ctx, { "else": body_8, "block": body_9 }, {}).h("sep", ctx, { "block": body_10 }, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<span>&copy; ").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "name"]), ctx, "h").w("</span>"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("<span>&copy; <a href=\"").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "site"]), ctx, "h").w("\" target=\"_blank\">").f(ctx.getPath(false, ["otherData", ctx.get(["$idx"], false), "name"]), ctx, "h").w("</a></span>"); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.w(", "); } body_10.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.apiAttribution = self.map.options.attribution || self.apiAttribution;

        var addData = function (obj) {
            if (obj) {
                // TODO: sanitizer
                var attr = obj.getAttribution();
                if (attr) {
                    if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                        self.mainDataAttribution = {
                            name: 'IDENA',
                            site: 'http://idena.navarra.es/'
                        };
                    }
                    else {
                        var textExists = false;
                        for (var i = 0; i < self.dataAttributions.length; i++) {
                            if (attr.name === self.dataAttributions[i].name) {
                                textExists = true;
                                break;
                            }
                        }
                        if (!textExists) {
                            self.dataAttributions.push(attr);
                        }
                    }
                }
            }
        };

        var removeData = function (obj) {
            if (obj) {

                var checkRemoveData = function () {
                    if (obj.map.workLayers.length > 0) {
                        var _wl = obj.map.workLayers.slice().reverse();
                        for (var i = 0; i < _wl.length; i++) {
                            if (_wl[i].url == obj.url && _wl[i].getVisibility())
                                return false;
                        }

                        return true;
                    }

                    return true;
                };

                if (obj instanceof TC.Layer ? checkRemoveData() : true) {
                    // TODO: sanitizer
                    var attr = obj.getAttribution();

                    if (attr) {
                        var index = self.dataAttributions.reduce(function (prev, cur, idx) {
                            if (cur.name === attr.name) {
                                return idx;
                            }
                            return prev;
                        }, -1);

                        const checkIsSameAttribution = function (toCheckName) {
                            return (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) &&
                                (/IDENA/.test(toCheckName) || /Tracasa Instrumental/.test(toCheckName)) ||
                                    (attr.name === toCheckName);
                        };

                        // Validamos si las atribuciones a borrar son también del mapa base
                        if (self.map.baseLayer && self.map.baseLayer.wrap.getAttribution() && checkIsSameAttribution(self.map.baseLayer.wrap.getAttribution().name)) {
                            return;
                        } else {
                            // Validamos si las atribuciones a borrar son también de alguna de las capas raster cargadas
                            if (self.map.workLayers.filter(function (layer) {
                                return layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS;
                            }).some(function (layer) {
                                var workLayerAttribution = layer.wrap.getAttribution();
                                return workLayerAttribution && checkIsSameAttribution(workLayerAttribution.name);
                            })) {
                                return;
                            }
                        }

                        if (index > -1) {
                            self.dataAttributions.splice(index, 1);
                        } else if (/IDENA/.test(attr.name) || /Tracasa Instrumental/.test(attr.name)) {
                            self.mainDataAttribution = null;
                        }
                    }
                }
            }
        };

        self.render();

        map.loaded(function () {
            if (map.baseLayer.wrap.getAttribution) {
                addData(map.baseLayer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (!layer.isBase && layer.wrap.getAttribution) {
                addData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.BEFOREBASELAYERCHANGE + " " + TC.Consts.event.OVERVIEWBASELAYERCHANGE, function (e) {
            const type = e.type;
            const newLayer = e.newLayer;
            const oldLayer = e.oldLayer;
            if (TC.Consts.event.OVERVIEWBASELAYERCHANGE.indexOf(type) > -1) {
                self.ignoreLayer = newLayer;
            }

            if (oldLayer && oldLayer.wrap.getAttribution) {
                removeData(oldLayer.wrap);
            }

            if (newLayer && newLayer.wrap.getAttribution) {
                addData(newLayer.wrap);
            }

            self.render();
        });

        map.on(TC.Consts.event.LAYERREMOVE, function (e) {
            const layer = e.layer;
            if (layer.wrap.getAttribution) {
                removeData(layer.wrap);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERADD, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                addData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.TERRAINPROVIDERREMOVE, function (e) {
            const terrainProvider = e.terrainProvider;
            if (terrainProvider.getAttribution) {
                removeData(terrainProvider);
                self.render();
            }
        });

        map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
            const layer = e.layer;
            if (self.ignoreLayer === layer) {
                return;
            }

            if (layer.wrap.getAttribution) {
                if (layer.getVisibility()) {
                    addData(layer.wrap);
                } else {
                    removeData(layer.wrap);
                }
                self.render();
            }
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(self.renderData({
            api: self.apiAttribution,
            mainData: self.mainDataAttribution,
            otherData: self.dataAttributions,
            isCollapsed: self.div.querySelector('.' + self.CLASS + '-other') ? self.div.querySelector('.' + self.CLASS + '-other').classList.contains(TC.Consts.classes.COLLAPSED) : true
        }, function () {
            const cmd = self.div.querySelector('.' + self.CLASS + '-cmd');
            cmd && cmd.addEventListener(TC.Consts.event.CLICK, function () {
                self.toggleOtherAttributions();
            });

            if (typeof callback === 'function') {
                callback();
            }
        }));
    };

    ctlProto.toggleOtherAttributions = function () {
        const self = this;
        const other = self.div.querySelector('.' + self.CLASS + '-other');
        if (other.classList.contains(TC.Consts.classes.COLLAPSED)) {
            other.classList.remove(TC.Consts.classes.COLLAPSED);
        }
        else {
            other.classList.add(TC.Consts.classes.COLLAPSED);
        }
    };
})();

﻿TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

(function () {

    TC.control.BasemapSelector = function () {
        var self = this;
        //options = options || {};

        TC.control.MapContents.apply(self, arguments);

        self._cssClasses = {
            LOAD_CRS_BUTTON: self.CLASS + '-crs-btn-load',
            CRS_DIALOG: self.CLASS + '-crs-dialog',
            CRS_LIST: self.CLASS + '-crs-list',
            CURRENT_CRS_NAME: self.CLASS + '-cur-crs-name',
            CURRENT_CRS_CODE: self.CLASS + '-cur-crs-code'
        };

        self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
        self._$dialogDiv = $(self._dialogDiv);
        if (!self.options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button:not(.tc-modal-close)', function (e) {

            if (e.target.classList.contains(self._cssClasses.LOAD_CRS_BUTTON)) {
                self.loadFallbackProjections();
                return;
            }

            TC.Util.closeModal();
            const btn = e.target;
            const crs = btn.dataset.crsCode;

            // dependerá del que esté activo
            const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
            dialog.classList.add(TC.Consts.classes.HIDDEN);

            const layer = self.getLayer(dialog.dataset.layerId);
            if (layer) {
                if (crs) {
                    TC.loadProjDef({
                        crs: crs,
                        callback: function () {
                            self.map.setProjection({
                                crs: crs,
                                baseLayer: layer
                            });
                        }
                    });
                }
                else {
                    const fallbackLayer = $(btn).data(_dataKeys.FALLBACK_LAYER);
                    if (fallbackLayer) {
                        self.map.setBaseLayer(fallbackLayer);
                    }
                }
            }
        }));
    };

    TC.inherit(TC.control.BasemapSelector, TC.control.MapContents);

    var ctlProto = TC.control.BasemapSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-bms';

    var _dataKeys = {
        FALLBACK_LAYER: 'tcFallbackLayer'
    };

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/BasemapSelector.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/BasemapSelectorNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/BasemapSelectorDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "backgroundMaps" }).w("</h2><div class=\"tc-ctl-bms-tree\"><form><ul class=\"tc-ctl-bms-branch\">").s(ctx.get(["baseLayers"], false), ctx, { "block": body_1 }, {}).s(ctx.get(["dialogMore"], false), ctx, { "block": body_2 }, {}).w("</ul></form></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.p("tc-ctl-bms-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<li class=\"tc-ctl-bms-node\"><label class=\"tc-ctl-bms-more-node\" title=\"").h("i18n", ctx, {}, { "$key": "moreBackgroundMaps" }).w("\"><input type=\"radio\" name=\"bms\" value=\"moreLayers\"><span></span></label></li>"); } body_2.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-bms-node\" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\" ><label").x(ctx.get(["legend"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["thumbnail"], false), ctx, { "block": body_2 }, {}).w("><input type=\"radio\" name=\"bms\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["mustReproject"], false), ctx, { "block": body_3 }, {}).w("><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" style=\"background-image: url(").f(ctx.getPath(false, ["legend", "src"]), ctx, "h").w(")\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" style=\"background-image: url(").f(ctx.get(["thumbnail"], false), ctx, "h").w(")\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" class=\"tc-disabled\""); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-bms-more-dialog tc-modal tc-hidden\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "backgroundMaps" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div><div class=\"tc-ctl-bms-crs-dialog tc-modal tc-hidden\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "baseLayerNotCompatible" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "baseLayerNotCompatible.instructions|h" }).w("</p><ul class=\"tc-ctl-bms-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const getClosestParent = function (elm, selector) {
        while (elm && !elm.matches(selector)) {
            elm = elm.parentElement;
        }
        return elm;
    };

    const changeInputRadioBaseMap = function (e, callback) {
        const self = this;
        var flagToCallback = true;

        var radio = e.target;

        var layer = self.getLayer(getClosestParent(radio, 'li').dataset.layerId);

        if (self.options.dialogMore && getClosestParent(radio, '.' + self.CLASS + '-more-dialog')) {
            const radios = self.div.querySelectorAll('input[type=radio]');
            for (var i = 0, len = radios.length; i < len; i++) {
                const bmsLayer = self.getLayer(getClosestParent(radios[i], 'li').dataset.layerId);
                if (bmsLayer) {
                    switch (true) {
                        case bmsLayer.id === layer.id:
                            layer = bmsLayer;
                            break;
                    }
                }
            };
        }

        if (layer != self.map.getBaseLayer()) {
            if (layer.mustReproject) {

                if (self.map.on3DView) {
                    if (!layer.getFallbackLayer()) {
                        self._currentSelection.checked = true;
                        e.stopPropagation();
                        return;
                    } else if (layer.getFallbackLayer()) {
                        const fallbackLayer = layer.getFallbackLayer();
                        if (fallbackLayer) {
                            fallbackLayer._capabilitiesPromise.then(function () {
                                if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                    self.map.setBaseLayer(layer);
                                }
                            });
                        }

                        flagToCallback = true;
                    }
                } else {
                    // provisonal
                    if (self._currentSelection) {
                        self._currentSelection.checked = true;
                    }

                    // Buscamos alternativa
                    const dialogOptions = {
                        layer: layer
                    };
                    const fallbackLayer = layer.getFallbackLayer();
                    if (fallbackLayer) {
                        fallbackLayer._capabilitiesPromise.then(function () {
                            if (fallbackLayer.isCompatible(self.map.getCRS())) {
                                dialogOptions.fallbackLayer = fallbackLayer;
                            }
                            self.showProjectionChangeDialog(dialogOptions);
                        });
                    }
                    else {
                        self.showProjectionChangeDialog(dialogOptions);
                    }
                    //layer.getCompatibleCRS({ normalized: true });
                    flagToCallback = false;
                }

            }
            else {

                if (layer.type === TC.Consts.layerType.WMS || layer.type === TC.Consts.layerType.WMTS && layer.getProjection() !== self.map.crs) {
                    layer.setProjection({ crs: self.map.crs });
                }

                self.map.setBaseLayer(layer);
            }
        }

        if (this._currentSelection) {
            this._currentSelection.checked = true;
        }


        if (callback) {
            callback(flagToCallback);
        }
    };

    const moveElement = function (array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapContents.prototype.register.call(self, map);

        if (self.options.dialogMore) {
            map.on(TC.Consts.event.VIEWCHANGE, function () {
                self._getMoreBaseLayers();
            });
        }

        map.on(TC.Consts.event.BASELAYERCHANGE + ' ' + TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.VIEWCHANGE, function (e) {
            self.update(self.div, e.layer);
        });


        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {

            if (e.target.value === "moreLayers") {
                self.showMoreLayersDialog();
            } else {
                changeInputRadioBaseMap.call(self, e);
            }

            e.stopPropagation();
        }));

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.control.MapContents.prototype.render.call(self, callback, self.options);

        self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;

            if (self.options.dialogMore) {
                const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

                dialog.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio]', function (e) {
                    changeInputRadioBaseMap.call(self, e, function (close) {
                        if (close) {
                            TC.Util.closeModal();
                        }
                    });

                    e.stopPropagation();
                }));
            }
        });

        return result;
    };

    ctlProto.update = function (div, baseLayer) {
        const self = this;

        div = div || self.div;

        div.querySelector('ul.' + self.CLASS + '-branch').querySelectorAll('li').forEach(function (li) {
            const layer = self.getLayer(li.dataset.layerId);
            if (layer) {
                const curBaseLayer = baseLayer || self.map.baseLayer;
                const radio = li.querySelector('input[type=radio]');
                const checked = curBaseLayer && (curBaseLayer === layer || curBaseLayer.id === layer.id || (layer.getFallbackLayer && (curBaseLayer === layer.getFallbackLayer() || (layer.getFallbackLayer() && curBaseLayer.id === layer.getFallbackLayer().id))));

                if (self.map.on3DView && layer.mustReproject && layer.fallbackLayer && layer.getFallbackLayer) {
                    layer.getFallbackLayer().getCapabilitiesPromise().then(function () {
                        var mustReproject = !layer.getFallbackLayer().isCompatible(self.map.getCRS());

                        radio.checked = checked;
                        if (mustReproject) {
                            radio.classList.add(TC.Consts.classes.DISABLED);
                            li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                        }
                        else {
                            radio.classList.remove(TC.Consts.classes.DISABLED);
                            li.removeAttribute('title');
                        }
                    });
                } else {
                    radio.checked = checked;
                    if (layer.mustReproject) {
                        radio.classList.add(TC.Consts.classes.DISABLED);
                        li.setAttribute('title', self.map.on3DView ? self.getLocaleString('notAvailableTo3D') : self.getLocaleString('reprojectionNeeded'));
                    }
                    else {
                        radio.classList.remove(TC.Consts.classes.DISABLED);
                        li.removeAttribute('title');
                    }
                }

                if (checked) {
                    self._currentSelection = radio;
                }
            }
        });

        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        const self = this;        
        if (layer.isBase && !layer.options.stealth) {
            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            var template = self.CLASS + '-node';
            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(template, self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        var uid = newLi.dataset.tcLayerUid;
                        const ul = self.div.querySelector('.' + self.CLASS + '-branch');
                        const currentLi = ul.querySelector('li[data-tc-layer-uid="' + uid + '"]');
                        if (currentLi) {
                            currentLi.innerHTML = newLi.innerHTML;
                        }
                        else {
                            newLi.dataset.layerId = layer.id;

                            // Insertamos elemento en el lugar correcto, según indica la colección baseLayers
                            var idx = self.map.baseLayers.filter(function (baseLayer) {
                                // Buscamos capas que deban mostrarse o capas que están siendo fallbacks de capas que deben mostrarse
                                return !baseLayer.stealth;
                            }).map(function (baseLayer) {
                                return baseLayer.id;
                            }).indexOf(layer.id);

                            const lis = ul.querySelectorAll('li');
                            if (idx < 0 || idx >= lis.length) {
                                ul.appendChild(newLi);
                            }
                            else {
                                ul.insertBefore(newLi, lis[idx]);
                            }
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx) {
        // no hace nada
    };

    ctlProto.removeLayer = function (layer) {
        const self = this;
        if (layer.isBase) {
            const lis = self.div.querySelector('.' + self.CLASS + '-branch').querySelectorAll('li');
            for (var i = 0, len = lis.length; i < len; i++) {
                const li = lis[i];
                if (li.dataset.layerId === layer.id) {
                    li.parentElement.removeChild(li);
                    break;
                }
            }
        }
    };

    ctlProto.onErrorLayer = function (layer) {
        const self = this;

        if (layer.isBase && !layer.options.stealth) {
            self.map.toast(self.getLocaleString('baseLayerNotAvailable', { mapName: layer.title }), { type: TC.Consts.msgType.ERROR });
        }
    };

    ctlProto.loadFallbackProjections = function () {
        const self = this;
        const lis = self._dialogDiv
            .querySelector('.' + self._cssClasses.CRS_DIALOG)
            .querySelectorAll('ul.' + self._cssClasses.CRS_LIST + ' li');
        lis.forEach(function (li) {
            li.classList.remove(TC.Consts.classes.HIDDEN);
            if (li.querySelector('button.' + self._cssClasses.LOAD_CRS_BUTTON)) {
                li.classList.add(TC.Consts.classes.HIDDEN);
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        options = options || {};
        const layer = options.layer;
        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-crs-dialog');
        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.classList.add(TC.Consts.classes.LOADING);
        const blCRSList = layer.getCompatibleCRS();

        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        dialog.dataset.layerId = layer.id;
        const ul = dialog.querySelector('ul.' + self.CLASS + '-crs-list');
        ul.innerHTML = '';
        self.map.loadProjections({
            crsList: self.map.getCompatibleCRS({
                layers: self.map.workLayers.concat(layer),
                includeFallbacks: true
            }),
            orderBy: 'name'
        }).then(function (projList) {
            var hasFallbackCRS = false;
            const fragment = document.createDocumentFragment();
            projList
                .forEach(function (projObj) {
                    const li = document.createElement('li');
                    const button = document.createElement('button');

                    if (blCRSList.filter(function (crs) {
                        return TC.Util.CRSCodesEqual(crs, projObj.code)
                    }).length === 0) {
                        // Es un CRS del fallback
                        hasFallbackCRS = true;

                        button.innerHTML = projObj.name + ' (' + projObj.code + ')';
                        $(button)
                            .data(_dataKeys.FALLBACK_LAYER, options.layer.fallbackLayer);
                        button.dataset.crsCode = projObj.code;
                        button.classList.add(TC.Consts.classes.WARNING);
                        li.classList.add(TC.Consts.classes.HIDDEN);
                    } else {
                        button.innerHTML = self.getLocaleString('changeMapToCrs', { crs: projObj.name + ' (' + projObj.code + ')' });
                        button.dataset.crsCode = projObj.code;
                    }

                    li.appendChild(button);
                    fragment.appendChild(li);
                });

            if (options.fallbackLayer) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.innerHTML = self.getLocaleString('reprojectOnTheFly');
                $(button).data(_dataKeys.FALLBACK_LAYER, options.fallbackLayer);
                li.appendChild(button);
                fragment.appendChild(li);
            }

            if (hasFallbackCRS) {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.classList.add(self._cssClasses.LOAD_CRS_BUTTON);
                button.innerHTML = self.getLocaleString('showOnTheFlyProjections');
                li.appendChild(button);
                fragment.appendChild(li);
            }
            ul.appendChild(fragment);

            modalBody.classList.remove(TC.Consts.classes.LOADING);
        });
        dialog.querySelector('.' + self.CLASS + '-name').innerHTML = layer.title || layer.name;
        TC.Util.showModal(dialog);
    };

    ctlProto.showMoreLayersDialog = function () {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-more-dialog');

        if (self.map.on3DView) {
            dialog.classList.add(TC.Consts.classes.THREED);
        } else {
            dialog.classList.remove(TC.Consts.classes.THREED);
        }

        const modalBody = dialog.querySelector('.tc-modal-body');
        modalBody.innerHTML = '';
        modalBody.classList.add(TC.Consts.classes.LOADING);
        dialog.classList.remove(TC.Consts.classes.HIDDEN);

        TC.Util.showModal(dialog, {
            closeCallback: function () {
                // no hay selección, vuelvo a seleccionar el mapa de fondo actual del mapa.
                this._currentSelection.checked = true;
                this.update();
            }.bind(self)
        });

        dialog.querySelector('.tc-modal-window').classList.add(self.CLASS + '-more-dialog');

        self._getMoreBaseLayers().then(function () {

            self.getRenderedHtml(self.CLASS, { baseLayers: self._moreBaseLayers }, function (html) {
                modalBody.innerHTML = html;
                modalBody.classList.remove(TC.Consts.classes.LOADING);
                modalBody.querySelectorAll('li').forEach(function (li, idx) {
                    li.dataset.layerId = self._moreBaseLayers[idx].id;
                });

                self.update(modalBody);
            });
        });
    };

    ctlProto.getLayer = function (id) {
        const self = this;
        return self.map && (self.map.getLayer(id) || (self._moreBaseLayers && self._moreBaseLayers.filter(function (layer) {
            return layer.id === id;
        })[0]));
    };

    const getTo3DVIew = function (baseLayer) {
        const self = this;

        return new Promise(function (resolve, reject) {
            Promise.all([
                baseLayer.getCapabilitiesPromise(),
                baseLayer.getFallbackLayer() ? baseLayer.getFallbackLayer().getCapabilitiesPromise() : Promise.resolve()
            ]).then(function () {
                resolve();
            });
        });
    };

    ctlProto._getMoreBaseLayers = function () {
        const self = this;

        if (!self._moreBaseLayers && !self._moreBaseLayersPromise) {

            self._moreBaseLayersPromise = new Promise(function (resolve, reject) {

                // GLS: Carlos no quiere que se muestren los respectivos dinámicos así que los filtro.
                var noDyn = TC.Cfg.availableBaseLayers.filter(function (l) {
                    return TC.Cfg.availableBaseLayers.filter(function (l) {
                        return l.fallbackLayer
                    }).map(function (l) {
                        return l.fallbackLayer
                    }).indexOf(l.id) == -1
                }).map(function (baseLayer) {
                    if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                        return new TC.layer.Raster(baseLayer);
                    } else if (baseLayer.type == TC.Consts.layerType.VECTOR) {
                        return new TC.layer.Vector(baseLayer);
                    }
                });

                Promise.all(noDyn).then(function (baseLayers) {
                    self._moreBaseLayers = new Array(baseLayers.length);

                    var numToAdd = baseLayers.length;

                    const resolvePromise = function () {
                        self._moreBaseLayers = self._moreBaseLayers.filter(function (baseLayer) {
                            return baseLayer !== null;
                        });

                        resolve(self._moreBaseLayers);
                    };
                    const addLayer = function (i) {
                        const baseLayer = this;

                        baseLayer.map = self.map;
                        baseLayer.isBase = baseLayer.options.isBase = true;

                        if (baseLayer.type === TC.Consts.layerType.WMTS) {
                            var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                            baseLayer.mustReproject = !matrixSet;
                        } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                            baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                        }

                        if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                            baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());
                        }

                        self._moreBaseLayers.splice(i, 1, baseLayer);
                        numToAdd--;

                        if (numToAdd === 0) {
                            resolvePromise();
                        }
                    };

                    baseLayers.forEach(function (baseLayer, i) {
                        if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {
                            var promise = self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                            promise.then(
                                addLayer.bind(baseLayer, i),
                                function (fail) {
                                    self._moreBaseLayers.splice(i, 1, null);
                                    numToAdd--;

                                    if (numToAdd === 0) {
                                        resolvePromise();
                                    }
                                });
                        } else {
                            addLayer.call(baseLayer, i);
                        }
                    });
                });
            });

        } else if (self._moreBaseLayers) {

            return new Promise(function (resolve, reject) {
                Promise.all(self._moreBaseLayers.filter(function (baseLayer) {
                    return baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS;
                }).map(function (baseLayer) {
                    return self.map.on3DView ? getTo3DVIew(baseLayer) : baseLayer.getCapabilitiesPromise();
                })).then(function () {

                    self._moreBaseLayers = self._moreBaseLayers.map(function (baseLayer) {

                        if (baseLayer.type === TC.Consts.layerType.WMTS) {
                            var matrixSet = baseLayer.wrap.getCompatibleMatrixSets(self.map.getCRS())[0];
                            baseLayer.mustReproject = !matrixSet;
                        } else if (baseLayer.type === TC.Consts.layerType.WMS) {
                            baseLayer.mustReproject = !baseLayer.isCompatible(self.map.getCRS());
                        }
                        if (self.map.on3DView && baseLayer.mustReproject && baseLayer.getFallbackLayer && baseLayer.getFallbackLayer()) {
                            baseLayer.mustReproject = !baseLayer.getFallbackLayer().isCompatible(self.map.getCRS());

                            return baseLayer;
                        }

                        return baseLayer;
                    });

                    resolve(self._moreBaseLayers);
                });
            });
        }

        return self._moreBaseLayersPromise;
    };
})();

﻿TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

(function () {

    TC.Consts.classes.CONNECTION_OFFLINE = TC.Consts.classes.CONNECTION_OFFLINE || 'tc-conn-offline';
    TC.Consts.classes.CONNECTION_WIFI = TC.Consts.classes.CONNECTION_WIFI || 'tc-conn-wifi';
    TC.Consts.classes.CONNECTION_MOBILE = TC.Consts.classes.CONNECTION_MOBILE || 'tc-conn-mobile';
    TC.Consts.classes.OFFLINE = TC.Consts.classes.OFFLINE || 'tc-offline';

    var ALREADY_EXISTS = 'already_exists';

    var appCache = window.applicationCache;

    if (!TC._appCacheBuilders) {
        TC._appCacheBuilders = [];
    }

    if (!TC._appCacheUpdater) {
        TC._appCacheUpdater = function (e, url) {
            var params = TC.Util.getQueryStringParams(url);
            for (var i = 0, len = TC._appCacheBuilders.length; i < len; i++) {
                var ctl = TC._appCacheBuilders[i];
                switch (e.type) {
                    case 'cached':
                        // Nuevo mapa
                        ctl.trigger(TC.Consts.event.MAPCACHEDOWNLOAD, { url: url });
                        break;
                    case 'obsolete':
                        // Borrado de mapa
                        ctl.trigger(TC.Consts.event.MAPCACHEDELETE, { url: url });
                        break;
                    case 'checking':
                        break;
                    case 'progress':
                        ctl.trigger(TC.Consts.event.MAPCACHEPROGRESS, { url: url, loaded: e.loaded, total: e.total });
                        break;
                    case 'error':
                        ctl.trigger(TC.Consts.event.MAPCACHEERROR, { url: url, reason: e.reason, status: e.status });
                        break;
                    case 'noupdate':
                    case 'updateready':
                        // En este caso se está pidiendo un mapa que ya tenemos pedido de antes
                        ctl.trigger(TC.Consts.event.MAPCACHEERROR, { url: url, reason: ALREADY_EXISTS, status: e.status });
                        break;
                    default:
                        break;
                }
            }
        };
    }

    var manifestUrlList;
    var requestManifest = function () {
        return new Promise(function (resolve, reject) {
            if (manifestUrlList && manifestUrlList.length) {
                resolve(manifestUrlList);
            }
            else {
                var manifestFile = document.documentElement.getAttribute('manifest');
                if (manifestFile) {
                    TC.ajax({
                        url: manifestFile,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (data) {
                        TC.loadJS(
                            !window.hex_md5,
                            [TC.apiLocation + TC.Consts.url.HASH],
                            function () {
                                var hash = hex_md5(data);
                                var idxEnd = data.indexOf('NETWORK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('FALLBACK:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                idxEnd = data.indexOf('SETTINGS:');
                                if (idxEnd >= 0) {
                                    data = data.substr(0, idxEnd);
                                }
                                var lines = $.grep(data.split(/[\n\r]/), function (elm) {
                                    return elm.length > 0 && elm.indexOf('#') !== 0 && elm !== 'CACHE:';
                                });
                                // Eliminamos la primera línea porque siempre es CACHE MANIFEST
                                lines.shift();
                                resolve({
                                    hash: hash,
                                    urls: lines
                                });
                            }
                        );
                    }).catch(function () {
                        reject();
                    });
                }
                else {
                    reject();
                }
            }
        });
    };

    if (appCache) {
        const sendAppCacheEvent = (function () {
            var mustSendCacheEvents = window.parent !== window && document.referrer && TC.Util.isSameOrigin(document.referrer) && parent.TC && parent.TC._appCacheUpdater;
            return function (e) {
                if (mustSendCacheEvents) {
                    parent.TC._appCacheUpdater(e, location.href);
                }
            }
        })();

        // Fired after the first cache of the manifest.
        appCache.addEventListener('cached', sendAppCacheEvent, false);

        //// Checking for an update. Always the first event fired in the sequence.
        //appCache.addEventListener('checking', handleCacheEvent, false);


        //// An update was found. The browser is fetching resources.
        //appCache.addEventListener('downloading', handleCacheEvent, false);

        // The manifest returns 404 or 410, the download failed,
        // or the manifest changed while the download was in progress.
        appCache.addEventListener('error', sendAppCacheEvent, false);

        // Fired after the first download of the manifest.
        appCache.addEventListener('noupdate', sendAppCacheEvent, false);

        // Fired if the manifest file returns a 404 or 410.
        // This results in the application cache being deleted.
        appCache.addEventListener('obsolete', sendAppCacheEvent, false);

        // Fired for each resource listed in the manifest as it is being fetched.
        appCache.addEventListener('progress', sendAppCacheEvent, false);

        // Fired when the manifest resources have been newly redownloaded.
        appCache.addEventListener('updateready', sendAppCacheEvent, false);
    }

    TC.control.CacheBuilder = function () {
        var self = this;

        TC.control.SWCacheClient.apply(this, arguments);

        var cs = self._classSelector = '.' + self.CLASS;
        self._selectors = {
            DRAW: cs + '-draw',
            DRAWING: cs + '-drawing',
            PROGRESS: cs + '-progress',
            NEW: cs + '-new',
            LIST: cs + '-list',
            LISTITEM: cs + '-list > li',
            OKBTN: cs + '-btn-ok',
            NEWBTN: cs + '-btn-new',
            SAVEBTN: '.tc-btn-save',
            CANCELBTN: '.tc-btn-cancel',
            EDITBTN: '.tc-btn-edit',
            VIEWBTN: '.tc-btn-view',
            DELETEBTN: '.tc-btn-delete',
            TILECOUNT: cs + '-tile-count',
            NAMETB: cs + '-txt-name',
            TEXTBOX: 'input.tc-textbox',
            EXIT: cs + '-link-exit',
            OFFPANEL: cs + '-off-panel',
            BLLIST: cs + '-bl-list',
            BLLISTITEM: cs + '-bl-list > li',
            BLLISTTEXT: cs + '-bl-panel-txt',
            RNGMAXRES: cs + '-rng-maxres',
            SEARCH: cs + '-map-available-srch',
            EMPTYLIST: cs + '-map-available-empty',
            OFFLINEHIDDEN: '[data-no-cb]'
        };

        self.storedMaps = [];

        TC._appCacheBuilders.push(self);

        // Carga de mapas guardados
        try {
            if (window.localStorage) {
                for (var i = 0, len = localStorage.length; i < len; i++) {
                    var key = localStorage.key(i);
                    if (key.indexOf(self.LOCAL_STORAGE_KEY_PREFIX) === 0 && key !== self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash') {
                        // Es un nombre de mapa y no es el hash de integridad de la cache root
                        var values = localStorage.getItem(key).split(" ");
                        var extent = getExtentFromString(values.shift());
                        var name = values.join(" ");
                        var map = {
                            name: name,
                            extent: extent,
                            url: decodeURIComponent(key.substr(self.LOCAL_STORAGE_KEY_PREFIX.length))
                        }
                        self.storedMaps.push(map);
                    }
                }
                self.storedMaps.sort(function (a, b) {
                    if (a.name > b.name) {
                        return 1;
                    }
                    if (a.name < b.name) {
                        return -1;
                    }
                    return 0;
                });
            }
        }
        catch (e) {
            TC.error(self.getLocaleString('couldNotAccessLocalStorage'));
        }

        var options = $.extend({}, len > 1 ? arguments[1] : arguments[0]);
        self._dialogDiv = TC.Util.getDiv(options.dialogDiv);
        self._$dialogDiv = $(self._dialogDiv);
        if (!options.dialogDiv) {
            document.body.appendChild(self._dialogDiv);
        }

        self.mapIsOffline = location.pathname.indexOf('/' + self.CACHE_REQUEST_PATH) === location.pathname.length - self.CACHE_REQUEST_PATH.length - 1;
        if (self.mapIsOffline) {
            document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                elm.classList.add(TC.Consts.classes.HIDDEN);
            })
        }

        TC.Control.apply(self, arguments);
        self.wrap = new TC.wrap.control.CacheBuilder(self);

        self.isDownloading = false;
        self.baseLayers = [];

        self.options.avgTileSize = self.options.avgTileSize || TC.Cfg.avgTileSize;
        self.requestSchemas = [];
        self.minResolution = 0;
        self.currentMap = null;

        self._loadedCount = 0;

        // Actualización del enlace al modo online
        // Parche para detectar cambios en el hash. Lo usamos para actualizar los enlaces a los idiomas
        var pushState = history.pushState;
        history.pushState = function (state) {
            var result;
            //if (typeof history.onpushstate == "function") {
            //    history.onpushstate({ state: state });
            //}
            result = pushState.apply(history, arguments);
            if (self._offlinePanelDiv) {
                var newPath = location.pathname.replace('/' + self.CACHE_REQUEST_PATH, '/');
                var params = TC.Util.getQueryStringParams();
                delete params[self.MAP_DEFINITION_PARAM_NAME];
                delete params[self.MAP_EXTENT_PARAM_NAME];
                delete params[self.SERVICE_WORKER_FLAG];
                var newParams = $.param(params);
                if (newParams.length) {
                    newParams = '?' + newParams;
                }
                var href = newPath + newParams + location.hash;
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).setAttribute('href', href);
            }
            return result;
        }

        // Detección de estado de conexión
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {};
        var onlineHandler = function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.remove(TC.Consts.classes.CONNECTION_OFFLINE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_WIFI);

                var type = connection.type;
                switch (type) {
                    case 1:
                    case 2:
                    case undefined:
                        panel.classList.add(TC.Consts.classes.CONNECTION_WIFI);
                        break;
                    default:
                        panel.classList.add(TC.Consts.classes.CONNECTION_MOBILE);
                        break;
                }
            }
        };
        if (connection.addEventListener) {
            connection.addEventListener('typechange', onlineHandler);
        }
        window.addEventListener('online', onlineHandler);
        window.addEventListener('offline', function () {
            if (self._offlinePanelDiv) {
                const panel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                panel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE);
                panel.classList.remove(TC.Consts.classes.CONNECTION_WIFI);
            }
        });
    };

    TC.inherit(TC.control.CacheBuilder, TC.control.SWCacheClient);

    var ctlProto = TC.control.CacheBuilder.prototype;

    ctlProto.CLASS = 'tc-ctl-cbuild';
    ctlProto.MAP_DEFINITION_PARAM_NAME = "map-def";
    ctlProto.MAP_EXTENT_PARAM_NAME = "map-extent";
    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.map.";
    ctlProto.ROOT_CACHE_NAME = "root";
    ctlProto.COOKIE_KEY_PREFIX = "TC.offline.map.";
    ctlProto.CACHE_REQUEST_PATH = "offline";
    ctlProto.SERVICE_WORKER_FLAG = 'sw';
    ctlProto._states = {
        READY: 'ready',
        EDIT: 'editing',
        DOWNLOADING: 'downloading',
        DELETING: 'deleting'
    };
    ctlProto._actions = {
        CREATE: 'create',
        DELETE: 'delete'
    };
    ctlProto.offlineControls = [
        'attribution',
        'basemapSelector',
        'cacheBuilder',
        'click',
        'coordinates',
        'draw',
        'edit',
        'geolocation',
        'loadingIndicator',
        'measure',
        'navBar',
        'popup',
        'print',
        'scale',
        'scaleBar',
        'scaleSelector',
        'state',
        'fullScreen'
    ];

    TC.Consts.event.MAPCACHEDOWNLOAD = TC.Consts.event.MAPCACHEDOWNLOAD || 'mapcachedownload.tc';
    TC.Consts.event.MAPCACHEDELETE = TC.Consts.event.MAPCACHEDELETE || 'mapcachedelete.tc';
    TC.Consts.event.MAPCACHEPROGRESS = TC.Consts.event.MAPCACHEPROGRESS || 'mapcacheprogress.tc';
    TC.Consts.event.MAPCACHEERROR = TC.Consts.event.MAPCACHEERROR || 'mapcacheerror.tc';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/CacheBuilder.html";
        ctlProto.template[ctlProto.CLASS + '-map-node'] = TC.apiLocation + "TC/templates/CacheBuilderMapNode.html";
        ctlProto.template[ctlProto.CLASS + '-bl-node'] = TC.apiLocation + "TC/templates/CacheBuilderBaseLayerNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CacheBuilderDialog.html";
        ctlProto.template[ctlProto.CLASS + '-off-panel'] = TC.apiLocation + "TC/templates/CacheBuilderOfflinePanel.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "offlineMaps" }).w("</h2><div class=\"tc-ctl-cbuild-content\"><div class=\"tc-ctl-cbuild-draw tc-hidden\"></div><i class=\"tc-ctl-cbuild-map-search-icon\"></i><input type=\"search\" list=\"").f(ctx.get(["listId"], false), ctx, "h").w("\" class=\"tc-ctl-cbuild-map-available-srch tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "cb.filter.plhr" }).w("\"").x(ctx.get(["storedMaps"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" maxlength=\"200\" /> <ul id=\"").f(ctx.get(["listId"], false), ctx, "h").w("\" class=\"tc-ctl-cbuild-list\"><li class=\"tc-ctl-cbuild-map-available-empty\"").x(ctx.get(["storedMaps"], false), ctx, { "block": body_3 }, {}).w("><span>").h("i18n", ctx, {}, { "$key": "cb.noMaps" }).w("</span></li><li class=\"tc-ctl-cbuild-map-not\" hidden><span>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</span></li>").s(ctx.get(["storedMaps"], false), ctx, { "block": body_4 }, {}).w("</ul><div class=\"tc-ctl-cbuild-new\"><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-new\" disabled title=\"").h("i18n", ctx, {}, { "$key": "newofflinemap" }).w("\">").h("i18n", ctx, {}, { "$key": "newOfflineMap" }).w("</button></div><div class=\"tc-ctl-cbuild-drawing tc-hidden\"><div class=\"tc-ctl-cbuild-tile-cmd\"><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-cancel-draw\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div><div class=\"tc-ctl-cbuild-progress tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "cb.DownloadingMap|s" }).w(": <span class=\"tc-ctl-cbuild-progress-count\"></span></p><div class=\"tc-ctl-cbuild-progress-bar\"><div class=\"tc-ctl-cbuild-progress-ratio\" style=\"width:0\"></div></div><button class=\"tc-button tc-icon-button tc-ctl-cbuild-btn-cancel-dl\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" disabled"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk; } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w(" hidden"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.p("tc-ctl-cbuild-map-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_4.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-map-node'] = function () { dust.register(ctlProto.CLASS + '-map-node', body_0); function body_0(chk, ctx) { return chk.w("<li data-extent=\"").f(ctx.get(["extent"], false), ctx, "h").w("\"><span><a href=\"").f(ctx.get(["url"], false), ctx, "h").w("\" title=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</a></span><input class=\"tc-textbox tc-hidden\" type=\"text\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\" /><button class=\"tc-btn-save tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "save" }).w("\"></button><button class=\"tc-btn-cancel tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\"></button><button class=\"tc-btn-edit\" title=\"").h("i18n", ctx, {}, { "$key": "editMapName" }).w("\">").h("i18n", ctx, {}, { "$key": "editMapName" }).w("</button><button class=\"tc-btn-view\" title=\"").h("i18n", ctx, {}, { "$key": "viewMapExtent" }).w("\">").h("i18n", ctx, {}, { "$key": "viewMapExtent" }).w("</button><button class=\"tc-btn-delete\" title=\"").h("i18n", ctx, {}, { "$key": "deleteMap" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteMap" }).w("</button></li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-bl-node'] = function () { dust.register(ctlProto.CLASS + '-bl-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-cbuild-bl-node\" data-tc-layer-uid=\"").f(ctx.get(["id"], false), ctx, "h").w("\"><label style=\"background-size: 100% 100%; background-image: url(").f(ctx.get(["thumbnail"], false), ctx, "h").w(")\"><input type=\"checkbox\" name=\"cbbl\" value=\"").f(ctx.get(["id"], false), ctx, "h").w("\" disabled><span>").f(ctx.get(["title"], false), ctx, "h").w("</span></label></li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-cbuild-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "newOfflineMap" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><input type=\"text\" class=\"tc-ctl-cbuild-txt-name\" placeholder=\"").h("i18n", ctx, {}, { "$key": "nameRequired" }).w("\" required /><div class=\"tc-ctl-cbuild-bl-panel\"><h4>").h("i18n", ctx, {}, { "$key": "availableOfflineMaps" }).w("</h4><p class=\"tc-ctl-cbuild-bl-panel-txt\">").h("i18n", ctx, {}, { "$key": "selectAtLeastOne" }).w("</p><ul class=\"tc-ctl-cbuild-bl-list\"></ul></div><div class=\"tc-ctl-cbuild-res-panel\"><h4>").h("i18n", ctx, {}, { "$key": "maxRes" }).w("</h4><div class=\"tc-ctl-cbuild-res\"></div><input type=\"range\" class=\"tc-ctl-cbuild-rng-maxres\" disabled value=\"0\" title=\"").h("i18n", ctx, {}, { "$key": "maxRes" }).w("\"></div><div class=\"tc-ctl-cbuild-tile-count\"></div></div><div class=\"tc-modal-footer\"><button class=\"tc-button tc-modal-close tc-ctl-cbuild-btn-ok\" disabled>").h("i18n", ctx, {}, { "$key": "ok" }).w("</button><button type=\"button\" class=\"tc-button tc-modal-close tc-ctl-cbuild-btn-cancel\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-off-panel'] = function () { dust.register(ctlProto.CLASS + '-off-panel', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-cbuild-off-panel tc-conn-wifi\"><span>").h("i18n", ctx, {}, { "$key": "offlineMap" }).w("</span> <a href=\"\" class=\"tc-ctl-cbuild-link-exit\" title=\"").h("i18n", ctx, {}, { "$key": "returnToOnlineMaps" }).w("\"><span>").h("i18n", ctx, {}, { "$key": "returnToOnlineMaps" }).w("</span></a></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const getExtentFromString = function (str) {
        return $.map(decodeURIComponent(str).split(','), function (elm) {
            return parseFloat(elm);
        });
    };

    const setDownloadingState = function (ctl) {
        ctl._state = ctl._states.DOWNLOADING;
        TC.Util.closeModal();
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.remove(TC.Consts.classes.HIDDEN);
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = true;
        ctl.layer.clearFeatures();
        ctl.boxDraw.cancel();
    };

    const setDeletingState = function (ctl) {
        ctl._state = ctl._states.DELETING;
        ctl.showDownloadProgress(0, 1);
        ctl.div.querySelector(ctl._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        ctl.div.querySelector(ctl._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        ctl.div.querySelectorAll(ctl._selectors.LISTITEM).forEach(function (li) {
            li.classList.add(TC.Consts.classes.DISABLED);
        });
        ctl._dialogDiv.querySelector(ctl._selectors.OKBTN).disabled = true;
        ctl.div.querySelector(ctl._selectors.NEWBTN).disabled = false;
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = '';
        ctl.boxDraw.cancel();
    };

    const setNameEditingState = function (ctl, li) {
        li.querySelector('span').classList.add(TC.Consts.classes.HIDDEN);
        const textbox = li.querySelector(ctl._selectors.TEXTBOX);
        textbox.classList.remove(TC.Consts.classes.HIDDEN);
        textbox.value = li.querySelector('span a').innerHTML;
        textbox.focus();
        li.querySelector(ctl._selectors.SAVEBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.add(TC.Consts.classes.HIDDEN);
    };

    const setNameReadyState = function (ctl, li) {
        li.querySelector('span').classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.TEXTBOX).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.SAVEBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.CANCELBTN).classList.add(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.EDITBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.VIEWBTN).classList.remove(TC.Consts.classes.HIDDEN);
        li.querySelector(ctl._selectors.DELETEBTN).classList.remove(TC.Consts.classes.HIDDEN);
    };

    var formatNumber = function (number) {
        return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
    };

    var updateResolutions = function (ctl, options) {
        var opts = options || {};
        const resDiv = ctl._dialogDiv.querySelector(ctl._classSelector + '-res');
        const range = ctl._dialogDiv.querySelector(ctl._selectors.RNGMAXRES);
        var resolutions = ctl.getResolutions();
        var resText, resLevel, resLeft;
        if (resolutions.length) {
            if (ctl.minResolution) {
                // Si ya había resolución previa y no se ha tocado el slider, se actualiza su valor
                if (opts.rangeValue === undefined) {
                    for (var i = 0, len = resolutions.length; i < len; i++) {
                        if (ctl.minResolution >= resolutions[i]) {
                            range.value = i;
                            break;
                        }
                    }
                }
            }
            else {
                if (opts.rangeValue === undefined) {
                    range.value = Math.floor(resolutions.length / 2);
                }
            }
            range.setAttribute('max', resolutions.length - 1);
            resLevel = parseInt(range.value);
            var resValue = Math.floor(new Number(resolutions[resLevel]) * 1000) / 1000;
            resText = ctl.getLocaleString('metersPerPixel', {
                value: resValue.toLocaleString((ctl.map ? ctl.map.options.locale : TC.Cfg.locale).replace('_', '-'))
            });
            resLeft = (resLevel + 1) * 100 / (resolutions.length + 1) + '%';
            range.disabled = false;
            ctl.minResolution = resolutions[range.value];
        }
        else {
            resLevel = 0;
            resText = '';
            range.value = 0;
            resLeft = '0';
            ctl.minResolution = 0;
            range.disabled = true;
        }
        resDiv.style.left = resLeft;
        resDiv.innerHTML = resText;
    };

    const findTileMatrixLimits = function (schema, resolution) {
        var result = null;
        for (var i = 0, len = schema.tileMatrixLimits.length; i < len; i++) {
            result = schema.tileMatrixLimits[i];
            if (result.res <= resolution) {
                break;
            }
        }
        return result;
    };

    const updateThumbnails = function (ctl) {
        ctl._dialogDiv.querySelectorAll(ctl._classSelector + '-bl-node input[type=checkbox]').forEach(function (cb, idx) {
            if (cb.checked) {
                var schema = ctl.requestSchemas.filter(function (elm) {
                    return elm.layerId === cb.value;
                })[0];
                if (schema) {
                    var tml = findTileMatrixLimits(schema, ctl.minResolution);
                    if (tml) {
                        var tmKey = '{TileMatrix}';
                        var trKey = '{TileRow}';
                        var tcKey = '{TileCol}';
                        var url = schema.url;
                        if (url.indexOf(tmKey) < 0) {
                            // Caso KVP
                            var qsIdx = url.indexOf('?');
                            if (qsIdx >= 0) {
                                url = url.substr(0, qsIdx);
                            }
                            for (var j = 0, lenj = ctl.baseLayers.length; j < lenj; j++) {
                                var l = ctl.baseLayers[j];
                                if (l.id === schema.layerId) {
                                    url = url + '?layer=' + l.layerNames + '&style=default&tilematrixset=' + l.matrixSet +
                                        '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + l.format +
                                        '&TileMatrix=' + tmKey + '&TileRow=' + trKey + '&TileCol=' + tcKey;
                                    break;
                                }
                            }
                        }
                        while (cb && cb.tagName !== 'LABEL') {
                            cb = cb.parentElement;
                        }
                        if (cb) {
                            cb.style.backgroundSize = 'auto';
                            cb.style.backgroundPosition = 'left bottom';
                            cb.style.backgroundImage = 'url(' + url.replace('{TileMatrix}', tml.mId).replace(trKey, tml.rt).replace(tcKey, tml.cl) + ')';
                        }
                    }
                }
            }
        });
    };

    const formatSize = function (ctl, size) {
        var result;
        if (size < 1) {
            result = ctl.getLocaleString('lessThan1Mb');
        }
        else {
            result = ctl.getLocaleString('approxXMb', { quantity: formatNumber(size) });
        }
        return result;
    };

    const showEstimatedMapSize = function (ctl) {
        var text = '';
        ctl.tileCount = 0;
        for (var i = 0, ii = ctl.requestSchemas.length; i < ii; i++) {
            var schema = ctl.requestSchemas[i];
            for (var j = 0, jj = schema.tileMatrixLimits.length; j < jj; j++) {
                var tml = schema.tileMatrixLimits[j];
                ctl.tileCount += (tml.cr - tml.cl + 1) * (tml.rb - tml.rt + 1);
                if (tml.res < ctl.minResolution) {
                    break;
                }
            }
        }
        if (ctl.tileCount) {
            ctl.estimatedMapSize = Math.round(ctl.tileCount * ctl.options.avgTileSize / 1048576);
            text = ctl.getLocaleString('xTiles', { quantity: formatNumber(ctl.tileCount) }) + ' (' + formatSize(ctl, ctl.estimatedMapSize) + ')';
        }
        ctl._dialogDiv.querySelector(ctl._selectors.TILECOUNT).innerHTML = text;
    };

    const getListElementByMapName = function (ctl, name) {
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.innerHTML === name) {
                return li;
            }
        }
        return null;
    };

    const getListElementByMapUrl = function (ctl, url) {
        var hashIdx = url.indexOf('#');
        if (hashIdx >= 0) {
            url = url.substr(0, hashIdx);
        }
        const lis = ctl.div.querySelectorAll(ctl._selectors.LISTITEM);
        for (var i = 0, len = lis.length; i < len; i++) {
            const li = lis[i];
            const anchor = li.querySelector('a');
            if (anchor && anchor.getAttribute('href') === url) {
                return li;
            }
        }
        return null;
    };

    const openCachedPage = function (ctl, url) {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.setAttribute('src', url);
        ctl.div.appendChild(iframe);
    };

    const closeCachedPage = function (ctl, url) {
        const iframe = ctl.div.querySelector('iframe[src="' + url + '"]');
        if (iframe) {
            iframe.parentElement.removeChild(iframe);
        }
    };

    var saveMapToStorage = function (ctl, map) {
        var result = false;
        if (window.localStorage) {
            localStorage.setItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(map.url), map.extent + " " + map.name);
            result = true;
        }
        return result;
    };

    var removeMapFromStorage = function (ctl, url) {
        var result = false;
        if (window.localStorage) {
            localStorage.removeItem(ctl.LOCAL_STORAGE_KEY_PREFIX + encodeURIComponent(url));
            result = true;
        }
        return result;
    };

    const addMap = function (ctl) {
        const map = ctl.currentMap;
        if (saveMapToStorage(ctl, map)) {
            ctl.getRenderedHtml(ctl.CLASS + '-map-node', { name: map.name, url: map.url }, function (html) {
                const parser = new DOMParser();
                ctl.div.querySelector(ctl._selectors.LIST).appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).setAttribute('hidden', 'hidden');
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = false;
            });
            ctl.storedMaps.push(map);
        }
    };

    const removeMap = function (ctl, url) {
        const map = ctl.findStoredMap({ url: url });
        if (map) {
            if (removeMapFromStorage(ctl, url)) {
                const li = getListElementByMapName(ctl, map.name);
                if (li) {
                    li.parentElement.removeChild(li);
                }
            }
            var idx = $.inArray(map, ctl.storedMaps);
            ctl.storedMaps.splice(idx, 1);
            if (!ctl.storedMaps.length) {
                ctl.div.querySelector(ctl._selectors.SEARCH).disabled = true;
                ctl.div.querySelector(ctl._selectors.EMPTYLIST).removeAttribute('hidden');
            }

            return map.name;
        }

        return null;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            var renderObject = { storedMaps: self.storedMaps, listId: self.CLASS + '-list-' + TC.getUID() };
            self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
                self._dialogDiv.innerHTML = html;
                self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener(TC.Consts.event.CLICK, function (e) {
                    e.preventDefault();
                    this.selectionStart = 0;
                    this.selectionEnd = this.value.length;
                    this.focus();

                });
            }).then(function () {
                self.renderData(renderObject, function () {
                    self._dialogDiv.querySelector(self._selectors.OKBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.generateCache();
                    });
                    self._dialogDiv.querySelector(self._selectors.NAMETB).addEventListener('input', function () {
                        self._updateReadyState();
                    });
                    self.div.querySelector(self._selectors.NEWBTN).addEventListener(TC.Consts.event.CLICK, function () {
                        self.setEditState();
                    });
                    self.div.querySelector(self._classSelector + '-btn-cancel-draw').addEventListener(TC.Consts.event.CLICK, function () {
                        self.setReadyState();
                    });

                    self.div.querySelector(self._classSelector + '-btn-cancel-dl').addEventListener(TC.Consts.event.CLICK, function () {
                        self.cancelCacheRequest();
                    });

                    const list = self.div.querySelector(self._selectors.LIST);
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.DELETEBTN, function (e) {
                        self.startDeleteMap(e.target.parentElement.querySelector('a').innerHTML);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.EDITBTN, function (e) {
                        setNameEditingState(self, e.target.parentElement);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.CANCELBTN, function (e) {
                        const li = e.target.parentElement;
                        li.querySelector(self._selectors.TEXTBOX).value = li.querySelector('a').innerHTML;
                        setNameReadyState(self, li);
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.SAVEBTN, function (e) {
                        const li = e.target.parentElement;
                        setNameReadyState(self, li);
                        const anchor = li.querySelector('a');
                        const oldName = anchor.innerHTML;
                        const newName = li.querySelector(self._selectors.TEXTBOX).value;
                        const map = self.findStoredMap({ url: anchor.getAttribute('href') });
                        if (map) {
                            map.name = newName;
                            anchor.innerHTML = newName;
                            anchor.setAttribute('title', newName);
                            saveMapToStorage(self, map);
                        }
                    }));
                    list.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector(self._selectors.VIEWBTN, function (e) {
                        const btn = e.target;
                        var showExtent = !btn.classList.contains(TC.Consts.classes.ACTIVE);
                        const viewBtn = self.div.querySelector(self._selectors.VIEWBTN);
                        viewBtn.classList.remove(TC.Consts.classes.ACTIVE);
                        viewBtn.parentElement.classList.remove(TC.Consts.classes.ACTIVE);
                        const mapName = btn.parentElement.querySelector('a').innerHTML;
                        if (mapName) {
                            var map = self.findStoredMap({ name: mapName });
                            if (map) {
                                var extent = getExtentFromString(map.extent);
                                self.layer.clearFeatures();
                                if (showExtent) {
                                    self.layer.addPolygon(
                                        [
                                            [
                                                [extent[0], extent[1]],
                                                [extent[0], extent[3]],
                                                [extent[2], extent[3]],
                                                [extent[2], extent[1]]
                                            ]
                                        ]
                                        , {
                                            showsPopup: false
                                        }).then(function () {
                                            self.layer.map.zoomToFeatures(self.layer.features);
                                        });
                                    btn.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.parentElement.classList.add(TC.Consts.classes.ACTIVE);
                                    btn.setAttribute('title', self.getLocaleString('removeMapExtent'));
                                }
                            }
                        }
                    }));

                    var _filter = function (searchTerm) {
                        searchTerm = searchTerm.toLowerCase();
                        //tc-ctl-cbuild-map-available-empty
                        const lis = self.div.querySelectorAll(self._selectors.LISTITEM);
                        lis.forEach(function (li) {
                            li.style.display = 'none';
                        });
                        const mapLis = [];
                        lis.forEach(function (li) {
                            if (li.matches('li:not([class]),li.' + TC.Consts.classes.ACTIVE)) {
                                mapLis.push(li);
                            }
                        });

                        if (searchTerm.length === 0) {
                            mapLis.forEach(function (li) {
                                li.style.removeProperty('display');
                            });
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'visible';
                        } else {
                            self.div.querySelector(self._classSelector + '-map-search-icon').style.visibility = 'hidden';
                            var r = new RegExp(searchTerm, 'i');
                            mapLis.forEach(function (li) {
                                li.style.display = r.test(li.querySelector('a').textContent) ? '' : 'none';
                            });

                            if (!mapLis.some(function (li) {
                                return !li.hidden;
                            })) {
                                lis.forEach(function (li) {
                                    if (li.matches('[class^="tc-ctl-cbuild-map-not"]')) {
                                        li.style.removeProperty('display');
                                    }
                                });
                            }
                        }
                    };

                    const trackSearch = self.div.querySelector(self._selectors.SEARCH);
                    const searchListener = function () {
                        _filter(this.value.toLowerCase().trim());
                    };
                    trackSearch.addEventListener('keyup', searchListener);
                    trackSearch.addEventListener('search', searchListener);

                    self._dialogDiv.querySelector(self._selectors.BLLIST).addEventListener('change', TC.EventTarget.listenerBySelector('input[type=checkbox]', function (e) {
                        self.baseLayers.length = 0;
                        self._dialogDiv.querySelectorAll(self._selectors.BLLIST + ' input[type=checkbox]').forEach(function (checkbox) {
                            if (checkbox.checked) {
                                var layerId = checkbox.value;
                                for (var i = 0, len = self.map.baseLayers.length; i < len; i++) {
                                    var layer = self.map.baseLayers[i];
                                    if (layer.id === layerId && layer.type === TC.Consts.layerType.WMTS) {
                                        self.baseLayers[self.baseLayers.length] = layer;
                                        break;
                                    }
                                }
                            }
                        });
                        self.updateRequestSchemas();
                        updateResolutions(self);
                        updateThumbnails(self);
                        self._updateReadyState();
                        showEstimatedMapSize(self);
                    }));

                    const range = self._dialogDiv.querySelector(self._selectors.RNGMAXRES);
                    const rangeListener = function (e) {
                        updateResolutions(self, {
                            rangeValue: e.target.value
                        });
                        updateThumbnails(self);
                        showEstimatedMapSize(self);
                    };
                    range.addEventListener('input', rangeListener);
                    range.addEventListener('change', rangeListener);

                    const li = getListElementByMapUrl(self, location.href);
                    if (li) {
                        li.classList.add(TC.Consts.classes.ACTIVE);
                    }

                    if ($.isFunction(callback)) {
                        callback();
                    }
                })
                    .then(function () {
                        resolve();
                    })
                    .catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
            });

            // Control para evitar que se cancele una descarga de cache al salir de la página
            window.addEventListener('beforeunload', function (e) {
                if (self.isDownloading) {
                    var msg = self.getLocaleString('cb.mapDownloading.warning');
                    e.returnValue = msg;
                    return msg;
                }
            }, true);
        }));
    };

    ctlProto.register = function (map) {
        var self = this;

        const result = TC.control.SWCacheClient.prototype.register.call(self, map);

        if (navigator.serviceWorker) {

            navigator.serviceWorker.addEventListener('message', function (event) {
                switch (event.data.event) {
                    case 'progress':
                        self.trigger(TC.Consts.event.MAPCACHEPROGRESS, { url: event.data.name, loaded: event.data.count, total: event.data.total });
                        break;
                    case 'cached':
                        self.trigger(TC.Consts.event.MAPCACHEDOWNLOAD, { url: event.data.name });
                        break;
                    case 'deleted':
                        self.trigger(TC.Consts.event.MAPCACHEDELETE, { url: event.data.name });
                        break;
                    case 'error':
                        if (event.data.action === self._actions.CREATE) {
                            TC.error(self.getLocaleString('cb.resourceDownload.error', { url: event.data.url }));
                        }
                        break;
                    default:
                        break;
                }
            });

            // Cacheamos mediante service worker las URLs del manifiesto
            requestManifest().then(function (obj) {
                const hashStorageKey = self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME + '.hash';
                var hash;
                if (window.localStorage) {
                    hash = localStorage.getItem(hashStorageKey);
                }
                if (hash !== obj.hash) {
                    self.cacheUrlList(obj.urls);
                    self.one(TC.Consts.event.MAPCACHEDOWNLOAD, function () {
                        const firstLoad = !hash;
                        if (window.localStorage) {
                            localStorage.setItem(hashStorageKey, obj.hash);
                        }
                        if (!firstLoad) {
                            TC.confirm(self.getLocaleString('newAppVersionAvailable'), function () {
                                location.reload();
                            });
                        }
                    });
                }
            });
        }

        if (self.mapIsOffline) {
            map.div.classList.add(TC.Consts.classes.OFFLINE);

            // Si no está especificado, el panel de aviso offline se cuelga del div del mapa
            self._offlinePanelDiv = TC.Util.getDiv(self.options.offlinePanelDiv);
            if (!self.options.offlinePanelDiv) {
                map.div.appendChild(self._offlinePanelDiv);
            }
            self.getRenderedHtml(self.CLASS + '-off-panel', null, function (html) {
                self._offlinePanelDiv.innerHTML = html;
                if (!navigator.onLine) {
                    const offPanel = self._offlinePanelDiv.querySelector(self._selectors.OFFPANEL);
                    offPanel.classList.add(TC.Consts.classes.CONNECTION_OFFLINE);
                    offPanel.classList.remove(TC.Consts.classes.CONNECTION_MOBILE);
                    offPanel.classList.remove(TC.Consts.classes.CONNECTION_WIFI);
                }
                self._offlinePanelDiv.querySelector(self._selectors.EXIT).addEventListener(TC.Consts.event.CLICK, function (e) {
                    TC.confirm(self.getLocaleString('offlineMapExit.confirm'),
                        null,
                        function () {
                            e.preventDefault();
                        });
                });
            });
        }

        const drawId = self.getUID();
        const layerId = self.getUID();
        self.layerPromise = map.addLayer({
            id: layerId,
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            styles: {
                line: map.options.styles.line
            }
        });
        self.layer = null;
        Promise.all([
            self.layerPromise,
            self.renderPromise(),
            map.addControl('draw', {
                id: drawId,
                div: self.div.querySelector(self._selectors.DRAW),
                mode: TC.Consts.geom.RECTANGLE,
                persistent: false
            })
        ]).then(function (objects) {
            const layer = self.layer = objects[0];
            const boxDraw = self.boxDraw = objects[2];
            boxDraw.setLayer(layer);
            boxDraw
                .on(TC.Consts.event.DRAWSTART, function (e) {
                    self.map.toast(self.getLocaleString('clickOnDownloadAreaOppositeCorner'), { type: TC.Consts.msgType.INFO });
                })
                .on(TC.Consts.event.DRAWEND, function (e) {
                    var points = e.feature.geometry[0];
                    var pStart = points[0];
                    var pEnd = points[2];
                    var minx = Math.min(pStart[0], pEnd[0]);
                    var maxx = Math.max(pStart[0], pEnd[0]);
                    var miny = Math.min(pStart[1], pEnd[1]);
                    var maxy = Math.max(pStart[1], pEnd[1]);
                    self.setExtent([minx, miny, maxx, maxy]);
                    const checkboxes = self._dialogDiv.querySelectorAll('input[type=checkbox]');
                    checkboxes.forEach(function (checkbox) {
                        // Comprobamos que la extensión del mapa está disponible a resolución máxima 
                        // (criterio arbitrario, elegido porque no nos vale el criterio de que el mapa
                        // esté disponible a alguna resolución, dado que el mapa base de IDENA abarca
                        // toda España)
                        for (var i = 0, len = self.map.baseLayers.length; i < len; i++) {
                            var layer = self.map.baseLayers[i];
                            if (checkbox.value === layer.id) {
                                var li = checkbox;
                                while (li && li.tagName !== 'LI') {
                                    li = li.parentElement;
                                }
                                var resolutions = layer.getResolutions();
                                var tml = self.wrap.getRequestSchemas({
                                    extent: self.extent,
                                    layers: [layer]
                                })[0].tileMatrixLimits;
                                if (!tml.length || resolutions[resolutions.length - 1] != tml[tml.length - 1].res) {
                                    checkbox.checked = false;
                                    li.classList.add(TC.Consts.classes.HIDDEN);
                                }
                                else {
                                    li.classList.remove(TC.Consts.classes.HIDDEN);
                                }
                                break;
                            }
                        }
                    });
                    var blListTextKey;
                    const lis = self._dialogDiv.querySelectorAll(self._selectors.BLLISTITEM);
                    for (var i = 0, len = lis.length; i < len; i++) {
                        if (lis[i].matches('.' + TC.Consts.classes.HIDDEN)) {
                            blListTextKey = 'selectAtLeastOne';
                            break;
                        }
                    }
                    if (!blListTextKey) {
                        blListTextKey = 'cb.noMapsAtSelectedExtent';
                    }
                    self._dialogDiv.querySelector(self._selectors.BLLISTTEXT).innerHTML = self.getLocaleString(blListTextKey);

                    updateThumbnails(self);
                    showEstimatedMapSize(self);
                    TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-dialog'), {
                        openCallback: function () {
                            checkboxes.forEach(function (cb) {
                                cb.disabled = false;
                            });
                            var time;
                            if (Date.prototype.toLocaleString) {
                                var opt = {};
                                opt.year = opt.month = opt.day = opt.hour = opt.minute = opt.second = 'numeric';
                                time = new Date().toLocaleString(self.map.options.locale.replace('_', '-'), opt);
                            }
                            else {
                                time = new Date().toString();
                            }
                            self._dialogDiv.querySelector(self._selectors.NAMETB).value = time;
                            self._updateReadyState();
                        },
                        closeCallback: function () {
                            checkboxes.forEach(function (cb) {
                                cb.disabled = true;
                            });
                            self.layer.clearFeatures();
                        }
                    });
                });

            map.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                if (boxDraw === e.control) {
                    if (self._state === self._states.EDITING) {
                        self.setReadyState();
                    }
                }
            });

        });

        var addRenderedListNode = function (layer) {
            var result = false;
            const blList = self._dialogDiv.querySelector(self._selectors.BLLIST);
            const isLayerAdded = function () {
                return !!blList.querySelector('li[data-tc-layer-uid="' + layer.id + '"]');
            };
            var isValidLayer = layer.type === TC.Consts.layerType.WMTS && !layer.mustReproject;
            if (TC.Util.detectSafari() && TC.Util.detectIOS()) {
                isValidLayer = isValidLayer && TC.Util.isSameOrigin(layer.url);
            }
            if (isValidLayer && !isLayerAdded()) {
                result = true;
                self.getRenderedHtml(self.CLASS + '-bl-node', layer, function (html) {
                    if (!isLayerAdded()) {
                        const parser = new DOMParser();
                        blList.appendChild(parser.parseFromString(html, 'text/html').body.firstChild);
                    }
                });
            }
            return result;
        };

        map
            .on(TC.Consts.event.LAYERADD, function (e) {
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    addRenderedListNode(e.layer);
                });
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                //14/03/2019 GLS: esperamos a que se haya renderizado el dialogo para obtener la lista
                self.renderPromise().then(function () {
                    const layer = e.layer;
                    if (layer.type === TC.Consts.layerType.WMTS) {
                        const li = self._dialogDiv
                            .querySelector(self._selectors.BLLIST)
                            .querySelector('li[data-tc-layer-uid="' + layer.id + '"]');
                        li.parentElement.removeChild(li);
                    }
                });
            });


        var params = TC.Util.getQueryStringParams();
        var mapDefString = params[self.MAP_DEFINITION_PARAM_NAME];
        var extentString = params[self.MAP_EXTENT_PARAM_NAME];

        map.ready(function () {
            if (self.mapIsOffline) {
                // Deshabilitamos los controles que no son usables en modo offline
                var offCtls = [];
                var i, len;
                for (i = 0, len = self.offlineControls.length; i < len; i++) {
                    var offCtl = self.offlineControls[i];
                    offCtl = offCtl.substr(0, 1).toUpperCase() + offCtl.substr(1);
                    offCtls = offCtls.concat(map.getControlsByClass('TC.control.' + offCtl));
                }

                for (i = 0, len = map.controls.length; i < len; i++) {
                    var ctl = map.controls[i];
                    if (offCtls.indexOf(ctl) < 0) {
                        ctl.disable();
                    }
                }

                document.querySelectorAll(self._selectors.OFFLINEHIDDEN).forEach(function (elm) {
                    elm.classList.add(TC.Consts.classes.HIDDEN);
                });
            }
        });

        map.loaded(function () {

            self.layerPromise.then(function (layer) {
                map.putLayerOnTop(layer);
            });

            self.renderPromise().then(function () {
                self.div.querySelector(self._selectors.NEWBTN).disabled = false;
                for (var i = 0, len = map.baseLayers.length; i < len; i++) {
                    addRenderedListNode(map.baseLayers[i]);
                }
            });

            if (self.mapIsOffline) {
                var mapDef = JSON.parse(window.atob(decodeURIComponent(mapDefString)));
                var excludedLayers = [];
                // Obtenemos la primera capa del esquema de la cache y de paso vemos qué capas no van a estar disponibles
                var baseLayer = $.grep(map.baseLayers, function (layer) {
                    var result = false;
                    if (layer.type === TC.Consts.layerType.WMTS) {
                        for (var i = 0, len = mapDef.layers.length; i < len; i++) {
                            var l = mapDef.layers[i];
                            var layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                            if (layerUrl === mapDef.url[l.urlIdx] && layer.layerNames === l.id && layer.matrixSet === mapDef.tms[l.tmsIdx]) {
                                result = true;
                                break;
                            }
                        }
                    }
                    // Quitamos todas las capas que no estén cacheadas y que no sean el mapa en blanco
                    if (!result) {
                        if (layer.type !== TC.Consts.layerType.VECTOR) {
                            excludedLayers[excludedLayers.length] = layer;
                        }
                    }
                    return result;
                })[0];
                if (baseLayer) {
                    map.setBaseLayer(baseLayer);
                }
                for (var i = 0, len = excludedLayers.length; i < len; i++) {
                    map.removeLayer(excludedLayers[i]);
                }

                map.setExtent(getExtentFromString(extentString));
            }
        });

        self
            .on(TC.Consts.event.MAPCACHEDOWNLOAD, function (e) {
                self.isDownloading = false;
                const removeHash = function (url) {
                    const hashIdx = url.indexOf('#');
                    return (hashIdx >= 0) ? url.substr(0, hashIdx) : url;
                }
                const url = removeHash(e.url);
                const li = getListElementByMapUrl(self, url);
                if (li && !self.serviceWorkerEnabled) {
                    // Se ha descargado un mapa cuando se quería borrar. Pasa cuando la cache ya estaba borrada pero la entrada en localStorage no.
                    li.classList.remove(TC.Consts.classes.DISABLED);
                    TC.alert(self.getLocaleString('cb.delete.error'));
                }
                else {
                    if (self.currentMap && url === self.currentMap.url) {
                        addMap(self);
                        map.toast(self.getLocaleString('mapDownloaded', { mapName: self.currentMap.name }));
                    }
                }
                self.currentMap = null;
                closeCachedPage(self, e.url);
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEDELETE, function (e) {
                self.isDownloading = false;
                var mapName = removeMap(self, e.url) || (self.currentMap && self.currentMap.name);
                closeCachedPage(self, e.url);
                self.currentMap = null;
                if (mapName) {
                    document.cookie = self.COOKIE_KEY_PREFIX + 'delete=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
                    map.toast(self.getLocaleString('mapDeleted', { mapName: mapName }));
                }
                self.setReadyState();
            })
            .on(TC.Consts.event.MAPCACHEPROGRESS, function (e) {
                var total = e.total;
                if (!total && self.requestSchemas) {
                    total = self.requestSchemas[0].tileCount;
                }
                var loaded = e.loaded;
                if (loaded) {
                    self._loadedCount = loaded;
                }
                else {
                    self._loadedCount += 1;
                    loaded = self._loadedCount;
                }
                self.showDownloadProgress(loaded, total);
            })
            .on(TC.Consts.event.MAPCACHEERROR, function (e) {
                self.isDownloading = false;
                closeCachedPage(self, e.url);
                self.setReadyState();
                var msg = self.getLocaleString('cb.mapCreation.error');
                var handleError = true;
                switch (e.reason) {
                    case 'quota':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonQuota');
                        break;
                    case 'resource':
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonResource');
                        break;
                    case 'manifest':
                        if (e.status == '410') {
                            removeMap(self, e.url);
                        }
                        handleError = false;
                        break;
                    case ALREADY_EXISTS:
                        msg += '. ' + self.getLocaleString('cb.mapCreation.error.reasonAlreadyExists');
                        break;
                    default:
                        break;
                }
                if (handleError) {
                    if (TC.Util.detectIE()) {
                        TC.error(msg);
                        TC.alert(self.getLocaleString('cb.mapCreation.error.reasonIE'));
                    }
                    else {
                        TC.alert(msg);
                    }
                }
                self.currentMap = null;
            });

        return result;
    };

    ctlProto.setExtent = function (extent) {
        var self = this;
        if ($.isArray(extent) && extent.length >= 4) {
            self.extent = extent;
            self.updateRequestSchemas();
        }
    };

    ctlProto._updateReadyState = function () {
        const self = this;
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled =
            !self.extent ||
            self._dialogDiv.querySelector(self._selectors.NAMETB).value.length === 0 ||
            self._dialogDiv.querySelector(self._selectors.RNGMAXRES).disabled;
    };

    ctlProto.setReadyState = function () {
        const self = this;
        self._state = self._states.READY;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.DRAWING).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.NEW).classList.remove(TC.Consts.classes.HIDDEN);
        self.div.querySelectorAll(self._selectors.LISTITEM).forEach(function (li) {
            li.classList.remove(TC.Consts.classes.DISABLED);
        });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = false;
        self._dialogDiv.querySelector(self._selectors.TILECOUNT).innerHTML = '';
        self.extent = null;
        self._loadedCount = 0;
        if (self.boxDraw) {
            self.boxDraw.cancel();
        }
    };

    ctlProto.setEditState = function () {
        const self = this;
        self._state = self._states.EDITING;
        self.showDownloadProgress(0, 1);
        self.div.querySelector(self._selectors.NEW).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.PROGRESS).classList.add(TC.Consts.classes.HIDDEN);
        self.div.querySelector(self._selectors.DRAWING).classList.remove(TC.Consts.classes.HIDDEN);
        self.map.toast(self.getLocaleString('clickOnDownloadAreaFirstCorner'), { type: TC.Consts.msgType.INFO });
        self._dialogDiv.querySelector(self._selectors.OKBTN).disabled = true;
        self.div.querySelector(self._selectors.NEWBTN).disabled = true;
        self._dialogDiv.querySelector(self._selectors.NAMETB).value = '';
        self.boxDraw.activate();
    };

    ctlProto.generateCache = function () {
        const self = this;
        const options = {
            mapName: self._dialogDiv.querySelector(self._selectors.NAMETB).value
        };
        if (self.findStoredMap({ name: options.mapName })) {
            TC.alert(self.getLocaleString('cb.mapNameAlreadyExists.error', options));
        }
        else {
            var startRequest = function () {
                self.div.querySelector(self._classSelector + '-name').innerHTML = options.mapName;
                self.map.toast(self.getLocaleString('downloadingMap', { mapName: options.mapName }));
                setDownloadingState(self);
                self.requestCache(options);
            };
            // Usamos Quota Management API si existe
            var storageInfo = navigator.temporaryStorage || navigator.webkitTemporaryStorage || {};
            if (storageInfo.queryUsageAndQuota) {
                storageInfo.queryUsageAndQuota(
                    function (usedBytes, grantedBytes) {
                        var availableMB = (grantedBytes - usedBytes) / 1048576;
                        if (self.estimatedMapSize < availableMB) {
                            startRequest();
                        }
                        else {
                            TC.confirm(self.getLocaleString('cb.mapCreation.warning.reasonSize', {
                                mapName: options.mapName,
                                mapSize: formatSize(self, self.estimatedMapSize),
                                availableStorage: formatSize(self, Math.round(availableMB))
                            }), startRequest);
                        }
                    },
                    function (e) {
                        TC.error(e);
                    }
                );
            }
            else {
                // En IE por defecto el límite de recursos por manifiesto es 1000, en Edge, 2000
                var ieVersion = TC.Util.detectIE();
                if (ieVersion) {
                    var maxResourceCount = ieVersion < 12 ? 1000 : 2000;
                    // Calculamos el número de recursos del manifiesto para ver cuándo va a fallar una cache en IE por exceso de recursos
                    var manifestResourceCount = 0;
                    var confirmRequest = function () {
                        var resourceCount = self.tileCount + manifestResourceCount;
                        if (resourceCount > maxResourceCount) {
                            TC.confirm(self.getLocaleString('cb.mapCreation.warning.reasonCount', {
                                mapName: options.mapName,
                                resourceCount: formatNumber(resourceCount),
                                maxResourceCount: formatNumber(maxResourceCount)
                            }), startRequest);
                        }
                        else {
                            startRequest();
                        }
                    };
                    requestManifest()
                        .then(function (obj) {
                            manifestResourceCount = obj.urls.length;
                            confirmRequest();
                        })
                        .catch(confirmRequest);
                }
                else {
                    startRequest();
                }
            }
        }
    };

    ctlProto.cacheUrlList = function (urlList, options) {
        var self = this;
        var opts = options || {};
        self.createCache(opts.name || (self.LOCAL_STORAGE_KEY_PREFIX + self.ROOT_CACHE_NAME), {
            urlList: urlList,
            silent: opts.silent
        });
    };

    ctlProto.requestCache = function (options) {
        var self = this;
        var opts = options || {};
        if (self.map) {
            var extent = opts.extent || self.extent || self.map.getExtent();
            self.updateRequestSchemas({ extent: extent });

            if (self.requestSchemas) {
                var filterTml = function (elm, i, arr) {
                    var result = elm.res >= self.minResolution;
                    if (!result && i > 0) {
                        result = arr[i - 1].res > self.minResolution;
                    }
                    return result;
                };
                var trimTml = function (tml) {
                    return {
                        mId: tml.mId,
                        cl: tml.cl,
                        cr: tml.cr,
                        rt: tml.rt,
                        rb: tml.rb
                    };
                };
                // Solo mantenemos los esquemas hasta el nivel de resolución mínima o el inmediatamente inferior a ella si no lo tiene
                var requestSchemas = self.requestSchemas.map(function (schema) {
                    return {
                        layerId: schema.layerId,
                        tileMatrixLimits: schema.tileMatrixLimits.filter(filterTml)
                    };
                });
                // Actualizamos el extent para que coincida con las teselas del último nivel de los esquemas
                // También eliminamos del esquema todo lo irrelevante para la petición
                var intersectionExtent = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (var i = 0, len = requestSchemas.length; i < len; i++) {
                    var rs = requestSchemas[i];
                    var tml = rs.tileMatrixLimits[rs.tileMatrixLimits.length - 1];
                    var unitsPerTile = tml.res * tml.tSize;
                    intersectionExtent[0] = Math.min(intersectionExtent[0], tml.origin[0] + unitsPerTile * tml.cl);
                    intersectionExtent[1] = Math.min(intersectionExtent[1], tml.origin[1] - unitsPerTile * (tml.rb + 1));
                    intersectionExtent[2] = Math.max(intersectionExtent[2], tml.origin[0] + unitsPerTile * (tml.cr + 1));
                    intersectionExtent[3] = Math.max(intersectionExtent[3], tml.origin[1] - unitsPerTile * tml.rt);
                    rs.tileMatrixLimits = rs.tileMatrixLimits.map(trimTml);
                }


                // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                var precision = Math.pow(10, self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION);
                intersectionExtent = intersectionExtent.map(function (elm, idx) {
                    var round = (idx < 3) ? Math.ceil : Math.floor;
                    return round(elm * precision) / precision;
                });

                var mapDefinition = {
                    bBox: intersectionExtent,
                    res: Math.floor(self.minResolution * 1000) / 1000, // Redondeamos previamente para que por errores de redondeo no haya confusión al identificar un mapa
                    url: [],
                    tms: [],
                    format: [],
                    layers: new Array(self.baseLayers.length)
                };
                for (var i = 0, len = self.baseLayers.length; i < len; i++) {
                    var layer = self.baseLayers[i];
                    var layerUrl = layer.url.indexOf('//') === 0 ? location.protocol + layer.url : layer.url;
                    var urlIdx = $.inArray(layerUrl, mapDefinition.url);
                    if (urlIdx < 0) {
                        urlIdx = mapDefinition.url.push(layerUrl) - 1;
                    }
                    var tmsIdx = $.inArray(layer.matrixSet, mapDefinition.tms);
                    if (tmsIdx < 0) {
                        tmsIdx = mapDefinition.tms.push(layer.matrixSet) - 1;
                    }
                    var shortFormat = layer.format.substr(layer.format.indexOf('/') + 1);
                    var formatIdx = $.inArray(shortFormat, mapDefinition.format);
                    if (formatIdx < 0) {
                        formatIdx = mapDefinition.format.push(shortFormat) - 1;
                    }
                    mapDefinition.layers[i] = {
                        urlIdx: urlIdx,
                        id: layer.layerNames,
                        tmsIdx: tmsIdx,
                        formatIdx: formatIdx
                    };
                }

                var params = TC.Util.getQueryStringParams();
                var e = params[self.MAP_EXTENT_PARAM_NAME] = intersectionExtent.toString();
                params[self.MAP_DEFINITION_PARAM_NAME] = btoa(JSON.stringify(mapDefinition));
                if (self.serviceWorkerEnabled) {
                    params[self.SERVICE_WORKER_FLAG] = 1;
                }
                var u = location.origin + location.pathname.substr(0, location.pathname.lastIndexOf('/') + 1) + self.CACHE_REQUEST_PATH + '?' + $.param(params);
                self.currentMap = { name: opts.mapName, extent: e, url: u };
                self.isDownloading = true;

                // Guardado mediante service workers
                if (self.serviceWorkerEnabled) {
                    for (var i = 0, len = requestSchemas.length; i < len; i++) {
                        var schema = requestSchemas[i];
                        var urlPattern = null;
                        for (var j = 0, lenj = self.baseLayers.length; j < lenj; j++) {
                            var l = self.baseLayers[j];
                            if (l.id === schema.layerId) {
                                urlPattern = self.wrap.getGetTilePattern(l);
                                break;
                            }
                        }
                        if (urlPattern) {
                            urlList = [];
                            var idx = 0;
                            for (k = 0, lenk = schema.tileMatrixLimits.length; k < lenk; k++) {
                                var tml = schema.tileMatrixLimits[k];
                                for (l = tml.cl; l <= tml.cr; l++) {
                                    for (m = tml.rt; m <= tml.rb; m++) {
                                        urlList[idx++] = urlPattern.replace('{TileMatrix}', tml.mId).replace('{TileCol}', l).replace('{TileRow}', m);
                                    }
                                }
                            }
                            urlList.push(u);
                            self.cacheUrlList(urlList, { name: u });
                        }
                    }
                }
                else {
                    // Guardado mediante application cache
                    openCachedPage(self, u);
                }
            }
        }
    }

    ctlProto.cancelCacheRequest = function () {
        var self = this;
        if (self.currentMap) {
            closeCachedPage(self, self.currentMap.url);
            self.deleteCache(self.currentMap.url).then(function (obj) {
                if (!obj) {
                    self.currentMap = null;
                }
            });
        }
        self.isDownloading = false;
        self.setReadyState();
    };

    ctlProto.deleteMap = function (name) {
        var self = this;

        var map = self.findStoredMap({ name: name });
        if (map) {
            var params = TC.Util.getQueryStringParams(map.url);
            var errorCallback = function (request, status, error) {
                TC.error('[' + status + '] ' + error);
            };
            self.deleteCache(map.url).then(function (obj) {
                if (!obj) {
                    // Borrado de application cache
                    document.cookie = self.COOKIE_KEY_PREFIX + 'delete=' + atob(decodeURIComponent(params[self.MAP_DEFINITION_PARAM_NAME]));
                    openCachedPage(self, map.url);
                }
            });
        }
    };

    ctlProto.startDeleteMap = function (name) {
        const self = this;
        if (navigator.onLine) {
            if (name) {
                var confirmText = self.getLocaleString('cb.delete.confirm', { mapName: name });
                if (!self.serviceWorkerEnabled) {
                    confirmText = confirmText + " " + self.getLocaleString('cb.delete.confirm.connect.warning');
                }
                if (confirm(confirmText)) {
                    if (navigator.onLine) {
                        setDeletingState(self);
                        self.deleteMap(name);
                    } else {
                        TC.alert(self.getLocaleString('cb.delete.conn.alert'));
                    }
                }
            }
        } else {
            TC.alert(self.getLocaleString('cb.delete.conn.alert'));
        }
    };

    ctlProto.findStoredMap = function (options) {
        var self = this;
        return $.grep(self.storedMaps, function (elm) {
            var result = true;
            if (options.name && options.name !== elm.name) {
                result = false;
            }
            if (result && options.url && options.url !== elm.url) {
                result = false;
            }
            return result;
        })[0];
    };

    ctlProto.showDownloadProgress = function (current, total) {
        const self = this;
        const cs = self._classSelector;
        const count = self.div.querySelector(cs + '-progress-count');
        if (total) {
            var percent = Math.min(Math.round(current * 100 / total), 100);
            var percentString = percent + '%';
            self.div.querySelector(cs + '-progress-ratio').style.width = percentString;
            count.innerHTML = percentString;
        }
        else {
            self.div.querySelector(cs + '-progress-bar').classList.add(TC.Consts.classes.HIDDEN);
            count.innerHTML = self.getLocaleString('xFiles', { quantity: current });
        }
    };

    ctlProto.updateRequestSchemas = function (options) {
        var self = this;
        var opts = options || {};
        opts.extent = opts.extent || self.extent;
        opts.layers = opts.layers || self.baseLayers;
        self.requestSchemas = self.wrap.getRequestSchemas(opts);
        return self.requestSchemas;
    };

    ctlProto.getResolutions = function () {
        var self = this;
        var result = [];

        var resolutionMapper = function (tml) {
            return tml.res;
        };
        // Obtenemos un array de resoluciones por cada esquema de cada capa
        var allResolutions = self.requestSchemas.map(function (schema) {
            return schema.tileMatrixLimits.map(resolutionMapper);
        });

        // "Hacemos la cremallera" con los arrays de resoluciones de todas las capas
        // y obtenemos uno que tenga todas las resoluciones dentro del rango de resoluciones común a todas las capas

        // Obtenemos el rango de resoluciones
        var maxRes = Number.POSITIVE_INFINITY;
        var minRes = 0;
        for (var i = 0, len = allResolutions.length; i < len; i++) {
            var ri = allResolutions[i];
            maxRes = Math.min(maxRes, ri[0]);
            minRes = Math.max(minRes, ri[ri.length - 1]);
        }
        // Quitamos resoluciones fuera del rango y el resto las añadimos al array de resultados
        for (var i = 0, len = allResolutions.length; i < len; i++) {
            result = result.concat(allResolutions[i].filter(function (elm) {
                return elm <= maxRes && elm >= minRes && result.indexOf(elm) < 0;
            }));
        }
        result.sort(function (a, b) {
            return b - a;
        });
        return result;
    };

})();

﻿TC.control = TC.control || {};

if (!TC.control.Container) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control/Container');
}

TC.control.ControlContainer = function () {
    var self = this;

    TC.control.Container.apply(self, arguments);

    var cs = self._classSelector = '.' + self.CLASS;
};

TC.inherit(TC.control.ControlContainer, TC.control.Container);

(function () {
    var ctlProto = TC.control.ControlContainer.prototype;

    ctlProto.CLASS = 'tc-ctl-cctr';
    ctlProto.SIDE = {
        LEFT: "left",
        RIGHT: "right"
    };

    ctlProto.template = {};
    if (TC.isDebug) {        
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ControlContainer.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/ControlContainerNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.write("<ul class=\"tc-ctl-cctr-left\">").section(ctx.get("controls"), ctx, { "block": body_1 }, null).write("</ul><ul class=\"tc-ctl-cctr-right\">").section(ctx.get("controls"), ctx, { "block": body_3 }, null).write("</ul>"); } function body_1(chk, ctx) { return chk.helper("eq", ctx, { "block": body_2 }, { "key": ctx.get("side"), "value": "left" }); } function body_2(chk, ctx) { return chk.write("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").reference(ctx.get("index"), ctx, "h").write("\"><div></div></li>"); } function body_3(chk, ctx) { return chk.helper("eq", ctx, { "block": body_4 }, { "key": ctx.get("side"), "value": "right" }); } function body_4(chk, ctx) { return chk.write("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").reference(ctx.get("index"), ctx, "h").write("\"><div></div></li>"); } return body_0; };        
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.w("<li class=\"tc-ctl-cctr-elm tc-ctl-cctr-elm-").f(ctx.get(["index"], false), ctx, "h").w("\"><div></div></li>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.onRenderPromise = function () {
        const self = this;

        var bufferPromises = new Array(self.ctlCount);

        Object.keys(self.controlOptions).forEach(function (key, i) {
            var ctl = self.controlOptions[key];            
            bufferPromises[i] = self.map.addControl(key, $.extend({
                id: self.uids[i],
                div: self.div.querySelector('.' + self.CLASS + '-elm-' + i).querySelector('div')
            }, ctl.options));
        });

        Promise.all(bufferPromises).then(function () {
            for (var i = 0, len = arguments.length; i < len; i++) {
                var ctl = arguments[i];
                ctl.containerControl = self;
            }
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData({
            controls: Object.keys(self.controlOptions).map(function (key, i) {
                return $.extend(self.controlOptions[key], { index: i });
            })
        }));
    };

    ctlProto.addControl = function (control, options) {
        const self = this;
        options.side = options.side || self.SIDE.LEFT;

        return new Promise(function (resolve, reject) {
            self.getRenderedHtml(self.CLASS + '-node', { index: ++self.ctlCount }, function (html) {
                var template = document.createElement('template');
                template.innerHTML = html.trim();

                self.div.querySelector('ul.' + self.CLASS + '-' + options.side).appendChild(template.content ? template.content.firstChild : template.firstChild);
                self.map.addControl(control, $.extend({
                    id: self.getUID(),
                    div: self.div.querySelector('.' + self.CLASS + '-elm-' + self.ctlCount).querySelector('div')
                }, options)).then(function (ctrl) {
                    resolve(ctrl);
                });
            });
        });
    };

    ctlProto.addElement = function (options) {
        const self = this;

        options.side = options.side || self.SIDE.LEFT;

        var li = document.createElement('li');
        li.setAttribute('class', (self.CLASS + '-elm ') + (self.CLASS + '-elm-' + self.ctlCount++ + ' '));

        self.div.querySelector('ul.' + self.CLASS + '-' + options.side).appendChild(li);

        var addedElement = li.appendChild(options.htmlElement);
        addedElement.setAttribute('class', addedElement.getAttribute('class') + ' tc-ctl');
        return addedElement;
    };
})();

﻿TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

TC.control.Coordinates = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.crs = '';
    self.xy = [0, 0, 0];
    self.latLon = [0, 0, 0];
    self.x = 0;
    self.y = 0;
    self.lat = 0;
    self.lon = 0;
    self.units = TC.Consts.units.METERS;
    self.isGeo = false;

    TC.control.ProjectionSelector.apply(self, arguments);

    $.extend(self._cssClasses, {
        CRS: self.CLASS + '-crs',
        GEOCRS: self.CLASS + '-geocrs',
        X: self.CLASS + '-x',
        Y: self.CLASS + '-y',
        LAT: self.CLASS + '-lat',
        LON: self.CLASS + '-lon',
        ELEVATION: self.CLASS + '-elevation',
        THREEDMARKER: self.CLASS + '-threed'
    });

    self.geoCrs = self.options.geoCrs || TC.Cfg.geoCrs;
    self.wrap = new TC.wrap.control.Coordinates(self);
};

TC.inherit(TC.control.Coordinates, TC.control.ProjectionSelector);

(function () {
    var ctlProto = TC.control.Coordinates.prototype;

    ctlProto.CLASS = 'tc-ctl-coords';

    var _dataKeys = {
        PROJCODE: 'tcProjCode'
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Coordinates.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/CoordinatesDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div>CRS: <span class=\"tc-ctl-coords-crs\">").f(ctx.get(["crs"], false), ctx, "h").w("</span><button class=\"tc-ctl-coords-crs\" title=\"").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("\">").f(ctx.get(["crs"], false), ctx, "h").w("</button></div><div class=\"tc-ctl-coords-xy\">").x(ctx.get(["isGeo"], false), ctx, { "else": body_1, "block": body_3 }, {}).w("</div>").x(ctx.get(["showGeo"], false), ctx, { "block": body_5 }, {}).w("<span class=\"close\"></span>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("x: <span class=\"tc-ctl-coords-x\">").f(ctx.get(["x"], false), ctx, "h").w("</span> y: <span class=\"tc-ctl-coords-y\">").f(ctx.get(["y"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("z: <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-coords-lat\">").f(ctx.get(["lat"], false), ctx, "h").w("</span> ").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-coords-lon\">").f(ctx.get(["lon"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_4 }, {}); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<div class=\"tc-ctl-coords-alt\"><div class=\"tc-ctl-coords-xy\">").h("i18n", ctx, {}, { "$key": "lat" }).w(": <span class=\"tc-ctl-coords-lat\">").f(ctx.get(["lat"], false), ctx, "h").w("</span> ").h("i18n", ctx, {}, { "$key": "lon" }).w(": <span class=\"tc-ctl-coords-lon\">").f(ctx.get(["lon"], false), ctx, "h").w("</span> ").x(ctx.get(["ele"], false), ctx, { "block": body_6 }, {}).w("</div></div>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }).w(": <span class=\"tc-ctl-coords-elevation\">").f(ctx.get(["ele"], false), ctx, "h").w("</span> "); } body_6.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-coords-crs-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "coords.currentProjection|h" }).w("</p><p class=\"tc-ctl-coords-no-change\">").h("i18n", ctx, {}, { "$key": "coords.noCrs.warning|s" }).w("</p><div class=\"tc-ctl-coords-change\"><p>").h("i18n", ctx, {}, { "$key": "coords.instructions|s" }).w("</p><p class=\"tc-msg-warning tc-hidden\">").h("i18n", ctx, {}, { "$key": "coords.instructions.warning|s" }).w("</p></div><ul class=\"tc-ctl-coords-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        self.crs = self.map.crs;

        self.clear();

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            if (view === TC.Consts.view.PRINTING) {
                return;
            }

            const _3dContainerListener = function (e) {
                if (!self.isPointerOver(e)) {
                    self.clear();
                }
            };

            if (view === TC.Consts.view.THREED) {
                self.isGeo = true;
                self.units = TC.Consts.units.DEGREES;
                self.crs = self.map.view3D.crs;

                self.map.view3D.container.addEventListener('mouseout', _3dContainerListener);

                /* provisional: faltaría el off cuando pasemos a default*/
                self.map.view3D.on(TC.Consts.event.MOUSEMOVE, function (coords) {
                    if (coords) {
                        if (TC.Util.detectMobile()) { // si estamos en móvil añadimos marcador al mapa 3D                            

                            self.clear();

                            self.coordsToClick({ coordinate: [coords.lon, coords.lat, coords.ele], cssClass: self._cssClasses.THREEDMARKER });
                        }

                        self.latLon = [coords.lat, coords.lon];
                        if (coords.ele > 0) {
                            var locale = TC.Util.getMapLocale(self.map);
                            self.latLon.push(coords.ele.toLocaleString(locale) + "m");
                        }

                        self.update();
                    } else {
                        self.clear();
                    }
                });

            } else if (view === TC.Consts.view.DEFAULT) {
                self.isGeo = self.map.wrap.isGeo();
                self.units = TC.Consts.units.METERS;
                self.crs = self.map.crs;

                if (self.map.view3D) {
                    self.map.view3D.container.removeEventListener('mouseout', _3dContainerListener);
                }                
            }

            if (self.map.view3D) {
                self.geoCrs = self.map.view3D.crs;
                self.render();
            }            
        });

        map.loaded(function () {
            // Se espera antes de registrar el control a que se cargue el mapa para evitar que muestre valores extraños
            self.wrap.register(map).then(function () {
                self.render(function () {
                    //self.update();
                    self.clear();
                });
            });

            if (TC.Util.detectMobile()) {
                self.renderPromise().then(function () {
                    self.getLayer();
                    self.activateCoords();
                });                
            }

            map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                if (!map.on3DView) {
                    self.isGeo = map.wrap.isGeo();
                    self.crs = e.crs;
                    self.render();
                }                
            });

            self.map.wrap.getViewport().then(function (viewport) {
                self.renderPromise().then(function () {
                    viewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {
                        if (self.map.on3DView) {
                            return;
                        }

                        self.onMouseMove(e);
                    });
                    viewport.addEventListener(TC.Consts.event.MOUSELEAVE, function (e) {
                        self.onMouseLeave(e);
                    });
                });                
            });
        });

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.renderData.call(self, {
                x: self.x,
                y: self.y,
                lat: self.lat,
                lon: self.lon,
                ele: self.isGeo && self.latLon.length > 2 ? self.latLon[2] : (!self.isGeo && self.xy.length > 2 ? self.xy[2] : null),
                crs: self.crs,
                geoCrs: self.geoCrs,
                isGeo: self.isGeo,
                showGeo: !self.isGeo && self.options.showGeo
            }, function () {
                self.div.querySelector('button.' + self._cssClasses.CRS).addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.showProjectionChangeDialog();
                });

                //self.div.addEventListener('mousemove', function (e) {
                //    self.setVisibility([e.clientX, e.clientY]);
                //});

                if ($.isFunction(callback)) {
                    callback();
                }
            });
        }));
    };

    ctlProto.onMouseMove = function (e) {
        this.wrap.onMouseMove(e);
    };

    ctlProto.onMouseLeave = function (e) {
        const self = this;
        setTimeout(function () {
            if (!self.isPointerOver(e)) {
                self.div.style.visibility = 'hidden';
                self.clear();
            }
        }, 200);
    };

    ctlProto.isPointerOver = function (e) {
        var self = this;

        var clientRect = self.div.getBoundingClientRect();
        return (clientRect.left <= e.clientX &&
            clientRect.left + clientRect.width >= e.clientX &&
            clientRect.top <= e.clientY &&
            clientRect.top + clientRect.height >= e.clientY);
    };

    ctlProto.formatCoord = function (x, nDecimales) {
        var result;
        result = x.toFixed(nDecimales);
        if (nDecimales <= 3) {
            result = result.replace(/\B(?=(\d{3})+(?!\d))/g, "|");
        }
        result = result.replace(".", ",").replace(/\|/g, ".");
        return result;
    };

    ctlProto.update = function () {
        const self = this;

        if (!self.isGeo && self.options.showGeo) {
            self.latLon = TC.Util.reproject(self.xy, self.crs, self.geoCrs).reverse();
        }

        if (!self.isGeo) {
            self.x = self.formatCoord(self.xy[0], TC.Consts.METER_PRECISION);
            self.y = self.formatCoord(self.xy[1], TC.Consts.METER_PRECISION);
        }

        if (self.isGeo || self.options.showGeo) {
            self.lat = self.formatCoord(self.latLon[0], TC.Consts.DEGREE_PRECISION);
            self.lon = self.formatCoord(self.latLon[1], TC.Consts.DEGREE_PRECISION);
        }

        self.render(function () {
            const closeSpan = self.div.querySelector('span.close');
            if (TC.Util.detectMobile()) {
                closeSpan.addEventListener('click', function () {
                    self.div.classList.add(TC.Consts.classes.HIDDEN);
                    self.clear();
                });

                closeSpan.style.display = '';
            }
            else {
                self.div.classList.remove(TC.Consts.classes.HIDDEN);
                self.div.style.visibility = 'visible';
                closeSpan.style.display = 'none';
            }
        });
    };

    ctlProto.clear = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.div.style.visibility = 'hidden';

        delete self.currentCoordsMarker;
        self.getLayer().then(function (layer) {
            layer.clearFeatures();
        });
    };

    ctlProto.deactivateCoords = function () {
        var self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);
        self.clear();

        self.wrap.coordsDeactivate();
    };

    ctlProto.activateCoords = function () {
        var self = this;

        self.wrap.coordsActivate();
    };

    ctlProto.getCoords = function () {
        var self = this;
        // si hay visible un popup, establecemos la posición de la cruz en el punto en el cual se ha abierto el popup
        var popup = self.map.getControlsByClass(TC.control.Popup);
        if (popup && popup.length > 0 && popup[0].isVisible()) {
            self.coordsToPopup(popup[0]);
        }
        else { // si no hay popup, calculamos el centro del mapa                
            self.updateCoordsCtrl([(self.map.getExtent()[0] + self.map.getExtent()[2]) / 2, (self.map.getExtent()[1] + self.map.getExtent()[3]) / 2]);

            self.coordsToClick.call(self, { coordinate: self.xy });
        }
    };

    ctlProto.coordsToPopup = function (popup) {
        var self = this;

        if (popup) {
            self.updateCoordsCtrl(popup.wrap.popup.getPosition());
        }
    };

    ctlProto.updateCoordsCtrl = function (position) {
        var self = this;

        if (position) {
            if (!self.isGeo) {
                self.x = position[0];
                self.y = position[1];
                self.xy = [self.x, self.y];

                if (position.length > 2) {
                    self.xy.push(position[2]);
                }
            }
            if (self.isGeo || self.options.showGeo) {
                self.lat = position[0];
                self.lon = position[1];
                self.latLon = [self.lat, self.lon];

                if (position.length > 2) {
                    self.latLon.push(position[2]);
                }
            }

            self.update();
        }
    };

    // Establece la posición de la cruz en la posición recibida
    var animationTimeout;
    ctlProto.coordsToClick = function (e) {
        var self = this;

        // Si streetView está activo, no responde al click
        if (!self.map.div.classList.contains('tc-ctl-sv-active ' + TC.Consts.classes.COLLAPSED)) {

            var coordsBounding = self.div.getBoundingClientRect();
            if ((coordsBounding.left <= e.clientX && e.clientX <= coordsBounding.right && coordsBounding.top <= e.clientY && e.clientY <= coordsBounding.bottom)) {
                self.div.classList.add(TC.Consts.classes.HIDDEN);
                self.clear();

                return;
            }

            $(self.div).stop(true, true);

            if (animationTimeout)
                clearTimeout(animationTimeout);

            self.updateCoordsCtrl(e.coordinate);

            if (!self.map.on3DView) {
                self.coordsMarkerAdd(e.coordinate, e.cssClass);
            }

            self.div.classList.remove(TC.Consts.classes.HIDDEN);
            self.div.style.visibility = 'visible';

            self.div.style.opacity = '0.7';

            animationTimeout = setTimeout(function () {
                $(self.div).animate({ opacity: 0 }, 3000, "linear",
                    function () {
                        self.clear();
                    });
            }, 5000);
        }
    };

    ctlProto.coordsMarkerAdd = function (position, cssClass) {
        var self = this;

        if (!self.currentCoordsMarker) {
            self.getLayer().then(function (layer) {
                layer.addMarker(position, { title: 'Coord', showsPopup: false, cssClass: cssClass || TC.Consts.classes.POINT, anchor: [0.5, 0.5] })
                    .then(function (marker) {
                        self.currentCoordsMarker = marker;
                    });
            });
        } else {
            self.currentCoordsMarker.setCoords(position);
        }
    };

    ctlProto.getLayer = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer == undefined) {
                self.map.addLayer({
                    id: self.getUID(),
                    type: TC.Consts.layerType.VECTOR,
                    stealth: true,
                    title: 'Coordenadas',
                }).then(function (layer) {
                    self.layer = layer;
                    self.layer.map.putLayerOnTop(self.layer);
                    resolve(self.layer);
                });
            } else {
                resolve(self.layer);
            }
        });
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.DataLoader = function () {
    const self = this;

    TC.control.TabContainer.apply(self, arguments);

    self.controlOptions = [
        {
            name: 'externalWMS',
            title: 'addWMS',
            options: {
                suggestions: self.options.wmsSuggestions
            }
        },
        {
            name: 'fileImport',
            options: {
                enableDragAndDrop: self.options.enableDragAndDrop
            }
        }
    ];
    self.defaultSelection = 0;
};

TC.inherit(TC.control.DataLoader, TC.control.TabContainer);

(function () {
    var ctlProto = TC.control.DataLoader.prototype;

    ctlProto.register = function (map) {
        const self = this;
        self.title = self.getLocaleString('addMaps');
        return TC.control.TabContainer.prototype.register.call(self, map);
    };

})();

﻿TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

TC.control.Download = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self._hiddenElms = [];

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    self._$dialogDiv = $(self._dialogDiv);
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }    
};

TC.inherit(TC.control.Download, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Download.prototype;

    ctlProto.CLASS = 'tc-ctl-download';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Download.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/DownloadDialog.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "download" }).w(" </h2><div class=\"tc-ctl-tctr tc-ctl-tctr-select\"><form><label class=\"tc-ctl-tctr-tab tc-ctl-download-image\" style=\"width:calc(100%/2 - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"image\" /><span>").h("i18n", ctx, {}, { "$key": "dl.export.map" }).w("</span></label><label class=\"tc-ctl-tctr-tab tc-ctl-download-data\" style=\"width:calc(100%/2 - 1px)\"><input type=\"radio\" name=\"sctnr-sel\" value=\"data\" /><span>").h("i18n", ctx, {}, { "$key": "dl.export.vector" }).w("</span></label></form></div><div class=\"tc-ctl tc-ctl-tctr-elm tc-ctl-tctr-elm-image tc-group tc-ctl-download-cnt tc-ctl-download-image tc-collapsed\"><div><label>").h("i18n", ctx, {}, { "$key": "format" }).w(":</label><select id=\"download-format-image\" class=\"tc-combo\"><option value=\"image/png\">PNG</option><option value=\"image/jpeg\">JPEG</option></select><div class=\"tc-ctl-download-div\"><input id=\"tc-ctl-download-image-qr\" class=\"tc-hidden\" type=\"checkbox\" checked style=\"display:none;\" /><label for=\"tc-ctl-download-image-qr\" class=\"tc-ctl-download-image-qr-label\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCodeToImage" }).w("\">").h("i18n", ctx, {}, { "$key": "appendQRCode" }).w("</label></div><div class=\"tc-group tc-group tc-ctl-download-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-ctl-download-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "downloadImageFromCurrentMap" }).w("\" name=\"descargar\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button></div><div class=\"tc-ctl-download-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div></div><div class=\"tc-ctl tc-ctl-tctr-elm tc-ctl-tctr-elm-data tc-group tc-ctl-download-cnt tc-collapsed\"><div><label>").h("i18n", ctx, {}, { "$key": "format" }).w(":</label><select id=\"download-format\" class=\"tc-combo\"><option value=\"GML32\">GML</option><option value=\"application/json\">GeoJSON</option><option value=\"application/vnd.google-earth.kml+xml\">KML (Google Earth)</option><option value=\"shape-zip\">Shape (ESRI)</option></select><div class=\"tc-ctl-download-div\"><i class=\"tc-ctl-download-help icon-question-sign\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "showDownloadHelp" }).w("\"></i></div><div class=\"tc-group tc-group tc-ctl-download-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-ctl-download-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "downloadLayersFromCurrentExtent" }).w("\" name=\"descargar\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button></div><div class=\"tc-alert alert-warning tc-hidden\"><p id=\"zoom-msg\"><strong>").h("i18n", ctx, {}, { "$key": "tooManyFeatures" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "tooManyFeatures.instructions" }).w("</p><p id=\"layers-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noLayersLoaded" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noLayersLoaded.instructions" }).w("</p><p id=\"url-msg\"><strong>").h("i18n", ctx, {}, { "$key": "tooManySelectedLayers" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "tooManySelectedLayers.instructions" }).w("</p><p id=\"noFeatures-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noData" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noData.instructions" }).w("</p><p id=\"novalid-msg\"><strong>").h("i18n", ctx, {}, { "$key": "noValidService" }).w(": </strong>").h("i18n", ctx, {}, { "$key": "noValidService.instructions" }).w("</p></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-download-help-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "downloadData" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "dl.instructions.1|s" }).w("</p><ul><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.2|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.3|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.4|s" }).w("<ul><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.5|s" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "dl.instructions.6|s" }).w("</li></ul></li></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, function () {

                const cs = '.tc-ctl-tctr';
                self._selectors = {
                    TAB: cs + '-tab',
                    RADIOBUTTON: 'input[type=radio][name=sctnr-sel]',
                    ELEMENT: cs + '-elm'
                };

                const clickHandler = function (e) {
                    var tab = this;
                    while (tab && !tab.matches(self._selectors.TAB)) {
                        tab = tab.parentElement;
                    }
                    if (tab) {
                        const checkbox = tab.querySelector(self._selectors.RADIOBUTTON);
                        const newValue = checkbox.value;
                        const elms = self.div.querySelectorAll(self._selectors.ELEMENT);
                        if (self._oldValue === newValue && self.options.deselectable) {
                            setTimeout(function () {
                                checkbox.checked = false;
                            }, 0);
                            self._oldValue = null;
                            self._activeElm = null;
                            elms.forEach(function (elm) {
                                self._hiddenElms.push(elm);
                            });
                        }
                        else {
                            elms.forEach(function (elm) {
                                if (elm.matches(self._selectors.ELEMENT + '-' + newValue)) {
                                    self._activeElm = elm;
                                }
                                else {
                                    self._hiddenElms.push(elm);
                                }
                            });
                            self._oldValue = newValue;
                        }

                        self._hiddenElms.forEach(function (elm) {
                            elm.classList.add(TC.Consts.classes.COLLAPSED);
                        });
                        if (self._activeElm) {
                            self._activeElm.classList.remove(TC.Consts.classes.COLLAPSED);
                        }
                        checkbox.checked = true;
                    }
                };

                self.div.querySelectorAll('span').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, clickHandler);
                });
                if (callback) {
                    callback();
                }
            });
        });
    };

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        /**
         * Descarga las features de las capas de trabajo actualmente seleccionadas. Comprueba que el número de features a descargar
         * no excede el límite impuesto por el servidor.
         */       

        var _download = function () {
            var wait = self.map.getLoadingIndicator().addWait();

            var format = '';
            if (self._activeElm) {
                format = self._activeElm.querySelector('select').value;
            }
            if (format.indexOf('image') > -1) {
                const doneQR = new Promise(function (resolve, reject) {
                    var canvas = self.map.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];
                    var newCanvas = TC.Util.cloneCanvas(canvas);

                    var sb = self.map.getControlsByClass(TC.control.ScaleBar);
                    if (sb) {
                        self.drawScaleBarIntoCanvas({ canvas: newCanvas, fill: true });
                    }

                    if (self._activeElm.querySelector('#' + self.CLASS + '-image-qr:checked')) {
                        const codeContainerId = 'qrcode';
                        var codeContainer = document.getElementById(codeContainerId);
                        if (codeContainer) {
                            codeContainer.innerHTML = '';
                        }
                        else {
                            codeContainer = document.createElement('div');
                            codeContainer.setAttribute('id', codeContainerId);
                            document.body.appendChild(codeContainer);
                        }

                        codeContainer.style.top = '-200px';
                        codeContainer.style.left = '-200px';
                        codeContainer.style.position = 'absolute';

                        self.makeQRCode(codeContainer, 87, 87).then(function (qrCodeBase64) {
                            if (qrCodeBase64) {
                                var ctx = newCanvas.getContext("2d");
                                ctx.fillStyle = "#ffffff";
                                ctx.fillRect(newCanvas.width - 91, newCanvas.height - 91, 91, 91);

                                TC.Util.addToCanvas(newCanvas, qrCodeBase64, { x: newCanvas.width - 88, y: newCanvas.height - 88 }).then(function (mapCanvas) {
                                    resolve(mapCanvas);
                                });
                            } else {
                                TC.error(self.getLocaleString('dl.export.map.error') + ': ' + 'QR');
                                self.map.getLoadingIndicator().removeWait(wait);
                            }
                        });
                    } else {
                        resolve(newCanvas);
                    }
                });

                doneQR.then(function (_canvas) {
                    try {
                        const res = _canvas.toDataURL(format);
                        TC.Util.downloadDataURI(window.location.hostname + '_' + TC.Util.getFormattedDate(new Date().toString(), true) + '.' + format.split('/')[1], format, res);
                    } catch (e) {
                        TC.error(self.getLocaleString('dl.export.map.error') + ': ' + e.message);
                    }

                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
            else {
                var extent = self.map.getExtent();
                var coordsXY = TC.Util.reproject(extent.slice(0, 2), self.map.crs, TC.Defaults.crs);
                var coordsXY2 = TC.Util.reproject(extent.slice(2), self.map.crs, TC.Defaults.crs);

                var arrPromises = TC.WFSGetFeatureBuilder(self.map, new TC.filter.bbox([coordsXY[0], coordsXY[1], coordsXY2[0], coordsXY2[1]]), format, true);
                Promise.all(arrPromises).then(function (responseArray) {

                    var responses = $.grep(responseArray, function (item) { return item != null });
                    if (responses.length === 0) {
                        _showAlertMsg({ key: TC.Consts.WFSErrors.NoLayers }, wait);
                        return;
                    }
                    var arrDownloads = [];
                    for (var i = 0; i < responses.length; i++) {
                        //errores del WFS
                        if (responses[i].errors && responses[i].errors.length) {
                            for (var j = 0; j < responses[i].errors.length; j++) {
                                var error = responses[i].errors[j];
                                _showAlertMsg(error, wait);
                            }
                            continue;
                        }
                        var data = responses[i].data;
                        var url = responses[i].url;
                        if (data && url)
                            arrDownloads.push({ url: url + "?download=zip", data: data });
                    }

                    TC.Util.downloadFileForm(arrDownloads);
                    self.map.getLoadingIndicator().removeWait(wait);
                });
            }
        };

        /**
         * Comprueba si hay capas visibles en el panel de capas cargadas.
         */
        var _getVisibleLayers = function () {
            var visibleLayers = [];
            for (var i = 0; i < self.map.workLayers.length; i++) {
                var layer = self.map.workLayers[i];
                if (layer.type === TC.Consts.layerType.WMS) {
                    if (layer.getVisibility() && layer.names.length > 0) {
                        visibleLayers.push(layer);
                    }
                }
            }
            return visibleLayers;
        };

        var _showAlertMsg = function (error, wait) {
            const alert = self.div.querySelector('.alert-warning:not(.' + self.CLASS + '-alert)');
            var errorMsg;
            switch (error.key) {
                case TC.Consts.WFSErrors.NumMaxFeatures:
                    errorMsg = alert.querySelector("#zoom-msg").innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NoLayers:
                    errorMsg = self.getLocaleString('noLayersLoaded');
                    break;
                case TC.Consts.WFSErrors.GetCapabilities:
                    errorMsg = alert.querySelector("#novalid-msg").innerHTML.format({ serviceName: error.params.serviceTitle });
                    break;
                case TC.Consts.WFSErrors.NoFeatures:
                    errorMsg = alert.querySelector("#noFeatures-msg").innerHTML;
                    break;
                case TC.Consts.WFSErrors.Indeterminate:
                    errorMsg = self.getLocaleString("wfs.IndeterminateError");
                    self.map.toast(errorMsg, { type: TC.Consts.msgType.ERROR });
                    TC.error("Error:{error} \r\n Descripcion:{descripcion} \r\n Servicio:{serviceName}".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);
                    self.map.getLoadingIndicator().removeWait(wait);
                    return
                    break;
                default:
                    errorMsg = self.getLocaleString("wfs." + error.key, error.params);
                    break;
            }
            self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

            self.map.getLoadingIndicator().removeWait(wait);
        };

        var _showHelp = function (evt) {
            evt.stopPropagation();
            TC.Util.showModal(self._dialogDiv.querySelector(self._classSelector + '-help-dialog'));
        };

        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-btn', _download));
        self.div.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('.tc-ctl-download-help', _showHelp));

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector("#" + self.CLASS + "-image-qr", function (e) {
            if (e.target.checked) {
                self.generateLink();
            } else {
                self.div.querySelector('.' + self.CLASS + '-alert').classList.add(TC.Consts.classes.HIDDEN);
            }
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {            
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;
        const alert = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.getElementById(self.CLASS + '-image-qr').checked) {
            if (maxLengthExceed.qr) {
                alert.classList.remove(TC.Consts.classes.HIDDEN);
            } else if (!maxLengthExceed.qr) {
                alert.classList.add(TC.Consts.classes.HIDDEN);
            }
        } else {
            alert.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}
if (!TC.Feature || !TC.feature.Point) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Point');
}
if (!TC.Feature || !TC.feature.Polyline) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polyline');
}
if (!TC.Feature || !TC.feature.Polygon) {
    TC.syncLoadJS(TC.apiLocation + 'TC/feature/Polygon');
}

TC.Consts.event.DRAWSTART = 'drawstart.tc';
TC.Consts.event.DRAWEND = 'drawend.tc';
TC.Consts.event.DRAWCANCEL = 'drawcancel.tc';
TC.Consts.event.DRAWUNDO = 'drawundo.tc';
TC.Consts.event.DRAWREDO = 'drawredo.tc';
TC.Consts.event.MEASURE = 'measure.tc';
TC.Consts.event.MEASUREPARTIAL = 'measurepartial.tc';
TC.Consts.event.STYLECHANGE = 'stylechange.tc';
TC.Consts.event.CHANGE = 'change';

(function () {

    const formatColor = function (color) {
        const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
        if (match && match.length) {
            return '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
        }
        return color;
    };

    TC.control.Draw = function () {
        var self = this;

        TC.Control.apply(self, arguments);

        if (!Modernizr.inputtypes.color && !window.CP) {
            TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
            TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
        }

        self._classSelector = '.' + self.CLASS;

        self._pointClass = self.CLASS + '-point';
        self._lineClass = self.CLASS + '-line';
        self._polygonClass = self.CLASS + '-polygon';

        self.history = [];
        self.historyIndex = 0;
        self.exportsState = true;

        self
            .on(TC.Consts.event.DRAWSTART, function (e) {
                self.resetValues();
            })
            .on(TC.Consts.event.POINT, function (e) {
                if (self.layer && !self.persistent && self.layer.features && self.layer.features.length > 0) {
                    self.layer.clearFeatures();
                }

                self.history.length = self.historyIndex;
                self.history[self.historyIndex++] = e.point;

                setDrawState(self);
            })
            .on(TC.Consts.event.DRAWEND, function (e) {
                setFeatureAddReadyState(self);

                e.feature.setId(TC.getUID(self.getLocaleString('sketch') + '.'));

                if (self.callBack) {
                    self.callBack(e.feature);
                }
            });

        self._layerPromise = null;
    };

    TC.inherit(TC.control.Draw, TC.Control);

    var ctlProto = TC.control.Draw.prototype;

    ctlProto.CLASS = 'tc-ctl-draw';

    var setDrawState = function (ctl) {
        ctl._endBtn.disabled =
            ctl.historyIndex === 0 ||
            (ctl.mode === TC.Consts.geom.POLYGON && ctl.historyIndex < 3) ||
            (ctl.mode === TC.Consts.geom.POLYLINE && ctl.historyIndex < 2);
        ctl._redoBtn.disabled = ctl.history.length === ctl.historyIndex;
        ctl._undoBtn.disabled = ctl.historyIndex === 0;
    };

    var setFeatureAddReadyState = function (ctl) {
        ctl.resetValues();
        ctl._endBtn.disabled = true;
        ctl._cancelBtn.disabled = false;
    };

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Draw.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-draw-tools\"><button class=\"tc-ctl-btn tc-ctl-draw-btn-new\" title=\"").f(ctx.get(["tooltip"], false), ctx, "h").w("\">").h("i18n", ctx, {}, { "$key": "new" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-undo\" disabled title=\"").h("i18n", ctx, {}, { "$key": "undo" }).w("\">").h("i18n", ctx, {}, { "$key": "undo" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-redo\" disabled title=\"").h("i18n", ctx, {}, { "$key": "redo" }).w("\">").h("i18n", ctx, {}, { "$key": "redo" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-end\" disabled title=\"").h("i18n", ctx, {}, { "$key": "end" }).w("\">").h("i18n", ctx, {}, { "$key": "end" }).w("</button><button class=\"tc-ctl-btn tc-ctl-draw-btn-cancel\" title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div>").x(ctx.get(["styleTools"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-draw-style\">").h("i18n", ctx, {}, { "$key": "strokeColor" }).w("<input type=\"color\" class=\"tc-ctl-col tc-ctl-draw-str-c\" value=\"").f(ctx.get(["strokeColor"], false), ctx, "h").w("\" title=\"").h("i18n", ctx, {}, { "$key": "selectColor" }).w("\" />").h("i18n", ctx, {}, { "$key": "strokeWidth" }).w("<div class=\"tc-ctl-draw-str-w-watch\" style=\"border-bottom-width:").f(ctx.get(["strokeWidth"], false), ctx, "h").w("px;\"> </div><input type=\"number\" class=\"tc-ctl-draw-str-w tc-textbox\" value=\"").f(ctx.get(["strokeWidth"], false), ctx, "h").w("\" min=\"1\" max=\"15\" /></div>"); } body_1.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        var self = this;
        var strToolTip;
        var strokeColor;
        var strokeWidth;
        switch (self.options.mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                strToolTip = self.getLocaleString('drawLine');
                self.div.classList.add(self._lineClass);
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                strToolTip = self.getLocaleString('drawPolygon');
                self.div.classList.add(self._polygonClass);
                strokeColor = TC.Cfg.styles.polygon.strokeColor;
                strokeWidth = TC.Cfg.styles.polygon.strokeWidth;
                break;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                strToolTip = self.getLocaleString('drawPoint');
                self.div.classList.add(self._pointClass);
                strokeColor = TC.Cfg.styles.point.strokeColor;
                strokeWidth = TC.Cfg.styles.point.strokeWidth;
                break;
            default:
                strToolTip = self.getLocaleString('draw');
                strokeColor = TC.Cfg.styles.line.strokeColor;
                strokeWidth = TC.Cfg.styles.line.strokeWidth;
                break;
        }
        const renderObject = {
            tooltip: strToolTip,
            strokeColor: formatColor(strokeColor),
            strokeWidth: strokeWidth,
            styleTools: self.options.styleTools
        };
        return self._set1stRenderPromise(self.renderData(renderObject, function () {
            if (!Modernizr.inputtypes.color) {
                // El navegador no soporta input[type=color], usamos polyfill
                const input = self.div.querySelector('input[type=color]');
                if (input) {
                    input.style.backgroundColor = input.value;
                    input.style.color = 'transparent';
                    const picker = new CP(input, 'click', document.body);

                    input.onclick = function (e) {
                        e.preventDefault();
                    };

                    // Evitamos que salga el teclado virtual en iOS
                    input.onfocus = function (e) {
                        this.blur();
                    };

                    input.onchange = function (e) {
                        this.style.backgroundColor = this.value;
                    };

                    self.map.loaded(function () {
                        picker.on("change", function (color) {
                            self.setStrokeColor('#' + color);
                        });
                    });
                }
            }
            self.reset = true;
            self.callBack = null;
            self.measure = false;
            self._cancelClick = false;

            self.mode = self.options.mode || TC.Consts.geom.POLYLINE;

            if (self.options.measure)
                self.measure = self.options.measure
            if ($.isFunction(self.options.callback))
                self.callBack = self.options.callback;
            if (self.options.persistent === undefined) {
                self.persistent = true;
            }
            else {
                self.persistent = self.options.persistent;
            }

            self.wrap = new TC.wrap.control.Draw(self);

            self._newBtn = self.div.querySelector(self._classSelector + '-btn-new');
            self._newBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.new();
            });

            self._cancelBtn = self.div.querySelector(self._classSelector + '-btn-cancel');
            self._cancelBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.cancel();
            });

            self._endBtn = self.div.querySelector(self._classSelector + '-btn-end');
            self._endBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.end();
            });

            self._undoBtn = self.div.querySelector(self._classSelector + '-btn-undo');
            self._undoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.undo();
            });

            self._redoBtn = self.div.querySelector(self._classSelector + '-btn-redo');
            self._redoBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.redo();
            });

            if (self.options.styleTools) {
                self._strokeColorPicker = self.div.querySelector(self._classSelector + '-str-c');
                self._strokeColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeColor(e.target.value);
                });

                self._strokeWidthSelector = self.div.querySelector(self._classSelector + '-str-w');
                self._strokeWidthSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                    self.setStrokeWidth(e.target.value);
                });
                self._strokeWidthWatch = self.div.querySelector(self._classSelector + '-str-w-watch');
            }

            if ($.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.map.on(TC.Consts.event.VIEWCHANGE, function () {
            if (self.map.view === TC.Consts.view.PRINTING) {
                self.end();

                // No lanzo el evento porque da error al no llegar una feature
                // self.trigger(TC.Consts.event.DRAWEND);
            }
        });

        const setStyles = function () {
            self.styles = {};
            $.extend(true, self.styles, self.options.styles || self.layer.options.styles);
        };

        self._layerPromise = new Promise(function (resolve, reject) {
            map.loaded(function () {
                if (self.options.layer) {
                    self.setLayer(self.options.layer);
                    resolve(self.layer);
                    setStyles();
                }
                else {
                    // Si self.options.layer === false se instancia el control sin capa asociada
                    if (self.options.layer === false) {
                        self.setLayer(null);
                        resolve(null);
                    }
                    else {
                        map.addLayer({
                            id: self.getUID(),
                            title: 'DrawControl',
                            stealth: true,
                            type: TC.Consts.layerType.VECTOR,
                            styles: {
                                point: map.options.styles.point,
                                line: map.options.styles.line,
                                polygon: map.options.styles.polygon
                            }
                        }).then(function (layer) {
                            map.putLayerOnTop(layer);
                            self.setLayer(layer);
                            resolve(self.layer);
                            setStyles();
                        });
                    }
                }
            });
        });

        return result;
    };

    ctlProto.new = function () {
        var self = this;
        if (self.layer && !self.persistent) {
            self.layer.clearFeatures();
        }
        self._cancelBtn.disabled = false;
        self.setMode(self.mode, true);
        return self;
    };

    ctlProto.undo = function () {
        var self = this;
        var result = self.wrap.undo();
        if (result) {
            self.historyIndex--;
            setDrawState(self);

            if (self.historyIndex <= 0) {
                self.resetValues();
            }
            self.trigger(TC.Consts.event.DRAWUNDO);
        }

        return result;
    };

    ctlProto.redo = function () {
        var self = this;
        var result = this.wrap.redo();
        if (result) {
            self.historyIndex++;
            setDrawState(self);
            self.trigger(TC.Consts.event.DRAWREDO);
        }
        return result;
    };

    ctlProto.cancel = function () {
        var self = this;
        self._cancelClick = true;
        this.setMode(null, false);
        self.resetValues();
        setFeatureAddReadyState(self);
        self._cancelBtn.disabled = true;
        self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        return self;
    };

    ctlProto.activate = function () {
        var self = this;
        self._newBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._cancelBtn.disabled = false;
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
        self.div.classList.remove(self._pointClass);
        self.div.classList.remove(self._lineClass);
        self.div.classList.remove(self._polygonClass);
        switch (self.mode) {
            case TC.Consts.geom.POINT:
                self.div.classList.add(self._pointClass);
                break;
            case TC.Consts.geom.POLYLINE:
                self.div.classList.add(self._lineClass);
                break;
            case TC.Consts.geom.POLYGON:
                self.div.classList.add(self._polygonClass);
                break;
            default:
                break;
        }

    };

    ctlProto.deactivate = function () {
        var self = this;
        if (self._newBtn) {
            self._newBtn.classList.remove(TC.Consts.classes.ACTIVE);
        }
        if (self._cancelBtn) {
            self._cancelBtn.disabled = true;
        }
        TC.Control.prototype.deactivate.call(self, !self._cancelClick);
        if (self.wrap) {
            self.wrap.deactivate();
        }
        self.resetValues();
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        self._cancelClick = false;
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        self.resetValues();
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        self.resetValues();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            if (self.layer) {
                self.layer.map.putLayerOnTop(self.layer);
            }
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.setStyle = function (style) {
        const self = this;
        if (style) {
            $.extend(self.style, style);
        }
        else {
            switch (self.options.mode) {
                case TC.Consts.geom.POLYLINE:
                case TC.Consts.geom.MULTIPOLYLINE:
                    style = { line: self.styles.line };
                    break;
                case TC.Consts.geom.POLYGON:
                case TC.Consts.geom.MULTIPOLYGON:
                    style = { polygon: self.styles.polygon };
                    break;
                case TC.Consts.geom.POINT:
                case TC.Consts.geom.MULTIPOINT:
                    style = { point: self.styles.point };
                    break;
                default:
                    style = {};
                    break;
            }
        }
        if (self.isActive) {
            self.wrap.setStyle(style);
        }
    };

    ctlProto.getModeStyle = function(mode) {
        const self = this;
        mode = mode || self.options.mode;
        switch (mode) {
            case TC.Consts.geom.POLYLINE:
            case TC.Consts.geom.MULTIPOLYLINE:
                return self.styles.line;
            case TC.Consts.geom.POLYGON:
            case TC.Consts.geom.MULTIPOLYGON:
                return self.styles.polygon;
            case TC.Consts.geom.POINT:
            case TC.Consts.geom.MULTIPOINT:
                return self.styles.point;
            default:
                return null;
                break;
        }
    };

    ctlProto.setStrokeColorWatch = function (color) {
        const self = this;
        if (self.options.styleTools) {
            if (color === undefined) {
                color = self.getModeStyle().strokeColor;
            }
            const match = color.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (match && match.length) {
                color = '#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
            }
            self._strokeColorPicker.value = color;
            if (!Modernizr.inputtypes.color) {
                const input = self._strokeColorPicker;
                input.style.backgroundColor = color;
                input.blur();
            }
        }
        return self;
    };

    ctlProto.setStrokeColor = function (color) {
        const self = this;
        const style = self.getModeStyle();
        if (style) {
            style.strokeColor = color;
        }

        // Resetea el estilo
        if (self.isActive) {
            self.setStyle();
        }

        self.setStrokeColorWatch(color);
        self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeColor', value: color });
        return self;
    };

    ctlProto.setStrokeWidthWatch = function (width) {
        const self = this;
        if (self.options.styleTools) {
            if (width === undefined) {
                width = self.getModeStyle().strokeWidth;
            }
            width = parseInt(width, 10);
            if (width !== Number.NaN) {
                self._strokeWidthSelector.value = width;
                self._strokeWidthWatch.style.borderBottomWidth = width + 'px';
            }
        }
        return self;
    };

    ctlProto.setStrokeWidth = function(width) {
        const self = this;
        width = parseInt(width, 10);
        if (width !== Number.NaN) {
            const style = self.getModeStyle();
            if (style) {
                style.strokeWidth = width;
            }

            // Resetea el estilo
            if (self.isActive) {
                self.setStyle();
            }

            self.setStrokeWidthWatch(width);
            self.trigger(TC.Consts.event.STYLECHANGE, { property: 'strokeWidth', value: width });
        }
        return self;
    };

    ctlProto.getLayer = function() {
        return this._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        if (self.map) {
            if (typeof (layer) === "string") {
                self.layer = self.map.getLayer(layer);
            }
            else {
                self.layer = layer;
            }
        }
    };

    ctlProto.resetValues = function () {
        const self = this;
        self.history.length = 0;
        self.historyIndex = 0;
        setDrawState(self);
        return self;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.getLayer().then(function (layer) {
            layer.importState(state.layer);
        });
    };
})();
﻿TC.control = TC.control || {};

if (!TC.control.Measure) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Measure');
}

TC.control.DrawMeasureModify = function () {
    var self = this;

    TC.control.Measure.apply(self, arguments);

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    self._$dialogDiv = $(self._dialogDiv);
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]'
    };

    self.persistentDrawControls = true;

    self.renderPromise().then(function () {
        self._1stCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-1-t');
        self._2ndCoordText = self.div.querySelector('.tc-ctl-meas-val-coord-2-t');
        self._1stCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-1-v');
        self._2ndCoordValue = self.div.querySelector('.tc-ctl-meas-val-coord-2-v');
        self._elevationText = self.div.querySelector('.tc-ctl-meas-val-coord-ele-t');
        self._elevationValue = self.div.querySelector('.tc-ctl-meas-val-coord-ele-v');
    });

    if (self.options.displayElevation) {        
        self.elevationProfileActive = true;
        TC.loadJS(
            !TC.tool || !TC.tool.Elevation,
            TC.apiLocation + 'TC/tool/Elevation',
            function () {
                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                self.elevation = new TC.tool.Elevation(elevationOptions);
            }
        );
    }
};

TC.inherit(TC.control.DrawMeasureModify, TC.control.Measure);

(function () {
    var ctlProto = TC.control.DrawMeasureModify.prototype;

    ctlProto.CLASS = 'tc-ctl-dmm';

    var _dataKeys = {
        VALUE: 'tcValue'
    };


    TC.Consts.event.RESULTSPANELCLOSE = TC.Consts.event.RESULTSPANELCLOSE || 'resultspanelclose.tc';
    TC.Consts.event.FEATURESSELECT = TC.Consts.event.FEATURESSELECT || "featuresselect.tc";

    const elevationProfileCache = [];

    const getElevationProfileFromCache = function (feature) {
        return elevationProfileCache.filter(function (elm) {
            return elm.feature === feature;
        })[0];
    };

    const cacheElevationProfile = function (feature, data) {
        var result = getElevationProfileFromCache(feature);
        if (!result) {
            result = {
                feature: feature
            };
            elevationProfileCache.push(result);
        }
        result.data = data;
        return result;
    };

    const removeElevationProfileFromCache = function (feature) {
        const featIdx = elevationProfileCache.reduce(function (prev, cur, idx) {
            if (cur.feature === feature) {
                return idx;
            }
            return prev;
        }, -1);
        if (featIdx >= 0) {
            elevationProfileCache.splice(featIdx, 1);
        }
    };

    const clearElevationProfileCache = function () {
        elevationProfileCache.length = 0;
    };

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/DrawMeasureModify.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/DrawMeasureModifyDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "drawAndMeasure" }).w("</h2><div class=\"tc-ctl-meas-select\"><form><label class=\"tc-ctl-meas-btn-pt\"><input type=\"radio\" name=\"mode\" value=\"point\" /><span>").h("i18n", ctx, {}, { "$key": "points" }).w("</span></label><label class=\"tc-ctl-meas-btn-len\"><input type=\"radio\" name=\"mode\" value=\"polyline\" /><span>").h("i18n", ctx, {}, { "$key": "lines" }).w("</span></label><label class=\"tc-ctl-meas-btn-area\"><input type=\"radio\" name=\"mode\" value=\"polygon\" /><span>").h("i18n", ctx, {}, { "$key": "polygons" }).w("</span></label></form></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-pt tc-hidden\"><div class=\"tc-ctl-meas-point\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "search.list.coordinates" }).w(" <span class=\"tc-ctl-meas-val-coord\"><span class=\"tc-ctl-meas-val-coord-1-t\"></span> <span class=\"tc-ctl-meas-val-coord-1-v\"></span> <span class=\"tc-ctl-meas-val-coord-2-t\"></span> <span class=\"tc-ctl-meas-val-coord-2-v\"></span> <span class=\"tc-ctl-meas-val-coord-ele-t\"></span> <span class=\"tc-ctl-meas-val-coord-ele-v\"></span></span></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-len tc-hidden\"><div class=\"tc-ctl-meas-line\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "2dLength" }).w(": <span class=\"tc-ctl-meas-val-len\"></span><button class=\"tc-ctl-meas-prof-btn tc-active\" title=\"").h("i18n", ctx, {}, { "$key": "deactivateElevationProfile" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.chart.chpe" }).w("</button></div></div><div class=\"tc-ctl-meas-mode tc-ctl-meas-area tc-hidden\"><div class=\"tc-ctl-meas-polygon\"></div><div class=\"tc-ctl-meas-txt\">").h("i18n", ctx, {}, { "$key": "area" }).w(": <span class=\"tc-ctl-meas-val-area\"></span>, ").h("i18n", ctx, {}, { "$key": "2dPerimeter" }).w(": <span class=\"tc-ctl-meas-val-peri\"></span></div></div><div class=\"tc-ctl-dmm-tool\"><div class=\"tc-ctl-dmm-mod\"></div><div class=\"tc-ctl-dmm-cmd\"><button class=\"tc-ctl-dmm-btn-clr\" disabled title=\"").h("i18n", ctx, {}, { "$key": "deleteAll" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteAll" }).w("</button><button class=\"tc-ctl-dmm-btn-dl\" disabled title=\"").h("i18n", ctx, {}, { "$key": "download" }).w("\">").h("i18n", ctx, {}, { "$key": "download" }).w("...</button></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "downloadSketch" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").s(ctx.get(["elevation"], false), ctx, { "block": body_1 }, {}).w("<div class=\"tc-ctl-dmm-dialog-dl\"><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-kml\" data-format=\"KML\" title=\"KML\">KML</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-gml\" data-format=\"GML\" title=\"GML\">GML</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-geojson\" data-format=\"GeoJSON\" title=\"GeoJSON\">GeoJSON</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-wkt\" data-format=\"WKT\" title=\"WKT\">WKT</button><button class=\"tc-button tc-btn-dl tc-ctl-dmm-dl-btn-gpx\" data-format=\"GPX\" title=\"GPX\">GPX</button></div></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog-elev\"><input id=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" type=\"checkbox\" checked /><label for=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" class=\"tc-ctl-ftools-dialog-elev-label\">").h("i18n", ctx, {}, { "$key": "includeElevations" }).w("</label></div>").x(ctx.get(["resolution"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-dmm-dialog-ip\"><h4>").h("i18n", ctx, {}, { "$key": "interpolateCoordsFromElevProfile" }).w("</h4><label><input type=\"radio\" name=\"ip-coords\" value=\"0\" checked /><span>").h("i18n", ctx, {}, { "$key": "no" }).w("</span></label><label><input type=\"radio\" name=\"ip-coords\" value=\"1\"/><span>").h("i18n", ctx, {}, { "$key": "yes" }).w("</span></label><div class=\"tc-ctl-dmm-dialog-ip-m tc-hidden\">").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.1" }).w("<input type=\"number\" min=\"1\" step=\"1\" class=\"tc-textbox\" value=\"").f(ctx.get(["resolution"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.2" }).w("</div></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        const self = this;
        const promise = self._set1stRenderPromise(TC.control.Measure.prototype.render.call(self, function () {
            self._clearBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-clr');
            self._clearBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                TC.confirm(self.getLocaleString('deleteAll.confirm'), function () {
                    self.clear();
                });
            });
            self._downloadBtn = self.div.querySelector('.tc-ctl-dmm-cmd button.tc-ctl-dmm-btn-dl');
            self._downloadBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showSketchDownloadDialog();
            });

            self._elevProfileBtn = self.div.querySelector('.tc-ctl-meas-prof-btn');
            self._elevProfileBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                self.elevationProfileActive ? self.deactivateElevationProfile() : self.activateElevationProfile();
            });

            if (!self.options.displayElevation) {
                self._elevProfileBtn.style.display = 'none';
            }

            if ($.isFunction(callback)) {
                callback();
            }
        }));

        const renderOptions = {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        };
        self.getRenderedHtml(self.CLASS + '-dialog', renderOptions, function (html) {
            const endExport = function (format) {
                TC.Util.closeModal();
                const exportOptions = {
                    fileName: self.getLocaleString('sketch').toLowerCase().replace(' ', '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true),
                    format: format
                };
                const includeElevation = self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked;
                if (includeElevation) {
                    const interpolateCoords = self._dialogDiv.querySelector('input[type=radio][name=ip-coords]:checked').value === "1";
                    const li = self.map.getLoadingIndicator();
                    const waitId = li && li.addWait();

                    const elevOptions = {
                        crs: self.map.crs,
                        features: self.layer.features.map(function (feat) {
                            // Solo mantenemos las features de las que hay que obtener elevación:
                            // - Las que no tienen elevación
                            // - Cuando hay interpolación, todas las líneas y los polígonos
                            if (feat.getGeometryStride() >= 3) {
                                if (!interpolateCoords || (TC.feature.Point && feat instanceof TC.feature.Point)) {
                                    return null;
                                }
                            }
                            return feat.clone();
                        }),
                        maxCoordQuantity: self.options.displayElevation.maxCoordQuantity,
                        sampleNumber: 0 // No queremos determinar el número de muestras
                    };
                    if (interpolateCoords) {
                        elevOptions.resolution = parseFloat(self._dialogDiv.querySelector('.' + self.CLASS + '-dialog-ip-m input[type=number]').value) || self.options.displayElevation.resolution;
                    }
                    self.elevation.setGeometry(elevOptions)
                        .then(function (features) {
                            // Volvemos a añadir las features de las que no hemos pedido elevación
                            features.forEach(function (feat, idx) {
                                if (!feat) {
                                    features[idx] = self.layer.features[idx];
                                }
                            });
                            self.map.exportFeatures(features, exportOptions);
                        })
                        .catch(function (error) {
                            if (error === TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED) {
                                TC.alert(self.getLocaleString('tooManyCoordinatesForElevation.warning'));
                                return;
                            }
                            TC.error(self.getLocaleString('elevation.error'));
                        })
                        .finally(function () {
                            li && li.removeWait(waitId);
                        });
                }
                else {
                    var features;
                    if (self.options.displayElevation && !includeElevation) { // Hay que quitar elevaciones
                        features = self.layer.features
                            .map(function (feat) {
                                var f = feat.clone();
                                if (f.getGeometryStride() > 2) {
                                    f.getCoordsArray().forEach(function (coord) {
                                        coord.length = 2;
                                    });
                                    f.setCoords(f.geometry);
                                }
                                return f;
                            });
                    }
                    else {
                        features = self.layer.features;
                    }
                    self.map.exportFeatures(features, exportOptions);
                }
            };
            self._dialogDiv.innerHTML = html;
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.ELEVATION_CHECKBOX, function (e) {
                self.showSketchDownloadDialog(); // Recalculamos todo el aspecto del diálogo de descarga
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector('input[type=radio][name=ip-coords]', function (e) {
                const ipMessage = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog-ip-m');
                if (e.target.value === '0') {
                    ipMessage.classList.add(TC.Consts.classes.HIDDEN);
                }
                else {
                    ipMessage.classList.remove(TC.Consts.classes.HIDDEN);
                }
            }));
            self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button[data-format]', function (e) {
                const format = e.target.dataset.format;
                if (format === TC.Consts.format.GPX) {
                    if (self.layer.features.some(function (feature) {
                        return TC.feature.Polygon && feature instanceof TC.feature.Polygon;
                    })) {
                        TC.confirm(self.getLocaleString('gpxNotCompatible.confirm'), function () {
                            endExport(format);
                        });
                    }
                    else {
                        endExport(format);
                    }
                }
                else {
                    endExport(format);
                }
            }));
        });

        return promise;
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            TC.control.Measure.prototype.register.call(self, map).then(function () {
                const drawPointsId = self.getUID();
                const modifyId = self.getUID();

                Promise.all([self.layerPromise, self.renderPromise()]).then(function (objects) {
                    const layer = objects[0];
                    layer.title = self.getLocaleString('sketch');

                    self._modifyPromise = map.addControl('modify', {
                        id: modifyId,
                        div: self.div.querySelector('.' + self.CLASS + '-mod'),
                        layer: layer
                    });

                    self._modifyPromise.then(function (modify) {

                        self.modify = modify;
                        modify
                            .on(TC.Consts.event.FEATURESSELECT, function (e) {
                                if (self.resultsPanelChart && !e.features.some(function (feature) {
                                    return self.resultsPanelChart.currentFeature === feature;
                                })) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                const feature = e.features[e.features.length - 1];
                                if (feature) {
                                    self.showMeasures(self.getFeatureMeasureData(feature));
                                    const style = feature._originalStyle || feature.getStyle();
                                    switch (true) {
                                        case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                            self.displayMode(TC.Consts.geom.POLYGON);
                                            self.drawPolygons
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                            self.displayMode(TC.Consts.geom.POLYLINE);
                                            self.drawLines
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            const profile = getElevationProfileFromCache(feature);
                                            if (profile) {
                                                self.resultsPanelChart.setCurrentFeature(feature);
                                                self.renderElevationChart(profile.data);
                                            }
                                            break;
                                        case TC.feature.Point && feature instanceof TC.feature.Point:
                                            self.displayMode(TC.Consts.geom.POINT);
                                            self.drawPoints
                                                .setStrokeColorWatch(style.strokeColor)
                                                .setStrokeWidthWatch(style.strokeWidth);
                                            break;
                                        default:
                                            break;
                                    }
                                    self.modify
                                        .setFontColorWatch(style.fontColor)
                                        .setFontSizeWatch(style.fontSize);
                                }
                            })
                            .on(TC.Consts.event.FEATURESUNSELECT, function (e) {
                                const features = self.modify.getSelectedFeatures();
                                if (!features.length) {
                                    self.resetDrawWatches();
                                }
                                self.resetElevationProfile();
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.close();
                                }
                            })
                            .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                                if (e.layer === self.layer) {
                                    removeElevationProfileFromCache(e.feature);
                                    const setMeasures = function (feature) {
                                        const measureData = self.getFeatureMeasureData(feature);
                                        self.showMeasures(measureData);
                                        self.setFeatureMeasureData(feature);
                                    };
                                    setMeasures(e.feature);

                                    // Si es un punto metemos la elevación en la geometría (porque la mostramos en las medidas)
                                    if (self.options.displayElevation && TC.feature.Point && e.feature instanceof TC.feature.Point) {
                                        self.elevation.setGeometry({
                                            features: [e.feature],
                                            crs: self.map.crs
                                        }).then(function (features) {
                                            setMeasures(features[0]);
                                        });
                                    }

                                    const popups = self.map.getControlsByClass('TC.control.Popup');
                                    popups.forEach(function (pu) {
                                        if (pu.isVisible() && pu.currentFeature === e.feature) {
                                            pu.hide();
                                        }
                                    });
                                }
                            });

                        map
                            .on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                                const control = e.control;
                                if (control === self.modify) {
                                    self.resetDrawWatches();
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.setCurrentFeature(null);
                                        self.resultsPanelChart.close();
                                    }
                                }
                                else if (control === self.drawLines) {
                                    self.resetElevationProfile();
                                    if (self.resultsPanelChart) {
                                        self.resultsPanelChart.close();
                                    }
                                }
                            })
                            .on(TC.Consts.event.FEATURECLICK, function (e) {
                                const feature = e.feature;
                                // No queremos que se muestre el perfil de la feature ya dibujada si estamos dibujando o seleccionando otra
                                if (!(map.activeControl instanceof TC.control.Draw || map.activeControl instanceof TC.control.Modify)) {
                                    if (TC.feature.Polyline && feature instanceof TC.feature.Polyline && self.layer.features.indexOf(feature) >= 0) {
                                        if (self.elevationProfileActive) {
                                            if (self.resultsPanelChart) {
                                                self.resultsPanelChart.setCurrentFeature(feature);
                                            }
                                            map.getControlsByClass('TC.control.Popup').forEach(function (ctl) {
                                                if (ctl.currentFeature === feature) {
                                                    ctl.hide();
                                                }
                                            });
                                        }
                                        const profile = getElevationProfileFromCache(feature);
                                        if (self.resultsPanelChart && self.resultsPanelChart.isMinimized()) {
                                            self.resultsPanelChart.maximize();
                                        }
                                        if (profile) {
                                            self.renderElevationChart(profile.data);
                                        }
                                        else {
                                            self.displayElevationProfile(feature.geometry);
                                        }
                                    }
                                }
                            });
                    });

                    self._drawLinesPromise.then(function (drawLines) {
                        drawLines
                            .on(TC.Consts.event.DRAWSTART, function () {
                                //self.resetElevationProfile();
                                if (self.resultsPanelChart && self.resultsPanelChart.currentFeature) {
                                    self.resultsPanelChart.setCurrentFeature(null);
                                }
                                self.resetValues();
                            })
                            .on(TC.Consts.event.DRAWUNDO + ' ' + TC.Consts.event.DRAWREDO, function () {
                                const drawLines = this;
                                self.displayElevationProfile(drawLines.history.slice(0, drawLines.historyIndex));
                            })
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                if (self.resultsPanelChart) {
                                    self.resultsPanelChart.currentFeature = e.feature;
                                }
                            })
                            .on(TC.Consts.event.POINT, function (e) {
                                const drawLines = this;
                                const coords = drawLines.history.slice(0, drawLines.historyIndex);
                                const lastCoord = coords[coords.length - 1];
                                if (lastCoord[0] !== e.point[0] || lastCoord[1] !== e.point[1]) {
                                    coords.push(e.point);
                                }
                                self.displayElevationProfile(coords);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._drawPolygonsPromise.then(function (drawPolygons) {
                        drawPolygons
                            .on(TC.Consts.event.DRAWSTART, function () {
                                self.resetValues();
                            })
                            //.on(TC.Consts.event.DRAWEND, function (e) {
                            //    if (self.options.displayElevation) {
                            //        self.elevation.setGeometry({
                            //            features: [e.feature],
                            //            crs: self.map.crs
                            //        });
                            //    }
                            //})
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                    });

                    self._drawPointsPromise = map.addControl('draw', {
                        id: drawPointsId,
                        div: self.div.querySelector('.' + TC.control.Measure.prototype.CLASS + '-point'),
                        mode: TC.Consts.geom.POINT,
                        persistent: self.persistentDrawControls,
                        styleTools: true,
                        layer: self.layer
                    });

                    self._drawPointsPromise.then(function (drawPoints) {

                        drawPoints.containerControl = self;
                        self.drawControls.push(drawPoints);
                        self.drawPoints = drawPoints;

                        self.resetValues();

                        drawPoints
                            .on(TC.Consts.event.DRAWEND, function (e) {
                                const updateChanges = function (feat) {
                                    self.showMeasures({ coords: feat.geometry, units: map.wrap.isGeo() ? 'degrees' : 'm' });
                                    self.setFeatureMeasureData(feat);
                                };
                                updateChanges(e.feature);
                                if (self.options.displayElevation) {
                                    self.elevation.setGeometry({
                                        features: [e.feature],
                                        crs: self.map.crs
                                    }).then(function (features) {
                                        updateChanges(features[0]);
                                    })
                                }
                            })
                            .on(TC.Consts.event.DRAWCANCEL, function (e) {
                                // Alerta de condición de carrera si no ponemos un timeout:
                                // 1- Se llama a cancel de un control Draw.
                                // 2- Se llama a deactivate (como es mediante cancel, no se se corta la cadena de activación controles).
                                // 3- Si el control activo anterior era otro de los modos de dibujo de Measure, se activa.
                                // 4- Se llama a cancel desde aquí.
                                // 5- Se llama a deactivate del control que acabamos de activar en 3.
                                // El activate de 3 y el deactivate de 5 sobre el mismo control entran en condición de carrera al crear/destruir la interaction
                                // por tanto se puede quedar en un estado inconsistente. Para evitar eso, separamos 3 de 5 por el siguiente timeout.
                                setTimeout(function () {
                                    self.cancel();
                                }, 100);
                            })
                            .on(TC.Consts.event.STYLECHANGE, function (e) {
                                self.onStyleChange(e);
                            });
                        // Desactivamos el método exportState que ya se encarga el control padre de ello
                        drawPoints.exportsState = false;
                    });

                    self.setMode(self.options.mode);

                    map
                        .on(TC.Consts.event.FEATUREADD, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                self.setFeatureMeasureData(feature);
                                
                                self._modifyPromise.then(function (modify) {
                                    modify.displayLabelText(feature.getStyle().label);
                                });
                                self._clearBtn.disabled = false;
                                self._downloadBtn.disabled = false;
                            }
                        })
                        .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                            const layer = e.layer;
                            const feature = e.feature;
                            if (layer === self.layer) {
                                if (self.layer.features.length === 0) {
                                    self._clearBtn.disabled = true;
                                    self._downloadBtn.disabled = true;
                                    self.resetValues();
                                    clearElevationProfileCache();
                                }
                                else if (feature) {
                                    removeElevationProfileFromCache(feature);
                                }
                            }
                        })
                        .on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                            const control = e.control;
                            if (control.setCurrentFeature) {
                                control.setCurrentFeature(null);
                            }
                        });

                    resolve(self);
                });

            }).catch(function (error) {
                reject(error);
            });
        });
    };

    ctlProto.displayMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self._activeMode = self.div.querySelector('.tc-ctl-meas-pt');
        }
        if (self.modify) {
            self.modify.div.classList.remove(TC.Consts.classes.COLLAPSED);
        }
        return TC.control.Measure.prototype.displayMode.call(self, mode);
    };

    ctlProto.setMode = function (mode) {
        const self = this;
        if (mode === TC.Consts.geom.POINT) {
            self.drawPoints.activate();
        }
        return TC.control.Measure.prototype.setMode.call(self, mode);
    };

    ctlProto.setFeatureMeasureData = function (feature) {
        const self = this;
        const data = {};
        switch (true) {
            case TC.feature.Point && feature instanceof TC.feature.Point:
                const firstCoordText = self._1stCoordText.innerHTML;
                const secondCoordText = self._2ndCoordText.innerHTML;
                const elevationText = self._elevationText.innerHTML;
                if (self._1stCoordValue.textContent.trim().length > 0 && self._2ndCoordValue.textContent.trim().length > 0) {
                    data.CRS = self.map.crs;
                    data[firstCoordText.substr(0, firstCoordText.indexOf(':'))] = $(self._1stCoordValue).data(_dataKeys.VALUE);
                    data[secondCoordText.substr(0, secondCoordText.indexOf(':'))] = $(self._2ndCoordValue).data(_dataKeys.VALUE);
                    if (elevationText) {
                        data[self.getLocaleString('ele')] = $(self._elevationValue).data(_dataKeys.VALUE);
                    }
                    feature.setData(data);
                }
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                if (self._len.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('2dLength')] = self._len.innerHTML;
                    feature.setData(data);
                }
                break;
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                if (self._area.innerHTML.trim() !== self.NOMEASURE && self._peri.innerHTML.trim() !== self.NOMEASURE) {
                    data[self.getLocaleString('area')] = self._area.innerHTML;
                    data[self.getLocaleString('2dPerimeter')] = self._peri.innerHTML;
                    feature.setData(data);
                }
                break;
            default:
                break;
        }
        return self;
    };

    ctlProto.getFeatureMeasureData = function (feature) {
        const self = this;
        const result = {
            units: 'm'
        };
        const measureOptions = {};
        if (self.map.wrap.isGeo()) {
            measureOptions.crs = TC.Cfg.utmCrs;
        }
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                result.area = feature.getArea(measureOptions);
                result.perimeter = feature.getLength(measureOptions);
                break;
            case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                result.length = feature.getLength(measureOptions);
                const profile = getElevationProfileFromCache(feature);
                if (profile) {
                    self.renderElevationChart(profile.data);
                }
                else {
                    self.displayElevationProfile(feature.geometry);
                }
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
                result.coords = feature.geometry;
                break;
            default:
                break;
        }
        return result;
    };

    ctlProto.showMeasures = function (options) {
        const self = this;
        TC.control.Measure.prototype.showMeasures.call(self, options);
        options = options || {};
        var units = options.units;
        const locale = self.map.options.locale || TC.Cfg.locale
        if (options.coords) {
            var precision;
            var coord1, coord2;
            if (options.units === 'm') {
                precision = TC.Consts.METER_PRECISION;
                coord1 = options.coords[0];
                coord2 = options.coords[1];
                self._1stCoordText.innerHTML = 'x: ';
                self._2ndCoordText.innerHTML = 'y: ';
            }
            else {
                precision = TC.Consts.DEGREE_PRECISION;
                coord1 = options.coords[1];
                coord2 = options.coords[0];
                self._1stCoordText.innerHTML = 'lat: ';
                self._2ndCoordText.innerHTML = 'lon: ';
            }
            const factor = Math.pow(10, precision);
            const round = function (val) {
                return Math.round(val * factor) / factor;
            }
            self._1stCoordValue.innerHTML = TC.Util.formatNumber(coord1.toFixed(precision), locale);
            $(self._1stCoordValue).data(_dataKeys.VALUE, round(coord1));
            self._2ndCoordValue.innerHTML = TC.Util.formatNumber(coord2.toFixed(precision), locale);
            $(self._2ndCoordValue).data(_dataKeys.VALUE, round(coord2));
            if (options.coords.length > 2) {
                const elevation = Math.round(options.coords[2]);
                self._elevationText.innerHTML = self.getLocaleString('ele').toLowerCase() + ': ';
                self._elevationValue.innerHTML = TC.Util.formatNumber(elevation.toFixed(TC.Consts.METER_PRECISION), locale) + ' m';
                $(self._elevationValue).data(_dataKeys.VALUE, elevation);
            }
            else {
                self._elevationText.innerHTML = '';
                self._elevationValue.innerHTML = '';
                $(self._elevationValue).data(_dataKeys.VALUE, null);
            }
        }
        return self;
    };

    ctlProto.resetValues = function () {
        const self = this;
        TC.control.Measure.prototype.resetValues.call(self);

        if (self._1stCoordText) {
            self._1stCoordText.innerHTML = self.NOMEASURE;
            self._2ndCoordText.innerHTML = '';
            self._1stCoordValue.innerHTML = '';
            $(self._1stCoordValue).data(_dataKeys.VALUE, null);
            self._2ndCoordValue.innerHTML = '';
            $(self._2ndCoordValue).data(_dataKeys.VALUE, null);
            self._elevationText.innerHTML = '';
            self._elevationValue.innerHTML = '';
            $(self._elevationValue).data(_dataKeys.VALUE, null);
        }
        return self;
    };

    ctlProto.resetDrawWatches = function () {
        const self = this;
        self.drawControls.forEach(function (ctl) {
            ctl
                .setStrokeColorWatch()
                .setStrokeWidthWatch();
        });
    };

    ctlProto.clear = function () {
        const self = this;
        self.resetValues();
        self.layer.clearFeatures();
        if (self.modify.isActive) {
            self.modify.deactivate();
        }
        if (self.options.displayElevation) {
            self.resetElevationProfile();
            if (self.resultsPanelChart) {
                self.resultsPanelChart.close();
            }
        }
        self._clearBtn.disabled = true;
        self._downloadBtn.disabled = true;
        return self;
    };

    ctlProto.showSketchDownloadDialog = function (options) {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog');
        const $dialog = $(dialog);
        const hasPoints = self.layer.features.some(function (feature) {
            return (TC.feature.Point && feature instanceof TC.feature.Point) ||
                (TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint);
        });
        const hasLines = self.layer.features.some(function (feature) {
            return (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
                (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
        });
        const hasPolygons = self.layer.features.some(function (feature) {
            return (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
                (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);
        });

        // Si no hay líneas o polígonos, no es necesario preguntar si queremos interpolar
        const ipDiv = dialog.querySelector('.' + self.CLASS + '-dialog-ip');

        if (!self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked || (!hasLines && !hasPolygons)) {
            ipDiv.classList.add(TC.Consts.classes.HIDDEN);
        }
        else {
            ipDiv.classList.remove(TC.Consts.classes.HIDDEN);
        }

        // Si no hay líneas o puntos, no es necesario mostrar el botón de GPX
        const gpxButton = dialog.querySelector('button[data-format=GPX]');
        if (hasLines || hasPoints) {
            gpxButton.classList.remove(TC.Consts.classes.HIDDEN);
        }
        else {
            gpxButton.classList.add(TC.Consts.classes.HIDDEN);
        }

        TC.Util.showModal(dialog, options);
        return self;
    };

    ctlProto.onStyleChange = function (e) {
        const self = this;
        var featureCtor;
        switch (e.target.mode) {
            case TC.Consts.geom.POLYGON:
                featureCtor = TC.feature.Polygon;
                break;
            case TC.Consts.geom.POLYLINE:
                featureCtor = TC.feature.Polyline;
                break;
            case TC.Consts.geom.POINT:
                featureCtor = TC.feature.Point;
                break;
            default:
                break;
        }
        if (featureCtor) {
            self.modify.getSelectedFeatures().forEach(function (feature) {
                if (feature instanceof featureCtor) {
                    const styleOptions = {};
                    styleOptions[e.property] = e.value;
                    //feature._originalStyle[e.property] = e.value;
                    feature.setStyle(styleOptions);
                    //clearTimeout(feature._selectionStyleTimeout);
                    //feature._selectionStyleTimeout = setTimeout(function () {
                    //    feature.setStyle(self.modify.styleFunction(feature));
                    //}, self.options.styleChangeDisplayTimeout || 1000);
                }
            });
        }
    }

    ctlProto.displayElevationProfile = function (coords) {
        const self = this;
        if (coords.length === 1) {
            // Espera una línea, metemos un segundo punto
            coords = coords.slice();
            coords.push(coords[0]);
        }
        const li = self.map.getLoadingIndicator();
        const waitId = li && li.addWait();
        self.elevation.getElevation({
            crs: self.map.crs,
            coordinates: coords
        }).then(
            function (elevCoords) {
                li && li.removeWait(waitId);
                var distance = 0.0;
                var maxElevation = Number.NEGATIVE_INFINITY;
                var minElevation = Number.POSITIVE_INFINITY;
                const profile = elevCoords
                    .map(function (point, idx, arr) {
                        const prev = idx === 0 ? point : arr[idx - 1];
                        const dx = point[0] - prev[0];
                        const dy = point[1] - prev[1];
                        distance += Math.sqrt(dx * dx + dy * dy);
                        var ele = point[2];
                        if (typeof ele === 'number') {
                            maxElevation = Math.max(ele, maxElevation);
                            minElevation = Math.min(ele, minElevation);
                        }
                        return [distance, ele];
                    });

                self.elevationProfileData = {
                    x: profile.map(function (elm) {
                        return elm[0];
                    }),
                    ele: profile.map(function (elm) {
                        return elm[1];
                    }),
                    coords: elevCoords
                };
                const elevationGainOptions = {
                    coords: elevCoords
                };
                if (typeof self.options.displayElevation === 'object') {
                    elevationGainOptions.hillDeltaThreshold = self.options.displayElevation.hillDeltaThreshold;
                }
                $.extend(self.elevationProfileData, TC.tool.Elevation.getElevationGain(elevationGainOptions));

                // Cacheamos el perfil
                const matchingFeature = self.layer.features
                    .filter(function (feat) {
                        return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
                    })
                    .filter(function (line) {
                        for (var i = 0, len = line.geometry.length; i < len; i++) {
                            const coord = coords[i];
                            const lineCoord = line.geometry[i];
                            if (!coord || coord[0] !== lineCoord[0] || coord[1] !== lineCoord[1]) {
                                return false;
                            }
                        }
                        return true;
                    })[0];
                if (matchingFeature) {
                    cacheElevationProfile(matchingFeature, self.elevationProfileData);
                }

                if (self.resultsPanelChart) {
                    self.renderElevationChart();
                }
                else {
                    self.createChartPanel().then(function (resultsPanelChart) {
                        self.resultsPanelChart.renderPromise().then(function () {
                            self.renderElevationChart();
                        });
                    });
                }
            },
            function (error) {
                self.resetElevationProfile();
                li && li.removeWait(waitId);
            });

    };

    ctlProto.createChartPanel = function () {
        const self = this;

        const resultsPanelOptions = {
            id: self.getUID(),
            content: "chart",
            titles: {
                main: self.getLocaleString("geo.trk.chart.chpe"),
                max: self.getLocaleString("geo.trk.chart.chpe")
            },
            chart: {
                ctx: self,
                onmouseout: ctlProto.removeElevationTooltip,
                tooltip: ctlProto.getElevationTooltip
            }
        };

        return new Promise(function (resolve, reject) {
            var addControlPromise;
            const addResultsPanelChart = function (controlContainer) {
                resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                addControlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
            };

            if (self.options.displayElevation.displayOn) {
                var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayElevation.displayOn[0].toUpperCase() + self.options.displayElevation.displayOn.substring(1))[0];
                if (!controlContainer) {
                    self.map.addControl(self.options.displayElevation.displayOn).then(addResultsPanelChart);
                } else {
                    addResultsPanelChart(controlContainer);
                }
            } else {
                resultsPanelOptions.div = document.createElement('div');
                self.map.div.appendChild(resultsPanelOptions.div);
                addControlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
            }

            addControlPromise.then(function (resultsPanelChart) {
                resultsPanelChart.caller = self;
                self.resultsPanelChart = resultsPanelChart;
                self._decorateChartPanel();
                resolve(resultsPanelChart);
            });
        });
    };

    ctlProto._decorateChartPanel = function () {
        const self = this;
        self.resultsPanelChart.setCurrentFeature = function (feature) {
            const that = this;
            if (that.currentFeature) {
                that.currentFeature.toggleSelectedStyle(false);
            }
            that.currentFeature = feature;
            if (feature) {
                feature.toggleSelectedStyle(true);
            }
        };
    };

    ctlProto.renderElevationChart = function (profileData) {
        const self = this;
        self.elevationProfileData = profileData || self.elevationProfileData;
        if (self.resultsPanelChart && self.elevationProfileActive) {
            self.resultsPanelChart.openChart(self.elevationProfileData);
            if (!self.resultsPanelChart.isMinimized()) {
                self.resultsPanelChart.show();
            }
        }
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.resultsPanelChart.wrap.showElevationMarker({
            data: d,
            layer: self.layer,
            coords: self.elevationProfileData.coords
        });

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.resultsPanelChart.wrap.hideElevationMarker();
    }

    ctlProto.activateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = true;
        self._elevProfileBtn.classList.add(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('deactivateElevationProfile'));
        var profileDrawn = false;
        if (self.drawLines.historyIndex > 1) {
            self.displayElevationProfile(self.drawLines.history.slice(0, self.drawLines.historyIndex));
            profileDrawn = true;
        }
        else {
            const features = self.modify.getActiveFeatures().filter(function (feat) {
                return TC.feature.Polyline && feat instanceof TC.feature.Polyline;
            });
            if (features.length) {
                const feature = features[features.length - 1];
                self.displayElevationProfile(feature.geometry);
                profileDrawn = true;
            }
        }
        if (!profileDrawn) {
            self.resetElevationProfile();
        }
        if (self.resultsPanelChart) {
            self.resultsPanelChart.show();
        }
    };

    ctlProto.deactivateElevationProfile = function () {
        const self = this;
        self.elevationProfileActive = false;
        self._elevProfileBtn.classList.remove(TC.Consts.classes.ACTIVE);
        self._elevProfileBtn.setAttribute('title', self.getLocaleString('activateElevationProfile'));
        self.resetElevationProfile();
        if (self.resultsPanelChart) {
            self.resultsPanelChart.close();
        }
    };

    ctlProto.resetElevationProfile = function () {
        const self = this;
        if (self.options.displayElevation && self.resultsPanelChart) {
            self.elevationProfileData = {
                x: [0],
                ele: [0],
                coords: [0, 0, 0],
                upHill: 0,
                downHill: 0
            };
            self.resultsPanelChart.openChart(self.elevationProfileData);
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.SWCacheClient) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/SWCacheClient');
}

TC.Consts.editMode = {
    SELECT: 'select',
    ADDPOINT: 'addpoint',
    ADDLINE: 'addline',
    ADDPOLYGON: 'addpolygon'
};
TC.Consts.editStyles = {
    NEW: 'temporary',
    SELECTED: 'select',
    DEFAULT: 'default'
};

TC.Consts.event.POINT = 'point.tc';
TC.Consts.event.BEFOREFEATUREMODIFY = "beforefeaturemodify.tc";
TC.Consts.event.FEATUREMODIFY = "featuremodify.tc";
TC.Consts.event.FEATURESSELECT = "featureselect.tc";
TC.Consts.event.FEATURESUNSELECT = "featureunselect.tc";

(function () {
    var newFeatureIdNumber = 0;
    var getNewFeatureId = function () {
        return "NewFeature." + newFeatureIdNumber++;
    };

    var storeFeature = function (key, feature) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                var obj;
                var geometryType;
                switch (true) {
                    case feature instanceof TC.feature.Polygon:
                        geometryType = TC.Consts.geom.POLYGON;
                        break;
                    case feature instanceof TC.feature.Polyline:
                        geometryType = TC.Consts.geom.POLYLINE;
                        break;
                    case feature instanceof TC.feature.Point:
                        geometryType = TC.Consts.geom.POINT;
                        break;
                    case feature instanceof TC.feature.MultiPolygon:
                        geometryType = TC.Consts.geom.MULTIPOLYGON;
                        break;
                    case feature instanceof TC.feature.MultiPolyline:
                        geometryType = TC.Consts.geom.MULTIPOLYLINE;
                        break;
                }
                obj = {
                    id: feature.id || feature.provId,
                    attributes: feature.data,
                    type: geometryType,
                    geometry: feature.geometry,
                }
                localforage.setItem(key, obj)
                    .then(function () {
                        resolve({ feature: feature });
                    })
                    .catch(function (error) {
                        reject({ feature: feature, error: error });
                    });
            });
        });
    };

    var deleteFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.removeItem(key)
                    .then(function () {
                        resolve(key);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            });
        });
    };

    var readFeature = function (key) {
        return new Promise(function (resolve, reject) {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(key)
                    .then(function (value) {
                        resolve({
                            key: key,
                            feature: value
                        });
                    })
                    .catch(function (error) {
                        reject(error);
                    });
            });
        });
    };

    var getStoragePrefix = function (ctl, layerId) {
        return ctl.LOCAL_STORAGE_KEY_PREFIX + (layerId || ctl.layer.id);
    };

    var getAddedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_ADDED_KEY_PREFIX;
    };

    var getModifiedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_MODIFIED_KEY_PREFIX;
    };

    var getRemovedStoragePrefix = function (ctl, layerId) {
        return getStoragePrefix(ctl, layerId) + ctl.LOCAL_STORAGE_REMOVED_KEY_PREFIX;
    };

    var setFeatureSelectReadyState = function (ctl) {
        ctl._deleteBtn.disabled = true;
        ctl._joinBtn.disabled = true;
        ctl._splitBtn.disabled = true;
    }

    var complexGeometryFilter = function (elm) {
        var result = false;
        if ((TC.feature.MultiPolygon && elm instanceof TC.feature.MultiPolygon) ||
            (TC.feature.MultiPolyline && elm instanceof TC.feature.MultiPolyline)) {
            if (elm.geometry.length > 1) {
                result = true;
            }
        }
        return result;
    };

    var setFeatureSelectedState = function (ctl, features) {
        ctl._deleteBtn.disabled = features.length === 0;
        ctl._joinBtn.disabled = features.length < 2;
        ctl._splitBtn.disabled = features.filter(complexGeometryFilter).length === 0;
    }

    var setSaveButtonsState = function (ctl, disabled) {
        ctl._saveBtn.disabled = disabled;
        ctl._discardBtn.disabled = disabled;
        self.checkedOut = !disabled;
    };

    var setChangedState = function (ctl, isChanged) {
        if (typeof isChanged !== 'undefined') {
            setSaveButtonsState(ctl, !isChanged);
        }
        else {
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                var storagePrefix = getStoragePrefix(ctl);
                localforage.keys().then(function (keys) {
                    if (keys) {
                        var disabled = true;
                        for (var i = 0, len = keys.length; i < len; i++) {
                            if (keys[i].indexOf(storagePrefix) === 0) {
                                disabled = false;
                                break;
                            }
                        }
                        setSaveButtonsState(ctl, disabled);
                    }
                });
            });
        }
    };

    var addChangesLayer = function (ctl, layer) {
        return new Promise(function (resolve, reject) {
            var changesLayer = ctl._changesLayers[layer.id];
            if (changesLayer) {
                resolve(changesLayer);
            }
            else {
                changesLayer = ctl._changesLayers[layer.id] = new TC.layer.Vector({
                    id: TC.getUID(),
                    title: layer.title + ' - cambios pendientes',
                    stealth: true,
                    styles: ctl.getChangesLayerStyle(layer)
                });
                var idx = ctl.map.layers.indexOf(layer);
                ctl.map.insertLayer(changesLayer, idx + 1, function () {
                    resolve(changesLayer);
                });
            }
        });
    };

    /* Creamos el constructor, llamando al constructor del padre */
    TC.control.Edit = function () {
        var self = this;

        TC.control.SWCacheClient.apply(this, arguments);

        self._classSelector = '.' + self.CLASS;

        self.wrap = new TC.wrap.control.Edit(self);
        self.layer = null;
        self.checkedOut = false;
        //self.feature = self.options.feature ? self.options.feature : null;
        self.callback = (arguments[2] && $.isFunction(arguments[2])) ? arguments[2] : (self.options.callback ? self.options.callback : null);
        self.multi = self.options.multi ? self.options.multi : false;
        self.eraseActionConfirmTxt = self.options.eraseText ? self.options.eraseText : "¿Está seguro de eliminar esta(s) geometría(s)?";
        self.cancelActionConfirmTxt = self.options.cancelText ? self.options.eraseText : "Si continua todos los cambios se perderán. ¿Desea continuar?";
        self.styles = self.options.styles;
        self.features = {};
        self.attributeEditor = null;
        self.pointDraw = null;
        self.lineDraw = null;
        self.polygonDraw = null;
        self.snapping = (typeof self.options.snapping === 'boolean') ? self.options.snapping : true;
        self._changesLayers = {};
        self._showsChanges = (typeof self.options.showChanges === 'boolean') ? self.options.showChanges : true;
        if ($.isFunction(self.options.getChangesLayerStyleFunction)) {
            self.getChangesLayerStyleFunction = self.getChangesLayerStyle;
        }

        self
            .on(TC.Consts.event.FEATUREADD, function (e) {
                var feat = e.feature;
                feat.provId = getNewFeatureId();
                var changesLayer = self._changesLayers[self.layer.id];
                self.features[self.layer.id].added.push(feat);
                changesLayer.addFeature(feat);
                storeFeature(getAddedStoragePrefix(self) + feat.provId, feat).then(function () {
                    setChangedState(self, true);
                    TC.toast("Adición guardada");
                }, function () {
                    TC.error("Fallo al guardar adición");
                });
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                var feat = e.feature;
                var fid = feat.provId || feat.id;
                var storeSuccess = function () {
                    setChangedState(self);
                    TC.toast("Eliminación guardada");
                };
                var storeFailure = function () {
                    TC.error("Fallo al guardar eliminación");
                };
                var changesLayer = self._changesLayers[self.layer.id];
                var features = self.features[self.layer.id];
                var idx = features.added.indexOf(feat);
                if (idx < 0) {
                    var removedStoragePrefix = getRemovedStoragePrefix(self);
                    idx = features.modified.indexOf(feat);
                    if (idx < 0) {
                        idx = features.removed.indexOf(feat);
                        if (idx < 0) {
                            features.removed.push(feat);
                            changesLayer.addFeature(feat);
                            storeFeature(removedStoragePrefix + feat.id, feat).then(storeSuccess, storeFailure);
                        }
                    }
                    else {
                        features.modified.splice(idx, 1);
                        features.removed.push(feat);
                        deleteFeature(getModifiedStoragePrefix(self) + feat.id).then(function () {
                            storeSuccess();
                            storeFeature(removedStoragePrefix + feat.id, feat).then(storeSuccess, storeFailure);
                        }, storeFailure);
                    }
                }
                else {
                    changesLayer.removeFeature(feat);
                    features.added.splice(idx, 1);
                    deleteFeature(getAddedStoragePrefix(self) + fid).then(storeSuccess, storeFailure);
                }
            })
            .on(TC.Consts.event.FEATUREMODIFY, function (e) {
                var feat = e.feature;
                var fid = feat.provId || feat.id;
                var storeSuccess = function () {
                    setChangedState(self, true);
                    TC.toast("Modificación guardada");
                };
                var storeFailure = function () {
                    TC.error("Fallo al guardar modificación");
                };
                var changesLayer = self._changesLayers[self.layer.id];
                var features = self.features[self.layer.id];
                var idx = features.added.indexOf(feat);
                if (idx < 0) {
                    idx = features.modified.indexOf(feat);
                    if (idx < 0) {
                        changesLayer.addFeature(feat);
                        features.modified.push(feat);
                    }
                    storeFeature(getModifiedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                }
                else {
                    storeFeature(getAddedStoragePrefix(self) + fid, feat).then(storeSuccess, storeFailure);
                }
            })
            .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATUREMODIFY, function (e) {
                if (self.serviceWorkerEnabled && navigator.onLine) {
                    var gfUrl = self.layer.wrap.getGetFeatureUrl();
                    var dftUrl = self.layer.wrap.getDescribeFeatureTypeUrl();
                    if (gfUrl && dftUrl) {
                        self.createCache(self.LOCAL_STORAGE_KEY_PREFIX + self.layer.id, {
                            urlList: [gfUrl, dftUrl]
                        });
                    }
                }
            })
            //.on(TC.Consts.event.MEASURE + ' ' + TC.Consts.event.MEASUREPARTIAL, function (e) {
            //    var precision = e.units === 'm' ? 0 : 3;
            //    if (e.area) {
            //        self._$area.html(e.area.toFixed(precision).replace('.', ',') + ' ' + e.units + '&sup2;');
            //    }
            //    if (e.perimeter) {
            //        self._$peri.html(e.perimeter.toFixed(precision).replace('.', ',') + ' ' + e.units);
            //    }
            //    if (e.length) {
            //        self._$len.html(e.length.toFixed(precision).replace('.', ',') + ' ' + e.units);
            //    }
            //})
            //.on(TC.Consts.event.MEASURE, function (e) {
            //    self._pointHistoryIdx = 0;
            //    self.history.length = self._pointHistoryIdx;
            //    self._$undoBtn.prop('disabled', true);
            //    self._$redoBtn.prop('disabled', true);
            //})
            .on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
                //self._$area.html('-');
                //self._$peri.html('-');
                //self._$len.html('-');
            })
            .on(TC.Consts.event.FEATURESSELECT, function (e) {
                
                var features = self.getSelectedFeatures();
                setFeatureSelectedState(self, features);
                if (features.length) {
                    features[0].showPopup(self.attributeEditor);
                }
            })
            .on(TC.Consts.event.FEATURESUNSELECT, function (e) {
                setFeatureSelectedState(self, self.getSelectedFeatures());
            });
            //.on(TC.Consts.event.EDITIONSAVE, function (e) {
            //    if (self.callback)
            //        self.callback(e.added, e.removed, e.modified);
            //});
    };

    TC.inherit(TC.control.Edit, TC.control.SWCacheClient);

    var ctlProto = TC.control.Edit.prototype;

    ctlProto.CLASS = 'tc-ctl-edit';
    ctlProto.LOCAL_STORAGE_KEY_PREFIX = "TC.offline.edit.";
    ctlProto.LOCAL_STORAGE_ADDED_KEY_PREFIX = ".added.";
    ctlProto.LOCAL_STORAGE_MODIFIED_KEY_PREFIX = ".modified.";
    ctlProto.LOCAL_STORAGE_REMOVED_KEY_PREFIX = ".removed.";

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Edit.html";
        ctlProto.template[ctlProto.CLASS + '-attr'] = TC.apiLocation + "TC/templates/EditAttributes.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "featureEdit" }).w("</h2><div class=\"tc-ctl-edit-layer\"><select class=\"tc-combo tc-ctl-edit-layer-sel\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "selectLayerToEdit" }).w("</option>").s(ctx.get(["layers"], false), ctx, { "block": body_1 }, {}).w("</select><input type=\"checkbox\" id=\"tc-ctl-edit-view-changes-cb\"").x(ctx.get(["showChanges"], false), ctx, { "block": body_2 }, {}).w(" /><label class=\"tc-ctl-edit-view-changes\" for=\"tc-ctl-edit-view-changes-cb\">").h("i18n", ctx, {}, { "$key": "highlightUnsyncedChanges" }).w("</label></div><div class=\"tc-ctl-edit-mode\"><form><label class=\"tc-ctl-edit-btn-select\" title=\"").h("i18n", ctx, {}, { "$key": "select" }).w("\"><input type=\"radio\" name=\"mode\" value=\"select\" /><span>").h("i18n", ctx, {}, { "$key": "select" }).w("</span></label><label class=\"tc-ctl-edit-btn-point\" title=\"").h("i18n", ctx, {}, { "$key": "newPoint" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addpoint\" /><span>").h("i18n", ctx, {}, { "$key": "newPoint" }).w("</span></label><label class=\"tc-ctl-edit-btn-line\" title=\"").h("i18n", ctx, {}, { "$key": "newLine" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addline\" /><span>").h("i18n", ctx, {}, { "$key": "newLine" }).w("</span></label><label class=\"tc-ctl-edit-btn-polygon\" title=\"").h("i18n", ctx, {}, { "$key": "newPolygon" }).w("\"><input type=\"radio\" name=\"mode\" value=\"addpolygon\" /><span>").h("i18n", ctx, {}, { "$key": "newPolygon" }).w("</span></label></form></div><div class=\"tc-ctl-edit-select tc-hidden\"><button class=\"tc-ctl-btn tc-ctl-edit-btn-delete\" disabled title=\"").h("i18n", ctx, {}, { "$key": "delete" }).w("\">").h("i18n", ctx, {}, { "$key": "delete" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-join\" disabled title=\"").h("i18n", ctx, {}, { "$key": "joinGeometries.tooltip" }).w("\">").h("i18n", ctx, {}, { "$key": "joinGeometries" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-split\" disabled title=\"").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("\">").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("</button><button class=\"tc-ctl-btn tc-ctl-edit-btn-cancel\" disabled title=\"").h("i18n", ctx, {}, { "$key": "cancel" }).w("\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div><div class=\"tc-ctl-edit-point tc-hidden\"></div><div class=\"tc-ctl-edit-line tc-hidden\"></div><div class=\"tc-ctl-edit-polygon tc-hidden\"></div><div class=\"tc-ctl-edit-save\"><button class=\"tc-button tc-icon-button tc-ctl-edit-btn-save\" disabled title=\"").h("i18n", ctx, {}, { "$key": "syncChanges" }).w("\">").h("i18n", ctx, {}, { "$key": "syncChanges" }).w("</button><button class=\"tc-button tc-icon-button tc-ctl-edit-btn-discard\" disabled title=\"").h("i18n", ctx, {}, { "$key": "discardChanges" }).w("\">").h("i18n", ctx, {}, { "$key": "discardChanges" }).w("</button></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["id"], false), ctx, "h").w("\">").f(ctx.get(["title"], false), ctx, "h").w("</option>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" checked"); } body_2.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-attr'] = function () {
            dust.register(ctlProto.CLASS + '-attr', body_0); var blocks = { "inputText": body_27, "inputNumber": body_28, "inputCheckbox": body_29, "inputDate": body_31, "inputTime": body_32, "inputDatetime": body_33 }; function body_0(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<div class=\"tc-ctl-edit-attr\"><h3>").h("i18n", ctx, {}, { "$key": "attributeEdit" }).w("</h3><div class=\"tc-ctl-edit-attr-body\"><table><tbody>").s(ctx.get(["data"], false), ctx, { "block": body_1 }, {}).w("</tbody></table></div><div class=\"tc-ctl-edit-attr-footer\"><button class=\"tc-button tc-ctl-edit-btn-attr-ok\">").h("i18n", ctx, {}, { "$key": "ok" }).w("</button><button class=\"tc-button tc-ctl-edit-btn-attr-cancel\">").h("i18n", ctx, {}, { "$key": "cancel" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<tr><th>").f(ctx.get(["name"], false), ctx, "h").w("</th><td>").x(ctx.get(["readOnly"], false), ctx, { "else": body_2, "block": body_34 }, {}).w("</td></tr>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.x(ctx.get(["availableValues"], false), ctx, { "block": body_3 }, {}).h("select", ctx, { "block": body_5 }, { "key": ctx.get(["type"], false) }); } body_2.__dustBody = !0; function body_3(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<select class=\"tc-combo\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\"><option value=\"\"></option>").s(ctx.get(["availableValues"], false), ctx, { "block": body_4 }, {}).w("</select>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<option value=\"").f(ctx.getPath(true, []), ctx, "h").w("\">").f(ctx.getPath(true, []), ctx, "h").w("</option>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.h("none", ctx, { "block": body_6 }, {}).h("eq", ctx, { "block": body_7 }, { "value": "int" }).h("eq", ctx, { "block": body_8 }, { "value": "integer" }).h("eq", ctx, { "block": body_9 }, { "value": "double" }).h("eq", ctx, { "block": body_10 }, { "value": "boolean" }).h("eq", ctx, { "block": body_11 }, { "value": "date" }).h("eq", ctx, { "block": body_12 }, { "value": "time" }).h("eq", ctx, { "block": body_13 }, { "value": "dateTime" }).h("eq", ctx, { "block": body_14 }, { "value": "byte" }).h("eq", ctx, { "block": body_15 }, { "value": "long" }).h("eq", ctx, { "block": body_16 }, { "value": "negativeInteger" }).h("eq", ctx, { "block": body_17 }, { "value": "nonNegativeInteger" }).h("eq", ctx, { "block": body_18 }, { "value": "nonPositiveInteger" }).h("eq", ctx, { "block": body_19 }, { "value": "positiveInteger" }).h("eq", ctx, { "block": body_20 }, { "value": "short" }).h("eq", ctx, { "block": body_21 }, { "value": "unsignedLong" }).h("eq", ctx, { "block": body_22 }, { "value": "unsignedInt" }).h("eq", ctx, { "block": body_23 }, { "value": "unsignedShort" }).h("eq", ctx, { "block": body_24 }, { "value": "unsignedByte" }).h("eq", ctx, { "block": body_25 }, { "value": "float" }).h("eq", ctx, { "block": body_26 }, { "value": "decimal" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputText"), ctx, {}, {}); } body_6.__dustBody = !0; function body_7(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_7.__dustBody = !0; function body_8(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_8.__dustBody = !0; function body_9(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_9.__dustBody = !0; function body_10(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputCheckbox"), ctx, {}, {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputDate"), ctx, {}, {}); } body_11.__dustBody = !0; function body_12(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputTime"), ctx, {}, {}); } body_12.__dustBody = !0; function body_13(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputDatetime"), ctx, {}, {}); } body_13.__dustBody = !0; function body_14(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_14.__dustBody = !0; function body_15(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_15.__dustBody = !0; function body_16(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_16.__dustBody = !0; function body_17(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_17.__dustBody = !0; function body_18(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_18.__dustBody = !0; function body_19(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_19.__dustBody = !0; function body_20(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_20.__dustBody = !0; function body_21(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_21.__dustBody = !0; function body_22(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_22.__dustBody = !0; function body_23(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_23.__dustBody = !0; function body_24(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_24.__dustBody = !0; function body_25(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_25.__dustBody = !0; function body_26(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.b(ctx.getBlock("inputNumber"), ctx, {}, {}); } body_26.__dustBody = !0; function body_27(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"text\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_27.__dustBody = !0; function body_28(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"number\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_28.__dustBody = !0; function body_29(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"checkbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["value"], false), ctx, { "block": body_30 }, {}).w("/>"); } body_29.__dustBody = !0; function body_30(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w(" checked"); } body_30.__dustBody = !0; function body_31(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"date\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_31.__dustBody = !0; function body_32(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"time\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_32.__dustBody = !0; function body_33(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.w("<input type=\"datetime\" class=\"tc-textbox\" name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" value=\"").f(ctx.get(["value"], false), ctx, "h").w("\" />"); } body_33.__dustBody = !0; function body_34(chk, ctx) { ctx = ctx.shiftBlocks(blocks); return chk.f(ctx.get(["value"], false), ctx, "h"); } body_34.__dustBody = !0; return body_0
        };
    }

    /* Extendemos el método register. 
       La lógica del control suele definirse aquí. */
    ctlProto.register = function (map) {
        var self = this;
        const result = TC.control.SWCacheClient.prototype.register.call(self, map);

        const drawPointsId = self.getUID();
        const drawLinesId = self.getUID();
        const drawPolygonsId = self.getUID();

        map.addControl('popup', { closeButton: true }).then(function (ctl) {
            self.attributeEditor = ctl;
        });

        map
            .on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    var features = self.features[layer.id] = self.features[layer.id] || {
                        added: [],
                        modified: [],
                        removed: []
                    };
                    addChangesLayer(self, layer).then(function (changesLayer) {
                        if (self.layer !== layer) {
                            changesLayer.setVisibility(false);
                        }
                        var storagePrefix = getStoragePrefix(self, layer.id);
                        var addedStoragePrefix = getAddedStoragePrefix(self, layer.id);
                        var modifiedStoragePrefix = getModifiedStoragePrefix(self, layer.id);
                        var removedStoragePrefix = getRemovedStoragePrefix(self, layer.id);
                        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                            //var li = map.getLoadingIndicator();
                            var uid = TC.getUID();
                            localforage.keys().then(function (keys) {
                                if (keys) {
                                    for (var i = 0, len = keys.length; i < len; i++) {
                                        var key = keys[i];
                                        if (key.indexOf(storagePrefix) === 0) {
                                            //li && li.addWait(uid);
                                            readFeature(key).then(function (obj) {
                                                var id;
                                                var k = obj.key;
                                                if (k.indexOf(removedStoragePrefix) === 0) {
                                                    id = k.substr(removedStoragePrefix.length);
                                                    var feature = layer.getFeatureById(id);
                                                    layer.removeFeature(feature);
                                                    changesLayer.addFeature(feature);
                                                    features.removed.push(feature);
                                                    //li && li.removeWait(uid);
                                                }
                                                else if (k.indexOf(modifiedStoragePrefix) === 0) {
                                                    id = k.substr(modifiedStoragePrefix.length);
                                                    var feature = layer.getFeatureById(id);
                                                    if (feature) {
                                                        changesLayer.addFeature(feature);
                                                        features.modified.push(feature);
                                                        feature.wrap.setGeometry(obj.feature.geometry);
                                                        feature.setData(obj.feature.attributes);
                                                        //li && li.removeWait(uid);
                                                    }
                                                }
                                                else if (k.indexOf(addedStoragePrefix) === 0) {
                                                    id = k.substr(addedStoragePrefix.length);
                                                    var idNumber = parseInt(id.substr(id.lastIndexOf('.') + 1));
                                                    newFeatureIdNumber = Math.max(newFeatureIdNumber, idNumber + 1);
                                                    var addPromise;
                                                    switch (obj.feature.type) {
                                                        case TC.Consts.geom.POINT:
                                                            addPromise = layer.addPoint(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.POLYLINE:
                                                            addPromise = layer.addPolyline(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.POLYGON:
                                                            addPromise = layer.addPolygon(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.MULTIPOLYLINE:
                                                            addPromise = layer.addMultiPolyline(obj.feature.geometry);
                                                            break;
                                                        case TC.Consts.geom.MULTIPOLYGON:
                                                            addPromise = layer.addMultiPolygon(obj.feature.geometry);
                                                            break;
                                                        default:
                                                            break;
                                                    };
                                                    addPromise.then(function (feat) {
                                                        //feat.setStyle($.extend({}, layer.styles.line, layer.styles.polygon));
                                                        changesLayer.addFeature(feat);
                                                        features.added.push(feat);
                                                        feat.provId = id;
                                                        feat.setData(obj.feature.attributes);
                                                        //li && li.removeWait(uid);
                                                    });
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        });
                    });
                    //map.off(TC.Consts.event.LAYERUPDATE, layerUpdateHandler);
                }
            })
            .on(TC.Consts.event.LAYERADD, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    self.features[layer.id] = self.features[layer.id] || {
                        added: [],
                        modified: [],
                        removed: []
                    };
                    const option = document.createElement('option');
                    option.setAttribute('value', layer.id);
                    option.innerHTML = layer.title || layer.id;
                    self._layerSelect.appendChild(option);
                }
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const layer = e.layer;
                if (layer.type === TC.Consts.layerType.WFS && !layer.options.stealth) {
                    var option = self._layerSelect.querySelector('option[value=' + layer.id + ']');
                    if (option.selected) {
                        self.setLayer(null);
                    }
                    option.parentElement.removeChild(option);
                }
            })
            .on(TC.Consts.event.POPUP, function (e) {
                if (e.control === self.attributeEditor) {
                    var feature = e.control.currentFeature;
                    var attributes = self.attributes.slice();
                    var attributeTypes = {};
                    var jfa = self._joinedFeatureAttributes || [];
                    for (var i = 0, ii = attributes.length; i < ii; i++) {
                        var attr
                        var data = feature.getData() || {};
                        var attributeObj = attributes[i];
                        attributeObj.value = data[attributeObj.name];
                        if (attributeObj.name === 'id') {
                            attributeObj.readOnly = true;
                        }
                        attributeObj.availableValues = [];
                        for (var j = 0, jj = jfa.length; j < jj; j++) {
                            var val = jfa[j][attributeObj.name];
                            if (val !== undefined && val !== '') {
                                attributeObj.availableValues[attributeObj.availableValues.length] = val;
                            }
                        }
                        attributeTypes[attributeObj.name] = attributeObj.type;
                    }
                    attributes.sort(function (a, b) {
                        if (a.readOnly ? !b.readOnly : b.readOnly) { //XOR
                            return !a.readOnly - !b.readOnly; // Primero readOnly
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        if (a.name < b.name) {
                            return -1;
                        }
                        return 0;
                    });
                    self.getRenderedHtml(self.CLASS + '-attr', { data: attributes }, function (html) {
                        const contentDiv = self.attributeEditor.contentDiv;
                        contentDiv.innerHTML = html;
                        const inputs = contentDiv.querySelectorAll('input');
                        const selects = contentDiv.querySelectorAll('select');
                        inputs.forEach(function (elm) {
                            elm.addEventListener('input', function (e) {
                                const input = e.target;
                                for (var i = 0, len = selects.length; i < len; i++) {
                                    const select = selects[i];
                                    if (select.matches('[name=' + e.target.getAttribute('name') + ']') && select.value !== input.value) {
                                        select.value = '';
                                        break;
                                    }
                                }
                            });
                        });
                        selects.forEach(function (elm) {
                            elm.addEventListener('change', function (e) {
                                const select = e.target;
                                for (var i = 0, len = inputs.length; i < len; i++) {
                                    const input = inputs[i];
                                    if (input.matches('[name=' + select.getAttribute('name') + ']')) {
                                        input.value = select.value;
                                        break;
                                    }
                                }
                            });
                        });
                        contentDiv.querySelector('.' + self.CLASS + '-btn-attr-ok').addEventListener('click', function () {
                            var data = {};
                            inputs.forEach(function (input) {
                                var name = input.getAttribute('name');
                                var value = input.value;
                                switch (attributeTypes[name]) {
                                    case 'int':
                                    case 'integer':
                                    case 'byte':
                                    case 'long':
                                    case 'negativeInteger':
                                    case 'nonNegativeInteger':
                                    case 'nonPositiveInteger':
                                    case 'positiveInteger':
                                    case 'short':
                                    case 'unsignedLong':
                                    case 'unsignedInt':
                                    case 'unsignedShort':
                                    case 'unsignedByte':
                                        value = parseInt(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'double':
                                    case 'float':
                                    case 'decimal':
                                        value = parseFloat(value);
                                        if (!Number.isNaN(value)) {
                                            data[name] = value;
                                        }
                                        break;
                                    case 'date':
                                    case 'time':
                                    case 'dateTime':
                                        data[name] = new Date(value);
                                        break;
                                    case 'boolean':
                                        data[name] = !!value;
                                        break;
                                    case undefined:
                                        break;
                                    default:
                                        data[name] = value;
                                        break;
                                }
                            });
                            feature.setData(data);
                            self.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature, layer: self.layer });
                            self.attributeEditor.hide();
                        });
                        contentDiv.querySelector('.' + self.CLASS + '-btn-attr-cancel').addEventListener('click', function () {
                            self.attributeEditor.hide();
                        });
                    });
                }
            });



        map.loaded(function () {
            if (self.options.layer) {
                self.setLayer(self.options.layer);
            }
            else {
                var wfsLayers = map.workLayers.filter(function (elm) {
                    return elm.type === TC.Consts.layerType.WFS && !elm.options.stealth;
                });
                if (wfsLayers.length === 1) {
                    self.setLayer(wfsLayers[0].id);
                }
                else {
                    self.setLayer(null);
                }
            }

            self.showChanges(self._showsChanges);

            self.renderPromise().then(function () {
                var DRAW = 'draw';
                Promise.all([
                    map.addControl(DRAW, {
                        id: drawPointsId,
                        div: self.div.querySelector('.' + self.CLASS + '-point'),
                        mode: TC.Consts.geom.POINT,
                        layer: false
                    }),
                    map.addControl(DRAW, {
                        id: drawLinesId,
                        div: self.div.querySelector('.' + self.CLASS + '-line'),
                        mode: TC.Consts.geom.POLYLINE,
                        layer: false
                    }),
                    map.addControl(DRAW, {
                        id: drawPolygonsId,
                        div: self.div.querySelector('.' + self.CLASS + '-polygon'),
                        mode: TC.Consts.geom.POLYGON,
                        layer: false
                    })
                ]).then (function (controls) {
                    self.pointDraw = controls[0];
                    self.lineDraw = controls[1];
                    self.polygonDraw = controls[2];

                    var drawendHandler = function (e) {
                        //var styleObj = {};
                        var feature = e.feature;
                        var featConstructor;
                        switch (self.geometryType) {
                            case TC.Consts.geom.POINT:
                                featConstructor = TC.feature.Point;
                                //$.extend(styleObj, self.layer.styles.point);
                                break;
                            case TC.Consts.geom.POLYLINE:
                                featConstructor = TC.feature.Polyline;
                                //$.extend(styleObj, self.layer.styles.line);
                                break;
                            case TC.Consts.geom.POLYGON:
                                featConstructor = TC.feature.Polygon;
                                //$.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                            case TC.Consts.geom.MULTIPOLYLINE:
                                featConstructor = TC.feature.MultiPolyline;
                                //$.extend(styleObj, self.layer.styles.line);
                                break;
                            case TC.Consts.geom.MULTIPOLYGON:
                                featConstructor = TC.feature.MultiPolygon;
                                //$.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                            default:
                                //$.extend(styleObj, self.layer.styles.line, self.layer.styles.polygon);
                                break;
                        }
                        if (featConstructor) {
                            feature = new featConstructor(feature.geometry, { geometryName: self.layer.options.geometryName });
                        }
                        //feature.setStyle(styleObj);
                        self.layer.addFeature(feature);
                        self.trigger(TC.Consts.event.FEATUREADD, { feature: feature });
                    };
                    var drawcancelHandler = function () {
                        self.cancel();
                    };
                    self.pointDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.lineDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    self.polygonDraw
                        .on(TC.Consts.event.DRAWEND, drawendHandler)
                        .on(TC.Consts.event.DRAWCANCEL, drawcancelHandler);
                    if (self.options.modes && $.isArray(self.options.modes) && self.options.modes.length == 1) {
                        self.setMode(self.options.modes[0], null);
                    }
                });
            });
        });
        //self.miEvent = map.on(TC.Consts.event.FEATURESADD + ".HasFeatures", function (e) {
        //    if (e.layer == self.layer) {
        //        self.miEvent = map.off(TC.Consts.event.FEATURESADD + ".HasFeatures");
        //    }
        //});

        //if (!self.layer || self.layer.features.length==0)
        //self._$resetBtn.prop('disabled', true);
        //self._deleteBtn.disabled = true;

        return result;
    };

    ctlProto.render = function (callback) {
        var self = this;
        var editLayers = [];
        if (self.map) {
            for (var i = 0, len = self.map.workLayers.length; i < len; i++) {
                var wl = self.map.workLayers[i];
                if (wl.type === TC.Consts.layerType.WFS && !wl.options.stealth) {
                    editLayers.push({
                        id: wl.id,
                        title: wl.title || wl.id
                    });
                }
            }
        }
        return self._set1stRenderPromise(TC.Control.prototype.renderData.call(self, { layers: editLayers, showChanges: self.showChanges }, function () {

            self._layerDiv = self.div.querySelector(self._classSelector + '-layer');
            self._layerSelect = self._layerDiv.querySelector(self._classSelector + '-layer-sel');
            self._layerSelect.addEventListener('change', function (e) {
                self.setLayer(self._layerSelect.value);
            });

            self._layerDiv.querySelector('#' + self.CLASS + '-view-changes-cb').addEventListener('change', function (e) {
                self.showChanges(e.target.checked);
            });

            //self._$len = self._$div.find(self._classSelector + '-val-len');
            //self._$area = self._$div.find(self._classSelector + '-val-area');
            //self._$peri = self._$div.find(self._classSelector + '-val-peri');

            self._cancelBtn = self.div.querySelector(self._classSelector + '-btn-cancel');
            self._cancelBtn.addEventListener('click', function () {
                self.cancel();
            });

            self._deleteBtn = self.div.querySelector(self._classSelector + '-btn-delete');
            self._deleteBtn.addEventListener('click', function () {
                TC.confirm(self.eraseActionConfirmTxt, function () {
                    self.deleteFeatures(self.getSelectedFeatures());
                });
            });
            self._joinBtn = self.div.querySelector(self._classSelector + '-btn-join');
            self._joinBtn.addEventListener('click', function () {
                self.joinFeatures(self.getSelectedFeatures());
            });
            self._splitBtn = self.div.querySelector(self._classSelector + '-btn-split');
            self._splitBtn.addEventListener('click', function () {
                self.splitFeatures(self.getSelectedFeatures());
            });
            self._saveBtn = self.div.querySelector(self._classSelector + '-btn-save');
            self._saveBtn.addEventListener('click', function () {
                self.applyEdits();
            });
            self._discardBtn = self.div.querySelector(self._classSelector + '-btn-discard');
            self._discardBtn.addEventListener('click', function () {
                self.discardEdits();
            });
            //control de renderizado enfunción del modo de edicion        
            if (self.options.modes && $.isArray(self.options.modes) && self.options.modes.length > 0) {
                for (var m in TC.Consts.editMode)
                    if (typeof m === 'string' && self.options.modes.indexOf(TC.Consts.editMode[m]) < 0) {
                        const label = self.div.querySelector("label" + self._classSelector + "-btn-" + TC.Consts.editMode[m]);
                        label.parentElement.removeChild(label);
                        const div = self.div.querySelector("div" + self._classSelector + "-" + TC.Consts.editMode[m]);
                        div.parentElement.removeChild(div);
                    }
                if (self.options.modes.length === 1) {
                    var mode = self.options.modes[0];
                    self.div.querySelector("label" + self._classSelector + "-btn-" + mode).style.display = 'none';
                }


            }
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.addEventListener('change', function () {
                    var newMode = this.value;
                    var mode = self.mode === newMode ? undefined : newMode;
                    self.setMode(mode);
                });
            });

            if ($.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        self.layer = map.getLayer(layer);
        self.setMode(null);
        var rbSelector = 'input[type=radio][name=mode]';
        if (self.layer) {
            addChangesLayer(self, self.layer).then(function (changesLayer) {
                for (var key in self._changesLayers) {
                    var cl = self._changesLayers[key];
                    cl.setVisibility(self._showsChanges && cl === changesLayer);
                }
            });

            self.layer.describeFeatureType().then(function (attributes) {
                // recogemos los atributos no geométricos y definimos la geometría
                self.attributes = attributes.filter(function (elm) {
                    switch (elm.type) {
                        case 'gml:LinearRingPropertyType':
                        case 'gml:PolygonPropertyType':
                            self.geometryType = TC.Consts.geom.POLYGON;
                            return false;
                        case 'gml:MultiPolygonPropertyType':
                        case 'gml:MultiSurfacePropertyType':
                            self.geometryType = TC.Consts.geom.MULTIPOLYGON;
                            return false;
                        case 'gml:LineStringPropertyType':
                            self.geometryType = TC.Consts.geom.POLYLINE;
                            return false;
                        case 'gml:MultiLineStringPropertyType':
                            self.geometryType = TC.Consts.geom.MULTIPOLYLINE;
                            return false;
                        case 'gml:PointPropertyType':
                        case 'gml:MultiPointPropertyType':
                            self.geometryType = TC.Consts.geom.POINT;
                            return false;
                        case 'gml:BoxPropertyType':
                            self.geometryType = TC.Consts.geom.RECTANGLE;
                            return false;
                        case 'gml:GeometryCollectionPropertyType':
                        case 'gml:GeometryAssociationType':
                            return false;
                        default:
                            return true;
                    }
                });
                for (var i = 0, len = self.attributes.length; i < len; i++) {
                    var attr = self.attributes[i];
                    attr.type = attr.type.substr(attr.type.indexOf(':') + 1);
                }
                self.renderPromise().then(function () {
                    setChangedState(self);
                    self.div.querySelector(self._classSelector + '-layer-sel').value = self.layer.id;

                    const rbList = self.div.querySelectorAll(rbSelector);
                    var selector;
                    switch (self.geometryType) {
                        case TC.Consts.geom.POINT:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDPOINT + ']';
                            break;
                        case TC.Consts.geom.POLYLINE:
                        case TC.Consts.geom.MULTIPOLYLINE:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDLINE + ']';
                            break;
                        case TC.Consts.geom.POLYGON:
                        case TC.Consts.geom.MULTIPOLYGON:
                            selector = '[value=select],[value=' + TC.Consts.editMode.ADDPOLYGON + ']';
                            break;
                        default:
                            selector = '[value]'
                            break;
                    }
                    rbList.forEach(function (rb) {
                        rb.disabled = !rb.matches(selector);
                    });
                });
            });
        }
        else {
            self.renderPromise().then(function () {
                setChangedState(self, false);
                const rbList = self.div.querySelectorAll(rbSelector);
                rbList.forEach(function (rb) {
                    rb.disabled = true;
                    rb.checked = false;
                });
            });
            self.layer = null;
        }
    };

    ctlProto.setMode = function (mode) {
        var self = this;
        self.mode = mode;
        setFeatureSelectReadyState(self);

        var activateDraw = function (draw) {
            if (draw) {
                if (self.snapping) {
                    draw.snapping = self.layer;
                }
                draw.activate();
            }
        };

        var active;
        var hiddenList;
        switch (mode) {
            case TC.Consts.editMode.SELECT:
                active = self.div.querySelector(self._classSelector + '-select');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                self.activate();
                break;
            case TC.Consts.editMode.ADDPOINT:
                active = self.div.querySelector(self._classSelector + '-point');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                activateDraw(self.pointDraw);
                break;
            case TC.Consts.editMode.ADDLINE:
                active = self.div.querySelector(self._classSelector + '-line');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-polygon');
                activateDraw(self.lineDraw);
                break;
            case TC.Consts.editMode.ADDPOLYGON:
                active = self.div.querySelector(self._classSelector + '-polygon');
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-line');
                activateDraw(self.polygonDraw);
                break;
            default:
                active = null;
                hiddenList = self.div.querySelectorAll(self._classSelector + '-select,' + self._classSelector + '-point,' + self._classSelector + '-line,' + self._classSelector + '-polygon');
                if (self.isActive) {
                    self.deactivate();
                }
                if (self.pointDraw && self.pointDraw.isActive) {
                    self.pointDraw.deactivate();
                }
                if (self.lineDraw && self.lineDraw.isActive) {
                    self.lineDraw.deactivate();
                }
                if (self.polygonDraw && self.polygonDraw.isActive) {
                    self.polygonDraw.deactivate();
                }
                break;
        }

        // Class TC.Consts.classes.CHECKED is for IE8 support
        var radio;
        if (mode) {
            const radio = self.div.querySelector('input[type=radio][name=mode][value=' + mode + ']');
            radio.checked = true;
            radio.classList.add(TC.Consts.classes.CHECKED);
            radio.nextSibling.classList.add(TC.Consts.classes.CHECKED);
        }
        else {
            self.div.querySelectorAll('input[type=radio][name=mode]').forEach(function (radio) {
                radio.checked = false;
                radio.classList.remove(TC.Consts.classes.CHECKED);
                radio.nextSibling.classList.remove(TC.Consts.classes.CHECKED);
            });
        }
        if (active) {
            active.classList.remove(TC.Consts.classes.HIDDEN);
        }
        hiddenList.forEach(function (hidden) {
            hidden.classList.add(TC.Consts.classes.HIDDEN);
        });
    };

    ctlProto.showChanges = function (show) {
        var self = this;
        self._showsChanges = show;
        for (var key in self._changesLayers) {
            var cl = self._changesLayers[key];
            cl.setVisibility(show && self.layer && key === self.layer.id);
        }
    };

    ctlProto.cancel = function () {
        var self = this;
        if (self.options.modes && $.isArray(self.options.modes) && self.options.modes.length == 1) {
            self.setMode(self.options.modes[0], null);
        }
        else {
            self.setMode(null, false);
        }
        self.wrap.cancel(true, self.cancelActionConfirmTxt);
    };

    ctlProto.onFeatureClick = function (e) {
        if (!self.activeControl || !self.activeControl.isExclusive()) {
            e.feature.show();
        }
    };
    
    ctlProto.activate = function (options) {
        //window.meas.deactivate();
        var self = this;
        TC.Control.prototype.activate.call(self);
        var opts = options || {};
        self._cancelBtn.disabled = false;
        self.wrap.activate(opts.mode ? opts.mode : self.mode);
        TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;
        TC.Control.prototype.deactivate.call(self);
        //self.features = {
        //    added: []
        //    , removed: []
        //};
        self.wrap.cancel(true);
        self._cancelBtn.disabled = true;
        self.wrap.deactivate();
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.joinFeatures = function (features) {
        var self = this;
        if (self.geometryType === TC.Consts.geom.MULTIPOLYLINE ||
            self.geometryType === TC.Consts.geom.MULTIPOLYGON ||
            self.geometryType === TC.Consts.geom.MULTIPOINT) {
            self._joinedFeatureAttributes = [];
            if (features.length > 1) {
                var geometries = features.map(function (elm) {
                    self._joinedFeatureAttributes[self._joinedFeatureAttributes.length] = elm.getData();
                    return elm.geometry;
                });
                var newGeometry = geometries.reduce(function (a, b) {
                    return a.concat(b);
                });
                var newFeature = new features[0].constructor(newGeometry);
                for (var i = 0, len = features.length; i < len; i++) {
                    var feature = features[i];
                    self.layer.removeFeature(feature);
                    self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
                }
                self.layer.addFeature(newFeature).then(function (feat) {
                    self.setSelectedFeatures([newFeature]);
                    self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
                    feat.showPopup(self.attributeEditor);
                });
            }
            setFeatureSelectedState(self, [newFeature]);
        }
    };

    ctlProto.splitFeatures = function (features) {
        var self = this;
        var complexFeatures = features.filter(complexGeometryFilter);
        var geometries = complexFeatures.map(function (elm) {
            return elm.geometry;
        });
        var newFeatures = [];
        for (var i = 0, ii = complexFeatures.length; i < ii; i++) {
            var feature = complexFeatures[i];
            var data = feature.getData();
            var geometry = geometries[i];
            for (var j = 0, jj = geometry.length; j < jj; j++) {
                newFeatures[newFeatures.length] = new feature.constructor([geometry[j]], { data: data });
            }
        }
        for (var i = 0, len = complexFeatures.length; i < len; i++) {
            var feature = complexFeatures[i];
            self.layer.removeFeature(feature);
            self.trigger(TC.Consts.event.FEATUREREMOVE, { feature: feature });
        }
        var newFeatPromises = new Array(newFeatures.length);
        for (var i = 0, len = newFeatures.length; i < len; i++) {
            const promise = newFeatPromises[i] = self.layer.addFeature(newFeatures[i]);
            promise.then(function (feat) {
                self.trigger(TC.Consts.event.FEATUREADD, { feature: feat });
            });
        }
        Promise.all(newFeatPromises).then(function() {
            self.setSelectedFeatures(newFeatures);
        });
        setFeatureSelectedState(self, newFeatures);
    };

    ctlProto.deleteFeatures = function (features) {
        var self = this;
        self.wrap.deleteFeatures(features);
        if (self.layer.features.length === 0) {
            self._deleteBtn.disabled = true;
        }
    };

    ctlProto.applyEdits = function () {
        var self = this;
        if (self.layer) {
            var features = self.features[self.layer.id];
            self.layer.applyEdits(features.added, features.modified, features.removed).then(function () {
                // Las acciones a realizar a partir de este punto son las mismas que al descartar una edición
                self.discardEdits();
                self.map.toast('Cambios sincronizados con éxito con el servidor');
            },
            function (obj) {
                TC.error("Error [" + obj.code + "] al guardar cambios: " + obj.reason);
            });
        }
    };

    ctlProto.discardEdits = function () {
        var self = this;
        self._joinedFeatureAttributes = [];
        var storagePrefix = getStoragePrefix(self);
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
            localforage.keys().then(function (keys) {
                if (keys) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var key = keys[i];
                        if (key.indexOf(storagePrefix) === 0) {
                            localforage.removeItem(key);
                        }
                    }
                    if (self.layer) {
                        var features = self.features[self.layer.id];
                        features.added.length = 0;
                        features.modified.length = 0;
                        features.removed.length = 0;
                        self.setSelectedFeatures([]);
                        self.attributeEditor.hide();
                        var changesLayer = self._changesLayers[self.layer.id];
                        changesLayer.clearFeatures();
                        self.deleteCache(storagePrefix).then(function () {
                            self.layer.refresh();
                        });
                    }
                    setChangedState(self, false);
                }
            });
        });
    };

    //ctlProto.setFeature = function (feature) {
    //    var self = this;
    //    self.feature = feature;
    //}

    ctlProto.getSelectedFeatures = function () {
        return this.wrap.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        return this.wrap.setSelectedFeatures(features);
    };

    ctlProto.getLayer = function () {
        var self = this;
        return self.layer;
    };

    ctlProto.getChangesLayerStyle = function (layer) {
        var getNegativeColor = function (color) {
            var str;
            var rgba = layer.wrap.getRGBA(color);
            for (var i = 0; i < 3; i++) {
                rgba[i] = 255 - rgba[i];
            }
            str = (rgba[0] * 65536 + rgba[1] * 256 + rgba[2]).toString(16);
            if (str.length === 4) {
                str = '00' + str;
            }
            else if (str.length === 5) {
                str = '0' + str;
            }
            return '#' + str;
        };

        var dash = [1, 3];
        var result = $.extend(true, {}, layer.options.styles);
        if (result.point) {
            result.point.strokeColor = getNegativeColor(result.point.strokeColor);
            result.point.lineDash = dash;
        }
        if (result.line) {
            result.line.strokeColor = getNegativeColor(result.line.strokeColor);
            result.line.lineDash = dash;
        }
        if (result.polygon) {
            result.polygon.strokeColor = getNegativeColor(result.polygon.strokeColor);
            result.polygon.lineDash = dash;
        }

        return result;
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ExternalWMS = function (options) {
    if (TC.isLegacy) {
        console.warn("El control ExternalWMS no soporta modo legacy");
        return;
    }
    var self = this;
    this.count = 0;
    this._addedUrls = [];

    TC.Control.apply(self, arguments);

    self.allowReprojection = typeof self.options.allowReprojection === 'boolean' ? self.options.allowReprojection : true;
};

TC.inherit(TC.control.ExternalWMS, TC.Control);

(function () {
    var ctlProto = TC.control.ExternalWMS.prototype;

    ctlProto.CLASS = 'tc-ctl-xwms';

    /**
     * Marca como seleccionadas aquellas opciones del desplegable correspondientes a servicios WMS ya añadidos al TOC.
     */
    ctlProto.markServicesAsSelected = function (options) {
        if (options.length > 0) {
            const selectedOption = options[0];
            selectedOption.disabled = true;
            selectedOption.classList.add('tc-ctl-xwms-option-selected');
        }
    };

    ctlProto.register = function (map) {
        if (TC.isLegacy) {
            console.warn("El control ExternalWMS no soporta modo legacy");
            return;
        }

        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.div.addEventListener('change', TC.EventTarget.listenerBySelector('select', function (evt) {
            if (evt.target.value !== '') {
                var url = evt.target.value;
                if (url.indexOf('//') === 0) {
                    url = location.protocol + url;
                }
                self.div.querySelector('input').value = url;
                evt.target.value = '';
            }
        }));

        /**
         * Borra parámetros no necesarios de la URL del servicio WMS.
         */
        var _removeParamsFromUrl = function (url, unwantedParams) {
            for (var i = 0; i < unwantedParams.length; i++) {
                url = TC.Util.removeURLParameter(url, unwantedParams[i]);
            }
            if (url.match(/\?$/)) {
                url = url.substr(0, url.length - 1);
            }
            return url;
        }

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('button[name="agregar"]', function (evt) {
            var url = self.div.querySelector('input').value.trim();

            if (!url) {
                TC.alert(self.getLocaleString('typeAnAddress'));
            }
            else if (!/^((https?|ftp):)?(\/\/)?(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(url)) {
                TC.alert(self.getLocaleString('typeAValidAddress'));
            }
            else {
                if (self._addedUrls.some(function (addedUrl) {
                    return addedUrl.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')
                })) {
                    TC.alert(self.getLocaleString('serviceAlreadyAdded'));
                }
                else {
                    var loadingCtrl = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];
                    loadingCtrl.show();
                    var params = TC.Util.getQueryStringParams(url);

                    if (!/https?:\/\/|\/\//i.test(url)) {
                        url = "//" + url;
                    }

                    //Extraemos sólo los parámetros adicionales
                    var unwantedParams = ["version", "service", "request"];
                    var urlWithoutParams = _removeParamsFromUrl(url, Object.keys(params));

                    for (var item in params) {
                        if (unwantedParams.indexOf(item.toLowerCase()) >= 0) {
                            delete params[item];
                        }
                    }

                    const addButton = self.div.querySelector('button');
                    addButton.disabled = true;

                    var obj = {
                        id: 'xwms' + (++self.count),
                        //"title": "Servicio externo",
                        type: 'WMS',
                        url: urlWithoutParams,
                        hideTree: false,
                        queryParams: params
                    };
                    //URI: recorremos las opciones buscando el servicio que se va a agregar a ver si tiene parametro layerNames
                    for (var i = 0; i < self.options.suggestions.length; i++) {
                        var _current = $.grep(self.options.suggestions[i].items, function (item, i) {
                            return item.url === url;
                        });
                        if (_current.length > 0 && _current[0].layerNames) {
                            obj["layerNames"] = _current[0].layerNames;
                            break;
                        }
                    }

                    var layer = new TC.layer.Raster(obj);
                    layer.getCapabilitiesPromise().then(function (cap) {
                        if (typeof (cap.Capability) === 'undefined') {
                            TC.alert(self.getLocaleString('noLayersFoundInService'));
                            loadingCtrl.hide();
                            addButton.disabled = false;
                            return;
                        } else {
                            var root = cap.Capability.Layer;
                            if (root.CRS && root.CRS.indexOf(self.map.crs) == -1 && !self.allowReprojection) {
                                //no soportado. avisar y fallar
                                TC.alert(self.getLocaleString('serviceSrsNotCompatible'));
                                loadingCtrl.hide();
                                addButton.disabled = false;
                                return;
                            }

                            self.map.trigger(TC.Consts.event.EXTERNALSERVICEADDED, { layer: layer });
                            self.div.querySelector('input').value = '';

                            const selectedOptions = [];
                            self.div.querySelectorAll('select option').forEach(function (option) {
                                if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                                    selectedOptions.push(option);
                                }
                            });                            
                            self.markServicesAsSelected(selectedOptions);
                            self._addedUrls.push(url);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        }
                    },
                        function (error) {
                            TC.alert(self.getLocaleString('serviceCouldNotBeLoaded') + ":\n" + error);
                            loadingCtrl.hide();
                            addButton.disabled = false;
                        });
                }
            }

        }));

        map.on(TC.Consts.event.LAYERADD, function (e) {
            const layer = e.layer;
            if (layer && !layer.isBase) {
                var url = layer.url;

                if (url) {
                    self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];
                    if (self.div.querySelectorAll('select option').length === 0 && url && self.pending_markServicesAsSelected.indexOf(url) === -1) {
                        self.pending_markServicesAsSelected.push(url);
                    }

                    const selectedOptions = [];
                    self.div.querySelectorAll('select option').forEach(function (option) {
                        if (option.value.replace(/https?:\/\/|\/\//, '') === url.replace(/https?:\/\/|\/\//, '')) {
                            selectedOptions.push(option);
                        }
                    });
                    self.markServicesAsSelected(selectedOptions);
                    self._addedUrls.push(url);
                }
            }
        });

        return result;
    };

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ExternalWMS.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["title"], false), ctx, { "block": body_1 }, {}).w("<div><div class=\"tc-group tc-ctl-xwms-cnt\"> <select id=\"add-wms-select\" class=\"tc-combo\" title=\"WMS (Web Map Service)\"><option value=\"\">WMS</option>").s(ctx.get(["suggestions"], false), ctx, { "block": body_2 }, {}).w("</select><input type=\"url\" class=\"tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "writeAddressOrSelect" }).w("\" /></div><div class=\"tc-group tc-group tc-ctl-xwms-cnt\" style=\"text-align:right;\"><button type=\"button\" class=\"tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "addService.title" }).w("\" name=\"agregar\">").h("i18n", ctx, {}, { "$key": "addService" }).w("</button></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "addMaps" }).w("</h2>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.x(ctx.get(["group"], false), ctx, { "block": body_3 }, {}).s(ctx.get(["items"], false), ctx, { "block": body_4 }, {}).x(ctx.get(["group"], false), ctx, { "block": body_5 }, {}); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<optgroup label=\"").f(ctx.get(["group"], false), ctx, "h").w("\">"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["url"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</option>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("\t</optgroup>"); } body_5.__dustBody = !0; return body_0
        };
    }

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.renderData(self.options, function () {
            self.pending_markServicesAsSelected = self.pending_markServicesAsSelected || [];

            self.pending_markServicesAsSelected.forEach(function (elemUrl) {
                const selectedOptions = [];
                self.div.querySelectorAll('select option').forEach(function (option) {
                    if (TC.Util.addProtocol(option.value) === TC.Util.addProtocol(elemUrl)) {
                        selectedOptions.push(option);
                    }
                });

                self.markServicesAsSelected(selectedOptions);
                self._addedUrls.push(elemUrl);
            });

            self.pending_markServicesAsSelected = [];
        }));
    };


})();
﻿TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}

(function () {
    TC.control.FeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.FeatureInfo(self);

        TC.Consts.classes.FROMLEFT = 'tc-fromleft';
        TC.Consts.classes.FROMRIGHT = 'tc-fromright';

        if (self.options.displayElevation) {
            TC.loadJS(
                !TC.tool || !TC.tool.Elevation,
                TC.apiLocation + 'TC/tool/Elevation',
                function () {
                    const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                    self.elevation = new TC.tool.Elevation(elevationOptions);
                }
            );
        }
    };

    TC.inherit(TC.control.FeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.FeatureInfo.prototype;

    var roundCoordinates = function roundCoordinates(obj, precision) {
        var result;
        var n = 20;
        if ($.isArray(obj)) {
            result = obj.slice();
            for (var i = 0, len = result.length; i < len; i++) {
                result[i] = roundCoordinates(result[i]);
            }
        }
        else if (typeof obj === "number") {
            result = Math.round(obj.toFixed(precision));
        }
        else {
            result = obj;
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        // Le ponemos un padre al div. Evitamos con esto que se añada el div al mapa (no es necesario, ya que es un mero buffer)
        document.createElement('div').appendChild(self.div);

        return result;
    };

    ctlProto.callback = function (coords, xy) {
        var self = this;

        if (self.elevation) {
            self.querying = true;

            self.elevationRequest = self.elevation.getElevation({
                crs: self.map.crs,
                coordinates: coords
            });
        }

        if (self.map && self.filterLayer) {
            //aquí se pone el puntito temporal
            var title = self.getLocaleString('featureInfo');
            var markerOptions = $.extend({}, self.map.options.styles.marker, self.markerStyle, { title: title, set: title, showsPopup: false });
            self.filterLayer.clearFeatures();
            self.filterLayer.addMarker(coords, markerOptions).then(function (marker) {
                ////cuando se queda el puntito es porque esto sucede tras el cierre de la popup
                ////o sea
                ////lo normal es que primero se ejecute esto, y luego se procesen los eventos FEATUREINFO o NOFEATUREINFO
                ////pero en el caso raro (la primera vez), ocurre al revés. Entonces, ya se habrá establecido lastFeatureCount (no será null)
                //if (self.lastFeatureCount === null) {
                //    self.map.putLayerOnTop(self.filterLayer);
                //    self.filterFeature = marker;
                //}
                //else {
                //    self.filterLayer.clearFeatures();
                //}
                self.map.putLayerOnTop(self.filterLayer);
                self.filterFeature = marker;

                var visibleLayers = false;
                for (var i = 0; i < self.map.workLayers.length; i++) {
                    var layer = self.map.workLayers[i];
                    if (layer.type === TC.Consts.layerType.WMS) {
                        if (layer.getVisibility() && layer.names.length > 0) {
                            visibleLayers = true;
                            break;
                        }
                    }
                }
                var resolution = self.map.getResolution();
                if (visibleLayers) {
                    self.wrap.getFeatureInfo(coords, resolution);
                }
                else {
                    // Metemos setTimeout para salirnos del hilo. Sin él se corre el riesgo de que se ejecute esto antes del evento BEFOREFEATUREINFO
                    setTimeout(function () {
                        self.responseCallback({ coords: coords });
                    });
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        var self = this;
        const endCallback = function (elevCoords) {

            TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);

            if (self.filterFeature) {
                var services = options.services;

                // Eliminamos capas sin resultados
                if (services) {
                    for (var i = 0; i < services.length; i++) {
                        var service = services[i];
                        for (var j = 0; j < service.layers.length; j++) {
                            if (!service.layers[j].features.length) {
                                service.layers.splice(j, 1);
                                j = j - 1;
                            }
                        }
                        if (!service.layers.length) {
                            services.splice(i, 1);
                            i = i - 1;
                        }
                    }
                }

                self.info.defaultFeature = options.defaultFeature;

                var locale = self.map.options.locale || TC.Cfg.locale;
                options.isGeo = self.map.wrap.isGeo();
                if (elevCoords.length) {
                    const elevationValue = elevCoords[0][2];
                    options.elevation = elevationValue === null ? null : TC.Util.formatNumber(Math.round(elevationValue), locale);
                }
                if (options.coords) {
                    options.crs = self.map.crs;
                    options.coords = options.coords.map(function (value) {
                        return TC.Util.formatNumber(value.toFixed(options.isGeo ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION), locale);
                    });
                }
                if ((services && services.length) || options.elevation !== null) {
                    self.renderData(options, function () {
                        self.insertLinks();

                        if (self.sharedFeatureInfo) {
                            self.div.querySelectorAll('ul.' + self.CLASS + '-services li').forEach(function (li) {
                                li.classList.add(TC.Consts.classes.CHECKED);
                            })
                            var sharedFeature;
                            var featureObj = self.sharedFeatureInfo;
                            for (var i = 0, ii = self.info.services.length; i < ii; i++) {
                                var service = self.info.services[i];
                                if (service.mapLayers.some(function (ml) { return ml.url === featureObj.s })) {
                                    for (var j = 0, jj = service.layers.length; j < jj; j++) {
                                        var layer = service.layers[j];
                                        if (layer.name === featureObj.l) {
                                            for (var k = 0, kk = layer.features.length; k < kk; k++) {
                                                var feature = layer.features[k];
                                                if (feature.id === featureObj.f) {
                                                    sharedFeature = feature;
                                                    var hash = hex_md5(JSON.stringify({
                                                        data: feature.getData(),
                                                        geometry: roundCoordinates(feature.geometry, TC.Consts.DEGREE_PRECISION) // Redondeamos a la precisión más fina (grado)
                                                    }));
                                                    if (featureObj.h !== hash) {
                                                        TC.alert(self.getLocaleString('finfo.featureChanged.warning'));
                                                    }
                                                    break;
                                                }
                                            }
                                            break;
                                        }
                                    }
                                    break;
                                }
                            }
                            if (sharedFeature) {
                                self.highlightedFeature = sharedFeature;
                                self.map.addLayer({
                                    id: self.getUID(),
                                    type: TC.Consts.layerType.VECTOR,
                                    title: self.getLocaleString('foi'),
                                    stealth: true
                                }).then(function (layer) {
                                    self.sharedFeatureLayer = layer;
                                    self.filterLayer.clearFeatures();
                                    layer.addFeature(sharedFeature);
                                    self.map.zoomToFeatures([sharedFeature]);
                                });
                            }
                            delete self.sharedFeatureInfo;
                        }
                        else {
                            self.displayResults();
                        }
                    });
                }
                else {
                    self.resultsLayer.clearFeatures();
                    self.filterLayer.clearFeatures();
                }
            }

        };
        if (self.elevationRequest) {
            self.elevationRequest.then(endCallback);
        }
        else {
            endCallback([]);
        }
    };

    ctlProto.loadSharedFeature = function (featureObj) {
        // Función para dar compatibilidad hacia atrás, ahora las features se comparten por URL
        const self = this;
        if (featureObj) {
            //buscamos si la feature compartida pertenece a alguna de las capas añadidas
            if (jQuery.grep(self.map.workLayers, function (item, i) {
                return item.type === TC.Consts.layerType.WMS && item.url === featureObj.s && item.getDisgregatedLayerNames().indexOf(featureObj.l) >= 0
            }).length === 0) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
                return;
            }
            self.sharedFeatureInfo = featureObj;
            TC.loadJS(
                !window.hex_md5,
                [TC.apiLocation + TC.Consts.url.HASH],
                function () {
                    // Creamos una consulta getFeatureInfo ad-hoc, con la resolución a la que estaba la consulta original.
                    const coords = [-100, -100];
                    self.beforeRequest({ xy: coords }); // xy negativo para que no se vea el marcador, ya que no sabemos dónde ponerlo.
                    //aquí se pone el puntito temporal
                    self.filterLayer.clearFeatures();
                    self.filterLayer.addMarker(coords).then(function (marker) {
                        self.filterFeature = marker;
                        self.wrap.getFeatureInfo(featureObj.xy, featureObj.r, {
                            serviceUrl: featureObj.s,
                            layerName: featureObj.l,
                            featureId: featureObj.f
                        });
                    });
                }
            );
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.event.DRAWCHART = TC.Consts.event.DRAWCHART || 'drawchart.tc';
TC.Consts.event.DRAWTABLE = TC.Consts.event.DRAWTABLE || 'drawtable.tc';

TC.control.FeatureTools = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self.layer = null;
    self.exportsState = true;

    const cs = self._classSelector = '.' + self.CLASS;
    self._selectors = {
        ELEVATION_CHECKBOX: cs + '-dialog-elev input[type=checkbox]',
        INTERPOLATION_RADIO: 'input[type=radio][name=finfo-ip-coords]',
        INTERPOLATION_DISTANCE: cs + '-dialog-ip-m'
    };

    if (self.options.displayElevation) {
        TC.loadJS(
            !TC.tool || !TC.tool.Elevation,
            TC.apiLocation + 'TC/tool/Elevation',
            function () {
                const elevationOptions = typeof self.options.displayElevation === 'boolean' ? {} : self.options.displayElevation;
                self.elevation = new TC.tool.Elevation(elevationOptions);
            }
        );
    }

    self._dialogDiv = TC.Util.getDiv(self.options.dialogDiv);
    self._$dialogDiv = $(self._dialogDiv);
    if (!self.options.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
};

TC.inherit(TC.control.FeatureTools, TC.Control);

(function () {
    var ctlProto = TC.control.FeatureTools.prototype;

    ctlProto.CLASS = 'tc-ctl-ftools';

    ctlProto.TITLE_SEPARATOR = ' • ';
    ctlProto.FILE_TITLE_SEPARATOR = '__';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/FeatureTools.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/FeatureToolsDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools\"><button class=\"tc-ctl-ftools-dl-btn\" title=\"").h("i18n", ctx, {}, { "$key": "download" }).w("\">").h("i18n", ctx, {}, { "$key": "download" }).w("</button><button class=\"tc-ctl-ftools-share-btn\" title=\"").h("i18n", ctx, {}, { "$key": "share" }).w("\">").h("i18n", ctx, {}, { "$key": "share" }).w("</button><button class=\"tc-ctl-ftools-zoom-btn\" title=\"").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("\">").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("</button><button class=\"tc-ctl-ftools-del-btn\" title=\"").h("i18n", ctx, {}, { "$key": "deleteFeature" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteFeature" }).w("</button></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog tc-ctl-ftools-dl-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "feature" }).w(" - ").h("i18n", ctx, {}, { "$key": "download" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").s(ctx.get(["elevation"], false), ctx, { "block": body_1 }, {}).w("<div class=\"tc-ctl-ftools-dialog-dl\"><div><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-kml\" data-format=\"KML\" title=\"KML\">KML</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-gml\" data-format=\"GML\" title=\"GML\">GML</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-geojson\" data-format=\"GeoJSON\" title=\"GeoJSON\">GeoJSON</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-wkt\" data-format=\"WKT\" title=\"WKT\">WKT</button><button class=\"tc-button tc-btn-dl tc-ctl-ftools-dl-btn-gpx\" data-format=\"GPX\" title=\"GPX\">GPX</button></div></div></div></div></div><div class=\"tc-ctl-ftools-dialog tc-ctl-ftools-share-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "feature" }).w(" - ").h("i18n", ctx, {}, { "$key": "share" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><div class=\"tc-ctl-ftools-share-dialog-ctl\"></div></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog-elev\"><input id=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" type=\"checkbox\"><label for=\"").f(ctx.get(["checkboxId"], false), ctx, "h").w("\" class=\"tc-ctl-ftools-dialog-elev-label\">").h("i18n", ctx, {}, { "$key": "includeElevations" }).w("</label></div>").x(ctx.get(["resolution"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-ftools-dialog-ip tc-hidden\"><h4>").h("i18n", ctx, {}, { "$key": "interpolateCoordsFromElevProfile" }).w("</h4><label><input type=\"radio\" name=\"finfo-ip-coords\" value=\"0\" checked /><span>").h("i18n", ctx, {}, { "$key": "no" }).w("</span></label><label><input type=\"radio\" name=\"finfo-ip-coords\" value=\"1\"/><span>").h("i18n", ctx, {}, { "$key": "yes" }).w("</span></label><div class=\"tc-ctl-ftools-dialog-ip-m tc-hidden\">").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.1" }).w("<input type=\"number\" min=\"1\" step=\"1\" class=\"tc-textbox\" value=\"").f(ctx.get(["resolution"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "interpolateEveryXMeters.2" }).w("</div></div>"); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        map
            .on(TC.Consts.event.POPUP + ' ' + TC.Consts.event.DRAWTABLE + ' ' + TC.Consts.event.DRAWCHART, function (e) {
                self.currentDisplay = e.control;              // caso feature compartida
                if (self.currentDisplay.caller || (!self.currentDisplay.caller && self.currentDisplay.currentFeature)) {
                    self.highlightedFeature = !(!self.currentDisplay.caller && self.currentDisplay.currentFeature) ? self.currentDisplay.caller.highlightedFeature : self.currentDisplay.currentFeature;
                    if (self.highlightedFeature) {
                        self.highlightedFeature.showsPopup = true;
                    }

                    self.addUI(self.currentDisplay);
                }                
            })
            .on(TC.Consts.event.POPUPHIDE + ' ' + TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                self.currentDisplay = null;
            })
            .on(TC.Consts.event.FEATUREADD, function (e) {
                const feature = e.feature;
                if (self.currentDisplay && self.currentDisplay.caller && feature === self.currentDisplay.caller.highlightedFeature) {
                    self.highlightedFeature = feature;
                    self.highlightedFeature.showsPopup = true;
                }
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                const feature = e.feature;
                if (feature === self.highlightedFeature) {
                    const highlightedFeature = feature.clone();
                    highlightedFeature.showsPopup = true;
                    // Si la feature se eliminó por un cierre de popup provocado por la apertura de otro, 
                    // reasignamos la feature nueva al popup, ya que este está apuntando a una feature que ya no está en el mapa.
                    map.getControlsByClass('TC.control.Popup').concat(map.getControlsByClass('TC.control.ResultsPanel')).forEach(function (ctl) {
                        if (ctl.currentFeature === self.highlightedFeature) {
                            ctl.currentFeature = highlightedFeature;
                        }
                    });
                    self.getHighlightLayer().then(function (layer) {
                        layer.addFeature(highlightedFeature);
                    });
                }
            });

        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {
                self.map.addControl('share', {
                    id: self.getUID(),
                    div: self._dialogDiv.querySelector('.tc-modal-body .' + self.CLASS + '-share-dialog-ctl'),
                    includeControls: false // Establecemos el control para que no exporte estados de controles, así no se comparte la feature dos veces
                }).then(function (ctl) {
                    self._shareCtl = ctl;
                    resolve(self);
                }).catch(function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
            });
        });
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self._set1stRenderPromise(self.getRenderedHtml(self.CLASS + '-dialog', {
            checkboxId: self.getUID(),
            elevation: self.options.displayElevation
        }, function (html) {
            self._dialogDiv.innerHTML = html;
            self._dialogDiv.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('button[data-format]', function (e) {
                TC.Util.closeModal();
                const li = self.map.getLoadingIndicator();
                const waitId = li && li.addWait();

                const shareOptions = {};
                if (self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX) && self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked) {
                    const interpolateCoords = self._dialogDiv.querySelector(self._selectors.INTERPOLATION_RADIO + ':checked').value === "1";
                    shareOptions.elevation = {
                        resolution: interpolateCoords ? parseFloat(self._dialogDiv.querySelector(self._selectors.INTERPOLATION_DISTANCE + ' input[type=number]').value) || self.options.displayElevation.resolution : 0
                    };
                }
                prepareFeatureToShare(self, shareOptions)
                    .then(
                    function (feature) {
                        self.map.exportFeatures([feature], {
                            fileName: self._getFeatureFilename(feature),
                            format: e.target.dataset.format
                        });
                    },
                    function (error) {
                        if (error === TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED) {
                            TC.alert(self.getLocaleString('tooManyCoordinatesForElevation.warning'));
                            return;
                        }
                        TC.error(self.getLocaleString('elevation.error'));
                    }
                    )
                    .finally(function () {
                        li && li.removeWait(waitId);
                    });
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.ELEVATION_CHECKBOX, function (e) {
                self.showDownloadDialog(); // Recalculamos todo el aspecto del diálogo de descarga
            }));
            self._dialogDiv.addEventListener('change', TC.EventTarget.listenerBySelector(self._selectors.INTERPOLATION_RADIO, function (e) {
                const idDiv = self._dialogDiv.querySelector(self._selectors.INTERPOLATION_DISTANCE);
                if (e.target.value === '0') {
                    idDiv.classList.add(TC.Consts.classes.HIDDEN);
                }
                else {
                    idDiv.classList.remove(TC.Consts.classes.HIDDEN);
                }
            }));

            self.trigger(TC.Consts.event.CONTROLRENDER);
            if ($.isFunction(callback)) {
                callback();
            }
        }));
    };

    ctlProto.addUI = function (ctl) {
        const self = this;
        const menuContainer = ctl.getMenuElement();
        // Nos aseguramos de que el se decora el control una sola vez
        const menuIsMissing = function () {
            return menuContainer && !menuContainer.querySelector('.' + self.CLASS);
        };
        if (menuIsMissing()) {
            // Añadimos los botones de herramientas
            self.getRenderedHtml(self.CLASS, null, function (html) {
                if (menuIsMissing()) {
                    const parser = new DOMParser();
                    const tools = parser.parseFromString(html, 'text/html').body.firstChild;
                    menuContainer.appendChild(tools);

                    self.updateUI(ctl);

                    if (!self.map.options.stateful) {
                        // Compartir no funciona sin estado
                        const shareBtn = tools.querySelector('.' + self.CLASS + '-share-btn');
                        shareBtn.parentElement.removeChild(shareBtn);
                    }
                    self._setToolButtonHandlers(tools);
                    self._decorateDisplay(ctl.getContainerElement());
                }
            });
        }
        else {
            self.updateUI(ctl);
        }
    };

    ctlProto._decorateDisplay = function (container) {
        const self = this;        

        if (self.highlightedFeature) {

            // Añadimos un zoom a la feature al pulsar en la tabla
            if (container.querySelector('table.tc-attr')) {
                container.querySelector('table.tc-attr').addEventListener(TC.Consts.event.CLICK, function (e) {
                    self.zoomToCurrentFeature();
                });

                container.querySelector('table.tc-attr').classList.add(self.CLASS + '-zoom');
                container.querySelector('table.tc-attr').setAttribute('title', self.getLocaleString('clickToCenter'));
            }                        

            // Añadimos botón de imprimir
            TC.loadJS(
                !TC.control.Print,
                [TC.apiLocation + 'TC/control/Print'],
                function () {
                    var printTitle = "";

                    if (self.highlightedFeature) {
                        printTitle = self.highlightedFeature.id;

                        if (self.highlightedFeature.showsPopup === true) {
                            new TC.control.Print({
                                target: container,
                                title: printTitle
                            });
                        }
                    }
                });
        }        
    };

    ctlProto.updateUI = function (ctl) {
        const self = this;
        const uiDiv = ctl.getMenuElement().querySelector('.' + self.CLASS);
        uiDiv.classList.remove(TC.Consts.classes.ACTIVE);
        clearTimeout(self._uiUpdateTimeout);
        self._uiUpdateTimeout = setTimeout(function () {
            const currentFeature = self.getCurrentFeature();
            if (currentFeature && currentFeature.showsPopup) {
                uiDiv.classList.add(TC.Consts.classes.ACTIVE);
            }
            else {
                uiDiv.classList.remove(TC.Consts.classes.ACTIVE);
            }
        }, 100);
    };

    ctlProto._setToolButtonHandlers = function (container) {
        const self = this;

        // Evento para mostrar diálogo modal de descarga
        container.querySelector('.' + self.CLASS + '-dl-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.showDownloadDialog();
        });

        if (self.map.options.stateful) {
            // Evento para mostrar diálogo modal de compartir
            container.querySelector('.' + self.CLASS + '-share-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
                self.showShareDialog();
            });
        }

        // Evento para hacer zoom
        container.querySelector('.' + self.CLASS + '-zoom-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.zoomToCurrentFeature();
        });

        // Evento para borrar la feature
        container.querySelector('.' + self.CLASS + '-del-btn').addEventListener(TC.Consts.event.CLICK, function (e) {
            self.removeCurrentFeature();
        });
    };

    ctlProto.getHighlightLayer = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (self.layer) {
                resolve(self.layer);
            }
            else {
                self.map.addLayer({
                    id: self.getUID(),
                    title: self.CLASS + ': Highlighted features layer',
                    type: TC.Consts.layerType.VECTOR,
                    stealth: true
                }).then(function (layer) {
                    if (!self.layer) {
                        self.layer = layer;
                    }
                    resolve(self.layer);
                });
            }
        });
    };

    ctlProto.showDownloadDialog = function () {
        const self = this;

        const dialog = self._dialogDiv.querySelector('.' + self.CLASS + '-dialog');
        const feature = self.getCurrentFeature();
        const isPoint = (TC.feature.Point && feature instanceof TC.feature.Point) ||
            (TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint);
        const isLine = (TC.feature.Polyline && feature instanceof TC.feature.Polyline) ||
            (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline);
        const isPolygon = (TC.feature.Polygon && feature instanceof TC.feature.Polygon) ||
            (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon);

        // Si no es una línea o polígono, no es necesario preguntar si queremos interpolar
        const ipDiv = dialog.querySelector('.' + self.CLASS + '-dialog-ip');
        if (ipDiv) {
            if ((self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX) && !self._dialogDiv.querySelector(self._selectors.ELEVATION_CHECKBOX).checked) || (!isLine && !isPolygon)) {
                ipDiv.classList.add(TC.Consts.classes.HIDDEN);
            }
            else {
                ipDiv.classList.remove(TC.Consts.classes.HIDDEN);
            }
        }
        // Si es un polígono, no es necesario mostrar el botón de GPX
        const gpxBtn = dialog.querySelector('button[data-format=GPX]');
        if (isPolygon) {
            gpxBtn.classList.add(TC.Consts.classes.HIDDEN);
        }
        else {
            gpxBtn.classList.remove(TC.Consts.classes.HIDDEN);
        }

        TC.Util.showModal(self._dialogDiv.querySelector('.' + self.CLASS + '-dl-dialog'));
    };

    ctlProto.showShareDialog = function () {
        const self = this;
        TC.Util.showModal(self._dialogDiv.querySelector('.' + self.CLASS + '-share-dialog'), {
            openCallback: function () {
                self.onShowShareDialog();
            },
            closeCallback: function () {
                self._shareCtl.featureToShare = null;
            }
        });
    };

    ctlProto.getCurrentFeature = function () {
        const self = this;
        return self.currentDisplay && ((self.currentDisplay.caller && self.currentDisplay.caller.highlightedFeature) ||
            self.currentDisplay.currentFeature);
    };

    ctlProto.zoomToCurrentFeature = function () {
        const self = this;
        if (self.map) {
            self.map.zoomToFeatures([self.getCurrentFeature()], { animate: true });
        }
    };

    ctlProto.removeCurrentFeature = function () {
        const self = this;
        const currentFeature = self.getCurrentFeature();
        const removeFeature = function () {
            self.highlightedFeature = null;
            if (currentFeature && currentFeature.layer) {
                currentFeature.layer.removeFeature(currentFeature);
            }
        };
        const closeDisplay = function () {
            if (self.currentDisplay) {
                self.currentDisplay.close ? self.currentDisplay.close() : self.currentDisplay.hide();
            }
        };
        // No pedimos confirmación para borrar si es un resalte de GFI o una de las features añadidas por FeatureTools.
        if ((self.currentDisplay && self.currentDisplay.caller && self.currentDisplay.caller.highlightedFeature === currentFeature) ||
            currentFeature.layer === self.layer) {
            removeFeature();
            closeDisplay();
        }
        else {
            TC.confirm(self.getLocaleString('deleteFeature.confirm'), function () {
                removeFeature();
                closeDisplay();
            });
        }
    };

    const prepareFeatureToShare = function (ctl, options) {
        options = options || {};
        return new Promise(function (resolve, reject) {
            const currentFeature = ctl.getCurrentFeature();
            if (currentFeature) {
                const feature = currentFeature.clone();
                feature.setId(currentFeature.id);
                feature.layer = currentFeature.layer;
                if (options.elevation) {
                    var mustGetElevations = true;
                    if (!options.elevation.resolution && feature.getGeometryStride() > 2) {
                        mustGetElevations = false;
                    }
                    if (mustGetElevations) {
                        const elevOptions = {
                            crs: ctl.map.crs,
                            features: [feature],
                            maxCoordQuantity: ctl.options.displayElevation && ctl.options.displayElevation.maxCoordQuantity,
                            resolution: options.elevation.resolution,
                            sampleNumber: 0 // No queremos determinar el número de muestras
                        };
                        ctl.elevation.setGeometry(elevOptions).then(
                            function (features) {
                                resolve(features[0]);
                            },
                            function (error) {
                                reject(Error(error));
                            }
                        );
                    }
                    else {
                        resolve(feature);
                    }
                }
                else {
                    const coordsArray = feature.getCoordsArray();
                    const firstCoord = coordsArray[0];
                    if (firstCoord && firstCoord.length > 2) {
                        coordsArray.forEach(function (coord) {
                            coord.length = 2;
                        });
                        feature.setCoords(feature.geometry);
                    }
                    resolve(feature);
                }
            }
            else {
                resolve(null);
            }
        });
    };

    ctlProto.onShowShareDialog = function () {
        const self = this;
        const shareCtl = self._shareCtl;
        shareCtl.extraParams = null;
        prepareFeatureToShare(self).then(function (feature) {
            shareCtl.featureToShare = feature;
            const shareDiv = shareCtl.div;
            const link = shareCtl.generateLink();
            shareDiv.querySelector(".tc-url input[type=text]").value = link;
            shareDiv.querySelector(".tc-iframe input[type=text]").value = shareCtl.generateIframe(link);
        });
    };

    ctlProto.getFeatureTitle = function (feature) {
        const self = this;
        var result = "";
        if (feature) {
            result = feature.id;
        }
        return result;
    };

    ctlProto._getFeatureFilename = function (feature) {
        const self = this;
        const layerTitle = self.getFeatureTitle(feature).toString().replace(new RegExp(self.TITLE_SEPARATOR, 'g'), self.FILE_TITLE_SEPARATOR) || self.getLocaleString('feature');
        return layerTitle.toLowerCase().replace(/\s/gi, '_') + '_' + TC.Util.getFormattedDate(new Date().toString(), true);
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState && self.layer) {
            return {
                id: self.id,
                layer: self.layer.exportState()
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (state.layer) {
            self.getHighlightLayer().then(function (layer) {
                layer.importState(state.layer);
            });
        }
    };
})();

﻿if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FileImport = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    if ($.isArray(self.options.formats)) {
        self.formats = self.options.formats;
    }
    else {
        self.formats = [
            TC.Consts.format.KML,
            TC.Consts.format.GML,
            TC.Consts.format.GML2,
            TC.Consts.format.GEOJSON,
            TC.Consts.format.WKT,
            TC.Consts.format.GPX
        ];
    }

    self.layers = [];

    self.apiAttribution = '';
    self.mainDataAttribution = '';
    self.dataAttributions = [];

    self.exportsState = true;
};

TC.inherit(TC.control.FileImport, TC.Control);

(function () {
    var ctlProto = TC.control.FileImport.prototype;

    ctlProto.CLASS = 'tc-ctl-file';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FileImport.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "openFile" }).w("</h2><div><p>").h("i18n", ctx, {}, { "$key": "fileImport.instructions" }).w("</p><div class=\"tc-ctl-file-open\"><label class=\"tc-button tc-ctl-file-open-label tc-icon-button\"><input type=\"file\" class=\"tc-ctl-file-open-ipt tc-button\" accept=\"").s(ctx.get(["formats"], false), ctx, { "block": body_1 }, {}).w("\" />").h("i18n", ctx, {}, { "$key": "openFile" }).w("</label></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(".").f(ctx.getPath(true, []), ctx, "h").h("sep", ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(","); } body_2.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        var self = this;
        const result = TC.Control.prototype.register.call(self, map);

        if (self.options.enableDragAndDrop) {
            map.wrap.enableDragAndDrop(self.options);
        }

        map
            .on(TC.Consts.event.FEATURESIMPORT, function (e) {
                const fileName = e.fileName;
                const target = e.dropTarget;
                const features = e.features;
                // Ignoramos los GPX (se supone que los gestionará Geolocation)
                var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();
                if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length || target !== self.map.div && target !== self) {
                    return;
                }
                
                map.addLayer({
                    id: self.getUID(),
                    title: fileName,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layers.push(layer);
                    var geogCrs = 'EPSG:4326';
                    const flatten = function (prev, cur) {
                        return prev.concat(cur);
                    };
                    var projectGeom = function (feature) {
                        var geom = feature.geometry;
                        if (geom) {
                            var coordinates;
                            switch (true) {
                                case TC.feature.Point && feature instanceof TC.feature.Point:
                                    coordinates = [geom];
                                    break;
                                case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                                case TC.feature.Polyline && feature instanceof TC.feature.Polyline:
                                    coordinates = geom;
                                    break;
                                case TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:
                                case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
                                    coordinates = geom.reduce(flatten);
                                    break;
                                case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                                    coordinates = geom.reduce(flatten).reduce(flatten);
                                    break;
                                default:
                                    break;
                            }
                            if (coordinates.every(function (coord) {
                                return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90; // Parecen geográficas
                            })) {
                                feature.setCoords(TC.Util.reproject(geom, geogCrs, self.map.crs));
                            }
                        }

                        return feature;
                    };

                    for (var i = 0, len = features.length; i < len; i++) {
                        var projectedFeature = projectGeom(features[i]);
                        layer.addFeature(projectedFeature);
                    }
                    setTimeout(function () {
                        map.zoomToFeatures(layer.features);
                    }, 100);
                });
            })
            .on(TC.Consts.event.FEATURESIMPORTERROR, function (e) {
                var dictKey;
                var fileName = e.file.name;
                if (fileName.toLowerCase().substr(fileName.length - 4) === '.kmz') {
                    dictKey = 'fileImport.error.reasonKmz';
                }
                else {
                    dictKey = 'fileImport.error.reasonUnknown';
                }

                TC.error(self.getLocaleString(dictKey, { fileName: fileName }), TC.Consts.msgErrorMode.TOAST);

                var reader = new FileReader();
                reader.onload = function (event) {
                    TC.error("Nombre del archivo: " + fileName + " \n Contenido del archivo: \n\n" + event.target.result, TC.Consts.msgErrorMode.EMAIL, "Error en la subida de un archivo");
                };
                reader.readAsText(e.file);
            })
            .on(TC.Consts.event.FEATUREREMOVE, function (e) {
                // Eliminamos la capa cuando ya no quedan features en ella
                const layer = e.layer;
                if (self.layers.indexOf(layer) >= 0) {
                    if (!layer.features.length) {
                        self.map.removeLayer(layer);
                    }
                }
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const idx = self.layers.indexOf(e.layer);
                if (idx >= 0) {
                    self.layers.splice(idx, 1);
                }
            });

        return result;
    };

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(self.renderData({ formats: self.formats }, function () {            
            const fileInput = self.div.querySelector('input[type=file]');
            // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
            fileInput.addEventListener(TC.Consts.event.CLICK, function (e) {
                const input = this;
                // Envolvemos el input en un form
                const form = document.createElement('form');
                const parent = input.parentElement;
                parent.insertBefore(form, input);
                form.appendChild(input);
                form.reset();
                // Desenvolvemos el input del form
                form.insertAdjacentElement('afterend', input);
                parent.removeChild(form);
            });
            fileInput.addEventListener('change', function (e) {
                if (self.map) {
                    console.log('salta el change');
                    self.map.wrap.loadFiles(e.target.files, { control: self });
                }
            });
        }));
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                layers: self.layers.map(function (layer) {
                    return {
                        title: layer.title,
                        state: layer.exportState()
                    };
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            const layerPromises = [];
            state.layers.forEach(function (layerData) {
                layerPromises.push(self.map.addLayer({
                    id: self.getUID(),
                    title: layerData.title,
                    type: TC.Consts.layerType.VECTOR
                }));
            });

            Promise.all(layerPromises).then(function (layers) {
                for (var i = 0, len = layers.length; i < len; i++) {
                    const layer = layers[i];
                    layer.importState(state.layers[i].state);
                    self.layers.push(layer);
                }
            });
        }
    };

})();

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.FullScreen = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.fullScreenElement = document.documentElement;
};

TC.inherit(TC.control.FullScreen, TC.Control);

(function () {
    var ctlProto = TC.control.FullScreen.prototype;

    ctlProto.CLASS = 'tc-ctl-fscreen';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/FullScreen.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-fscreen-btn\" title=\"").h("i18n", ctx, {}, { "$key": "fscreen.tip" }).w("\"></button>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        result.then(function () {
            const btn = self.div.querySelector('.' + self.CLASS + '-btn');

            if (self.enabledFullScreen()) {
                btn.addEventListener(TC.Consts.event.CLICK, function () {
                    self.toggleFullScreen();                    
                });

                const fullscreenchangeListener = function () {
                    if (self.isFullScreen()) {
                        btn.classList.add(TC.Consts.classes.ACTIVE);
                    }
                    else {
                        btn.classList.remove(TC.Consts.classes.ACTIVE);
                    }
                    btn.setAttribute('title', self.isFullScreen() ? self.getLocaleString("fscreen.tip.return") : self.getLocaleString("fscreen.tip"));
                };
                document.addEventListener('fullscreenchange', fullscreenchangeListener);
                document.addEventListener('mozfullscreenchange', fullscreenchangeListener);
                document.addEventListener('webkitfullscreenchange', fullscreenchangeListener);
                document.addEventListener('MSFullscreenChange', fullscreenchangeListener);
            } else {
                // GLS: 19/02/2019 en lugar de ocultar el botón, deshabilitamos el control para que no quede espacio de más entre los botones
                self.disable();                
            }
        });

        return result;
    };

    ctlProto.requestFullScreen = function () {
        var self = this;
        var elm = self.fullScreenElement;
        document.documentElement.requestFullScreen ? elm.requestFullScreen() :
            elm.mozRequestFullScreen ? elm.mozRequestFullScreen() :
            elm.webkitRequestFullScreen ? elm.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) :
            elm.msRequestFullscreen && elm.msRequestFullscreen();
    };

    ctlProto.cancelFullScreen = function () {
        var self = this;
        document.cancelFullScreen ? document.cancelFullScreen() :
            document.mozCancelFullScreen ? document.mozCancelFullScreen() :
            document.webkitCancelFullScreen ? document.webkitCancelFullScreen() :
            document.msExitFullscreen && document.msExitFullscreen();
    };

    ctlProto.isFullScreen = function () {
        return document.fullScreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement;
    };

    ctlProto.toggleFullScreen = function () {
        var self = this;
        self.isFullScreen() ? self.cancelFullScreen() : self.requestFullScreen();
    };

    ctlProto.enabledFullScreen = function () {
        var self = this;        
        var elm = self.fullScreenElement;
        var enabled = document.documentElement.requestFullScreen || elm.mozRequestFullScreen || elm.webkitRequestFullScreen || elm.msRequestFullscreen;        
        return enabled && typeof (enabled) == "function";
    };

})();

﻿(function () {
    Math.hypot = Math.hypot || function () {
        var y = 0;
        var length = arguments.length;

        for (var i = 0; i < length; i++) {
            if (arguments[i] === Infinity || arguments[i] === -Infinity) {
                return Infinity;
            }
            y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
    };
}());
(function () {
    var lastTime = 0,
        vendors = ['ms', 'moz', 'webkit', 'o'],
        // Feature check for performance (high-resolution timers)
        hasPerformance = !!(window.performance && window.performance.now);

    for (var x = 0, max = vendors.length; x < max && !window.requestAnimationFrame; x += 1) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }

    // Add new wrapper for browsers that don't have performance
    if (!hasPerformance) {
        // Store reference to existing rAF and initial startTime
        var rAF = window.requestAnimationFrame,
            startTime = +new Date;

        // Override window rAF to include wrapped callback
        window.requestAnimationFrame = function (callback, element) {
            // Wrap the given callback to pass in performance timestamp
            var wrapped = function (timestamp) {
                // Get performance-style timestamp
                var performanceTimestamp = (timestamp < 1e12) ? timestamp : timestamp - startTime;

                return callback(performanceTimestamp);
            };

            // Call original rAF with wrapped callback
            rAF(wrapped, element);
        }
    }
})();
(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.Geolocation = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    self._layerPromises = {};

    self.Const = {
        Classes: {
            ACTIVE: 'tc-ctl-geolocation-active',
            CLOSED: 'closed',
            SELECTEDTRACK: 'selectedTrack',
            DRAWACTIVATED: 'draw-activated',
            SIMULATIONACTIVATED: 'simulation-activated'
        },
        Selector: {
            SIMULATE: '.tc-btn-simulate',
            DRAW: '.tc-draw',
            EDIT: '.tc-btn-edit',
            DELETE: '.tc-btn-delete',
            SAVE: '.tc-btn-save',
            CANCEL: '.tc-btn-cancel',
            EXPORT_GPX: '.tc-btn-export-gpx',
            EXPORT_KML: '.tc-btn-export-kml',
            STOP: '.tc-btn-stop',
            PAUSE: '.tc-btn-pause',
            BACKWARD: '.tc-btn-backward',
            FORWARD: '.tc-btn-forward',
            SPEED: '.tc-spn-speed'
        },
        LocalStorageKey: {
            TRACKING: 'trk',
            TRACKINGTEMP: 'trktemp',
            TRACKINGSHOWADVERTISEMENT: 'trkAdvertisement',
            GPSSHOWADVERTISEMENT: 'gpsAdvertisement',
            TEST: 'test'
        },
        Message: {
            VALIDATENAME: '',
        },
        Event: {
            POSITIONCHANGE: 'positionchange.tc.geolocation',
            GPSPOSITIONCHANGE: 'gpspositionchange.tc.geolocation',
            GPSPOSITIONERROR: 'positionerror.tc.geolocation',
            STATEUPDATED: 'stateupdated.tc.geolocation',
            GPSADD: 'gpsadd.tc.geolocation',
            TRACKSNAPPING: 'tracksnapping.tc.geolocation',
            DRAWTRACK: 'drawtrack.tc.geolocation',
            CLEARTRACK: 'cleartrack.tc.geolocation',
            IMPORTEDTRACK: 'importedtrack.tc.geolocation'
        },
        MimeMap: {
            KML: 'application/vnd.google-earth.kml+xml',
            GPX: 'application/gpx+xml'
        },
        SupportedFileExtensions: [
            '.kml',
            '.gpx'
        ],
        Tabs: {
            GPS: "gps"
        },
        Layers: {
            GPS: "gps",
            TRACK: "track",
            TRACKING: "tracking"
        }
    };

    TC.Control.apply(self, arguments);

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    self._$dialogDiv = $(self._dialogDiv);
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }
    self.delta = 500;
    self.walkingSpeed = 5000;
    self.gapHill = self.options.gapHill || 20;

    self.snappingTolerance = self.options.snappingTolerance || 50;

    self.exportsState = true;

    self.storageCRS = 'EPSG:4326';
};

TC.inherit(TC.control.Geolocation, TC.Control);

(function () {
    var ctlProto = TC.control.Geolocation.prototype;

    ctlProto.CLASS = 'tc-ctl-geolocation';

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 300,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    ctlProto.featuresToShare = [];

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';
    TC.Consts.event.TOOLSOPEN = TC.Consts.event.TOOLSOPEN || 'toolsopen.tc';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Geolocation.html";
        ctlProto.template[ctlProto.CLASS + '-track-node'] = TC.apiLocation + "TC/templates/GeolocationTrackNode.html";
        ctlProto.template[ctlProto.CLASS + '-track-snapping-node'] = TC.apiLocation + "TC/templates/GeolocationTrackSnappingNode.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/GeolocationDialog.html";
        ctlProto.template[ctlProto.CLASS + '-tracking-toast'] = TC.apiLocation + "TC/templates/GeolocationTrackingToast.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "geo" }).w("</h2><div class=\"tc-ctl-geolocation-content\"> <div class=\"tc-ctl-geolocation-track\"><div class=\"tc-ctl-geolocation-track-snap-info\"></div> <!-- img se insertan en el div del mapa--> <div id=\"tc-ctl-geolocation-track-elevation-marker\" class=\"tc-ctl-geolocation-trackMarker elevation\" style=\"display: none;\"></div> <div class=\"tc-ctl-geolocation-track-panel-block\" ><input id=\"tc-ctl-geolocation-track-panel-opened\" type=\"checkbox\" checked/><label for=\"tc-ctl-geolocation-track-panel-opened\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.1" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.2" }).w("</label><i class=\"tc-ctl-geolocation-track-panel-help icon-question-sign\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.panel.help.3" }).w("\"></i></div><div class=\"tc-ctl-geolocation-track-mng\"><div class=\"tc-ctl-geolocation-select\"><form> <label class=\"tc-ctl-geolocation-btn-track\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.title" }).w("\"><input type=\"radio\" name=\"mode\" checked value=\"tracks\" /><span>").h("i18n", ctx, {}, { "$key": "geo.gps" }).w("</span></label><label class=\"tc-ctl-geolocation-btn-tracks\" title=\"").h("i18n", ctx, {}, { "$key": "geo.tracks.title" }).w("\"><input type=\"radio\" name=\"mode\" value=\"track-available\" /><span>").h("i18n", ctx, {}, { "$key": "geo.tracks" }).w("</span></label> </form></div> <div class=\"tc-ctl-geolocation-track-available tc-ctl-geolocation-track-cnt tc-ctl-geolocation-panel tc-hidden\"><i class=\"tc-ctl-geolocation-track-search-icon\"></i><input id=\"tc-ctl-geolocation-track-available-srch\" type=\"search\" list=\"tc-ctl-geolocation-track-available-lst\" class=\"tc-ctl-geolocation-track-available-srch tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.filter.plhr" }).w("\" maxlength=\"200\" /> <ol id=\"tc-ctl-geolocation-track-available-lst\" class=\"tc-ctl-geolocation-track-available-lst\"><li class=\"tc-ctl-geolocation-track-available-empty\"><span>").h("i18n", ctx, {}, { "$key": "geo.noTracks" }).w("</span></li><li class=\"tc-ctl-geolocation-track-not\" hidden><span>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</span></li></ol><div class=\"tc-ctl-geolocation-track-cnt\"><input name=\"uploaded-file\" id=\"uploaded-file\" type=\"file\" class=\"tc-ctl-geolocation-track-import tc-button\" accept=\".gpx,.kml\" disabled /><label class=\"tc-button tc-icon-button\" for=\"uploaded-file\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.import.upload" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.import.lbl" }).w("</label></div></div><div class=\"tc-ctl-geolocation-tracks tc-ctl-geolocation-panel\"> <div class=\"tc-alert alert-warning tc-hidden\" ><p id=\"panel-msg\">").h("i18n", ctx, {}, { "$key": "geo.trk.panel.1" }).w(" <ul><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.2" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.3" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.4" }).w("</li><li>").h("i18n", ctx, {}, { "$key": "geo.trk.panel.5" }).w("</li></ul></p></div> <div class=\"tc-ctl-geolocation-track-ui\"> <div class=\"tc-ctl-geolocation-track-render\"><input id=\"tc-ctl-geolocation-track-render\" type=\"checkbox\" hidden checked /><label for=\"tc-ctl-geolocation-track-render\" class=\"tc-ctl-geolocation-track-render\" title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.render" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.trk.render" }).w("</label></div><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-ui-activate\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.activate.title" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.track.activate" }).w("</button><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-ui-deactivate tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "geo.track.deactivate.title" }).w("\">").h("i18n", ctx, {}, { "$key": "geo.track.deactivate" }).w("</button></div><div class=\"tc-ctl-geolocation-track-current tc-ctl-geolocation-track-cnt\"><input type=\"text\" class=\"tc-ctl-geolocation-track-title tc-textbox\" disabled placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.trk.name.plhr" }).w("\" maxlength=\"200\" /><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-save\" disabled title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.name.save" }).w("\"></button><input type=\"text\" class=\"tc-ctl-geolocation-track-waypoint tc-textbox\" disabled placeholder=\"").h("i18n", ctx, {}, { "$key": "geo.trk.wyp.plhr" }).w("\" maxlength=\"200\" /><button class=\"tc-button tc-icon-button tc-ctl-geolocation-track-add-wpt\" disabled title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.wyp.save" }).w("\"></button></div></div></div></div></div><div class=\"tc-ctl-geolocation-track-center tc-hidden\"><button title=\"").h("i18n", ctx, {}, { "$key": "geo.trk.center" }).w("\"></button></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-track-node'] = function () { dust.register(ctlProto.CLASS + '-track-node', body_0); function body_0(chk, ctx) { return chk.w("<li data-id=\"").f(ctx.get(["id"], false), ctx, "h").w("\" data-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><span class=\"tc-draw tc-selectable\" title=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["name"], false), ctx, "h").w("</span><input class=\"tc-textbox tc-hidden\" type=\"text\" value=\"").f(ctx.get(["name"], false), ctx, "h").w("\" /> <button class=\"tc-btn-simulate\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.simulate" }).w("\"></button><button hidden class=\"tc-btn-stop\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.stop" }).w("\"></button><button class=\"tc-btn-edit\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.edit" }).w("\"></button><button hidden class=\"tc-btn-pause\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.pause" }).w("\"></button> <button hidden class=\"tc-btn-backward\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.backward" }).w("\"></button><label hidden class=\"tc-spn-speed\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.velocity" }).w("\"></label><button hidden class=\"tc-btn-forward\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.forward" }).w("\"></button> <button class=\"tc-btn-save tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "save" }).w("\"></button><button class=\"tc-btn-cancel tc-hidden\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.cancel" }).w("\"></button><button class=\"tc-btn-delete\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.delete" }).w("\"></button><button class=\"tc-btn-export-gpx\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.exportGPX" }).w("\"></button><button class=\"tc-btn-export-kml\" title=\"").h("i18n", ctx, {}, { "$key": "tr.lst.exportKML" }).w("\"></button> </li>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-track-snapping-node'] = function () { dust.register(ctlProto.CLASS + '-track-snapping-node', body_0); function body_0(chk, ctx) { return chk.w("<ul>").x(ctx.get(["n"], false), ctx, { "block": body_1 }, {}).w("<li> <span>").x(ctx.get(["isGeo"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(":</span> ").f(ctx.get(["x"], false), ctx, "h").w("</li><li> <span>").x(ctx.get(["isGeo"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(":</span> ").f(ctx.get(["y"], false), ctx, "h").w(" </li>").x(ctx.get(["z"], false), ctx, { "block": body_6 }, {}).x(ctx.get(["m"], false), ctx, { "block": body_8 }, {}).w("</ul>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li><span>").h("i18n", ctx, {}, { "$key": "geo.trk.snapping.name" }).w(":</span> ").f(ctx.get(["n"], false), ctx, "h").w("</li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("X"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lon" }); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("Y"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.h("ne", ctx, { "block": body_7 }, { "key": ctx.get(["z"], false), "value": 0 }); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w("<li> <span>Z:</span> ").f(ctx.get(["z"], false), ctx, "h").w(" </li>"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<li> ").f(ctx.get(["m"], false), ctx, "h").w(" </li>"); } body_8.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-geolocation-continue-track-dialog tc-modal\" ><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "geo.gps" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><button class=\"tc-button tc-ctl-geolocation-track-continue\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.cnt" }).w(" </button><button class=\"tc-button tc-ctl-geolocation-track-new\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.new" }).w(" </button> <button class=\"tc-button tc-modal-close\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.cancel" }).w(" </button></div></div></div><div class=\"tc-ctl-geolocation-track-advert-dialog tc-modal\" ><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "geo.track.activate.title" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p id=\"pageBlurMsg\">").h("i18n", ctx, {}, { "$key": "geo.trk.page.blur" }).w("</p><p class=\"tc-ctl-geolocation-track-advertisement p\"> <label> <input type=\"checkbox\" name=\"checkbox\" id=\"advertisement\"> ").h("i18n", ctx, {}, { "$key": "geo.trk.dialog.advertisement" }).w(" </label> </p></div><div class=\"tc-modal-footer\"><button class=\"tc-button tc-ctl-geolocation-track-advert-ok\"> ").h("i18n", ctx, {}, { "$key": "ok" }).w(" </button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-tracking-toast'] = function () { dust.register(ctlProto.CLASS + '-tracking-toast', body_0); function body_0(chk, ctx) { return chk.w("<table class=\"tc-ctl-geolocation-info-tracking\"><tr><th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(":</th><td> ").f(ctx.get(["x"], false), ctx, "h").w(" </td>").x(ctx.get(["accuracy"], false), ctx, { "block": body_3 }, {}).w("</tr><tr><th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(":</th><td> ").f(ctx.get(["y"], false), ctx, "h").w(" </td>").x(ctx.get(["speed"], false), ctx, { "block": body_6 }, {}).w("</tr><tr>").x(ctx.get(["z"], false), ctx, { "block": body_7 }, {}).x(ctx.get(["mdt"], false), ctx, { "block": body_10 }, {}).w("</tr> </table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("X"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lon" }); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<th>").h("i18n", ctx, {}, { "$key": "geo.trk.accuracy" }).w(":</th><td> ").f(ctx.get(["accuracy"], false), ctx, "h").w(" m </td>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("Y"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "lat" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<th>").h("i18n", ctx, {}, { "$key": "geo.trk.speed" }).w(":</th><td>").f(ctx.get(["speed"], false), ctx, "h").w(" km/h</td>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w("<th>").x(ctx.get(["isGeo"], false), ctx, { "else": body_8, "block": body_9 }, {}).w(":</th><td> ").f(ctx.get(["z"], false), ctx, "h").w(" m </td>"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("Z"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "ele" }); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.w("<th title=\"").h("i18n", ctx, {}, { "$key": " mdt.title" }).w("\">").h("i18n", ctx, {}, { "$key": "ele" }).w(" (").h("i18n", ctx, {}, { "$key": "mdt" }).w("):</th><td>").f(ctx.get(["mdt"], false), ctx, "h").w(" m </td>"); } body_10.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self.wrap = new TC.wrap.control.Geolocation(self);
        self.wrap.register(map);

        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.GPS',
        }).then(function (layer) {
            self.layerGPS = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.Tracking',
            styles: {
                point: {
                    radius: 3,
                    fillColor: "#00ced1",
                    fillOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeColor: "#ffffff",
                    fontColor: "#00ced1",
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 1,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                },
                line: {
                    strokeOpacity: function () {
                        return this.track.renderTrack.checked ? 1 : 0;
                    }.bind(self),
                    strokeWidth: 2,
                    strokeColor: "#00ced1",
                    lineDash: [.1, 6]
                }
            }
        }).then(function (layer) {
            self.layerTracking = layer;
        });
        map.addLayer({
            id: self.getUID(),
            type: TC.Consts.layerType.VECTOR,
            stealth: true,
            title: 'Posicionar.Track',
            styles: {
                line: {
                    strokeWidth: 2,
                    strokeColor: "#C52737"
                },
                point: {
                    radius: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            return 3;
                        } else {
                            return 6;
                        }

                        return 3;
                    },
                    fillColor: "#C52737",
                    strokeColor: "#ffffff",
                    fontColor: "#C52737",
                    fontSize: 10,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2,
                    label: function (feature) {
                        var name = feature.getData()['name'];
                        if (name && (name + '').trim().length > 0) {
                            name = (name + '').trim().toLowerCase();
                        } else {
                            name = '';
                        }

                        return name;
                    }
                }
            }
        }).then(function (layer) {
            self.layerTrack = layer;
        });

        map.on(TC.Consts.event.FEATURESIMPORT, function (e) {
            const self = this;
            const fileName = e.fileName;
            const target = e.dropTarget;
            var kmlPattern = '.' + TC.Consts.format.KML.toLowerCase();
            var gpxPattern = '.' + TC.Consts.format.GPX.toLowerCase();

            // GLS: ¿es un GPX?
            if (fileName.toLowerCase().indexOf(gpxPattern) === fileName.length - gpxPattern.length ||
                // GLS: ¿es un KML y viene desde el upload de Geolocation?
                (fileName.toLowerCase().indexOf(kmlPattern) === fileName.length - kmlPattern.length && target === self)) {

                self.clear(self.Const.Layers.TRACK);
                self.importTrack(e);

                if (/.kml$/g.test(fileName.toLowerCase()) && self.layerTrack) {
                    if (self.layerTrack.styles) {
                        self.layerTrack.features.forEach(function (feature) {
                            if (feature instanceof TC.feature.Point && self.layerTrack.styles.point) {
                                feature.setStyle(self.layerTrack.styles.point);
                            } else if (feature instanceof TC.feature.Polyline && self.layerTrack.styles.line) {
                                feature.setStyle(self.layerTrack.styles.line);
                            }
                        });
                    }
                }
            } else {
                //GLS: si es un KML pero viene desde el mapa o es otro tipo de archivo que no es ni GPX ni KML, lo ignoramos
                return;
            }
        }.bind(self));

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, callback);
        });
    };

    ctlProto.importTrack = function (options) {
        var self = this;

        if (!self.isDisabled) {
            if (options.fileName && options.features && options.features.length > 0) {

                var wait = self.getLoadingIndicator().addWait();
                self.importedFileName = options.fileName;
                const addPromises = [];
                for (var i = 0, len = options.features.length; i < len; i++) {
                    addPromises.push(self.layerTrack.addFeature(options.features[i]));
                }
                Promise.all(addPromises).then(function () {
                    self.wrap.processImportedFeatures({ wait: wait, notReproject: options.notReproject });

                    if (self.layerTrack) { // Si tenemos capa es que todo ha ido bien y gestionamos el despliegue del control
                        // Desplegamos el control "ubicar" al importar mediante drag&drop
                        if (self.map && self.map.layout && self.map.layout.accordion) {
                            if (self.div.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                self.map.controls
                                    .filter(function (ctl) {
                                        // Todos los otros controles que no cuelgan de otro control
                                        return ctl !== self && !ctl.containerControl;
                                    })
                                    .forEach(function (ctl) {
                                        ctl.div.classList.add(TC.Consts.classes.COLLAPSED);
                                    });
                            }
                        }

                        self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                        self.div.querySelector('.' + self.CLASS + '-btn-tracks > span').click();

                        if (!options.isShared) {
                            // abrimos el panel de herramientas
                            self.map.trigger(TC.Consts.event.TOOLSOPEN);
                        }                        
                    }
                });
            }
        } else if (/.gpx$/g.test(options.fileName.toLowerCase())) {
            self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
        }
    };

    ctlProto.prepareFeaturesToShare = function (trackUid) {
        const self = this;

        return new Promise(function (resolve, reject) {
            if (trackUid) {

                var storageData = self.availableTracks.filter(function (saved) {
                    return saved.uid.toString() === trackUid.toString();
                })[0].data;

                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                var storageFeatures = new ol.format.GeoJSON().readFeatures(storageData);
                const promises = new Array(storageFeatures.length);
                storageFeatures.forEach(function (f, idx) {
                    promises[idx] = TC.wrap.Feature.createFeature(f);
                });

                Promise.all(promises).then(function (tcFeatures) {
                    self.featuresToShare = tcFeatures.map(function (f) {
                        const fObj = {};
                        var layerStyle;
                        switch (true) {
                            case TC.feature.Marker && f instanceof TC.feature.Marker:
                                fObj.type = TC.Consts.geom.MARKER;
                                break;
                            case TC.feature.Point && f instanceof TC.feature.Point:
                                fObj.type = TC.Consts.geom.POINT;
                                break;
                            case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                                fObj.type = TC.Consts.geom.POLYLINE;
                                break;
                            case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                                fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                                break;
                        }
                        fObj.id = f.id;
                        fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                        fObj.data = f.getData();

                        return fObj;
                    });

                    resolve();
                });
            } else {
                resolve();
            }
        });


    };

    var visibilityTrack = true;
    ctlProto.renderData = function (data, callback) {
        const self = this;

        var sel = self.Const.Selector;

        return TC.Control.prototype.renderData.call(self, data, function () {

            const options = self.div.querySelectorAll(self._classSelector + '-panel');
            self.div.querySelectorAll('.' + self.CLASS + '-select span').forEach(function (span) {
                span.addEventListener(TC.Consts.event.CLICK, function (e) {
                    var label = e.target;
                    while (label && label.tagName !== 'LABEL') {
                        label = label.parentElement;
                    }
                    const newFormat = label.querySelector('input[type=radio][name=mode]').value;

                    options.forEach(function (option) {
                        if (option.matches('.' + self.CLASS + '-' + newFormat)) {
                            option.classList.remove(TC.Consts.classes.HIDDEN);
                        }
                        else {
                            option.classList.add(TC.Consts.classes.HIDDEN);
                        }
                    });
                });
            });

            self.track = {
                activateButton: self.div.querySelector(self._classSelector + '-track-ui-activate'),
                deactivateButton: self.div.querySelector(self._classSelector + '-track-ui-deactivate'),
                trackSearch: self.div.querySelector(self._classSelector + '-track-available-srch'),
                trackImportFile: self.div.querySelector(self._classSelector + '-track-import'),
                trackSave: self.div.querySelector(self._classSelector + '-track-save'),
                trackAdd: self.div.querySelector(self._classSelector + '-track-add-wpt'),
                trackContinue: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-continue'),
                trackRenew: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-new'),
                trackClose: self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog button.tc-modal-close'),
                //trackAddSegment: self.div.querySelector('#tc-ctl-geolocation-track-segment'),
                trackAdvertisementOK: self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-ok')
            };

            self.track.trackList = self.div.querySelector(self._classSelector + '-track-available-lst');

            self.track.trackToolPanelOpened = self.div.querySelector('#tc-ctl-geolocation-track-panel-opened');

            self.div.querySelector('.' + ctlProto.CLASS + '-track-panel-help').addEventListener('click', function () {
                _showAlerMsg.call(self);
            });

            self.track.trackName = self.div.querySelector(self._classSelector + '-track-title');

            self.track.trackWPT = self.div.querySelector(self._classSelector + '-track-waypoint');

            if (TC.Util.detectMobile()) {
                if (Modernizr.mq('screen and (max-height: 50em) and (max-width: 50em)'))
                    self.track.trackToolPanelOpened.checked = false;
            }

            if (window.File && window.FileReader && window.FileList && window.Blob) {
                self.track.trackImportFile.disabled = false;
                // GLS: Eliminamos el archivo subido, sin ello no podemos subir el mismo archivo seguido varias veces
                self.track.trackImportFile.addEventListener(TC.Consts.event.CLICK, function (e) {
                    // Envolvemos el input en un form
                    const input = this;
                    const form = document.createElement('form');
                    const parent = input.parentElement;
                    parent.insertBefore(form, input);
                    form.appendChild(input);
                    form.reset();
                    // Desenvolvemos el input del form
                    form.insertAdjacentElement('afterend', input);
                    parent.removeChild(form);
                });
                self.track.trackImportFile.addEventListener('change', function (e) {
                    if (!self._cleaning) { // Valido que el evento import no lo provoco yo al limpiar el fileinput (al limpiar se lanza el change)                        
                        self.clear(self.Const.Layers.TRACK);

                        if (self.map) {
                            self.map.on(TC.Consts.event.LAYERERROR, _layerError);
                            self.map.wrap.loadFiles(e.target.files, { control: self });
                        }
                    }
                });
            } else {
                console.log('no es posible la importación');
            }

            self.track.activateButton.addEventListener('click', function () {
                self.activateTracking();
                _activateTrackingBtns.call(self);

            });
            self.track.deactivateButton.addEventListener('click', function () {
                self.deactivateTracking();
                _deactivateTrackingBtns.call(self);
            });

            var _filter = function (searchTerm) {
                searchTerm = searchTerm.toLowerCase();
                //tc-ctl-geolocation-track-available-empty
                const lis = Array.from(self.track.trackList.querySelectorAll('li'));
                lis.forEach(function (li) {
                    li.style.display = 'none';
                });
                const trackLis = lis.filter(function (li) {
                    return li.matches('li:not([class]),li.' + self.Const.Classes.SELECTEDTRACK);
                });

                const searchIcon = self.div.querySelector(self._classSelector + '-track-search-icon');
                if (searchTerm.length === 0) {
                    trackLis.forEach(function (li) {
                        li.style.display = '';
                    });
                    searchIcon.style.visibility = 'visible';
                } else {
                    searchIcon.style.visibility = 'hidden';
                    var r = new RegExp(searchTerm, 'i');
                    trackLis.forEach(function (li) {
                        li.style.display = r.test(li.querySelector('span').textContent) ? '' : 'none';
                    });

                    if (!trackLis.some(function (li) {
                        return li.style.display === '';
                    })) {
                        lis.forEach(function (li) {
                            if (li.matches('[class^="tc-ctl-geolocation-track-not"]')) {
                                li.style.display = '';
                            }
                        });
                    }
                }
            };
            const trackSearchListener = function () {
                _filter(this.value.toLowerCase().trim());
            };
            self.track.trackSearch.addEventListener("keyup", trackSearchListener);
            self.track.trackSearch.addEventListener("search", trackSearchListener);

            // IE10 polyfill
            try {
                if (self.track.trackSearch.querySelector('::-ms-clear')) {
                    var oldValue;
                    self.track.trackSearch.addEventListener('mouseup', function (e) {
                        oldValue = self.track.trackSearch.value;

                        if (oldValue === '') {
                            return;
                        }

                        // When this event is fired after clicking on the clear button
                        // the value is not cleared yet. We have to wait for it.
                        setTimeout(function () {
                            var newValue = self.track.trackSearch.value;

                            if (newValue === '') {
                                _filter(newValue);
                            }
                        }, 1);
                    });
                }
            }
            catch (e) { }

            // en el panel
            self.track.trackSave.addEventListener('click', self.saveTrack.bind(self));
            self.track.trackAdd.addEventListener('click', self.addWaypoint.bind(self));

            const list = self.div.querySelector(self._classSelector + '-track-available-lst');

            // en lista
            var _edit = function (edit, elm) {
                if (elm.tagName !== 'LI') {
                    elm = elm.parentElement;
                }

                const input = elm.querySelector('input');
                const span = elm.querySelector('span');

                if (edit) {

                    input.classList.remove(TC.Consts.classes.HIDDEN);
                    input.focus();
                    input.value = span.textContent;
                    span.classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_GPX).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_KML).classList.add(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.remove(TC.Consts.classes.HIDDEN);
                } else {

                    input.classList.add(TC.Consts.classes.HIDDEN);
                    span.classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SIMULATE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EDIT).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DELETE).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.DRAW).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_GPX).classList.remove(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.EXPORT_KML).classList.remove(TC.Consts.classes.HIDDEN);

                    elm.querySelector(sel.SAVE).classList.add(TC.Consts.classes.HIDDEN);
                    elm.querySelector(sel.CANCEL).classList.add(TC.Consts.classes.HIDDEN);
                }
            };

            self.uiSimulate = function (simulate, elm) {
                if (elm) {
                    var editControls = [
                        sel.SIMULATE,
                        sel.EDIT,
                        sel.DELETE,
                        sel.EXPORT_GPX,
                        sel.EXPORT_KML
                    ];
                    var simulateControls = [
                        sel.STOP,
                        sel.PAUSE,
                        sel.BACKWARD,
                        sel.FORWARD,
                        sel.SPEED
                    ];
                    var cnt = elm.tagName === 'LI' ? elm : elm.parentNode;

                    editControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = simulate;
                    });

                    simulateControls.forEach(function (ctl) {
                        cnt.querySelector(ctl).hidden = !simulate;
                    });
                }
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.SIMULATE, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';

                _loadTrack(self, e.target).then(function () { //Para evitar el bloqueo de la interfaz en móviles
                    self.getLoadingIndicator().removeWait(wait)
                });
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(sel.DRAW, function (e) {
                var wait = self.getLoadingIndicator().addWait();

                _drawTrack(self, e.target).then(function () {
                    self.getLoadingIndicator().removeWait(wait);
                });
            }));

            self.on(self.Const.Event.IMPORTEDTRACK, function (e) {
                if (!self.isDisabled) {
                    const listElement = self.track.trackList.querySelector('li[data-id="' + e.index + '"]');
                    _drawTrack(self, listElement.querySelector(sel.DRAW));
                    $(self.track.trackList).animate({
                        scrollTop: e.index * listElement.offsetHeight
                    }, 'slow');
                } else {
                    self.map.toast(self.getLocaleString("geo.trk.import.disabled"), { type: TC.Consts.msgType.WARNING });
                }
            });

            const _stopOtherTracks = function (self, trackLiId) {
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (listItem) {
                    if (listItem.dataset.id !== trackLiId) {
                        const btnSimulate = listItem.querySelector(sel.SIMULATE);
                        const btnPause = listItem.querySelector(sel.PAUSE);

                        btnSimulate.classList.remove(self.Const.Classes.SIMULATIONACTIVATED);
                        btnSimulate.setAttribute('title', self.getLocaleString("tr.lst.simulate"));
                        btnPause.classList.remove('play');
                        btnPause.setAttribute('title', self.getLocaleString("tr.lst.pause"));

                        self.uiSimulate(false, listItem);
                        _edit(false, listItem);
                    }
                });

                self.clear(self.Const.Layers.TRACK);
            };

            var _drawTrack = function (self, btnDraw) {
                return new Promise(function (resolve, reject) {

                    const trackLi = btnDraw.parentElement;

                    setTimeout(function () {
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.uiSimulate(false, btnDraw);

                            self.clear(self.Const.Layers.TRACK);

                            btnDraw.setAttribute('title', btnDraw.textContent);
                        }
                        else if (self.getSelectedTrack()) { // GLS: si hay elemento seleccionado actuamos
                            _stopOtherTracks(self, trackLi.dataset.id);
                            self.drawTrack(trackLi);
                        } else {
                            self.drawTrack(trackLi);
                        }

                        /* GLS: 15/02/2019 Preparamos la feature por si se comparte, necesito hacerlo aquí 
                           porque la gestión en asíncrona y todo el flujo de exportación es síncrono */
                        if (trackLi.classList.contains(self.Const.Classes.SELECTEDTRACK)) {
                            self.prepareFeaturesToShare(trackLi.dataset.uid).then(function () {
                                resolve();
                            });
                        } else {
                            resolve();
                        }
                    }, 0);
                });
            };

            var _loadTrack = function (self, btnSimulate) {
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        const trackLi = btnSimulate.parentElement;

                        _stopOtherTracks(self, trackLi.dataset.id);
                        self.uiSimulate(false, self.getSelectedTrack());
                        self.uiSimulate(true, btnSimulate);

                        self.simulate_paused = false;
                        self.simulateTrack(trackLi);

                        resolve();
                    }, 0);
                });
            };

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EDIT, function (e) {
                _edit(true, e.target);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.DELETE, function (e) {
                self.removeTrack(e.target.parentElement);
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.SAVE, function (e) {
                var newName = e.target.parentElement.querySelector('input').value;
                if (newName.trim().length === 0) {
                    TC.alert(self.getLocaleString('geo.trk.edit.alert'));
                }
                else {
                    self.editTrackName(e.target.parentElement.dataset.id, e.target.parentElement.querySelector('input').value);
                    _edit(false, e.target);
                }
            }));
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.CANCEL, function (e) {
                _edit(false, e.target);
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.EXPORT_GPX + ',' + self._classSelector + ' ' + sel.EXPORT_KML, function (e) {
                const parent = e.target.parentElement;
                var prefix = 'tc-btn-export-';
                var className = Array.from(e.target.classList).filter(function (cls) {
                    return cls.indexOf(prefix) === 0;
                })[0];
                var mimeType = className.replace(prefix, '').toUpperCase();

                self.export(mimeType, parent).then(function (data) {
                    if (data) {
                        var filename = parent.querySelector('span').textContent;
                        var regex = new RegExp(self.Const.SupportedFileExtensions.join('|'), 'gi');
                        var cleanFilename = filename.replace(regex, '');
                        TC.Util.downloadFile(cleanFilename + '.' + mimeType.toLowerCase(), self.Const.MimeMap[mimeType], data);
                    } else {
                        TC.alert(self.getLocaleString('geo.error.export'));
                    }
                });
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.STOP, function (e) {
                self.uiSimulate(false, e.target);
                self.wrap.simulateTrackEnd();
                const btnPause = e.target.parentElement.querySelector(sel.PAUSE);
                btnPause.classList.remove('play');
                btnPause.setAttribute('title', self.getLocaleString('tr.lst.pause'));

                e.target.parentElement.querySelector(sel.SPEED).textContent = 'x 1';
                self.simulate_speed = 1;
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.PAUSE, function (e) {
                self.simulate_paused = !e.target.classList.contains('play');
                if (self.simulate_paused)
                    self.simulate_pausedElapse = -1;

                e.target.setAttribute('title', self.getLocaleString(self.simulate_paused ? 'tr.lst.play' : 'tr.lst.pause'));
                if (self.simulate_paused) {
                    e.target.classList.add('play');
                }
                else {
                    e.target.classList.remove('play');
                }
            }));

            var lapse = 0.5;
            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.BACKWARD, function (e) {
                if (self.simulate_speed == 1)
                    self.simulate_speed = lapse;
                else self.simulate_speed = self.simulate_speed / 2;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.FORWARD).disabled = false;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                if (self.simulate_speed == 0.000244140625) {
                    e.target.disabled = true;
                }
            }));

            list.addEventListener('click', TC.EventTarget.listenerBySelector(self._classSelector + ' ' + sel.FORWARD, function (e) {
                self.simulate_speed = self.simulate_speed / lapse;

                e.target.parentElement.querySelector(sel.SPEED).textContent = self.simulate_speed < 1 ? '/ ' + (1 / self.simulate_speed) : 'x ' + self.simulate_speed;

                e.target.parentElement.querySelector(self._classSelector + " " + sel.BACKWARD).disabled = false;

                if (self.simulate_speed == 4096) {
                    e.target.disabled = true;
                }
            }));


            // popup
            self.track.trackContinue.addEventListener('click', function () {
                // cerramos popup y continuamos con el track de session y almacenando en session
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackRenew.addEventListener('click', function () {
                // eliminamos el track actual de session - restablecemos el tracking
                delete self.sessionTracking;
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, undefined);
                localforage.removeItem(self.Const.LocalStorageKey.TRACKINGTEMP);
                // cerramos el popup
                TC.Util.closeModal();
                // al obtener la posición se almacena en session y continuamos almacenando en session mientras se mueve
                _tracking.call(self);
            });
            self.track.trackClose.addEventListener('click', function () {
                _deactivateTrackingBtns.call(self);
            });
            //self.track.trackAddSegment.addEventListener('click', function () {
            //    TC.alert('pendiente');
            //    // cerramos el popup
            //    TC.Util.closeModal();
            //});

            // popup advertencia
            self.track.trackAdvertisementOK.addEventListener('click', function () {

                const checkboxes = document.body.querySelectorAll('input[name*="Advertisement"]:checked');

                if (checkboxes.length > 0) {
                    const promise = new Promise(function (resolve, reject) {
                        if (window.localforage)
                            resolve();
                        else {
                            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                                resolve();
                            });
                        }
                    });

                    promise.then(function () {
                        localforage.setItem(checkboxes[0].getAttribute('name'), false);
                    });
                }

                TC.Util.closeModal();
            });

            self.track.renderTrack = document.querySelector('#tc-ctl-geolocation-track-render');
            self.track.renderTrack.addEventListener('change', function () {
                if (self.track.activateButton.classList.contains(TC.Consts.classes.HIDDEN)) {
                    self.layerTracking.setVisibility(this.checked);
                }

                visibilityTrack = this.checked;
            });

            if (window.localforage)
                self.bindTracks();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    self.bindTracks();
                });
            }

            if ($.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        var self = this;
        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Util.closeModal();
        self.clearSelection();
        self.deactivateTracking();
        //TC.Control.prototype.deactivate.call(self);
    };

    var _layerError = function () {
        var self = this;

        self.map.off(TC.Consts.event.LAYERERROR, _layerError);
        self.clearFileInput(self.track.trackImportFile);

        TC.alert(self.getLocaleString("geo.trk.upload.error3"));
    };
    var _activateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.add(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.remove(TC.Consts.classes.HIDDEN);
    };

    var _deactivateTrackingBtns = function () {
        var self = this;

        self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
        self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
    };

    var _showAlerMsg = function () {
        var self = this;
        self.map.toast(self.div.querySelector(".alert-warning").innerHTML, {
            duration: 10000
        });
    };

    ctlProto.markerStyle = {
        radius: 7,
        fillColor: [255, 0, 0, 100],
        strokeColor: [255, 255, 255, 255],
        strokeWidth: 2
    };

    ctlProto.lineStyle = {
        strokeWidth: 2,
        strokeColor: [0, 206, 209, 255]
    };

    ctlProto.setFormatInfoNewPosition = function (newPosition) {
        var self = this;

        var data = {};
        var locale = TC.Util.getMapLocale(self.map);

        if (self.map.on3DView) {
            var geoCoords = self.map.crs !== self.map.view3D.crs ? TC.Util.reproject(newPosition.position, self.map.crs, self.map.view3D.crs) : newPosition.position;
            data.x = geoCoords[0].toLocaleString(locale);
            data.y = geoCoords[1].toLocaleString(locale);

            data.mdt = Math.round(self.map.view3D.getHeightFromMDT(geoCoords)).toLocaleString(locale);

            data.isGeo = true;

        } else {
            data.x = Math.round(newPosition.position[0]).toLocaleString(locale);
            data.y = Math.round(newPosition.position[1]).toLocaleString(locale);
        }

        data.z = (Math.round(newPosition.altitude).toLocaleString(locale));
        data.accuracy = (Math.round(newPosition.accuracy).toLocaleString(locale));
        data.speed = newPosition.speed.toLocaleString(locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 });

        return data;
    };

    ctlProto.renderInfoNewPosition = function (d) {
        var self = this;

        self.getRenderedHtml(self.CLASS + '-tracking-toast', self.setFormatInfoNewPosition(d.pd), function (html) {

            if (!self.track.infoPanel) {
                self.track.infoPanel = true;

                var resultsPanelOptions = {
                    content: "table",
                    titles: {
                        main: self.getLocaleString("geo.mylocation"),
                        max: self.getLocaleString("geo.mylocation.show")
                    },
                    classes: {
                        collapsed: "tracking"
                    }
                };

                var ctlPromise;
                const addResultsPanelInfo = function (controlContainer) {
                    resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                    ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                };

                if (self.options.displayOn) {
                    var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                    if (!controlContainer) {
                        self.map.addControl(self.options.displayOn).then(addResultsPanelInfo);
                    } else {
                        addResultsPanelInfo(controlContainer);
                    }
                } else {
                    resultsPanelOptions.div = document.createElement('div');
                    self.map.div.appendChild(resultsPanelOptions.div);
                    ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                }

                ctlPromise.then(function (resultsPanelInfo) {
                    resultsPanelInfo.caller = self;
                    self.map.getControlsByClass('TC.control.ResultsPanel').filter(function (panel) {
                        return panel.content === "table" && panel !== resultsPanelInfo;
                    }).forEach(function (panel) {
                        panel.close();
                    });

                    self.track.infoPanel = resultsPanelInfo;

                    resultsPanelInfo.renderPromise().then(function () {
                        resultsPanelInfo.open(html);
                    });
                });
            } else if (typeof (self.track.infoPanel) !== "boolean" && !self.track.infoPanel.isMinimized()) {
                self.track.infoPanel.renderPromise().then(function () {
                    self.track.infoPanel.getTableContainer().innerHTML = html;
                    if (!self.track.infoPanel.isVisible()) {
                        self.track.infoPanel.doVisible();
                    }
                });
            }
        });
    };


    var duringTrackingToolsPanel = function () {
        var self = this;

        if (!self.track.trackToolPanelOpened.checked) {
            self.map.trigger(TC.Consts.event.TOOLSCLOSE);
        }
    };

    var _tracking = function () {
        var self = this;

        self.activate();

        _activateTrackingBtns.call(self);
        duringTrackingToolsPanel.call(self);

        self.on(self.Const.Event.POSITIONCHANGE, function (d) {

            self.currentPoint = d.pd;
            self.renderInfoNewPosition(d);

            self.track.trackName.disabled = false;
            self.track.trackSave.disabled = false;

            self.track.trackWPT.disabled = false;
            self.track.trackAdd.disabled = false;

            // cada vez que se registra una nueva posición almacenamos en sessionStorage
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);
        });
        self.on(self.Const.Event.STATEUPDATED, function (data) {
            //self.track.htmlMarker.setAttribute('src', data.moving ? 'layout/idena/img/geo-marker-heading.png' : 'layout/idena/img/geo-marker.png');
        });

        self.clear(self.Const.Layers.TRACKING);

        advertisement.call(self, self.Const.LocalStorageKey.TRACKINGSHOWADVERTISEMENT);

        self.wrap.setTracking(true);
    };

    /* inicio gestión suspensión de la pantalla en móviles */
    var _onpauseVideo;
    var addVideoKeepScreenOn = function () {
        var self = this;

        if (!self.videoScreenOn) {
            var media = {
                WebM: "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=",
                MP4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=="
            };

            self.videoScreenOn = document.createElement('video');
            self.videoScreenOn.setAttribute("loop", "");
            self.videoScreenOn.setAttribute("muted", "");
            self.videoScreenOn.setAttribute("webkit-playsinline", "");
            self.videoScreenOn.setAttribute("playsinline", "");
            self.videoScreenOn.setAttribute("style", "transform: translateZ(0px);");

            var sourceWebM = document.createElement('source');
            sourceWebM.src = media.WebM;
            sourceWebM.type = "video/webm";
            self.videoScreenOn.appendChild(sourceWebM);

            var sourceMP4 = document.createElement('source');
            sourceMP4.src = media.MP4;
            sourceMP4.type = "video/mp4";
            self.videoScreenOn.appendChild(sourceMP4);
        }

        self.videoScreenOn.play();
    };
    var removeVideoKeepScreenOn = function () {
        var self = this;
        if (self.videoScreenOn) {
            self.videoScreenOn.pause();
        }
    };

    var _onWindowBlurred;
    var onWindowBlurred = function () {
        var self = this;

        fromSessionToStorage.apply(self);
    };

    var _onWindowFocused;
    var onWindowFocused = function () {
        var self = this;

        if (self.videoScreenOn.paused)
            self.videoScreenOn.play();

        fromStorageToSession.apply(self);
    };

    var getHiddenProperty = function () {
        var prefixes = ['webkit', 'moz', 'ms', 'o'];

        if ('hidden' in document) return 'hidden';

        for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document)
                return prefixes[i] + 'Hidden';
        }

        return null;
    };
    var _onWindowVisibility;
    var onWindowVisibility = function () {
        var self = this;

        var hidden = getHiddenProperty();

        if (!document[hidden])
            onWindowFocused.apply(self);

        console.log('video is: ' + self.videoScreenOn.paused);
    };
    var addWindowEvents = function () {
        var self = this;

        if (!_onWindowVisibility)
            _onWindowVisibility = onWindowVisibility.bind(self);

        if (!_onWindowBlurred)
            _onWindowBlurred = onWindowBlurred.bind(self);

        if (!_onWindowFocused)
            _onWindowFocused = onWindowFocused.bind(self);

        window.addEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && Modernizr.touch && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.addEventListener('pagehide', _onWindowBlurred, false);
            window.addEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.addEventListener('blur', _onWindowBlurred, false);
            window.addEventListener('focus', _onWindowFocused, false);
        }
    }
    var removeWindowEvents = function () {

        window.removeEventListener('visibilitychange', _onWindowVisibility, false);

        // ipad / iphone / ipod (Safari mobile, not Android default browsers not Chrome Mobile that is)
        if (TC.Util.detectSafari() && Modernizr.touch && !navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/CriOS/i)) {
            window.removeEventListener('pagehide', _onWindowBlurred, false);
            window.removeEventListener('pageshow', _onWindowFocused, false);
        } else { // the rest            
            window.removeEventListener('blur', _onWindowBlurred, false);
            window.removeEventListener('focus', _onWindowFocused, false);
        }
    };

    var fromSessionToStorage = function () {
        var self = this;

        var sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
        if (sessionTracking && sessionTracking.length > 0)
            localforage.setItem(self.Const.LocalStorageKey.TRACKINGTEMP, typeof (sessionTracking) === "string" ? sessionTracking : JSON.stringify(sessionTracking));
    };
    var fromStorageToSession = function () {
        var self = this;

        localforage.getItem(self.Const.LocalStorageKey.TRACKINGTEMP).then(function (storageData) {
            if (storageData !== null && storageData !== "null" && storageData.length > 0) {
                TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, storageData);
            }
        });
    };
    /* final gestión suspensión de la pantalla en móviles */

    var advertisement = function (showAdvertisement) {
        var self = this;

        var done = new Promise(function (resolve, reject) {
            if (window.localforage)
                resolve();
            else {
                TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                    resolve();
                });
            }
        });

        done.then(function () {
            localforage.getItem(showAdvertisement).then(function (registeredShowAdvertisement) {
                if (registeredShowAdvertisement == null) {
                    const dialog = self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog');
                    const checkbox = dialog.querySelector('input[type="checkbox"]');
                    checkbox.setAttribute('name', showAdvertisement);
                    checkbox.checked = false;

                    document.querySelector('#pageBlurMsg').textContent = TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur'): self.getLocaleString('geo.trk.page.blur.desktop');

                    dialog.querySelector('h3').textContent = showAdvertisement == self.Const.LocalStorageKey.GPSSHOWADVERTISEMENT ?
                        self.getLocaleString("geo.track.activate") + " " + self.getLocaleString("geo.gps") :
                        self.getLocaleString('geo.track.activate.title');

                    TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-track-advert-dialog'));
                }
            });
        });

        self.map.toast(!TC.Util.detectMobile() ? self.getLocaleString('geo.trk.page.blur.desktop') : self.getLocaleString('geo.trk.page.blur'), {
            type: TC.Consts.msgType.WARNING
        });
    };

    ctlProto._askTracking = function (callback) {
        var self = this;

        TC.Util.showModal(self._dialogDiv.querySelector('.tc-ctl-geolocation-continue-track-dialog'), {
            closeCallback: function () {

                if ($.isFunction(callback)) {
                    callback();
                }
            }
        });

        return true;
    };

    ctlProto.activateTracking = function () {
        var self = this;
        var trackingAvailable = true;

        if (!self.isActive) {
            self.activate();
        }

        self.clear(self.Const.Layers.TRACKING);

        try {
            TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TEST, self.Const.LocalStorageKey.TEST);
        } catch (error) {
            if (error.code === DOMException.QUOTA_EXCEEDED_ERR)
                TC.alert(self.getLocaleString("geo.error.trackinglocalstorage"));
            else TC.error(error);

            trackingAvailable = false;
        }

        if (trackingAvailable) {
            addVideoKeepScreenOn.apply(self);
            addWindowEvents.apply(self);

            self.sessionTracking = TC.Util.storage.getSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP);
            if (self.sessionTracking) {
                var asked = self._askTracking(function () {
                    _deactivateTrackingBtns.call(self);
                });

                if (!asked) {
                    self.track.trackRenew.click();
                }
            } else _tracking.call(self);
        } else { _deactivateTrackingBtns.call(self); }
    };

    ctlProto.deactivateTracking = function () {
        var self = this;

        var _deactivateTracking = function () {

            self.track.infoPanel.close();

            fromSessionToStorage.apply(self);

            self.wrap.setTracking(false);


            delete self.geopositionTracking;

            if (!visibilityTrack) {
                self.div.querySelector(self._classSelector + '-track-render').querySelector('label').click();
            }

            removeVideoKeepScreenOn.apply(self);
            removeWindowEvents.apply(self);

            self.off(self.Const.Event.POSITIONCHANGE);
            self.off(self.Const.Event.STATEUPDATED);

            _deactivateTrackingBtns.call(self);

            self.track.trackName.value = '';
            self.track.trackName.disabled = true;
            self.track.trackSave.disabled = true;

            self.track.trackWPT.value = '';
            self.track.trackWPT.disabled = true;
            self.track.trackAdd.disabled = true;

            self.clear(self.Const.Layers.TRACKING);
            self.clear(self.Const.Layers.GPS);

            //TC.Control.prototype.deactivate.call(self);

            return true;
        };

        if (self.wrap.hasCoordinates()) {
            self.map.toast(self.getLocaleString("geo.trk.deactivate.alert"), {
                duration: 10000
            });
            //TC.alert(self.getLocaleString("geo.trk.deactivate.alert"));
            return _deactivateTracking();
        } else return _deactivateTracking();
    };

    /* Obtengo los tracks desde localForage */
    ctlProto.getStoredTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            var tracks = [];

            localforage.keys().then(function (keys) {
                keys = keys.filter(function (k) {
                    if (!(k.indexOf(self.Const.LocalStorageKey.TRACKINGTEMP) === 0) && k.indexOf(self.Const.LocalStorageKey.TRACKING) === 0) {
                        return /trk#\d/i.exec(k);
                    }
                    return false;
                });

                if (keys.length == 0) {
                    self.availableTracks = tracks;
                    resolve(tracks);
                }

                const promises = new Array(keys.length);
                keys.forEach(function (key, idx) {
                    promises[idx] = new Promise(function (res, rej) {
                        localforage.getItem(key, function (e, v) {
                            res(v);
                        });
                    });
                });

                Promise.all(promises).then(function (results) {
                    if (results && results.length) {
                        results.forEach(function (r) {
                            var r = JSON.parse(r);
                            if (r instanceof Array) {
                                tracks = tracks.concat(r);
                            } else {
                                tracks.push(r);
                            }
                        });

                        var tracksArray = tracks.length > 1 ? _orderTracks(tracks) : tracks;
                        self.availableTracks = tracksArray;
                        resolve(tracksArray);
                    }
                });
            });
        });
    };

    /**
     * Recibe una sucesión de tracks y la ordena por nombre.
     */
    var _orderTracks = function (tracks) {
        var tracksArray = [];

        for (var index in tracks) {
            if (tracks[index] && typeof (tracks[index]) === "object") {
                tracksArray.push(tracks[index]);
                tracksArray.sort(function (a, b) {
                    if (typeof (a.name) === "string") {
                        return $.isFunction(a.name.localeCompare) ? a.name.localeCompare(b.name) : 0;
                    } else { return 0; }
                });
            }
        }

        return tracksArray;
    };

    /* Almaceno los tracks mediante localForage, actualizo la vble availableTracks y actualizo la lista de tracks */
    ctlProto.setStoredTracks = function (tracks) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const promises = [];
            tracks.forEach(function (t) {
                promises.push(new Promise(function (res, rej) {
                    localforage.setItem(self.Const.LocalStorageKey.TRACKING + "#" + t.uid, JSON.stringify(t), function (e, v) {
                        res(v);
                    });
                }));
            });

            Promise.all(promises).then(function () {
                self.getStoredTracks().then(function () {
                    self.bindTracks();
                    resolve();
                });
            });
        });
    };

    /* Obtengo los tracks desde vble local */
    ctlProto.getAvailableTracks = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            if (!self.availableTracks) {
                self.getStoredTracks().then(function (availableTracks) {
                    resolve(availableTracks);
                });
            }
            else {
                resolve(self.availableTracks);
            }
        });
    };

    ctlProto.bindTracks = function () {
        var self = this;

        const listItems = self.track.trackList.querySelectorAll('li');
        listItems.forEach(function (li) {
            li.style.display = 'none';
        });

        self.getAvailableTracks().then(function (tracks) {

            if (_isEmpty(tracks)) {
                self.track.trackList.querySelectorAll('li[class^="tc-ctl-geolocation-track-available-empty"]').forEach(function (li) {
                    li.style.display = '';
                });
                self.track.trackSearch.disabled = true;
            }
            else {
                const currentSelectedTrack = self.getSelectedTrack();
                var currentSelectedTrackId;
                if (currentSelectedTrack) {
                    currentSelectedTrackId = currentSelectedTrack.dataset.uid
                }
                self.track.trackList.querySelectorAll('li[data-id]').forEach(function (li) {
                    self.track.trackList.removeChild(li);
                });

                for (var i = 0; i < tracks.length; i++) {
                    var t = tracks[i];
                    if (typeof (t) === "object") {
                        self.getRenderedHtml(self.CLASS + '-track-node', {
                            id: i, uid: t.uid, name: t.name ? t.name.trim() : ''
                        }, function (html) {
                            const parser = new DOMParser();
                            const newLi = parser.parseFromString(html, 'text/html').body.firstChild;
                            self.track.trackList.appendChild(newLi);
                        });
                    }
                }

                if (currentSelectedTrackId) {
                    self.setSelectedTrack(self.track.trackList.querySelector('li[data-uid="' + currentSelectedTrackId + '"]'));
                }

                self.track.trackSearch.disabled = false;
            }
        });
    };

    ctlProto.chartProgressInit = function () {
        const self = this;

        if (!window.d3) {
            TC.syncLoadJS(TC.Consts.url.D3C3);
        }

        const dataDiv = d3.select(".c3-event-rects,.c3-event-rects-single").node().getBoundingClientRect();
        self.miDiv = document.createElement('div');
        self.miDiv.classList.add('miDiv');
        self.miDiv.style.width = dataDiv.width + 'px';
        self.miDiv.style.height = dataDiv.height + 'px';

        self.miProgressDiv = document.createElement('div');
        self.miProgressDiv.classList.add('miProgressDiv');
        self.miProgressDiv.classList.add(self.CLASS + '-track-elevation-chart-progress');
        self.miProgressDiv.classList.add(TC.Consts.classes.HIDDEN);
        self.miProgressDiv.style.width = '0%';
        self.miProgressDiv.style.height = dataDiv.height + 'px';

        self.miProgressTextDiv = document.createElement('div');
        self.miProgressTextDiv.classList.add('miProgressTextDiv');
        self.miProgressTextDiv.classList.add('tc-ctl-geolocation-track-elevation-chart-progress');
        self.miProgressTextDiv.classList.add('text');
        self.miProgressTextDiv.style.width = dataDiv.width + 'px';
        self.miProgressTextDiv.style.height = dataDiv.height + 'px';

        self.miDiv.style.top = dataDiv.top + 'px';
        self.miDiv.style.left = dataDiv.left + 'px';
        self.miDiv.style.bottom = dataDiv.bottom + 'px';
        self.miDiv.style.right = dataDiv.right + 'px';
        self.miDiv.style.position = 'absolute';
        self.miDiv.style.zIndex = 10008;
        self.miDiv.style.display = 'none';

        self.miProgressDiv.appendChild(self.miProgressTextDiv);
        self.miDiv.appendChild(self.miProgressDiv);
        document.body.appendChild(self.miDiv);

    };

    ctlProto.chartProgressClear = function () {
        const self = this;
        if (self.miDiv) {
            self.miDiv.parentElement.removeChild(self.miDiv);
            self.miDiv = null;
            self.miProgressDiv = null;
            self.miProgressTextDiv = null;
        }
    };

    ctlProto.chartSetProgress = function (previous, current, distance, doneTime) {
        var self = this;

        if (self.miDiv) {
            if (self.miDiv.style.display === 'none') {
                self.miDiv.style.display = '';
            }

            self.miProgressDiv.classList.remove(TC.Consts.classes.HIDDEN);

            var done = previous.d;
            var progress = (done + Math.hypot(previous.p[0] - current[0], previous.p[1] - current[1])) / distance * 100;

            self.miProgressDiv.style.width = progress + '%';

            var locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
            var ele = parseInt(current[2].toFixed(0)).toLocaleString(locale);
            var dist;
            var measure;
            if ((done / 1000) < 1) {
                dist = Math.round((done / 1000) * 1000);
                measure = ' m';
            } else {
                dist = Math.round((done / 1000) * 100) / 100;
                measure = ' km';
            }

            dist = dist.toLocaleString(locale);

            self.miProgressTextDiv.innerHTML = '<div><span>' + ele + ' m' + '</span>' + '<br>' + '<span>' + dist + measure + '</span></div>' + (doneTime ? '<br><span>' + doneTime.toString + '</span>' : '');
        }
    };

    ctlProto._getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return $.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.simulateTrack = function (li) {
        var self = this;

        self.simulate_speed = 1;

        self.drawTrack(li, false).then(function () {
            self.wrap.simulateTrack();
        });
    };

    ctlProto.drawTrack = function (li, activateSnapping) {
        var self = this;

        duringTrackingToolsPanel.call(self);
        return new Promise(function (resolve, reject) {
            self.setSelectedTrack(li);
            self.drawTrackingData(li).then(function () {
                self.elevationTrack(li);

                self.activate();
                resolve();
            });
        });
    };


    ctlProto.elevationTrack = function (li, resized) {
        var self = this;

        if (resized) {            

            self.wrap.simulateTrackEnd();
            self.uiSimulate(false, li);
            return;
        }

        if (!self.onResize) {
            self.onResize = self.elevationTrack.bind(self, li, true);
            window.addEventListener("resize", self.onResize, false);
        }

        self.chart = {
            coordinates: []
        };

        if (self.track.elevationChart)
            self.track.elevationChart = self.track.elevationChart.destroy();

        var getChartData = function (li) {
            return new Promise(function (resolve, reject) {
                TC.loadJS(
                    !TC.tool || !TC.tool.Elevation,
                    TC.apiLocation + 'TC/tool/Elevation',
                    function () {
                        self.getTrackingData(li).then(function (track) {
                            var geoJSON = track.data;
                            if (geoJSON) {
                                var x, ele; x = []; ele = [];
                                var empty = true;
                                var minEle, maxEle;
                                var elevationGain = {};
                                var time = {};
                                var km = 0;
                                var geom;

                                var f = (new ol.format.GeoJSON()).readFeatures(geoJSON);

                                var getDistance = function () {
                                    if (geom.getLayout() == ol.geom.GeometryLayout.XYZ ||
                                        geom.getLayout() == ol.geom.GeometryLayout.XYZM) {
                                        var distance = 0;
                                        if (self.map.crs !== self.map.options.utmCrs) {
                                            line = new ol.geom.LineString(TC.Util.reproject(geom.getCoordinates(), self.map.crs, self.map.options.utmCrs));
                                            distance = line.getLength();
                                        } else {
                                            distance = geom.getLength();
                                        }
                                        return parseFloat((distance / 1000).toFixed(2));
                                    }

                                    return null;
                                };
                                var getTime = function () {
                                    if (geom.getLayout() == ol.geom.GeometryLayout.XYZM ||
                                        geom.getLayout() == ol.geom.GeometryLayout.XYM) {
                                        var diff = geom.getLastCoordinate()[3] - geom.getFirstCoordinate()[3];
                                        return {
                                            s: Math.floor((diff / 1000) % 60),
                                            m: Math.floor(((diff / (1000 * 60)) % 60)),
                                            h: Math.floor(((diff / (1000 * 60 * 60)) % 24))
                                        };
                                    }

                                    return null;
                                };

                                var addX = function (x) {
                                    if (self.chart.coordinates.length > 0) {
                                        var distance = 0;
                                        self.chart.coordinates
                                            .forEach(function (point, idx, arr) {
                                                var prev = idx === 0 ? point : arr[idx - 1];

                                                if (self.map.crs !== self.map.options.utmCrs) {
                                                    point = TC.Util.reproject(point, self.map.crs, self.map.options.utmCrs);
                                                    prev = TC.Util.reproject(prev, self.map.crs, self.map.options.utmCrs);
                                                }

                                                const dx = point[0] - prev[0];
                                                const dy = point[1] - prev[1];
                                                distance += Math.sqrt(dx * dx + dy * dy);

                                                x.push(parseFloat(distance.toFixed(2)));
                                            });
                                    }
                                };

                                var addElevation = function (ele) {
                                    var y = [];
                                    for (var i = 0; i < self.chart.coordinates.length; i++) {
                                        if (self.chart.coordinates[i].length > 2) {
                                            var v = (Math.round(self.chart.coordinates[i][2] * 10) / 10);
                                            if (empty && v > 0)
                                                empty = false;

                                            ele.push(v);

                                            if (i == 0)
                                                minEle = maxEle = v;

                                            minEle = Math.min(minEle, v);
                                            maxEle = Math.max(maxEle, v);

                                        }
                                        else {
                                            resolve(null);
                                            return;
                                        }
                                    }
                                };

                                f.filter(function (feature) {
                                    return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';
                                }).forEach(function (feature) {
                                    geom = feature.getGeometry();

                                    switch (geom.getType().toLowerCase()) {
                                        case 'linestring':

                                            if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                track.layout === ol.geom.GeometryLayout.XYZ) {

                                                time = getTime(geom);
                                                km = getDistance(geom);
                                                elevationGain = TC.tool.Elevation.getElevationGain({ coords: geom.getCoordinates(), hillDeltaThreshold: self.gapHill });
                                                self.chart.coordinates = self.chart.coordinates.concat(geom.getCoordinates());

                                                addX(x);
                                                addElevation(ele);
                                            }
                                            break;
                                        case 'multilinestring':

                                            if (track.layout === ol.geom.GeometryLayout.XYZM ||
                                                track.layout === ol.geom.GeometryLayout.XYZ) {

                                                var _time;
                                                var ls = geom.getLineStrings();
                                                for (var i = 0; i < ls.length; i++) {
                                                    km = km + getDistance(ls[i]);

                                                    if (ls[i].getLayout() == ol.geom.GeometryLayout.XYZM)
                                                        _time = _time + (ls[i].getLastCoordinate()[3] - ls[i].getFirstCoordinate()[3]);

                                                    self.chart.coordinates = self.chart.coordinates.concat(ls[i].getCoordinates());

                                                    if (_time) { time = getTime(_time); }

                                                    addX(x);
                                                    addElevation(ele);
                                                }
                                            }

                                            break;
                                        default:
                                            return null;
                                            break;
                                    }
                                });

                                if (ele instanceof Array && ele.length == 0) {
                                    empty = true;
                                }

                                self.chartData = !empty ? $.extend({}, { time: time, ele: ele, x: x, miny: minEle, maxy: maxEle }, elevationGain) : null;

                                resolve(self.chartData);
                                return;
                            }

                            resolve(null);
                            return;
                        });
                    }
                );
            });
        };

        getChartData(li).then(function (data) {
            var locale = TC.Util.getMapLocale(self.map);
            if (data != null) {
                if (data.time) data.time = ("00000" + data.time.h).slice(-2) + ':' + ("00000" + data.time.m).slice(-2) + ':' + ("00000" + data.time.s).slice(-2);
                data.coords = self.chart.coordinates;
                self.hasElevation = true;
            }
            else {
                self.hasElevation = false;
                data = {
                    msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                };
            }

            data.minHeight = self.CHART_SIZE.MIN_HEIGHT;
            data.maxHeight = self.CHART_SIZE.MAX_HEIGHT;

            data.minWidth = self.CHART_SIZE.MIN_WIDTH;
            data.mediumWidth = self.CHART_SIZE.MEDIUM_WIDTH;
            data.maxWidth = self.CHART_SIZE.MAX_WIDTH;

            self.map.one(TC.Consts.event.DRAWCHART, function (e) {
                self.chartProgressInit();
            });

            if (!self.resultsPanelChart) {

                if (!window.c3) {
                    TC.syncLoadJS(TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js');
                }

                var resultsPanelOptions = {
                    content: "chart",
                    titles: {
                        main: self.getLocaleString("geo.trk.chart.chpe"),
                        max: self.getLocaleString("geo.trk.chart.chpe")
                    },
                    openOn: self.Const.Event.DRAWTRACK,
                    closeOn: self.Const.Event.CLEARTRACK,
                    chart: {
                        ctx: self,
                        onmouseout: ctlProto.removeElevationTooltip,
                        tooltip: ctlProto.getElevationTooltip
                    }
                };

                var ctlPromise;
                const addResultsPanelChart = function (controlContainer) {
                    resultsPanelOptions.side = controlContainer.SIDE.RIGHT;
                    ctlPromise = controlContainer.addControl('resultsPanel', resultsPanelOptions);
                };

                if (self.options.displayOn) {
                    var controlContainer = self.map.getControlsByClass('TC.control.' + self.options.displayOn[0].toUpperCase() + self.options.displayOn.substring(1))[0];
                    if (!controlContainer) {
                        self.map.addControl(self.options.displayOn).then(addResultsPanelChart);
                    } else {
                        addResultsPanelChart(controlContainer);
                    }
                } else {
                    resultsPanelOptions.div = document.createElement('div');
                    self.map.div.appendChild(resultsPanelOptions.div);
                    ctlPromise = self.map.addControl('resultsPanel', resultsPanelOptions);
                }

                ctlPromise.then(function (resultsPanelChart) {
                    resultsPanelChart.caller = self;
                    self.resultsPanelChart = resultsPanelChart;
                    resultsPanelChart.renderPromise().then(function () {

                        resultsPanelChart.activateSnapping = function (e) {
                            if (self.layerTrack && (!self.layerTrack.getVisibility() && self.layerTrack.getOpacity() == 0))
                                self.wrap.deactivateSnapping.call(self.wrap);
                        };
                        resultsPanelChart.deactivateSnapping = function (e) {
                            if (self.layerTrack && self.layerTrack.getVisibility() && self.layerTrack.getOpacity() > 0)
                                self.wrap.activateSnapping.call(self.wrap);
                        };

                        resultsPanelChart.div.addEventListener('mouseover', resultsPanelChart.deactivateSnapping);
                        resultsPanelChart.div.addEventListener('mouseout', resultsPanelChart.activateSnapping);

                        self.map
                            .on(TC.Consts.event.RESULTSPANELMIN, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = 'none';
                                }
                            })
                            .on(TC.Consts.event.RESULTSPANELMAX, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = '';
                                }
                            })
                            .on(TC.Consts.event.RESULTSPANELCLOSE, function () {
                                if (self.miDiv) {
                                    self.miDiv.style.display = 'none';
                                }
                            });

                        self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
                    });
                });
            } else {
                self.resultsPanelChart.open();
                self.map.trigger(self.Const.Event.DRAWTRACK, { data: data });
            }
        });
    };

    ctlProto.clear = function (layerType) {
        var self = this;

        if (self.onResize) {
            window.removeEventListener("resize", self.onResize, false);
            self.onResize = undefined;
        }

        if (layerType == self.Const.Layers.TRACK) {

            self.layerTrack.clearFeatures();

            // gráfico perfil de elevación
            if (self.resultsPanelChart)
                self.resultsPanelChart.close();
            delete self.chartData;

            // overlay de la simulación
            self.wrap.simulateTrackEnd();

            self.wrap.clear();

            // eliminamos la selección en la lista de tracks
            self.track.trackList.querySelectorAll('li').forEach(function (li) {
                li.classList.remove(self.Const.Classes.SELECTEDTRACK);
            });

            self.map.trigger(self.Const.Event.CLEARTRACK);

            self.featuresToShare = [];

            //TC.Control.prototype.deactivate.call(self);

        } else {
            self.layerTracking.clearFeatures();
            self.layerGPS.clearFeatures();
        }
    };

    ctlProto.saveTrack = function (options) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var message = options.message || self.getLocaleString("geo.trk.save.alert");

            var _save = function (layer) {
                var wait;
                wait = self.getLoadingIndicator().addWait();

                var trackName = options.importedFileName || self.track.trackName.value.trim();

                var tracks = self.availableTracks;
                if (!tracks) {
                    tracks = [];
                }

                var formatted = self.wrap.formattedToStorage(layer, true, options.notReproject);

                var clean = function (wait) {
                    self.track.trackName.value = '';
                    self.track.trackName.disabled = true;
                    self.track.trackSave.disabled = true;

                    self.track.trackWPT.value = '';
                    self.track.trackWPT.disabled = true;
                    self.track.trackAdd.disabled = true;

                    self.getLoadingIndicator().removeWait(wait);

                    duringTrackingToolsPanel.call(self);
                };

                var newTrack = {
                    name: trackName,
                    data: formatted.features,
                    layout: formatted.layout,
                    crs: self.storageCRS
                };

                TC.loadJS(
                    !window.hex_md5,
                    [TC.apiLocation + TC.Consts.url.HASH],
                    function () {
                        var hash = hex_md5(JSON.stringify(newTrack));

                        var sameTrackUID = tracks.map(function (savedTrack) {
                            var clonedTrack = JSON.parse(JSON.stringify(savedTrack));
                            delete clonedTrack.uid;
                            if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                return savedTrack.uid;
                            } else {
                                const jsonFormat = new ol.format.GeoJSON();
                                // validamos si se trata de un track exportado/importado ya que se compacta la geometría
                                var features = jsonFormat.readFeatures(clonedTrack.data);
                                // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
                                var precision = Math.pow(10, TC.Consts.DEGREE_PRECISION + 1);

                                features.forEach(function (feature) {
                                    var geom = TC.Util.explodeGeometry(TC.Util.compactGeometry(feature.getGeometry().getCoordinates(), precision));
                                    feature.getGeometry().setCoordinates(geom);
                                });

                                clonedTrack.data = jsonFormat.writeFeatures(features);

                                if (hash === hex_md5(JSON.stringify(clonedTrack))) {
                                    return savedTrack.uid;
                                } else {
                                    return null;
                                }
                            }

                        }).filter(function (uid) {
                            return uid !== null
                        });

                        const getTrackIndex = function (uid) {
                            return self.getStoredTracks().then(function () {
                                self.bindTracks();

                                var index;
                                for (var i = 0; i < self.availableTracks.length; i++) {
                                    if (self.availableTracks[i].uid === uid) {
                                        index = i;
                                        break;
                                    }
                                }

                                return index;
                            });
                        };

                        if (sameTrackUID.length === 0) {

                            newTrack.uid = Date.now() + Math.random();
                            tracks.push(newTrack);
                            tracks = _orderTracks(tracks);

                            try {
                                self.setStoredTracks(tracks).then(function () {
                                    self.map.toast(message, { duration: 3000 });

                                    clean(wait);

                                    getTrackIndex(newTrack.uid).then(function (index) {
                                        resolve(index);
                                    });
                                });

                            } catch (error) {
                                TC.alert(self.getLocaleString("geo.error.savelocalstorage") + ': ' + error.message);
                                clean(wait);
                                reject();
                            }
                        } else {
                            console.log('Ya existe un track con ese mismo hash');

                            clean(wait);

                            getTrackIndex(sameTrackUID[0]).then(function (index) {
                                resolve(index);
                            });
                        }
                    });

            };

            const createTCFeatures = function (features) {
                return new Promise(function (resolve, reject) {
                    var featurePromises = features.filter(function (feature) {
                        return !feature._wrap;
                    }).forEach(function (elm) {
                        return TC.wrap.Feature.createFeature(elm);
                    });

                    Promise.all(featurePromises).then(function (tcFeatures) {
                        resolve();
                    });
                });
            };

            if (self.importedFileName)
                _save(self.layerTrack);
            else if (self.track.trackName.value.trim().length == 0) {
                self.track.trackName.value = new Date().toLocaleString();
                _save(self.layerTracking);
            }
            else {
                _save(self.layerTracking);
            }
        });
    };

    ctlProto.addWaypoint = function () {
        var self = this;

        var waypointName = self.track.trackWPT.value.trim();
        if (!waypointName) {
            waypointName = new Date().toLocaleString();
        }

        var wait = self.getLoadingIndicator().addWait();

        duringTrackingToolsPanel.call(self);

        self.wrap.addWaypoint(self.currentPoint.position, {
            name: waypointName,
            ele: self.currentPoint.heading,
            time: new Date().getTime() // GLS: lo quito ya que hemos actualizado la función que gestiona la fechas para la exportación a GPX - espera la fecha en segundos -> / 1000 // para la exportación a GPX - espera la fecha en segundos
        });

        self.track.trackWPT.value = '';
        self.track.trackWPT.disabled = true;
        self.track.trackAdd.disabled = true;

        // cada vez que se añade un waypoint almacenamos en sessionStorage
        TC.Util.storage.setSessionLocalValue(self.Const.LocalStorageKey.TRACKINGTEMP, self.wrap.formattedToStorage(self.layerTracking).features);

        self.getLoadingIndicator().removeWait(wait);
    };

    ctlProto.editTrackName = function (trackId, newName) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                if (tracks[trackId]) {
                    tracks[trackId].name = newName;

                    self.setStoredTracks(tracks);
                }
            }
        });
    };

    ctlProto.removeTrack = function (li) {
        var self = this;

        self.getAvailableTracks().then(function (tracks) {
            if (tracks) {
                var dataId = li.dataset.id;
                if (tracks[dataId]) {
                    var uid = tracks[dataId].uid;

                    TC.confirm(self.getLocaleString("geo.trk.delete.alert"), function () {

                        const selectedTrack = self.getSelectedTrack();
                        if (selectedTrack && selectedTrack.dataset.id === dataId) {
                            self.clear(self.Const.Layers.TRACK);
                        }

                        localforage.removeItem(self.Const.LocalStorageKey.TRACKING + '#' + uid).then(function () {
                            self.getStoredTracks().then(function () {
                                self.bindTracks();
                            });
                        }).catch(function (err) {
                            console.log(err);
                        });

                    }, function () { });
                }
            }
        });
    };

    ctlProto.setSelectedTrack = function (li) {
        var self = this;

        if (!self.isActive) {
            self.activate();
        }

        self.track.trackList.querySelectorAll('li[data-id] > span').forEach(function (span) {
            span.setAttribute('title', span.textContent);
        });
        self.track.trackList.querySelectorAll('li').forEach(function (li) {
            li.classList.remove(self.Const.Classes.SELECTEDTRACK);
        });

        li.classList.add(self.Const.Classes.SELECTEDTRACK);

        li.setAttribute('title', self.getLocaleString("tr.lst.clear") + " " + li.querySelector('span').textContent);
        li.querySelector(self.Const.Selector.DRAW).setAttribute('title', li.getAttribute('title'));
    };

    ctlProto.getSelectedTrack = function () {
        var self = this;

        return self.track.trackList.querySelector('li.' + self.Const.Classes.SELECTEDTRACK);
    };

    ctlProto.clearSelectedTrack = function () {
        const self = this;

        const selected = self.getSelectedTrack();
        if (selected) {

            if (self.onResize) {
                window.removeEventListener('resize', self.onResize, false);
                self.onResize = undefined;
            }

            selected.classList.remove(self.Const.Classes.SELECTEDTRACK);
            selected.setAttribute('title', selected.textContent);
            selected.querySelector(self.Const.Selector.DRAW).setAttribute('title', selected.getAttribute('title'));
        }
    };

    ctlProto.clearSelection = function () {
        var self = this;

        self.wrap.deactivateSnapping();
        var selected = self.getSelectedTrack();
        if (selected) {
            self.clearSelectedTrack();
        }
        if (self.resultsPanelChart) {

            self.resultsPanelChart.div.removeEventListener('mouseover', self.resultsPanelChart.deactivateSnapping);
            self.resultsPanelChart.div.removeEventListener('mouseout', self.resultsPanelChart.activateSnapping);

            self.resultsPanelChart.close();
        }

        self.clear(self.Const.Layers.TRACK);
    };

    ctlProto.drawTrackingData = function (li) {
        const self = this;

        return new Promise(function (resolve, reject) {
            self.wrap.clear();

            self.getTrackingData(li).then(function (track) {
                var data = track.data;
                if (track.data)
                    self.wrap.drawTrackingData(track).then(function () {
                        var showFeatures = self.layerTrack.features;
                        if (showFeatures && showFeatures.length > 0) {

                            var coordinates = showFeatures.filter(function (feature) {
                                feature.showsPopup = false;
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return true;
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return true;
                                }
                                return false;
                            }).map(function (feature) {
                                if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline) {
                                    return feature.geometry[0];
                                } else if (feature instanceof TC.feature.Polyline) {
                                    return feature.geometry;
                                }
                            })[0];

                            if (coordinates) {
                                var first = coordinates[0];
                                var last = coordinates[coordinates.length - 1];

                                if (first && !(first === last)) {
                                    self.layerTrack.addMarker(first.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon-end', anchor: [0.5, 1], notExport: true
                                    });
                                }

                                if (last) {
                                    self.layerTrack.addMarker(last.slice().splice(0, 2), {
                                        showsPopup: false, cssClass: self.CLASS + '-track-marker-icon', anchor: [0.5, 1], notExport: true
                                    });
                                }
                            }
                        }
                        self.layerTrack.setVisibility(true);
                        resolve();
                    });
            });
        });
    };

    ctlProto.getTrackingData = function (li) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.getAvailableTracks().then(function (tracks) {
                if (tracks) {
                    const dataId = li.dataset.id;
                    if (tracks[dataId]) {
                        var track = tracks[dataId].data;

                        // GLS: tengo que transformar de 4326 al crs del mapa en el momento de pintar, porque si lo hacemos al cargar la lista
                        // y después hay cambio de crs, en el momento de pintar no sé desde qué crs debo tranformar
                        track = self.wrap.formattedFromStorage(track);

                        resolve({ data: track, layout: tracks[dataId].layout });
                    }
                } else {
                    resolve();
                }
            });
        });
    };

    ctlProto.export = function (type, li) {
        var self = this;

        return self.wrap.export(type, li);
    };

    ctlProto.getElevationTooltip = function (d) {
        const self = this;
        self.wrap.showElevationMarker(d);

        return self.resultsPanelChart.getElevationChartTooltip(d);
    };

    ctlProto.removeElevationTooltip = function () {
        var self = this;
        self.wrap.hideElevationMarker();
    }

    ctlProto.clearFileInput = function (fileInput) {
        const form = document.createElement('form');
        const parent = fileInput.parentElement;
        parent.insertBefore(form, fileInput);
        form.appendChild(fileInput);
        form.reset();
        // Desenvolvemos el input del form
        form.insertAdjacentElement('afterend', fileInput);
        parent.removeChild(form);
    };

    ctlProto.getLoadingIndicator = function () {
        var self = this;

        if (!self.loading) {
            self.loading = self.map.getControlsByClass(TC.control.LoadingIndicator);
            if (self.loading && self.loading.length > 0)
                self.loading = self.loading[0];
        }

        return self.loading;
    };

    ctlProto.onGeolocateError = function (error) {
        var self = this;

        if (navigator.geolocation) {
            if (self.currentPosition)
                navigator.geolocation.clearWatch(self.currentPosition);
            if (self.currentPositionTrk) {
                self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];

                self.currentPositionTrk.forEach(function (watch) {
                    navigator.geolocation.clearWatch(watch);
                });

                self.currentPositionTrk = [];
            }
        }

        if (self.currentPositionWaiting)
            self.getLoadingIndicator().removeWait(self.currentPositionWaiting);

        var errorMsg;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMsg = self.getLocaleString("geo.error.permission_denied");
                break;
            case error.POSITION_UNAVAILABLE:
                errorMsg = self.getLocaleString("geo.error.position_unavailable");
                break;
            case error.TIMEOUT:
                errorMsg = self.getLocaleString("geo.error.timeout");
                break;
            default:
                errorMsg = self.getLocaleString("geo.error.default");
                break;
        }

        self.map.toast(errorMsg, { type: TC.Consts.msgType.WARNING });

        if (!self.geopositionTracking && self.track) {
            self.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);
            self.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    var _isEmpty = function (obj) {
        return !obj || obj.length === 0;
    };

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            const state = {};
            if (self.layerTrack) {
                var features = self.layerTrack.features;

                if (features.length > 0 && self.featuresToShare && self.featuresToShare.length > 0) {
                    state.features = self.featuresToShare;
                } else {
                    const layerState = self.layerTrack.exportState({
                        features: features
                    });

                    state.features = layerState.features;
                }

                state.id = self.id;
                const selectedTrack = self.getSelectedTrack();
                if (selectedTrack) {
                    state.trackName = selectedTrack.querySelector('span').innerHTML;
                }
                return state;
            }
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        if (self.map) {
            if (state.features && state.features.length) {
                self.enable();

                if (state.features.length > 0) {
                    const promises = new Array(state.features.length);
                    state.features.forEach(function (f, idx) {
                        const featureOptions = { data: f.data, id: f.id, showsPopup: f.showsPopup };
                        var addFn;
                        var geom = TC.Util.explodeGeometry(f.geom);
                        switch (f.type) {
                            case TC.Consts.geom.POLYLINE:
                                promises[idx] = new TC.feature.Polyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MULTIPOLYLINE:
                                promises[idx] = new TC.feature.MultiPolyline(geom, featureOptions);
                                break;
                            case TC.Consts.geom.MARKER:
                                promises[idx] = new TC.feature.Marker(geom, featureOptions);
                                break;
                            case TC.Consts.geom.POINT:
                                promises[idx] = new TC.feature.Point(geom, featureOptions);
                                break;
                        }
                    });

                    Promise.all(promises).then(function (tcFeatures) {
                        var options = { features: tcFeatures, fileName: state.trackName, notReproject: true, isShared: true };
                        if (!self.availableTracks) {
                            self.getStoredTracks().then(function () {
                                self.importTrack(options);
                            });
                        } else {
                            self.importTrack(options);
                        }
                    });
                }
            }
        }
    };
})();
﻿TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
if (!TC.filter) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
}

(function () {
    TC.control.GeometryFeatureInfo = function () {
        var self = this;
        TC.control.FeatureInfoCommons.apply(this, arguments);
        self.wrap = new TC.wrap.control.GeometryFeatureInfo(self);
        self.lineColor = !self.options.lineColor ? "#c00" : self.options.lineColor;
        self._isDrawing = false;
        self._isSearching = false;
        self._drawToken = false;
    };

    TC.inherit(TC.control.GeometryFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.GeometryFeatureInfo.prototype;

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);

        self.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {
            self.wrap.cancelDraw();
        });

        return result;
    };

    ctlProto.callback = function (coords, xy) {
        var self = this;
        if (self._drawToken) {
            return;
        }
        self.closeResults();
        //self.filterLayer.clearFeatures();
        var visibleLayers = false;
        for (var i = 0; i < self.map.workLayers.length; i++) {
            var layer = self.map.workLayers[i];
            if (layer.type === TC.Consts.layerType.WMS) {
                if (layer.getVisibility() && layer.names.length > 0) {
                    visibleLayers = true;
                    break;
                }
            }
        }
        if (visibleLayers) {
            self.closeResults();
            self.wrap.beginDraw({
                geometryType: self.geometryType,
                xy: coords,
                layer: self.filterLayer,
                callback: function (feature) {
                    self.wrap.getFeaturesByGeometry(feature);
                }
            });
        }
    };

    ctlProto.responseCallback = function (options) {
        var self = this;

        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);

        if (self.filterFeature) {
            var services = options.services;

            // Eliminamos capas sin resultados a no ser que tenga un error
            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                if (service.hasLimits) {
                    delete service.layers;
                    service.hasLimits = service.hasLimits;
                }
                else {
                    for (var j = 0; j < service.layers.length; j++) {
                        if (!service.layers[j].features.length) {
                            service.layers.splice(j, 1);
                            j = j - 1;
                        }
                    }
                    if (!service.layers.length) {
                        services.splice(i, 1);
                        i = i - 1;
                    }
                }

            }
            if (services.length) {
                self.renderData(options, function () {
                    self.insertLinks();
                    self.displayResults();
                });
            }
            else {
                self.resultsLayer.clearFeatures();
            }
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.ProjectionSelector) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/ProjectionSelector');
}

(function () {

    TC.control.LayerCatalog = function () {
        var self = this;

        self.layers = [];
        self.searchInit = false;

        TC.control.ProjectionSelector.apply(self, arguments);

        self._selectors = {
            LAYER_ROOT: 'div.' + self.CLASS + '-tree > ul.' + self.CLASS + '-branch > li.' + self.CLASS + '-node'
        };

        if (!TC.Consts.classes.SELECTABLE) {
            TC.Consts.classes.SELECTABLE = 'tc-selectable';
        }
        if (!TC.Consts.classes.INCOMPATIBLE) {
            TC.Consts.classes.INCOMPATIBLE = 'tc-incompatible';
        }
        if (!TC.Consts.classes.ACTIVE) {
            TC.Consts.classes.ACTIVE = 'tc-active';
        }
    };

    TC.inherit(TC.control.LayerCatalog, TC.control.ProjectionSelector);

    var ctlProto = TC.control.LayerCatalog.prototype;

    ctlProto.CLASS = 'tc-ctl-lcat';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/LayerCatalog.html";
        ctlProto.template[ctlProto.CLASS + '-branch'] = TC.apiLocation + "TC/templates/LayerCatalogBranch.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LayerCatalogNode.html";
        ctlProto.template[ctlProto.CLASS + '-info'] = TC.apiLocation + "TC/templates/LayerCatalogInfo.html";
        ctlProto.template[ctlProto.CLASS + '-results'] = TC.apiLocation + "TC/templates/LayerCatalogResults.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/LayerCatalogDialog.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "availableLayers" }).x(ctx.get(["enableSearch"], false), ctx, { "block": body_1 }, {}).w("</h2><div class=\"tc-ctl-lcat-search tc-hidden tc-collapsed\"><div class=\"tc-group\"><input type=\"search\" class=\"tc-ctl-lcat-input tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "textToSearchInLayers" }).w("\"></input></div><ul></ul></div><div class=\"tc-ctl-lcat-tree\">").x(ctx.get(["layerTrees"], false), ctx, { "else": body_3, "block": body_4 }, {}).w("</div><div class=\"tc-ctl-lcat-info tc-hidden\">").p("tc-ctl-lcat-info", ctx, ctx.rebase(ctx.getPath(true, [])), {}).w("</div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.x(ctx.get(["layerTrees"], false), ctx, { "block": body_2 }, {}); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<button class=\"tc-ctl-lcat-btn-search\" title=\"").h("i18n", ctx, {}, { "$key": "searchLayersbytext" }).w("\"></button>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<div class=\"tc-ctl tc-ctl-lcat-loading\"><span>").h("i18n", ctx, {}, { "$key": "loadingLayerTree" }).w("...</span></div>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<ul class=\"tc-ctl-lcat-branch\">").s(ctx.get(["layerTrees"], false), ctx, { "block": body_5 }, {}).w("</ul>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.p("tc-ctl-lcat-branch", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_5.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-branch'] = function () { dust.register(ctlProto.CLASS + '-branch', body_0); function body_0(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_1, "block": body_2 }, {}).w(" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><button class=\"tc-ctl-lcat-collapse-btn\"></button><span>").f(ctx.get(["title"], false), ctx, "h").w("</span><ul class=\"tc-ctl-lcat-branch tc-collapsed\">").s(ctx.get(["children"], false), ctx, { "block": body_3 }, {}).w("</ul></li>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-ctl-lcat-leaf\""); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-collapsed\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.p("tc-ctl-lcat-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["isVisible"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\">").x(ctx.get(["children"], false), ctx, { "block": body_4 }, {}).w("<span data-tooltip=\"").x(ctx.get(["name"], false), ctx, { "block": body_5 }, {}).w("\">").f(ctx.get(["title"], false), ctx, "h").w("</span>").x(ctx.get(["name"], false), ctx, { "block": body_6 }, {}).w("<ul class=\"tc-ctl-lcat-branch tc-collapsed\">").s(ctx.get(["children"], false), ctx, { "block": body_7 }, {}).w("</ul></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-ctl-lcat-leaf\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("class=\"tc-ctl-lcat-node tc-collapsed\""); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<button class=\"tc-ctl-lcat-collapse-btn\"></button>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.h("i18n", ctx, {}, { "$key": "clickToAddToMap" }); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<button title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\" class=\"tc-ctl-lcat-btn-info\"></button>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.p("tc-ctl-lcat-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_7.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-info'] = function () { dust.register(ctlProto.CLASS + '-info', body_0); function body_0(chk, ctx) { return chk.w("<a class=\"tc-ctl-lcat-info-close\"></a><h2>").h("i18n", ctx, {}, { "$key": "layerInfo" }).w("</h2><h3 class=\"tc-ctl-lcat-title\">").f(ctx.get(["title"], false), ctx, "h").w("</h3>").x(ctx.get(["abstract"], false), ctx, { "block": body_1 }, {}).x(ctx.get(["metadata"], false), ctx, { "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-abstract\"><h4>").h("i18n", ctx, {}, { "$key": "abstract" }).w("</h4><div><pre>").f(ctx.get(["abstract"], false), ctx, "h", ["s"]).w("</pre></div></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-metadata\"><h4>").h("i18n", ctx, {}, { "$key": "metadata" }).w("</h4><ul>").s(ctx.get(["metadata"], false), ctx, { "block": body_3 }, {}).w("</ul></div>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<li><a href=\"").f(ctx.get(["url"], false), ctx, "h", ["s"]).w("\" type=\"").f(ctx.get(["format"], false), ctx, "h").w("\" title=\"").f(ctx.get(["formatDescription"], false), ctx, "h").w("\" target=\"_blank\">").f(ctx.get(["formatDescription"], false), ctx, "h", ["s"]).w("</a></li>"); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-results'] = function () { dust.register(ctlProto.CLASS + '-results', body_0); function body_0(chk, ctx) { return chk.s(ctx.get(["servicesFound"], false), ctx, { "else": body_1, "block": body_2 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li class=\"tc-ctl-lcat-no-results\"><h5>").h("i18n", ctx, {}, { "$key": "noMatches" }).w("</h5></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.h("gt", ctx, { "block": body_3 }, { "key": ctx.get(["servicesLooked"], false), "value": 1 }).s(ctx.get(["founds"], false), ctx, { "block": body_5 }, {}).h("gt", ctx, { "block": body_8 }, { "key": ctx.get(["servicesLooked"], false), "value": 1 }); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<li class=\"tc-ctl-lcat-search-group ").x(ctx.getPath(false, ["service", "isCollapsed"]), ctx, { "block": body_4 }, {}).w("\" data-tc-service-index=\"").f(ctx.getPath(false, ["service", "index"]), ctx, "h").w("\"><h5>").f(ctx.getPath(false, ["service", "title"]), ctx, "h").w("</h5><ul>"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("tc-collapsed"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.w("<li data-tc-layer-name=\"").f(ctx.get(["Name"], false), ctx, "h").w("\" ").x(ctx.get(["alreadyAdded"], false), ctx, { "else": body_6, "block": body_7 }, {}).w("><h5 class=\"tc-selectable\">").f(ctx.get(["Title"], false), ctx, "h").w("</h5><button class=\"tc-ctl-lcat-search-btn-info\" title=\"").h("i18n", ctx, {}, { "$key": "infoFromThisLayer" }).w("\"></button></li>"); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w(" data-tooltip=\"").h("i18n", ctx, {}, { "$key": "clickToAddToMap" }).w("\" "); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(" data-tooltip=\"").h("i18n", ctx, {}, { "$key": "layerAlreadyAdded" }).w("\" class=\"tc-checked\" "); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("</ul></li>"); } body_8.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-lcat-crs-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "changeCRS" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><p>").h("i18n", ctx, {}, { "$key": "wmsLayerNotCompatible.instructions|h" }).w("</p><ul class=\"tc-ctl-lcat-crs-list tc-crs-list\"></ul></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }



    var _dataKeys = {
        LAYER: 'tcLayer',
        LAYERNAME: 'tcLayerName',
        LAYERINFO: 'tcLayerInfo',
        SERVICEINDEX: 'tcServiceIndex',
        PROJCODE: 'tcProjCode'
    };

    const showProjectionChangeDialog = function (ctl, layer) {
        ctl.showProjectionChangeDialog({
            layer: layer,
            closeCallback: function () {
                ctl.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.LOADING);
                    node.querySelector('span').setAttribute(TOOLTIP_DATA_ATTR, ctl.getLocaleString('clickToAddToMap'));
                });
            }
        });
    };

    var SEARCH_MIN_LENGTH = 3;

    var TOOLTIP_DATA_ATTR = 'data-tooltip';

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.ProjectionSelector.prototype.register.call(self, map);

        const load = function (resolve, reject) {
            if ($.isArray(self.options.layers)) {
                for (var i = 0; i < self.options.layers.length; i++) {
                    var layer = self.options.layers[i];
                    if (!layer.type || layer.type === TC.Consts.layerType.WMS) {
                        if (!layer.id) {
                            layer.id = TC.getUID();
                        }
                        if ($.isPlainObject(layer)) {
                            layer = new TC.layer.Raster(layer);
                        }                        
                        self.layers.push(layer);
                    }
                }
                self.render(function () {
                    resolve();
                });
            }
            else {
                resolve();
            }
        };

        self._readyPromise = new Promise(function (resolve, reject) {
            const waitLoad = function (e) {
                if (e.layer === map.baseLayer) {
                    load(resolve, reject);
                    map.off(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            };

            map.loaded(function () {
                if (!map.baseLayer.state || map.baseLayer.state === TC.Layer.state.IDLE) {
                    load(resolve, reject);
                }
                else {
                    map.on(TC.Consts.event.LAYERUPDATE, waitLoad);
                }
            });
        });

        const findResultNodes = function (layer) {
            const result = [];
            if (!layer.isBase) {
                var url = layer.options.url;
                if (self.list) {
                    self.list.querySelectorAll('li').forEach(function (li) {
                        const $li = $(li);
                        var lyr = $li.data(_dataKeys.LAYER);
                        if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                            for (var i = 0; i < layer.names.length; i++) {
                                if (li.dataset.tcLayerName === layer.names[i]) {
                                    result.push(li);
                                }
                            }
                        }
                    });
                }
            }
            return result;
        };

        var _refreshResultList = function () {
            if ("createEvent" in document) {
                var evt = document.createEvent('HTMLEvents');
                evt.initEvent("keyup", false, true);
                if (self.textInput) {
                    self.textInput.dispatchEvent(evt);
                }
            }
            else {
                if (self.textInput) {
                    self.textInput.fireEvent("keyup");
                }
            }
        };

        /**
         * Marca todas las capas del TOC como añadidas excepto la que se está borrando que se recibe como parámetro.
         */
        const _markWorkLayersAsAdded = function (layerRemoved) {
            var wlCtrl = self.map.getControlsByClass(TC.control.WorkLayerManager)[0];
            if (wlCtrl) {
                var layers = wlCtrl.layers;

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];

                    if (layer !== layerRemoved) {
                        self.getLayerNodes(layer).forEach(function (node) {
                            node.classList.add(TC.Consts.classes.CHECKED);
                            node.querySelector('span').setAttribute(TOOLTIP_DATA_ATTR, layerAddedText);
                        });
                    }
                }
            }
        };

        var layerAddedText = self.getLocaleString('layerAlreadyAdded');
        var clickToAddText = self.getLocaleString('clickToAddToMap');

        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' + TC.Consts.event.BEFOREUPDATEPARAMS, function (e) {
                self.getLayerNodes(e.layer).forEach(function (node) {
                    node.classList.add(TC.Consts.classes.LOADING);
                    node.querySelector('span').removeAttribute(TOOLTIP_DATA_ATTR);
                });
            })
            .on(TC.Consts.event.LAYERADD + ' ' + TC.Consts.event.UPDATEPARAMS, function (e) {
                const layer = e.layer;
                if (!layer.isBase && layer.type === TC.Consts.layerType.WMS) {
                    self.loaded().then(function () { // Esperamos a que cargue primero las capas de la configuración
                        const updateControl = function () {
                            self.getLayerNodes(layer).forEach(function (node) {
                                node.classList.remove(TC.Consts.classes.LOADING);
                                node.classList.add(TC.Consts.classes.CHECKED);
                                node.querySelector('span').setAttribute(TOOLTIP_DATA_ATTR, layerAddedText);
                            });
                            _refreshResultList();
                        };
                        if (self.getLayerRootNode(layer)) {
                            updateControl();
                        }
                        else {
                            // la capa no está renderizada, pero podría estar en proceso, comprobamos que no está en la lista de capas del control
                            var layerAlreadyAdded = false;
                            for (var i = 0, len = self.layers.length; i < len; i++) {
                                var lyr = self.layers[i];
                                if (lyr.type === layer.type && lyr.options.url === layer.options.url) {
                                    layerAlreadyAdded = true;
                                    break;
                                }
                            }
                            if (!layerAlreadyAdded) {
                                self.addLayer(new TC.layer.Raster({
                                    url: layer.options.url,
                                    type: layer.type,
                                    layerNames: [],
                                    title: layer.title || layer.wrap.getServiceTitle(),
                                    hideTitle: true,
                                    hideTree: false
                                })).then(function () {
                                    updateControl();
                                });
                            }
                        }
                    });
                }
            })
            .on(TC.Consts.event.LAYERERROR, function (e) {
                const reason = e.reason;
                if (reason) {
                    TC.alert(self.getLocaleString(reason, { url: e.layer.url }));
                }
                self.getLayerNodes(e.layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.LOADING);
                });
            })
            .on(TC.Consts.event.LAYERREMOVE, function (e) {
                const layer = e.layer;
                self.getLayerNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.querySelector('span').setAttribute(TOOLTIP_DATA_ATTR, clickToAddText);
                });
                findResultNodes(layer).forEach(function (node) {
                    node.classList.remove(TC.Consts.classes.CHECKED);
                    node.setAttribute(TOOLTIP_DATA_ATTR, clickToAddText);
                });

                //Marcamos como añadidas aquellas capas que estén en el control de capas cargadas. Esto previene que si borramos una capa padre, todas
                //sus hijas aparezcan como no añadidas, a pesar que que alguna de ellas haya sido añadida previamente de manera individual
                _markWorkLayersAsAdded(layer);

                //refresh del searchList            
                _refreshResultList();
            })
            .on(TC.Consts.event.EXTERNALSERVICEADDED, function (e) {
                if (e && e.layer) {
                    self.addLayer(e.layer);
                    self.div.classList.remove(TC.Consts.classes.COLLAPSED);
                }
            })
            .on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                self.update();
            });

        return result;
    };

    const onCollapseButtonClick = function (e) {
        e.target.blur();
        e.stopPropagation();
        const li = e.target.parentElement;
        if (li.tagName === 'LI' && !li.classList.contains(self.CLASS + '-leaf')) {
            if (li.classList.contains(TC.Consts.classes.COLLAPSED)) {
                li.classList.remove(TC.Consts.classes.COLLAPSED);
            }
            else {
                li.classList.add(TC.Consts.classes.COLLAPSED);
            }
            const ul = li.querySelector('ul');
            if (ul.classList.contains(TC.Consts.classes.COLLAPSED)) {
                ul.classList.remove(TC.Consts.classes.COLLAPSED);
            }
            else {
                ul.classList.add(TC.Consts.classes.COLLAPSED);
            }
        }
    };

    const onSpanClick = function (e, ctl) {
        const li = e.target.parentNode;
        if (!li.classList.contains(TC.Consts.classes.LOADING) && !li.classList.contains(TC.Consts.classes.CHECKED)) {
            e.preventDefault;

            var layerName = $(li).data(_dataKeys.LAYERNAME);
            layerName = (layerName !== undefined) ? layerName.toString() : '';
            var layer;
            for (var i = 0, len = ctl._roots.length; i < len; i++) {
                const root = ctl._roots[i];
                if (root.contains(li)) {
                    layer = $(root).data(_dataKeys.LAYER);
                    break;
                }
            }
            if (!layer) {
                layer = $(li).data(_dataKeys.LAYER);
            }
            if (layer && layerName) {
                var redrawTime = 1;

                if (/iPad/i.test(navigator.userAgent))
                    redrawTime = 10;
                else if (TC.Util.detectFirefox())
                    redrawTime = 250;

                if (!layer.title) {
                    layer.title = layer.getTree().title;
                }

                li.classList.add(TC.Consts.classes.LOADING);
                li.querySelector('span').setAttribute(TOOLTIP_DATA_ATTR, '');

                const reDraw = function (element) {
                    return new Promise(function (resolve, reject) {
                        setTimeout(function () {
                            element.offsetHeight = element.offsetHeight;
                            element.offsetWidth = element.offsetWidth;

                            resolve();
                        }, redrawTime);
                    });
                };

                reDraw(li).then(function () {
                    ctl.addLayerToMap(layer, layerName);
                });
                e.stopPropagation();
            }
        }
    };


    ctlProto.render = function (callback) {
        const self = this;

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            const promises = $.map(self.layers, function (layer) {
                return layer.wrap.getLayer();
            });

            Promise.all(promises).then(function () {

                var layerTrees = $.map(self.layers, function (layer) {
                    var result = layer.getTree();
                    var makeNodeVisible = function makeNodeVisible(node) {
                        var result = false;
                        var childrenVisible = false;
                        for (var i = 0; i < node.children.length; i++) {
                            if (makeNodeVisible(node.children[i])) {
                                childrenVisible = true;
                            }
                        }
                        if (node.hasOwnProperty('isVisible')) {
                            node.isVisible = (!layer.names || !layer.names.length) || childrenVisible || node.isVisible;
                        }
                        return node.isVisible;
                    };
                    makeNodeVisible(result);
                    return result;
                });

                self.renderData({ layerTrees: layerTrees, enableSearch: self.options.enableSearch }, function () {

                    const addedLayerText = self.getLocaleString('layerAlreadyAdded');

                    self.div.querySelectorAll('li > button.' + self.CLASS + '-collapse-btn').forEach(function (btn) {
                        btn.addEventListener('click', onCollapseButtonClick);
                    });

                    self.div.querySelectorAll('span').forEach(function (span) {
                        span.addEventListener('click', function (e) {
                            onSpanClick(e, self);
                        });
                    })


                    self._roots = self.div.querySelectorAll(self._selectors.LAYER_ROOT);
                    self._roots.forEach(function (root, idx) {
                        var layer = self.layers[idx];
                        $(root).data(_dataKeys.LAYER, layer);

                        var formatDescriptions = {};
                        root.querySelectorAll('.' + self.CLASS + '-btn-info').forEach(function (a) {
                            const span = a.parentElement.querySelector('span');
                            const name = $(a.parentElement).data(_dataKeys.LAYERNAME).toString();
                            if (name) {
                                span.classList.add(TC.Consts.classes.SELECTABLE);
                                var info = layer.wrap.getInfo(name);
                                if (!info.hasOwnProperty('abstract') && !info.hasOwnProperty('legend') && !info.hasOwnProperty('metadata')) {
                                    a.parentElement.removeChild(a);
                                }
                                else {
                                    if (info.metadata) {
                                        for (var j = 0, len = info.metadata.length; j < len; j++) {
                                            var md = info.metadata[j];
                                            md.formatDescription = formatDescriptions[md.format] =
                                                formatDescriptions[md.format] ||
                                                self.getLocaleString(TC.Util.getSimpleMimeType(md.format)) ||
                                                self.getLocaleString('viewMetadata');
                                        }
                                    }
                                    $(a).data(_dataKeys.LAYERINFO, info);
                                    a.addEventListener(TC.Consts.event.CLICK, function (e) {
                                        e.stopPropagation();
                                        const elm = this;
                                        if (!elm.classList.contains(TC.Consts.classes.CHECKED)) {
                                            self.showLayerInfo(layer, name);
                                            elm.classList.add(TC.Consts.classes.CHECKED);

                                        } else {
                                            elm.classList.remove(TC.Consts.classes.CHECKED);
                                            self.hideLayerInfo();
                                        }
                                    });
                                }
                                if (layer.compatibleLayers && layer.compatibleLayers.indexOf(name) < 0) {
                                    span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                                    span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                                    //console.log("capa " + name + " incompatible");
                                }
                                if (self.map) {
                                    for (var j = 0, len = self.map.workLayers.length; j < len; j++) {
                                        var wl = self.map.workLayers[j];
                                        if (wl.type === TC.Consts.layerType.WMS && wl.url === layer.url && wl.names.length === 1 && wl.names[0] === name) {
                                            span.parentElement.classList.add(TC.Consts.classes.CHECKED);
                                            span.setAttribute(TOOLTIP_DATA_ATTR, addedLayerText);
                                        }
                                    }
                                }
                            }
                            else {
                                span.setAttribute(TOOLTIP_DATA_ATTR, '');
                                a.parentElement.removeChild(a);
                            }
                        });
                    });

                    self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
                        self._dialogDiv.innerHTML = html;
                    });

                    self.textInput = self.div.querySelector("." + self.CLASS + "-input");
                    self.list = self.div.querySelector("." + self.CLASS + "-search ul");
                    // Clear results list when x button is pressed in the search input
                    self.textInput.addEventListener('mouseup', function (e) {
                        var oldValue = self.textInput.value;

                        if (oldValue === '') {
                            return;
                        }

                        // When this event is fired after clicking on the clear button
                        // the value is not cleared yet. We have to wait for it.
                        setTimeout(function () {
                            var newValue = self.textInput.value;

                            if (newValue === '') {
                                self.list.innerHTML = '';
                            }
                        }, 1);
                    });

                    var layerCheckedList = [];
                    //Definir el autocomplete del buscador de capas por texto
                    TC._search = TC._search || {};
                    TC._search.retryTimeout = null;

                    TC.loadJS(
                        !TC.UI || !TC.UI.autocomplete,
                        [TC.apiLocation + 'TC/ui/autocomplete.js'],
                        function () {
                            TC.UI.autocomplete.call(self.textInput, {
                                link: '#',
                                target: self.list,
                                minLength: 0,
                                source: function (text, callback) {
                                    //lista de capas marcadas
                                    layerCheckedList = [];
                                    self._roots.forEach(function (root) {
                                        root.querySelectorAll("li." + TC.Consts.classes.CHECKED).forEach(function (item) {
                                            layerCheckedList.push($(item).data(_dataKeys.LAYERNAME).toString());
                                        });
                                    });

                                    //con texto vacío, limpiar  y ocultar la lista de resultados
                                    text = text.trim();
                                    if (text.length < SEARCH_MIN_LENGTH) {
                                        self.list.innerHTML = '';
                                    }
                                    else if (text.length >= SEARCH_MIN_LENGTH) {
                                        if (TC._search.retryTimeout)
                                            clearTimeout(TC._search.retryTimeout);
                                        TC._search.retryTimeout = setTimeout(function () {
                                            var results = [];
                                            for (var index = 0; index < self.layers.length; index++) {
                                                var _founds = self.layers[index].searchSubLayers(text);
                                                if (_founds.length) {
                                                    results.push({
                                                        service: {
                                                            index: index,
                                                            title: self.layers[index].title || self.layers[index].id
                                                        },
                                                        founds: _founds
                                                    });
                                                }
                                            }
                                            callback({ servicesFound: results, servicesLooked: self.layers.length });
                                        }, TC._search.interval);
                                    }
                                },
                                callback: function (e) {
                                    self.textInput.value = e.target.text || e.target.innerText;
                                    TC._search.lastPattern = self.textInput.value;
                                    self.goToResult(unescape(e.target.hash).substring(1));
                                    TC.UI.autocomplete.call(self.textInput, 'clear');
                                },
                                buildHTML: function (data) {
                                    //si hay resultados, mostramos la lista
                                    if (data.results && data.results.servicesFound.length > 0) {
                                        var workLayers = self.map.getLayerTree().workLayers;
                                        for (var k = 0; k < data.results.servicesFound.length; k++) {
                                            var founds = data.results.servicesFound[k].founds;
                                            for (var j = 0; j < founds.length; j++) {
                                                delete founds[j].alreadyAdded;
                                                for (var i = 0; i < workLayers.length; i++) {
                                                    //if (workLayers[i].title == data.results[j].Title ) {
                                                    if (layerCheckedList.indexOf(founds[j].Name) >= 0) {
                                                        founds[j].alreadyAdded = true;
                                                        break;
                                                    }
                                                }
                                                //Si la capa no tiene Name, no se puede añadir al TOC
                                                if (!founds[j].Name) {
                                                    founds.splice(j, 1);
                                                    j--;
                                                }
                                            }
                                            if (!data.results.servicesFound[k].founds.length) {
                                                data.results.servicesFound.splice(k, 1);
                                                continue;
                                            }
                                            //si estaba collapsado mantenemos el estado
                                            if (self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k]) {
                                                data.results.servicesFound[k].service.isCollapsed = self.div.querySelectorAll(".tc-ctl-lcat-search-group")[k].classList.contains(TC.Consts.classes.COLLAPSED);
                                            }
                                        }
                                    }
                                    var ret = '';
                                    dust.render(self.CLASS + '-results', data.results, function (err, out) {
                                        ret = out;
                                    });
                                    return ret;
                                }
                            });
                        });


                    if (!self.searchInit) {
                        //botón de la lupa para alternar entre búsqueda y árbol
                        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2 button', function (e) {
                            const wasCollapsed = self.div.classList.contains(TC.Consts.classes.COLLAPSED);
                            self.div.classList.remove(TC.Consts.classes.COLLAPSED);

                            const searchPane = self.div.querySelector('.' + self.CLASS + '-search');
                            const treePane = self.div.querySelector('.' + self.CLASS + '-tree');
                            const infoPane = self.div.querySelector('.' + self.CLASS + '-info');

                            if (searchPane.classList.contains(TC.Consts.classes.HIDDEN) || wasCollapsed) {
                                searchPane.classList.remove(TC.Consts.classes.HIDDEN);
                                treePane.classList.add(TC.Consts.classes.HIDDEN);
                                self.textInput.focus();
                                e.target.classList.add(self.CLASS + '-btn-tree');
                                e.target.setAttribute('title', self.getLocaleString('viewAvailableLayersTree'));
                                e.target.classList.remove(self.CLASS + '-btn-search');

                                //Si no hay resultados resaltados en el buscador, ocultamos el panel de info
                                const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-search li button.tc-checked').length;
                                if (selectedCount === 0) {
                                    infoPane.classList.add(TC.Consts.classes.HIDDEN);
                                }
                            }
                            else {
                                searchPane.classList.add(TC.Consts.classes.HIDDEN);
                                treePane.classList.remove(TC.Consts.classes.HIDDEN);
                                e.target.classList.add(self.CLASS + '-btn-search');
                                e.target.setAttribute('title', self.getLocaleString('searchLayersByText'));
                                e.target.classList.remove(self.CLASS + '-btn-tree');

                                //Si hay resaltados en el árbol, mostramos el panel de info
                                const selectedCount = self.div.querySelectorAll('.tc-ctl-lcat-tree li button.tc-checked').length;
                                if (selectedCount > 0) {
                                    infoPane.classList.remove(TC.Consts.classes.HIDDEN);
                                }
                            }
                        }));


                        //evento de expandir nodo de info
                        //self._$div.off("click", ".tc-ctl-lcat-search button");                        
                        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("." + self.CLASS + "-search button." + self.CLASS + "-search-btn-info", function (evt) {
                            evt.stopPropagation();
                            const target = evt.target;
                            if (!target.classList.contains(TC.Consts.classes.CHECKED)) {
                                const li = target.parentElement;
                                var parent = li;
                                do {
                                    parent = parent.parentElement;
                                }
                                while (parent && parent.tagName !== 'LI');
                                self.showLayerInfo(self.layers.length > 1 ? self.layers[$(parent).data(_dataKeys.SERVICEINDEX)] : self.layers[0], $(li).data(_dataKeys.LAYERNAME));
                                target.classList.add(TC.Consts.classes.CHECKED);

                            } else {
                                target.classList.remove(TC.Consts.classes.CHECKED);
                                self.hideLayerInfo();
                            }
                        }));

                        //click en un resultado - añadir capa
                        const searchListElementSelector = '.' + self.CLASS + ' li';
                        self.div.addEventListener('click', TC.EventTarget.listenerBySelector(searchListElementSelector, function (evt) {
                            evt.stopPropagation();
                            var li = evt.target;
                            while (li && !li.matches(searchListElementSelector)) {
                                li = li.parentElement;
                            }
                            if (li.classList.contains(self.CLASS + '-no-results')) {
                                return; //si clicko en el li de "no hay resultados" rompo el ciclo de ejecución
                            }
                            if (li.classList.contains(self.CLASS + '-search-group')) {
                                if (li.classList.contains(TC.Consts.classes.COLLAPSED)) {
                                    li.classList.remove(TC.Consts.classes.COLLAPSED);
                                }
                                else {
                                    li.classList.add(TC.Consts.classes.COLLAPSED);
                                }
                                return;
                            }
                            var layerName = $(li).data(_dataKeys.LAYERNAME);
                            if (!layerName) {
                                return;
                            }
                            layerName = layerName.toString();

                            //si la capa ya ha sido anteriormente, no la añadimos y mostramos un mensaje
                            if (li.classList.contains(TC.Consts.classes.CHECKED)) {
                                return;
                            } else {
                                var liParent = li;
                                do {
                                    liParent = liParent.parentElement;
                                }
                                while (liParent && !liParent.matches('li.' + self.CLASS + '-search-group'));

                                const layerIdx = (!liParent ? 0 : $(liParent).data(_dataKeys.SERVICEINDEX));
                                const url = self.layers[layerIdx].options.url;
                                const title = self.layers[layerIdx].title;

                                const layer = new TC.layer.Raster({
                                    id: self.getUID(),
                                    url: url,
                                    title: title,
                                    hideTitle: self.layers[layerIdx].hideTitle || self.layers[layerIdx].options.hideTitle,
                                    hideTree: false,
                                    layerNames: [layerName]
                                });
                                if (layer.isCompatible(self.map.crs)) {
                                    self.map.addLayer(layer, function (layer) {
                                        $(li).data(_dataKeys.LAYER, layer);
                                        layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                                            var layer = this.parent;
                                            if (event.error.code === 401 || event.error.code === 403)
                                                layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                                            layer.map.removeLayer(layer);
                                        });
                                    });
                                    //marcamos el resultado como añadido
                                    li.classList.add(TC.Consts.classes.CHECKED);
                                    li.setAttribute(TOOLTIP_DATA_ATTR, addedLayerText);
                                }
                                else {
                                    showProjectionChangeDialog(self, layer);
                                }
                            }
                        }));

                        self.searchInit = true;
                    }

                    if ($.isFunction(callback)) {
                        callback();
                    }
                }).then(function () {
                    resolve();
                }).catch(function (err) {
                    reject(err);
                })
            });
        }));
    };

    ctlProto.getLayerRootNode = function (layer) {
        const self = this;
        var result = null;
        if (!layer.isBase) {
            var url = layer.options.url;
            if (self._roots) {
                self._roots.forEach(function (li) {
                    var lyr = $(li).data(_dataKeys.LAYER);
                    if (lyr && lyr.type === layer.type && lyr.options.url === url) {
                        result = li;
                    }
                });
            }
        }
        return result;
    };

    ctlProto.getLayerNodes = function (layer) {
        const self = this;
        const result = [];
        const rootNode = self.getLayerRootNode(layer);
        if (rootNode) {
            for (var i = 0; i < layer.names.length; i++) {
                const liLayer = rootNode.querySelector('li[data-tc-layer-name="' + layer.names[i] + '"]');
                if (!liLayer) {
                    continue;
                }
                result[result.length] = liLayer;
                liLayer.querySelectorAll('li').forEach(function (li) {
                    result[result.length] = li;
                });
            }
        }
        return result;
    };

    ctlProto.showLayerInfo = function (layer, name) {
        const self = this;
        var result = null;

        var info = self.div.querySelector('.' + self.CLASS + '-info');

        const toggleInfo = function (layerName, infoObj) {
            var result = false;
            var lName = $(info).data(_dataKeys.LAYERNAME);
            //if (lName !== undefined && lName.toString() === layerName) {
            //    $info.data(_dataKeys.LAYERNAME, '');
            //    $info.removeClass(TC.Consts.classes.HIDDEN);
            //}
            //else {
            if (infoObj) {
                result = true;
                $(info).data(_dataKeys.LAYERNAME, layerName);
                info.classList.remove(TC.Consts.classes.HIDDEN);
                dust.render(self.CLASS + '-info', infoObj, function (err, out) {
                    info.innerHTML = out;
                    if (err) {
                        TC.error(err);
                    }
                    info.querySelector('.' + self.CLASS + '-info-close').addEventListener(TC.Consts.event.CLICK, function () {
                        self.hideLayerInfo();
                    });
                });
            }
            //}
            return result;
        };

        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });

        for (var i = 0, ii = self._roots.length; i < ii; i++) {
            const root = self._roots[i];
            if ($(root).data(_dataKeys.LAYER) === layer) {
                const as = root.querySelectorAll('.' + self.CLASS + '-btn-info');
                for (var j = 0, jj = as.length; j < jj; j++) {
                    const a = as[j];
                    var n = $(a.parentElement).data(_dataKeys.LAYERNAME).toString();
                    if (n === name) {
                        const info = $(a).data(_dataKeys.LAYERINFO);
                        const checked = toggleInfo(n, info);
                        const infoBtn = self.div.querySelector('li [data-tc-layer-name="' + n + '"] > button.' + self.CLASS + '-btn-info');
                        if (toggleInfo(n, info)) {
                            infoBtn.classList.add(TC.Consts.classes.CHECKED);
                        }
                        else {
                            infoBtn.classList.remove(TC.Consts.classes.CHECKED);
                        }
                        result = info;
                        break;
                    }
                }
                break;
            }
        }

        return result;
    };

    ctlProto.update = function () {
        const self = this;
        self.layers.forEach(function (layer) {
            layer.getCapabilitiesPromise().then(function () {
                layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);

                const rootNode = self.getLayerRootNode(layer);
                if (rootNode) {
                    rootNode
                        .querySelectorAll('li[data-tc-layer-name]')
                        .forEach(function (li) {
                            const name = $(li).data(_dataKeys.LAYERNAME);
                            const span = li.querySelector('span.' + TC.Consts.classes.SELECTABLE);
                            if (layer.compatibleLayers.indexOf(name) < 0) {
                                span.classList.add(TC.Consts.classes.INCOMPATIBLE);
                                span.setAttribute('title', self.getLocaleString('reprojectionNeeded'));
                            }
                            else {
                                span.classList.remove(TC.Consts.classes.INCOMPATIBLE)
                                span.removeAttribute('title');
                            }
                        });
                }
            });
        });
    };

    ctlProto.hideLayerInfo = function () {
        var self = this;
        self.div.querySelectorAll('.' + self.CLASS + '-btn-info, .' + self.CLASS + '-search-btn-info').forEach(function (btn) {
            btn.classList.remove(TC.Consts.classes.CHECKED);
        });
        self.div.querySelector('.' + self.CLASS + '-info').classList.add(TC.Consts.classes.HIDDEN);
    };

    ctlProto.addLayer = function (layer) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var fromLayerCatalog = [];

            if (self.options.layers && self.options.layers.length) {
                fromLayerCatalog = $.grep(self.options.layers, function (l) {
                    var getMap = TC.Util.reqGetMapOnCapabilities(l.url);
                    return getMap && getMap.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });
            }

            if (fromLayerCatalog.length == 0)
                fromLayerCatalog = $.grep(self.layers, function (l) {
                    return l.url.replace(TC.Util.regex.PROTOCOL) == layer.url.replace(TC.Util.regex.PROTOCOL);
                });

            if (fromLayerCatalog.length == 0) {
                self.layers.push(layer);
                layer.getCapabilitiesPromise().then(function () {
                    layer.compatibleLayers = layer.wrap.getCompatibleLayers(self.map.crs);
                    layer.title = layer.title || layer.wrap.getServiceTitle();
                    self.render(function () {
                        resolve(); //ver linea 55 y por ahí
                    });
                });
            } else { resolve(); }
        });
    };

    ctlProto.addLayerToMap = function (layer, layerName) {
        const self = this;
        const layerOptions = $.extend({}, layer.options);
        layerOptions.id = self.getUID();
        layerOptions.layerNames = [layerName];
        layerOptions.title = layer.title;
        const newLayer = new TC.layer.Raster(layerOptions);
        if (newLayer.isCompatible(self.map.crs)) {
            self.map.addLayer(layerOptions).then(function (layer) {
                layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {
                    var layer = this.parent;
                    if (event.error.code === 401 || event.error.code === 403)
                        layer.map.toast(event.error.text, { type: TC.Consts.msgType.ERROR });
                    layer.map.removeLayer(layer);
                });
            });
        }
        else {
            showProjectionChangeDialog(self, newLayer);
        }
    };

    ctlProto.loaded = function () {
        return this._readyPromise;
    };

    ctlProto.getAvailableCRS = function (options) {
        const self = this;
        options = options || {};
        return self.map.getCompatibleCRS({
            layers: self.map.workLayers.concat(self.map.baseLayer, options.layer),
            includeFallbacks: true
        });
    };

    ctlProto.setProjection = function (options) {
        const self = this;
        options = options || {};

        TC.loadProjDef({
            crs: options.crs,
            callback: function () {
                self.map.setProjection(options).then(function () {
                    if (self._layerToAdd) {
                        self.map.addLayer(self._layerToAdd);
                    }
                    TC.Util.closeModal();
                });
            }
        });
    };

    ctlProto.showProjectionChangeDialog = function (options) {
        const self = this;
        self._layerToAdd = options.layer;
        TC.control.ProjectionSelector.prototype.showProjectionChangeDialog.call(self, options);
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.MapContents) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapContents');
}

TC.control.Legend = function () {
    TC.control.MapContents.apply(this, arguments);
};

TC.inherit(TC.control.Legend, TC.control.MapContents);

(function () {
    var ctlProto = TC.control.Legend.prototype;

    ctlProto.CLASS = 'tc-ctl-legend';

    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Legend.html";
        ctlProto.template[ctlProto.CLASS + '-node'] = TC.apiLocation + "TC/templates/LegendNode.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "legend" }).w("</h2><div class=\"tc-ctl-legend-tree\"><ul class=\"tc-ctl-legend-branch\">").s(ctx.get(["workLayers"], false), ctx, { "else": body_1, "block": body_2 }, {}).w("</ul></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li class=\"tc-ctl-legend-empty\">").h("i18n", ctx, {}, { "$key": "noData" }).w("</li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.p("tc-ctl-legend-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_2.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-node'] = function () { dust.register(ctlProto.CLASS + '-node', body_0); function body_0(chk, ctx) { return chk.x(ctx.get(["customLegend"], false), ctx, { "else": body_1, "block": body_11 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<li ").x(ctx.get(["children"], false), ctx, { "else": body_2, "block": body_3 }, {}).w(" data-tc-layer-name=\"").f(ctx.get(["name"], false), ctx, "h").w("\" data-tc-layer-uid=\"").f(ctx.get(["uid"], false), ctx, "h").w("\"><div class=\"tc-ctl-legend-title\">").f(ctx.get(["title"], false), ctx, "h").w("</div>").x(ctx.get(["legend"], false), ctx, { "block": body_4 }, {}).w("<ul class=\"tc-ctl-legend-branch\">").s(ctx.get(["children"], false), ctx, { "block": body_10 }, {}).w("</ul></li>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("class=\"tc-ctl-legend-node tc-ctl-legend-leaf\" "); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("class=\"tc-ctl-legend-node\" "); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<div class=\"tc-ctl-legend-watch\">").x(ctx.getPath(false, ["legend", "src"]), ctx, { "else": body_5, "block": body_8 }, {}).w("</div><div class=\"tc-ctl-legend-nvr\">").h("i18n", ctx, {}, { "$key": "notVisibleAtCurrentResolution" }).w("</div>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_6 }, {}); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<div class=\"tc-ctl-legend-img\" style=\"border:solid ").f(ctx.getPath(false, ["legend", "strokeWidth"]), ctx, "h").w("px ").f(ctx.getPath(false, ["legend", "strokeColor"]), ctx, "h").w(";background-color:").f(ctx.getPath(false, ["legend", "fillColor"]), ctx, "h").x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_7 }, {}).w("\"></div>"); } body_6.__dustBody = !0; function body_7(chk, ctx) { return chk.w(";width:").f(ctx.getPath(false, ["legend", "width"]), ctx, "h").w("px;height:").f(ctx.getPath(false, ["legend", "height"]), ctx, "h").w("px;border-radius:50%"); } body_7.__dustBody = !0; function body_8(chk, ctx) { return chk.w("<img src=\"\" data-tc-img=\"").f(ctx.getPath(false, ["legend", "src"]), ctx, "h").w("\" ").x(ctx.getPath(false, ["legend", "width"]), ctx, { "block": body_9 }, {}).w(" />"); } body_8.__dustBody = !0; function body_9(chk, ctx) { return chk.w("style=\"width:").f(ctx.getPath(false, ["legend", "width"]), ctx, "h").w("px;height:").f(ctx.getPath(false, ["legend", "height"]), ctx, "h").w("px;\" "); } body_9.__dustBody = !0; function body_10(chk, ctx) { return chk.p("tc-ctl-legend-node", ctx, ctx.rebase(ctx.getPath(true, [])), {}); } body_10.__dustBody = !0; function body_11(chk, ctx) { return chk.f(ctx.get(["customLegend"], false), ctx, "h", ["s"]); } body_11.__dustBody = !0; return body_0 };
    }

    var _dataKeys = {
        layer: 'tcLayer',
        layerUid: 'tcLayerUid'
    };

    ctlProto.register = function (map) {
        const self = this;

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            const view = e.view;
            const onLayerAdd = self.loadGraphics.bind(self);

            if (view === TC.Consts.view.THREED) {                
                map.on(TC.Consts.event.LAYERADD, onLayerAdd);
            } else if (view === TC.Consts.view.DEFAULT) {
                map.off(TC.Consts.event.LAYERADD, onLayerAdd);
            }
        });

        return TC.control.MapContents.prototype.register.call(self, map);
    };

    ctlProto.loadGraphics = function () {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);
            if (layer) {
                li.querySelectorAll('li.' + self.CLASS + '-node-visible').forEach(function (l) {
                    const img = l.querySelector('img');
                    if (img && img.getAttribute('src') !== undefined && img.getAttribute('src').length === 0) {
                        self.styleLegendImage(img, layer);
                    }
                });
            }
        });
    };

    ctlProto.updateScale = function () {
        var self = this;
        var inScale = self.CLASS + '-node-inscale';
        var outOfScale = self.CLASS + '-node-outofscale';

        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);

            if (layer) {
                var layersInScale = false;
                li.querySelectorAll('li').forEach(function (l) {
                    if (l.classList.contains(self.CLASS + '-node-visible')) {
                        var uid = $(l).data(_dataKeys.layerUid);
                        if (layer.isVisibleByScale((uid))) {
                            layersInScale = true;
                            l.classList.remove(outOfScale);
                            l.classList.add(inScale);
                            const img = l.querySelector('img');
                            if (img) {
                                self.styleLegendImage(img, layer);
                            }
                        }
                        else {
                            l.classList.add(outOfScale);
                            l.classList.remove(inScale);
                        }
                    }
                });
                if (layersInScale) {
                    li.classList.remove(outOfScale);
                    li.classList.add(inScale);
                }
                else {
                    li.classList.remove(inScale);
                    li.classList.add(outOfScale);
                }
            }
        });
    };

    ctlProto.update = function () {
        var self = this;

        self.getLayerUIElements().forEach(function (li) {
            var layer = $(li).data(_dataKeys.layer);
            if (layer) {
                layer.getTree();

                li.querySelectorAll('li').forEach(function (l) {
                    var uid = $(l).data(_dataKeys.layerUid);
                    var visible = self.CLASS + '-node-visible';
                    var notVisible = self.CLASS + '-node-notvisible';
                    var hasVisible = self.CLASS + '-node-hasvisible';

                    switch (layer._cache.visibilityStates[uid]) {
                        case TC.Consts.visibility.NOT_VISIBLE:
                            l.classList.remove(visible);
                            l.classList.remove(hasVisible);
                            l.classList.add(notVisible);                            
                            break;
                        case TC.Consts.visibility.HAS_VISIBLE:
                            l.classList.remove(visible);
                            l.classList.remove(notVisible);
                            l.classList.add(hasVisible);                            
                            break;
                        default:
                            // visible
                            l.classList.remove(notVisible);
                            l.classList.remove(hasVisible);
                            l.classList.add(visible);                            
                            break;
                    }
                });

                self.updateLayerVisibility(layer);
            }
        });
        self.updateScale();
    };

    ctlProto.updateLayerTree = function (layer) {
        var self = this;        

        if (!layer.isBase && !layer.options.stealth) {
            
            //// 09/04/2019 GLS: ignoramos el atributo que venga en la capa porque en la leyenda queremos que el árbol se muestre siempre y 
            //// nos ahorramos el tener que pasarlo en el estado del mapa
            if (layer.hideTree || layer.options.hideTree) {
                layer.tree = null;
                layer.hideTree = layer.options.hideTree = false;

                layer._cache.visibilityStates = {};
            }            

            TC.control.MapContents.prototype.updateLayerTree.call(self, layer);

            self.div.querySelector('.' + self.CLASS + '-empty').classList.add(TC.Consts.classes.HIDDEN);            

            TC.loadJSInOrder(
                !window.dust,
                TC.url.templating,
                function () {
                    dust.render(self.CLASS + '-node', self.layerTrees[layer.id], function (err, out) {
                        const parser = new DOMParser();
                        const newLi = parser.parseFromString(out, 'text/html').body.firstChild;
                        const uid = $(newLi).data(_dataKeys.layerUid);
                        const ul = self.div.querySelector('ul.' + self.CLASS + '-branch');
                        const lis = ul.querySelectorAll('li[data-tc-layer-uid="' + uid + '"]');
                        if (lis.length === 1) {
                            const li = lis[0];
                            li.innerHTML = newLi.innerHTML;
                            li.setAttribute('class', newLi.getAttribute('class')); // Esto actualiza si un nodo deja de ser hoja o pasa a ser hoja
                        }
                        else {
                            $(newLi).data(_dataKeys.layer, layer);
                            ul.insertBefore(newLi, ul.firstChild);
                        }
                        if (err) {
                            TC.error(err);
                        }
                    });
                    self.update();
                }
            );
        }
    };

    ctlProto.removeLayer = function (layer) {
        if (!layer.isBase) {
            TC.control.MapContents.prototype.removeLayer.call(this, layer);
        }
    };

    ctlProto.updateLayerVisibility = function (layer) {
        var self = this;
        self.getLayerUIElements().forEach(function (li) {
            if ($(li).data(_dataKeys.layer) === layer) {
                if (layer.getVisibility()) {
                    li.classList.remove(self.CLASS + '-node-notvisible');
                }
                else {
                    li.classList.add(self.CLASS + '-node-notvisible');
                }
            }
        });
    };

    ctlProto.getLayerUIElements = function () {
        const self = this;
        return self.div.querySelector('ul.' + self.CLASS + '-branch').querySelectorAll('li.' + self.CLASS + '-node');
    };
})();

﻿TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.LineFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYLINE;
    };

    TC.inherit(TC.control.LineFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.LineFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
﻿TC.control = TC.control || {};

if (!TC.control.WorkLayerManager) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/WorkLayerManager');
}

TC.control.ListTOC = TC.control.WorkLayerManager;
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.LoadingIndicator = function () {
    const self = this;

    TC.Control.apply(self, arguments);

    self._waits = {};

    window.addEventListener('error', function () {
        self.reset();
        // Tell browser to run its own error handler as well
        return false;
    }, false);
};

TC.inherit(TC.control.LoadingIndicator, TC.Control);

(function () {
    var ctlProto = TC.control.LoadingIndicator.prototype;

    ctlProto.CLASS = 'tc-ctl-load';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/LoadingIndicator.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-load-bar\"><div class=\"tc-ctl-load-dots tc-ctl-load-dot1\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot2\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot3\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot4\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot5\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot6\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot7\"> </div><div class=\"tc-ctl-load-dots tc-ctl-load-dot8\"> </div></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.startWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        if (self._waits[layerId] === undefined) {
            self._waits[layerId] = 0;
        }
        self._waits[layerId] = self._waits[layerId] + 1;
        self.show();

        self.map.trigger(TC.Consts.event.STARTLOADING);
    };

    ctlProto.stopWait = function (e) {
        const self = this;
        const layerId = e.layer.id;
        var wait = self._waits[layerId];
        if (wait > 0) {
            wait = self._waits[layerId] = wait - 1;
        }
        if (!wait) {
            delete self._waits[layerId];
        }
        var count = 0;
        for (var key in self._waits) {
            count++;
        }
        if (!count) {
            self.hide();
            self.map.trigger(TC.Consts.event.STOPLOADING);
        }
    };

    ctlProto.reset = function (e) {
        var self = this;
        self._waits = {};
        self.hide();
        self.map.trigger(TC.Consts.event.STOPLOADING);
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        map
            .on(TC.Consts.event.BEFORELAYERADD + ' ' +
                TC.Consts.event.BEFORELAYERUPDATE + ' ' +
                TC.Consts.event.BEFOREFEATURESADD, function (e) { self.startWait(e); })
            .on(TC.Consts.event.LAYERADD + ' ' +
                TC.Consts.event.LAYERERROR + ' ' +
                TC.Consts.event.LAYERUPDATE + ' ' +
                TC.Consts.event.FEATURESADD, function (e) { self.stopWait(e); })
            .on(TC.Consts.event.BEFOREFEATUREINFO, function () {
                self.addWait(TC.Consts.event.FEATUREINFO);
            })
            .on(TC.Consts.event.FEATUREINFO + ' ' +
                TC.Consts.event.NOFEATUREINFO + ' ' +
                TC.Consts.event.FEATUREINFOERROR, function () {
                self.removeWait(TC.Consts.event.FEATUREINFO);
            });
        if (!TC.isDebug) {
            //Para evitar que se quede el indicador indefinidamente activo cuando hay un error en la página
            window.addEventListener('error', function (msg, url, line, col, error) {
                self.reset();
                return false;
            });

            $(document).ajaxError(function (event, request, settings) {
                self.reset();
            });
        }

        return result;
    };

    ctlProto.addWait = function (uid) {
        const self = this;
        const result = uid || TC.getUID();
        self.startWait({ layer: { id: result } });
        return result;
    };

    ctlProto.removeWait = function (uid) {
        this.stopWait({ layer: { id: uid } });
    };

})();

﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.BEFOREFEATUREMODIFY = "beforefeaturemodify.tc";
TC.Consts.event.FEATUREMODIFY = "featuremodify.tc";
TC.Consts.event.FEATURESSELECT = "featuresselect.tc";
TC.Consts.event.FEATURESUNSELECT = "featuresunselect.tc";
TC.Consts.event.CHANGE = 'change';

(function () {

    TC.control.Modify = function () {
        var self = this;

        TC.Control.apply(self, arguments);

        if (!Modernizr.inputtypes.color && !window.CP) {
            TC.loadCSS(TC.apiLocation + 'lib/color-picker/color-picker.min.css');
            TC.syncLoadJS(TC.apiLocation + 'lib/color-picker/color-picker.min.js');
        }

        self.styles = $.extend(true, TC.Cfg.styles.selection, self.options.styles);
        self.styles.text = self.styles.text || {
            fontSize: self.styles.line.fontSize,
            fontColor: self.styles.line.fontColor,
            labelOutlineColor: self.styles.line.labelOutlineColor,
            labelOutlineWidth: self.styles.line.labelOutlineWidth
        };

        self._classSelector = '.' + self.CLASS;

        self.wrap = new TC.wrap.control.Modify(self);
    };

    TC.inherit(TC.control.Modify, TC.Control);

    var ctlProto = TC.control.Modify.prototype;

    ctlProto.CLASS = 'tc-ctl-mod';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Modify.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-btn tc-ctl-mod-btn-select\" disabled title=\"").h("i18n", ctx, {}, { "$key": "select" }).w("\">").h("i18n", ctx, {}, { "$key": "select" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-delete\" disabled title=\"").h("i18n", ctx, {}, { "$key": "deleteSelection" }).w("\">").h("i18n", ctx, {}, { "$key": "deleteSelection" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-join\" disabled title=\"").h("i18n", ctx, {}, { "$key": "joinGeometries.tooltip" }).w("\">").h("i18n", ctx, {}, { "$key": "joinGeometries" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-split\" disabled title=\"").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("\">").h("i18n", ctx, {}, { "$key": "splitGeometry" }).w("</button><button class=\"tc-ctl-btn tc-ctl-mod-btn-text\" contenteditable=\"true\" disabled title=\"").h("i18n", ctx, {}, { "$key": "addText" }).w("\">").h("i18n", ctx, {}, { "$key": "addText" }).w("</button><div class=\"tc-ctl-mod-style tc-hidden\"><input type=\"text\" class=\"tc-ctl-mod-txt tc-textbox\" placeholder=\"").h("i18n", ctx, {}, { "$key": "writeTextForSketch" }).w("\" style=\"font-size:").f(ctx.get(["fontSize"], false), ctx, "h").w("pt;font-color:").f(ctx.get(["fontColor"], false), ctx, "h").w(";text-shadow: 0 0 ").f(ctx.get(["labelOutlineWidth"], false), ctx, "h").w("px ").f(ctx.get(["labelOutlineColor"], false), ctx, "h").w(";\" />").h("i18n", ctx, {}, { "$key": "textColor" }).w("<input type=\"color\" class=\"tc-ctl-mod-fnt-c\" value=\"").f(ctx.get(["fontColor"], false), ctx, "h").w("\" />").h("i18n", ctx, {}, { "$key": "fontSize" }).w("<input type=\"number\" class=\"tc-ctl-mod-fnt-s tc-textbox\" value=\"").f(ctx.get(["fontSize"], false), ctx, "h").w("\" min=\"7\" max=\"20\" /></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const setFeatureSelectedState = function (ctl, features) {
        ctl._deleteBtn.disabled = features.length === 0;
        ctl._joinBtn.disabled = features.length < 2;
        ctl._splitBtn.disabled = features.filter(complexGeometryFilter).length === 0;
        ctl.displayLabelText();
    };

    const styleFunction = function (feature, mapStyles) {
        var result;
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                result = $.extend({}, mapStyles.polygon);
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
            case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                result = $.extend({}, mapStyles.point);
                break;
            default:
                result = $.extend({}, mapStyles.line);
                break;
        }
        const style = feature.getStyle();
        if (style.label) {
            result.label = style.label;
            result.fontSize = style.fontSize;
            result.fontColor = style.fontColor;
            result.labelOutlineColor = style.labelOutlineColor;
            result.labelOutlineWidth = style.labelOutlineWidth;
        }
        return result;
    };

    //const setFeatureSelectedStyle = function (ctl, features) {
    //    const mapStyles = ctl.map.options.styles.selection;
    //    features.forEach(function (feature) {
    //        feature._originalStyle = $.extend({}, feature.getStyle());
    //        feature.setStyle(ctl.styleFunction(feature));
    //    });
    //};

    //const setFeatureUnselectedStyle = function (ctl, features) {
    //    features.forEach(function (feature) {
    //        if (feature._originalStyle) {
    //            const style = feature.getStyle();
    //            if (style.label) {
    //                const originalStyle = feature._originalStyle;
    //                originalStyle.label = style.label;
    //                originalStyle.fontSize = style.fontSize;
    //                originalStyle.fontColor = style.fontColor;
    //                originalStyle.labelOutlineColor = style.labelOutlineColor;
    //                originalStyle.labelOutlineWidth = style.labelOutlineWidth;
    //            }
    //            feature.setStyle(feature._originalStyle);
    //            feature._originalStyle = undefined;
    //        }
    //    })
    //};

    const complexGeometryFilter = function (elm) {
        var result = false;
        if ((TC.feature.MultiPolygon && elm instanceof TC.feature.MultiPolygon) ||
            (TC.feature.MultiPolyline && elm instanceof TC.feature.MultiPolyline)) {
            if (elm.geometry.length > 1) {
                result = true;
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        if (self.options.layer) {

            self.setLayer(self.options.layer);

            map
                .on(TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {
                    Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                        const layer = objects[0];
                        if (e.layer === layer) {
                            self._selectBtn.disabled = false;
                            self._textBtn.disabled = false;
                        }
                    });
                })
                .on(TC.Consts.event.FEATUREREMOVE + ' ' + TC.Consts.event.FEATURESCLEAR, function (e) {
                    const layer = e.layer;
                    const feature = e.feature;
                    Promise.all([self.getLayer(), self.renderPromise()]).then(function (objects) {
                        if (layer === objects[0]) {
                            if (feature) {
                                self.unselectFeatures([feature]);
                            }
                            else {
                                self.unselectFeatures();
                            }
                            setFeatureSelectedState(self, self.getSelectedFeatures());
                            if (self.layer.features.length === 0) {
                                self._selectBtn.disabled = true;
                                self.setTextMode(false);
                                self._textBtn.disabled = true;
                            }
                        }
                    });
                });

            const featureSelectUpdater = function () {
                const selectedFeatures = self.getSelectedFeatures();
                setFeatureSelectedState(self, selectedFeatures);
                const unselectedFeatures = self.layer.features.filter(function (feature) {
                    return selectedFeatures.indexOf(feature) < 0;
                });
                unselectedFeatures.forEach(function (feature) {
                    feature.toggleSelectedStyle(false);
                });
                selectedFeatures.forEach(function (feature) {
                    feature.toggleSelectedStyle(true);
                });
            };
            self
                .on(TC.Consts.event.FEATURESSELECT, featureSelectUpdater)
                .on(TC.Consts.event.FEATURESUNSELECT, featureSelectUpdater);
        }

        return result;
    };

    ctlProto.render = function (callback) {
        const self = this;

        const renderCallback = function () {
            self._selectBtn = self.div.querySelector('.' + self.CLASS + '-btn-select');
            self._selectBtn.addEventListener(TC.Consts.event.CLICK, function (e) {
                if (!e.target.disabled) {
                    if (self.isActive) {
                        self.deactivate();
                    }
                    else {
                        self.activate();
                    }
                }
            });
            self._deleteBtn = self.div.querySelector('.' + self.CLASS + '-btn-delete');
            self._deleteBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.deleteSelectedFeatures();
            });
            self._textBtn = self.div.querySelector('.' + self.CLASS + '-btn-text');
            self._textBtn.addEventListener(TC.Consts.event.CLICK, function () {
                self.setTextMode(!self.textActive);
            });
            self._joinBtn = self.div.querySelector('.' + self.CLASS + '-btn-join');
            self._splitBtn = self.div.querySelector('.' + self.CLASS + '-btn-split');
            self._textInput = self.div.querySelector('input.' + self.CLASS + '-txt');
            self._textInput.addEventListener('input', function (e) {
                self.labelFeatures(e.target.value);
            });
            self._styleSection = self.div.querySelector('.' + self.CLASS + '-style');

            self._fontColorPicker = self.div.querySelector(self._classSelector + '-fnt-c');
            self._fontColorPicker.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontColor(e.target.value);
            });

            self._fontSizeSelector = self.div.querySelector('.' + self.CLASS + '-fnt-s');
            self._fontSizeSelector.addEventListener(TC.Consts.event.CHANGE, function (e) {
                self.setFontSize(e.target.value);
            });

            if ($.isFunction(callback)) {
                callback();
            }
        };

        const renderObject = {
            fontSize: self.styles.text.fontSize,
            fontColor: self.styles.text.fontColor,
            labelOutlineColor: self.styles.text.labelOutlineColor,
            labelOutlineWidth: self.styles.text.labelOutlineWidth
        };

        var promise;
        if (Modernizr.inputtypes.color) {
            promise = self._set1stRenderPromise(self.renderData(renderObject, renderCallback));
        }
        else {
            // El navegador no soporta input[type=color], usamos polyfill
            promise = self._set1stRenderPromise(self.renderData(renderObject, function () {
                const input = self.div.querySelector('input[type=color]');
                input.style.backgroundColor = input.value;
                input.style.color = 'transparent';
                const picker = new CP(input, 'click', document.body);

                input.onclick = function (e) {
                    e.preventDefault();
                };

                // Evitamos que salga el teclado virtual en iOS
                input.onfocus = function (e) {
                    this.blur();
                };

                input.onchange = function (e) {
                    this.style.backgroundColor = this.value;
                };
                self.map.loaded(function () {
                    picker.on("change", function (color) {
                        self.setFontColor('#' + color);
                    });
                });

                renderCallback();
            }));
        }
        return promise;
    };

    ctlProto.activate = function () {
        const self = this;
        self._selectBtn.classList.add(TC.Consts.classes.ACTIVE);
        TC.Control.prototype.activate.call(self);
        self.wrap.activate(self.mode);
    };

    ctlProto.deactivate = function () {
        const self = this;
        TC.Control.prototype.deactivate.call(self);
        if (self._selectBtn) {
            setFeatureSelectedState(self, []);
        }
        if (self.wrap) {
            self.wrap.deactivate();
        }
        //self.trigger(TC.Consts.event.DRAWCANCEL, { ctrl: self });
        if (self._selectBtn) {
            self._selectBtn.classList.remove(TC.Consts.classes.ACTIVE);
            self.layer.features.forEach(function (feature) {
                feature.toggleSelectedStyle(false);
            });
            //setFeatureUnselectedStyle(self, self.getSelectedFeatures());
        }
    };

    ctlProto.clear = function () {
        const self = this;
        if (self.layer) {
            self.layer.clearFatures();
        }
        return self;
    };

    ctlProto.isExclusive = function () {
        return true;
    };

    ctlProto.end = function () {
        const self = this;
        self.wrap.end();
        return self;
    };

    ctlProto.setMode = function (mode, activate) {
        const self = this;

        if (mode)
            self.mode = mode;

        if (activate && mode) {
            if (self.layer) {
                self.layer.map.putLayerOnTop(self.layer);
            }
            self.activate();
        }
        else {
            self.deactivate();
        }
        return self;
    };

    ctlProto.getLayer = function () {
        var self = this;
        // Se ha instanciado un control sin capa asociada
        if (self.options && typeof self.options.layer === 'boolean' && !self.options.layer) {
            return Promise.resolve(null);
        }
        if (self.layer) {
            return Promise.resolve(self.layer);
        }
        return self._layerPromise;
    };

    ctlProto.setLayer = function (layer) {
        var self = this;
        if (self.map) {
            self._layerPromise = new Promise(function (resolve, reject) {
                if (typeof (layer) === "string") {
                    self.map.loaded(function () {
                        self.layer = self.map.getLayer(layer);
                        resolve(self.layer);
                    });
                }
                else {
                    self.layer = layer;
                    resolve(self.layer);
                }
            });
        }
    };

    ctlProto.getSelectedFeatures = function () {
        return this.wrap.getSelectedFeatures();
    };

    ctlProto.setSelectedFeatures = function (features) {
        const self = this;
        const result = self.wrap.setSelectedFeatures(features);
        self.displayLabelText();
        return result;
    };

    ctlProto.getActiveFeatures = function () {
        const self = this;
        const result = self.getSelectedFeatures();
        if (!result.length && self.layer.features.length) {
            result.push(self.layer.features[self.layer.features.length - 1]);
        }
        return result;
    };

    ctlProto.unselectFeatures = function (features) {
        features = features || [];
        this.wrap.unselectFeatures(features.map(function (feat) {
            return feat.wrap.feature;
        }));
        return this;
    };

    ctlProto.deleteSelectedFeatures = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        self.wrap.unselectFeatures(features);
        features.forEach(function (feature) {
            self.layer.removeFeature(feature);
        });
        return self;
    };

    ctlProto.styleFunction = function (feature, resolution) {
        const self = this;
        var result;
        const mapStyles = self.map.options.styles.selection;
        switch (true) {
            case TC.feature.Polygon && feature instanceof TC.feature.Polygon:
            case TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:
                result = $.extend({}, mapStyles.polygon);
                break;
            case TC.feature.Point && feature instanceof TC.feature.Point:
            case TC.feature.MultiPoint && feature instanceof TC.feature.MultiPoint:
                result = $.extend({}, mapStyles.point);
                break;
            default:
                result = $.extend({}, mapStyles.line);
                break;
        }
        const style = feature.getStyle();
        if (style.label) {
            result.label = style.label;
            result.fontSize = style.fontSize;
            result.fontColor = style.fontColor;
            result.labelOutlineColor = style.labelOutlineColor;
            result.labelOutlineWidth = style.labelOutlineWidth;
        }
        return result;
    };

    ctlProto.setTextMode = function (active) {
        const self = this;
        self.textActive = active;
        if (active) {
            self._textBtn.classList.add(TC.Consts.classes.ACTIVE);
            self._textBtn.classList.add(active);
        }
        else {
            self._textBtn.classList.remove(TC.Consts.classes.ACTIVE);
            self._textBtn.classList.remove(active);
        }
        if (active) {
            self._styleSection.classList.remove(TC.Consts.classes.HIDDEN);
        }
        else {
            self._styleSection.classList.add(TC.Consts.classes.HIDDEN);
        }
        self.displayLabelText();
        return self;
    };

    ctlProto.setFontColorWatch = function (color, outlineColor) {
        const self = this;
        if (color === undefined) {
            color = self.styles.text.fontColor;
        }
        color = TC.Util.colorArrayToString(color);
        outlineColor = outlineColor || self.getLabelOutlineColor(color);
        self.renderPromise().then(function () {
            self._fontColorPicker.value = color;
            self._textInput.style.color = color;
            self._textInput.style.textShadow = '0 0 ' + self.styles.text.labelOutlineWidth + 'px ' + outlineColor;
            if (!Modernizr.inputtypes.color) {
                self._fontColorPicker.style.backgroundColor = color;
                self._fontColorPicker.blur();
            }
        });
        return self;
    };

    ctlProto.setFontColor = function (color) {
        const self = this;
        self.styles.text.fontColor = color;
        self.styles.text.labelOutlineColor = self.getLabelOutlineColor(color);
        self.setFontColorWatch(color, self.styles.text.labelOutlineColor);
        const features = self.getActiveFeatures();
        features.forEach(function (feature) {
            const style = feature.getStyle();
            style.fontColor = color;
            style.labelOutlineColor = self.styles.text.labelOutlineColor;
            feature.setStyle(style);
        });
        return self;
    };

    ctlProto.setFontSizeWatch = function (size) {
        const self = this;
        if (size === undefined) {
            size = self.styles.text.fontSize;
        }
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.renderPromise().then(function () {
                self._fontSizeSelector.value = sizeValue;
                self._textInput.style.fontSize = sizeValue + 'pt';
            });
        }
        return self;
    };

    ctlProto.setFontSize = function (size) {
        const self = this;
        const sizeValue = parseInt(size);
        if (sizeValue !== Number.NaN) {
            self.styles.text.fontSize = sizeValue;
            self.setFontSizeWatch(sizeValue);
            const features = self.getActiveFeatures();
            features.forEach(function (feature) {
                const style = feature.getStyle();
                style.fontSize = sizeValue;
                feature.setStyle(style);
            });
        }
        return self;
    };

    ctlProto.getLabelOutlineColor = function (fontColor) {
        if (fontColor) {
            fontColor = TC.Util.colorArrayToString(fontColor);
            const matchForShort = fontColor.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i);
            if (matchForShort && matchForShort.length) {
                fontColor = '#' + matchForShort[1] + matchForShort[1] + matchForShort[2] + matchForShort[2] + matchForShort[3] + matchForShort[3];
            }
            const matchForLong = fontColor.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
            if (matchForLong && matchForLong.length) {
                const r = parseInt(matchForLong[1], 16);
                const g = parseInt(matchForLong[2], 16);
                const b = parseInt(matchForLong[3], 16);
                return (r + g + b) / 3 < 128 ? '#ffffff' : '#000000';
            }
        }
        return '#ffffff';
    };

    ctlProto.displayLabelText = function () {
        const self = this;
        const features = self.getSelectedFeatures();
        var text;
        var size;
        var color;
        if (self.isActive && features.length) {
            const feature = features[features.length - 1];
            const style = feature.getStyle();
            text = style.label;
            color = style.fontColor;
            size = style.fontSize;
        }
        else {
            text = '';
            color = self.styles.text.fontColor;
            size = self.styles.text.fontSize;
        }
        self.renderPromise().then(function () {
            self
                .setFontSizeWatch(size)
                .setFontColorWatch(color)
                ._textInput.value = text;
        });
        return self;
    };

    ctlProto.labelFeatures = function (text) {
        const self = this;
        const features = self.getActiveFeatures();
        if (features.length) {
            const style = features[0].getStyle();
            features.forEach(function (feature) {
                const textStyle = $.extend({}, self.styles.text, style);
                style.label = text;
                style.labelOffset = textStyle.labelOffset;
                style.fontColor = textStyle.fontColor;
                style.fontSize = textStyle.fontSize;
                style.labelOutlineColor = textStyle.labelOutlineColor;
                style.labelOutlineWidth = textStyle.labelOutlineWidth;
                feature.setStyle(style);
            });
        }
        return self;
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.FeatureInfoCommons) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');
}
(function () {
    TC.control.MultiFeatureInfo = function () {
        var self = this;
        self.lineColor = null;
        TC.Control.apply(self, arguments);
        self.modes = self.options.modes || {};
        if (typeof self.modes[TC.Consts.geom.POINT] === 'undefined') {
            self.modes[TC.Consts.geom.POINT] = true;
        }
        if (typeof self.modes[TC.Consts.geom.POLYGON] === 'undefined') {
            self.modes[TC.Consts.geom.POLYGON] = true;
        }
        self.fInfoCtrl = null;
        self.lineFInfoCtrl = null;
        self.polygonFInfoCtrl = null;
        self.lastCtrlActive = null;
        self.popup = null;
        self.exportsState = false; // Los controles que exportan estado son los hijos
    };

    TC.inherit(TC.control.MultiFeatureInfo, TC.control.FeatureInfoCommons);

    var ctlProto = TC.control.MultiFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-m-finfo';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/MultiFeatureInfo.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS,body_0);function body_0(chk,ctx){return chk.w("<div class=\"tc-ctl-m-finfo-select\"><form><span>").h("i18n",ctx,{},{"$key":"selection"}).w("</span>").x(ctx.get(["pointSelectValue"], false),ctx,{"block":body_1},{}).x(ctx.get(["lineSelectValue"], false),ctx,{"block":body_2},{}).x(ctx.get(["polygonSelectValue"], false),ctx,{"block":body_3},{}).w("</form></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-point\" title=\"").h("i18n",ctx,{},{"$key":"selectionByPoint"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["pointSelectValue"], false),ctx,"h").w("\" checked /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byPoint"}).w("</span></label>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-line\" title=\"").h("i18n",ctx,{},{"$key":"selectionByLine"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["lineSelectValue"], false),ctx,"h").w("\" /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byLine"}).w("</span></label>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<label class=\"tc-ctl-m-finfo-btn-polygon\" title=\"").h("i18n",ctx,{},{"$key":"selectionByPrecinct"}).w("\"><input type=\"radio\" name=\"selectmode\" value=\"").f(ctx.get(["polygonSelectValue"], false),ctx,"h").w("\" /><span class=\"tc-ctl-btn\">").h("i18n",ctx,{},{"$key":"byPrecinct"}).w("</span></label>");}body_3.__dustBody=!0;return body_0};
    }

    const mergeOptions = function (opt1, opt2) {
        if (opt1 === true) {
            opt1 = {};
            return $.extend(opt1, opt2);
        }
        return opt1;
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const ctlPromises = [TC.Control.prototype.register.call(self, map)]
            if (self.modes[TC.Consts.geom.POINT]) {
                ctlPromises.push(map.addControl("featureInfo", mergeOptions(self.modes[TC.Consts.geom.POINT],
                    { displayMode: self.options.displayMode })).then(function (control) {
                        self.fInfoCtrl = control;
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYLINE]) {
                ctlPromises.push(map.addControl("lineFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYLINE],
                    { displayMode: self.options.displayMode, lineColor: self.lineColor })).then(function (control) {
                        self.lineFInfoCtrl = control;
                        return control;
                    }));
            }
            if (self.modes[TC.Consts.geom.POLYGON]) {
                ctlPromises.push(map.addControl("polygonFeatureInfo", mergeOptions(self.modes[TC.Consts.geom.POLYGON],
                    { displayMode: self.options.displayMode, lineColor: self.lineColor })).then(function (control) {
                        self.polygonFInfoCtrl = control;
                        return control;
                    }));
            }
            Promise.all(ctlPromises).then(function () {
                if (self.fInfoCtrl) {
                    self.fInfoCtrl.activate();
                    self.lastCtrlActive = self.fInfoCtrl;
                }
                resolve(self);
            });
        });

    };

    ctlProto.render = function (callback) {
        const self = this;
        self.lineColor = !self.options.lineColor ? "#c00" : self.options.lineColor;
        var renderData = {};
        if (self.modes[TC.Consts.geom.POINT]) {
            renderData.pointSelectValue = TC.Consts.geom.POINT;
        }
        if (self.modes[TC.Consts.geom.POLYLINE]) {
            renderData.lineSelectValue = TC.Consts.geom.POLYLINE;
        }
        if (self.modes[TC.Consts.geom.POLYGON]) {
            renderData.polygonSelectValue = TC.Consts.geom.POLYGON;
        }
        return TC.Control.prototype.renderData.call(self, renderData,
            function () {
                var changeEvent = function () {
                    switch (this.value) {
                        case TC.Consts.geom.POLYLINE:
                            //modo línea
                            console.log("seleccion por línea");
                            if (self.map.activeControl === self.fInfoCtrl || self.map.activeControl === self.polygonFInfoCtrl)
                                self.lineFInfoCtrl.activate();
                            self.lastCtrlActive = self.lineFInfoCtrl;
                            break;
                        case TC.Consts.geom.POLYGON:
                            //modo poligono
                            console.log("seleccion por polígono");
                            if (self.map.activeControl === self.fInfoCtrl || self.map.activeControl === self.lineFInfoCtrl)
                                self.polygonFInfoCtrl.activate();
                            self.lastCtrlActive = self.polygonFInfoCtrl;
                            break;
                        default:
                            //modo point
                            console.log("seleccion por punto");
                            if (self.map.activeControl === self.polygonFInfoCtrl || self.map.activeControl === self.lineFInfoCtrl)
                                self.fInfoCtrl.activate();
                            self.lastCtrlActive = self.fInfoCtrl;
                            break;
                    }
                };
                self.div.querySelectorAll('input[type=radio]').forEach(function (input) {
                    input.addEventListener('change', changeEvent);
                });

                if ($.isFunction(callback)) {
                    callback();
                }
            });
    };
    ctlProto.activate = function () {
        var self = this;
        if (self.lastCtrlActive)
            self.lastCtrlActive.activate();
    }
    ctlProto.deactivate = function () {
        var self = this;
        self.lastCtrlActive.deactivate(false);
    }


    TC.Map.prototype.getDefaultControl = function () {
        var candidate = this.getControlsByClass("TC.control.MultiFeatureInfo");
        if (candidate && candidate.length)
            return candidate[0].lastCtrlActive;
        else {
            candidate = this.getControlsByClass("TC.control.FeatureInfo");
            if (candidate && candidate.length)
                return candidate[0];
            else
                return null;
        }
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBar, TC.Control);

(function () {
    var ctlProto = TC.control.NavBar.prototype;

    ctlProto.CLASS = 'tc-ctl-nav';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBar(self);
        }
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);

        if (self.options.home === undefined || self.options.home) {
            map.addControl('navBarHome');
        }        

        //esta chama es para que la primera vez se ajuste la barrita de escala (debido a otra chama con el maxResolution, que es culpa de OL)
        map.loaded(function () {
            self.wrap.refresh();
        });        

        return result;
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.NavBarHome = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.NavBarHome, TC.Control);

(function () {
    var ctlProto = TC.control.NavBarHome.prototype;

    ctlProto.CLASS = 'tc-ctl-nav-home';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.NavBarHome(self);
        }
        return Promise.resolve();
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        self.wrap.register(map);        

        map.on(TC.Consts.event.PROJECTIONCHANGE, function (e) {
            const crs = e.crs;
            var bottomLeft = TC.Util.reproject([map.options.initialExtent[0], map.options.initialExtent[1]], map.options.crs, crs);
            var topRight = TC.Util.reproject([map.options.initialExtent[2], map.options.initialExtent[3]], map.options.crs, crs);
            self.wrap.setInitialExtent([bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]);
        });

        return result;
    };

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.OverviewMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.isLoaded = false;

    self.layer = null;
};

TC.inherit(TC.control.OverviewMap, TC.Control);

(function () {
    var ctlProto = TC.control.OverviewMap.prototype;

    ctlProto.CLASS = 'tc-ctl-ovmap';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/OverviewMap.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-ovmap-load tc-hidden\"></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const instanceLayer = function (layer) {
            var lyr;

            var findLayerById = function (id, layers) {
                var result = null;
                for (var i = 0; i < layers.length; i++) {
                    var lyr = layers[i];
                    var l = lyr.id || lyr;
                    if (l === id) {
                        result = lyr;
                        break;
                    }
                }
                return result;
            };

            if (typeof layer === 'string') {
                var lyrObj = findLayerById(layer, map.options.availableBaseLayers);
                if (!$.isPlainObject(lyrObj)) {
                    lyrObj = findLayerById(layer, map.options.baseLayers);
                }
                if ($.isPlainObject(lyrObj)) {
                    lyr = new TC.layer.Raster(lyrObj);
                }
            }
            else {
                if (layer instanceof TC.Layer) {
                    lyr = layer;
                }
                else if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {
                    lyr = new TC.layer.Vector(layer);
                }
                else {
                    lyr = new TC.layer.Raster(layer);
                }
            }

            return lyr;
        };

        const registerLayer = function (layer) {
            var lyr;

            lyr = instanceLayer(layer);

            return lyr;
        };

        const resetOVMapProjection = function (e) {
            const resetOptions = {};
            self.layer.getCapabilitiesPromise().then(function () {
                if (!self.layer.isCompatible(map.crs) && self.layer.wrap.getCompatibleMatrixSets(map.crs).length === 0) {
                    resetOptions.layer = self.layer.getFallbackLayer();
                }
                self.wrap.reset(resetOptions);
            });
        };

        const changeBaseLayer = function (e) {
            const self = this;

            if (self.map.baseLayer.type === TC.Consts.layerType.WMS || self.map.baseLayer.type === TC.Consts.layerType.WMTS || self.options.layer) {
                var newLayer = self.map.baseLayer.overviewMapLayer || self.options.layer;
                if (self.layer.id !== newLayer) {
                    var overviewMapLayer = registerLayer(newLayer);
                    self.wrap.reset({
                        layer: overviewMapLayer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                } else if (TC.Consts.event.PROJECTIONCHANGE.indexOf(e.type) > -1) {
                    self.wrap.reset({
                        layer: self.layer
                    }).then(function (layer) {
                        self.layer = layer;
                    });
                }
            }
        };

        const result = new Promise(function (resolve, reject) {
            TC.Control.prototype.register.call(self, map)
                .then(function (ctl) {
                    self.wrap = new TC.wrap.control.OverviewMap(self);
                    map.loaded(function () {
                        self.defaultLayer = registerLayer(self.options.layer);
                        self.layer = registerLayer(map.baseLayer.overviewMapLayer || self.options.layer || map.options.baseLayers[0] || map.options.availableBaseLayers[0]);

                        self.wrap.register(map);                        

                        resetOVMapProjection({ crs: map.crs });

                        map.on(TC.Consts.event.PROJECTIONCHANGE + ' ' + TC.Consts.event.BASELAYERCHANGE, changeBaseLayer.bind(self));
                    });
                    resolve(ctl);
                })
                .catch(function (err) {
                    reject(err);
                });
        });

        return result;
    };

    ctlProto.loaded = function (callback) {
        var self = this;

        if ($.isFunction(callback)) {
            if (self.isLoaded && self.map && self.map.isLoaded) {
                callback();
            }
            else {
                self.on(TC.Consts.event.MAPLOAD, callback);
            }
        }
    };

    ctlProto.activate = function () {
        this.enable();
    };

    ctlProto.deactivate = function () {
        this.disable();
    };

    ctlProto.enable = function () {
        var self = this;
        TC.Control.prototype.enable.call(self);
        self.wrap.enable();
    };

    ctlProto.disable = function () {
        var self = this;
        TC.Control.prototype.disable.call(self);
        self.wrap.disable();
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.GeometryFeatureInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/GeometryFeatureInfo');
}

(function () {
    TC.control.PolygonFeatureInfo = function () {
        var self = this;
        TC.control.GeometryFeatureInfo.apply(this, arguments);
        self.geometryType = TC.Consts.geom.POLYGON;
    };

    TC.inherit(TC.control.PolygonFeatureInfo, TC.control.GeometryFeatureInfo);

    var ctlProto = TC.control.PolygonFeatureInfo.prototype;

    ctlProto.CLASS = 'tc-ctl-finfo';

})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.POPUP = TC.Consts.event.POPUP || 'popup.tc';
TC.Consts.event.POPUPHIDE = TC.Consts.event.POPUPHIDE || 'popuphide.tc';
TC.Consts.classes.DRAG = TC.Consts.classes.DRAG || 'tc-drag';
TC.Consts.classes.DRAGGED = TC.Consts.classes.DRAGGED || 'tc-dragged';
TC.Consts.classes.DRAGGABLE = TC.Consts.classes.DRAGGABLE || 'tc-draggable';

TC.control.Popup = function () {
    var self = this;

    TC.Control.apply(self, arguments);
    self.currentFeature = null;
    //self.wrap = { popup: null };    
    self.wrap = new TC.wrap.control.Popup(self);
};

TC.inherit(TC.control.Popup, TC.Control);

(function () {
    var ctlProto = TC.control.Popup.prototype;

    ctlProto.CLASS = 'tc-ctl-popup';

    ctlProto.render = function () {
        const self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.map.wrap.addPopup(self)
                .then(function () {
                    self.trigger(TC.Consts.event.CONTROLRENDER);
                    resolve();
                },
                function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
        }));
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);
        return new Promise(function (resolve, reject) {
            Promise.all([result, self.renderPromise()]).then(function () {
                map.on(TC.Consts.event.VIEWCHANGE, function () {
                    if (map.view === TC.Consts.view.PRINTING) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERVISIBILITY, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer && !e.layer.getVisibility()) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.LAYERREMOVE, function (e) {
                    if (self.currentFeature && self.currentFeature.layer === e.layer) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.UPDATE, function () {
                    if (!self.currentFeature || self.currentFeature._visibilityState === TC.Consts.visibility.NOT_VISIBLE) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                map.on(TC.Consts.event.FEATUREREMOVE, function (e) {
                    if (self.currentFeature === e.feature) {
                        if (self.isVisible()) {
                            self.hide();
                        }
                    }
                });

                /**
                    GLS: Controlamos el ancla del popup cuando hay zoom in/out de pantalla o navegador, debería hacerlo OL pero no lo gestiona.
                    No funciona, sólo salta la primera vez, paso a sobrescribir el método de OL
                 */
                //var config = { attributes: true, attributeFilter: ['style', 'class'], childList: false, subtree: false };
                //var observer = new MutationObserver(function (mutationsList, observer) {
                //    //var positionMutation = mutationsList.filter(function (mutation) {
                //    //    return mutation.type === "attributes"
                //    //}).filter(function (mutation) {
                //    //    return ['top', 'right', 'bottom', 'left', 'style'].indexOf(mutation.attributeName) > -1;
                //    //});

                //    if (mutationsList.length > 0) {
                //        // me desconecto para no entrar en un bucle infinito
                //        //observer.disconnect();

                //        var top = mutationsList[0].target[mutationsList[0].attributeName].top;
                //        var right = mutationsList[0].target[mutationsList[0].attributeName].right;
                //        var bottom = mutationsList[0].target[mutationsList[0].attributeName].bottom;
                //        var left = mutationsList[0].target[mutationsList[0].attributeName].left;

                //        [{ top: top }, { right: right }, { bottom: bottom }, { left: left }].forEach(function (elm) {
                //            var key = Object.keys(elm)[0];
                //            if (elm[key].length > 0) {
                //                document.querySelector('.ol-overlay-container').style[key] = parseFloat(elm[key].replace('px', '')) / window.devicePixelRatio + 'px';
                //            }
                //        });

                //        // volvemos a observar
                //        //observer.observe(document.querySelector('.ol-overlay-container'), config);
                //    }
                //});
                //observer.observe(document.querySelector('.ol-overlay-container'), config);

                resolve(self);
            }).catch(function (err) {
                reject(err instanceof Error ? err : Error(err));
            });
        })
    };

    ctlProto.fitToView = function (delayed) {
        var self = this;
        if (delayed) {
            setTimeout(function () {
                self.wrap.fitToView();
            }, 1000);
        }
        else {
            self.wrap.fitToView();
        }
    };

    ctlProto.hide = function () {
        var self = this;
        if (self.map) {
            self.map.wrap.hidePopup(self);
            self.setDragged(false);
            self.map.trigger(TC.Consts.event.POPUPHIDE, { control: self });
        }
    };

    ctlProto.getContainerElement = function () {
        return this.contentDiv || null;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv || null;
    };

    ctlProto.setDragged = function (dragged) {
        const self = this;
        self.dragged = dragged;
        if (self.popupDiv) {
            if (dragged) {
                self.popupDiv.classList.add(TC.Consts.classes.DRAGGED);
            }
            else {
                self.popupDiv.classList.remove(TC.Consts.classes.DRAGGED);
            }
        }
        self.wrap.setDragged(dragged);
    };

    ctlProto.setDragging = function (dragging) {
        const self = this;
        if (dragging) {
            self.setDragged(true);
            self.popupDiv.classList.add(TC.Consts.classes.DRAG);
        }
        else {
            self.popupDiv.classList.remove(TC.Consts.classes.DRAG);
        }
    };

    ctlProto.isVisible = function () {
        const self = this;

        return self.popupDiv && self.popupDiv.classList.contains(TC.Consts.classes.VISIBLE);
    };

})();
﻿TC.control = TC.control || {};

TC.Consts.classes.PRINTABLE = 'tc-printable';




TC.control.Print = function (options)
{
    var self = this;
    var opts = options || {};

    self.ready = false;

    self.title = opts.title || TC.Util.getLocaleString(TC.Cfg.locale, 'printPage');
    self.cssUrl = opts.cssUrl || TC.apiLocation + 'TC/css/print.css';

    if (opts.target)
    {
        const target = opts.target;

        if (!target.querySelector('.' + self.CLASS + '-btn')) {
            for (var key in self.template) {
                if (!dust.cache[key]) {
                    self.template[key]();
                }
            }
            
            target.classList.add(TC.Consts.classes.PRINTABLE);

            var renderPage = function (e) {
                var page = open(null, self.CLASS);
                var content = target.innerHTML;
                dust.render(self.CLASS + '-page', { title: self.title, content: content, cssUrl: self.cssUrl }, function (err, out) {
                    page.document.write(out);
                    page.document.close();
                    page.focus();
                    if (err) {
                        TC.error(err);
                    }
                });
            };
            dust.render(self.CLASS, null, function (err, out) {
                if (target.firstChild) {
                    target.firstChild.insertAdjacentHTML('beforebegin', out);
                }
                else {
                    target.innerHTML = out;
                }
                target.querySelector('.' + self.CLASS + '-btn').addEventListener('click', renderPage);
            });
        }
    }
};

(function () {
    var ctlProto = TC.control.Print.prototype;

    ctlProto.CLASS = 'tc-ctl-print';

    ctlProto.template = {};

    //if (TC.isDebug) {
    //    ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Print.html";
    //    ctlProto.template[ctlProto.CLASS + '-page'] = TC.apiLocation + "TC/templates/PrintPage.html";
    //}
    //else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<a class=\"tc-ctl-print-btn\" title=\"").h("i18n", ctx, {}, { "$key": "printThisWindow" }).w("\">").h("i18n", ctx, {}, { "$key": "print" }).w("</a>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-page'] = function () { dust.register(ctlProto.CLASS + '-page', body_0); function body_0(chk, ctx) { return chk.w("<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><title>").f(ctx.get(["title"], false), ctx, "h").w("</title><link rel=\"stylesheet\" href=\"").f(ctx.get(["cssUrl"], false), ctx, "h").w("\" /></head><body onload=\"print()\" class=\"tc-ctl-print-page\"><h1>").f(ctx.get(["title"], false), ctx, "h").w("</h1>").f(ctx.get(["content"], false), ctx, "h", ["s"]).w("</body></html>"); } body_0.__dustBody = !0; return body_0 };
    //}

})();
﻿TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.PrintMap = function () {
    var self = this;

    TC.Control.apply(self, arguments);
};

TC.inherit(TC.control.PrintMap, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.PrintMap.prototype;

    ctlProto.CLASS = 'tc-ctl-printMap';

    var self = this;

    const ORIENTATION = {
        PORTRAIT: 'portrait',
        LANDSCAPE: 'landscape'
    };
    const PAGE_SIZE = {
        A4: 'A4',
        A3: 'A3'
    };

    /*
        GLS:
        La librería makePDF se basa en la librería PDFKit explicación sobre la unidad de medida que usa:
        PDF points (72 per inch)
        https://stackoverflow.com/questions/51540144/pdfkit-node-js-measurement-unit
        https://www.ninjaunits.com/converters/pixels/points-pixels/
        https://www.ninjaunits.com/converters/pixels/pixels-points/

        La clave es mantener las dimensiones del mapa en px enteros (canvas sólo admite px enteros), ajustando el layout que está en puntos y que sí admite decimales
    */

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a4 indicando el valor en px la sección del mapa   */
    var a4_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 595,
                height: 842
            },
            pageMargins: [29.5, 14, 29.5, 22.5],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            alignment: 'center',
                            margin: [0, 10, 0, 0]
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 534,
                                height: 775.5
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a4 indicando el valor en px la sección del mapa   */
    var a4_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 842,
                height: 595
            },
            pageMargins: [30, 14, 30, 22],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 528
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-portrait-a3 indicando el valor en px la sección del mapa   */
    var a3_portrait = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 841.89,
                height: 1190.55
            },
            pageMargins: [29.954, 14, 29.954, 21.55],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            width: 489,
                            margin: [0, 10, 0, 0],
                            alignment: 'center'
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 780,
                                height: 1125
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };
    /* GLS: si se cambian los valores de los layout es necesario actualizar los valores de la clases CSS:  tc-ctl-printMap-landscape-a3 indicando el valor en px la sección del mapa   */
    var a3_landscape = {
        logoWidth: 60,
        logoHeight: 30,
        layoutPDF: {
            pageSize: {
                width: 1190.55,
                height: 841.89
            },
            pageMargins: [28.775, 14, 28.775, 14.89],
            content: [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ]
        },
        reset: function () {
            this.layoutPDF.content = [
                {
                    columns: [
                        { /* logo */
                            image: null,
                            height: 22,
                            width: 45,
                            margin: [0, 0, 0, 6]
                        },
                        { /* título */
                            text: "",
                            alignment: 'center',
                            margin: [0, 10, 0, 0],
                            width: 600
                        },
                        { /* barra de escala */
                            alignment: 'right',
                            margin: [0, 10, 0, 0]
                        }
                    ]
                },
                {
                    table: {
                        widths: ['*'],
                        body: [
                            [{ /* mapa */
                                image: null,
                                width: 1131,
                                height: 783
                            }]
                        ]
                    },
                    layout: {
                        paddingLeft: function (i, node) { return 0; },
                        paddingRight: function (i, node) { return 0; },
                        paddingTop: function (i, node) { return 0; },
                        paddingBottom: function (i, node) { return 0; }
                    }
                }
            ];
        }
    };

    const getLayout = function (orientation, format) {
        switch (orientation) {
            case ORIENTATION.PORTRAIT: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_portrait;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_portrait;
                    }
                    default:
                }
                break;
            }
            case ORIENTATION.LANDSCAPE: {
                switch (format) {
                    case PAGE_SIZE.A4: {
                        return a4_landscape;
                    }
                    case PAGE_SIZE.A3: {
                        return a3_landscape;
                    }
                    default:
                }
                break;
            }
            default:
                return a4_portrait;
        }
    };

    const getLogoColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[0];
    };
    const getTitleColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[1];
    };
    const getScaleBarColumn = function (layout) {
        return layout.layoutPDF.content[0].columns[2];
    };
    const getMap = function (layout) {
        return layout.layoutPDF.content[1].table.body[0][0];
    };

    const options = {
        qrCode: {
            sideLength: 85
        }
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/PrintMap.html";
        ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/PrintMapView.html";
        ctlProto.template[ctlProto.CLASS + '-tools'] = TC.apiLocation + "TC/templates/PrintMapTools.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "print" }).w("</h2><div><div class=\"tc-ctl-printMap-div\"><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "title" }).w(":</label><input type=\"text\" class=\"tc-ctl-printMap-title tc-textbox\" maxlength=\"30\" placeholder=\"").h("i18n", ctx, {}, { "$key": "mapTitle" }).w("\" /></div><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "layout" }).w(":</label><select id=\"print-design\" class=\"tc-combo\"><option value=\"landscape\">").h("i18n", ctx, {}, { "$key": "landscape" }).w("</option><option value=\"portrait\">").h("i18n", ctx, {}, { "$key": "portrait" }).w("</option></select></div><div class=\"tc-group tc-ctl-printMap-cnt\"><label>").h("i18n", ctx, {}, { "$key": "size" }).w(":</label><select id=\"print-size\" class=\"tc-combo\"><option value=\"a4\">A4</option><option value=\"a3\">A3</option></select></div><div class=\"tc-group tc-ctl-printMap-cnt tc-ctl-printMap-cnt-btn\"><input id=\"tc-ctl-printMap-image-qr\" class=\"tc-hidden\" type=\"checkbox\" checked style=\"display:none;\" /><label for=\"tc-ctl-printMap-image-qr\" class=\"tc-ctl-printMap-image-qr-label\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCodeToImage" }).w("\">").h("i18n", ctx, {}, { "$key": "appendQRCode" }).w("</label><button class=\"tc-ctl-printMap-btn tc-button tc-icon-button\" title=\"").h("i18n", ctx, {}, { "$key": "printMap" }).w("\">").h("i18n", ctx, {}, { "$key": "print" }).w("</button></div><div class=\"tc-group tc-ctl-printMap-cnt\"><div class=\"tc-ctl-printMap-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-view'] = function () { dust.register(ctlProto.CLASS + '-view', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-printMap-view\"> </div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-tools'] = function () { dust.register(ctlProto.CLASS + '-tools', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-printMap-tools\"><div class=\"tc-ctl-printMap-btn-pdf\" title=\"").h("i18n", ctx, {}, { "$key": "printpdf" }).w("\"></div><div class=\"tc-ctl-printMap-btn-close\" title=\"").h("i18n", ctx, {}, { "$key": "close" }).w("\"></div></div> "); } body_0.__dustBody = !0; return body_0 };
    }

    const hasLegend = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
        });
    };

    const hasLegendToPrint = function () {
        const self = this;

        return self.map.workLayers.some(function (layer) {
            if (layer.type === TC.Consts.layerType.WMS && layer.getVisibility()) {
                for (var i = 0; i < layer.names.length; i++) {
                    if (layer.isVisibleByScale(layer.names[i])) {
                        return true;
                    }
                }

                return false;
            }

            return false;
        });
    };

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.control.MapInfo.prototype.register.call(self, map);

        // GLS: Añado el flag al mapa para tenerlo en cuenta cuando se establece la función de carga de imágenes
        self.map.mustBeExportable = true;

        const manageLegendOnZoom = function () {
            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            layout.reset();
        };

        const print = function () {

            self.map.setView(TC.Consts.view.PRINTING);

            var codeContainer = document.querySelector('.' + self.CLASS + '-qrcode');
            if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                if (!codeContainer) {
                    codeContainer = document.createElement('div');
                    codeContainer.classList.add(self.CLASS + '-qrcode');
                    self.map.div.appendChild(codeContainer);
                }

                codeContainer.innerHTML = '';
                self.makeQRCode(codeContainer, options.qrCode.sideLength, options.qrCode.sideLength);
            } else {
                if (codeContainer) {
                    codeContainer.innerHTML = '';
                }
            }

            const printBtnSelector = '.' + self.CLASS + '-btn';
            self.map.on(TC.Consts.event.STARTLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.add('disabled');
                printBtn.disabled = true;
            });

            self.map.on(TC.Consts.event.STOPLOADING, function () {
                const printBtn = self.div.querySelector(printBtnSelector);
                printBtn.classList.remove('disabled');
                printBtn.disabled = false;
            });

            if (hasLegend.call(self)) {
                // GLS: controlamos si una capa deja de verse por la escala para resetear la leyenda                
                self.map.on(TC.Consts.event.ZOOM, manageLegendOnZoom);
            }

            const updateCanvas = function (printFormat) {
                if (printFormat) {
                    self.map.div.classList.add(printFormat);
                    /**
                     * Validamos que el resultado en pixels sean valores enteros, si no lo son, redondeamos y establecemos evitando estiramiento del canvas /
                     */
                    var bounding = self.map.div.getBoundingClientRect();
                    if (!Number.isInteger(bounding.width)) {
                        self.map.div.style.width = Math.round(bounding.width) + 'px';
                    }
                    if (!Number.isInteger(bounding.height)) {
                        self.map.div.style.height = Math.round(bounding.height) + 'px';
                    }

                    self.map.toast(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'), { type: TC.Consts.msgType.INFO, duration: 7000 });
                }

                self.map.wrap.map.updateSize();
            };

            const resetPrinting = function () {

                var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
                layout.reset();

                if (hasLegend.call(self)) {
                    self.map.off(TC.Consts.event.ZOOM, manageLegendOnZoom);
                }

                self.map.toastHide(self.getLocaleString('print.advice.title') + ': ' + self.getLocaleString('print.advice.desc'));

                self.map.div.classList.remove(self.currentFormat);
                self.map.div.classList.remove(self.CLASS + '-printing');

                self.map.div.style.removeProperty('width');
                self.map.div.style.removeProperty('height');

                updateCanvas();

                self.map.setView(TC.Consts.view.DEFAULT);

                self._viewDiv.classList.add(TC.Consts.classes.HIDDEN);
            };

            if (!self._viewDiv) {
                self._viewDiv = TC.Util.getDiv();
                document.body.appendChild(self._viewDiv);

                self.getRenderedHtml(self.CLASS + '-view', null, function (html) {
                    self._viewDiv.innerHTML = html;
                });

                self.getRenderedHtml(self.CLASS + '-tools', null, function (html) {
                    self.map.div.lastElementChild.insertAdjacentHTML('afterend', html);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-close').addEventListener('click', resetPrinting);

                    self.map.div.querySelector('.' + self.CLASS + '-btn-pdf').addEventListener('click', self.createPdf.bind(self));
                });
            }

            self.orientation = self.div.querySelector("#print-design").value;
            self.format = self.div.querySelector("#print-size").value;

            self.currentFormat = self.CLASS + '-' + self.orientation + '-' + self.format;

            self._viewDiv.classList.remove(TC.Consts.classes.HIDDEN);

            self.map.div.classList.add(self.CLASS + "-printing");
            updateCanvas(self.currentFormat);
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.' + self.CLASS + '-btn', print));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('#' + self.CLASS + '-image-qr', function (evt) {
            self.generateLink();
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            self.generateLink();
            self.registerListeners();
        }));

        return result;
    };

    ctlProto.createPdf = function () {
        var self = this;

        var loadingCtrl = self.map.getControlsByClass(TC.control.LoadingIndicator)[0];
        var hasWait = loadingCtrl.addWait();

        TC.loadJS(!window.pdfMake, [TC.Consts.url.PDFMAKE], function () {
            const olViewport = self.map.div.querySelectorAll('.ol-viewport');
            for (var i = 0, len = olViewport.length; i < len; i++) {
                const elm = olViewport[i];
                if (!elm.parentElement.classList.contains('ol-overviewmap-map')) {
                    self.canvas = elm.querySelector('canvas');
                    break;
                }
            }

            var layout = getLayout(self.orientation || ORIENTATION.PORTRAIT, self.format.toString().toUpperCase() || "A4");
            var printLayout = layout.layoutPDF;

            const createPDF = function (printLayout) {
                var filename = window.location.host + '_';
                var title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();

                if (title) {
                    filename += title;
                } else {
                    var currentDate = TC.Util.getFormattedDate(new Date().toString(), true);
                    filename += currentDate;
                }

                try {
                    pdfMake.createPdf(printLayout).download(filename.replace(/[\\\/:*?"<>\|]/g, "") + '.pdf');
                } catch (error) {
                    self.map.toast(self.getLocaleString('print.error'), { type: TC.Consts.msgType.ERROR });
                    TC.error(error.message + '  ' + error.stack, TC.Consts.msgErrorMode.EMAIL);
                }

                loadingCtrl.removeWait(hasWait);
            };

            const imageErrorHandling = function (imageUrl) {
                TC.error(self.getLocaleString('print.error'));
                TC.error('No se ha podido generar el base64 correspondiente a la imagen: ' + imageUrl, TC.Consts.msgErrorMode.EMAIL, 'Error en la impresión'); //Correo de error
            };

            const getLogo = function () {

                const onLogoError = function () {
                    var logoColumn = getLogoColumn(layout);
                    delete logoColumn.image;
                    logoColumn.text = "";
                    return logoColumn;
                };

                if (self.options.logo) {
                    return TC.Util.imgToDataUrl(self.options.logo, 'image/png').then(function (result) {
                        const canvas = result.canvas;
                        const dataUrl = result.dataUrl;
                        var size = TC.Util.calculateAspectRatioFit(canvas.width, canvas.height, layout.logoWidth, layout.logoHeight);

                        var logoColumn = getLogoColumn(layout);
                        logoColumn.image = dataUrl;
                        return logoColumn;

                    }, function () {
                        imageErrorHandling(self.options.logo);

                        return onLogoError();
                    });
                } else {
                    return onLogoError();
                }
            };
            const getScaleBar = function () {
                const onError = function () {
                    var scaleBarColumn = getScaleBarColumn(layout);
                    delete scaleBarColumn.image;
                    scaleBarColumn.text = "";
                    scaleBarColumn.width = "auto";
                    return scaleBarColumn;
                };

                var scaleCtrl = self.map.getControlsByClass(TC.control.ScaleBar)[0];
                if (scaleCtrl) {
                    var elem = document.getElementsByClassName("ol-scale-line-inner"); // no cogemos el DIV del control ya que contiene los bordes y suman al ancho total
                    var bounding = elem[0].getBoundingClientRect();
                    if (bounding) {
                        var styling = getComputedStyle(elem[0], null);
                        var leftBorder = parseInt(styling.getPropertyValue('border-left-width').replace('px', '')) || 0;
                        var rightBorder = parseInt(styling.getPropertyValue('border-right-width').replace('px', '')) || 0;

                        var scaleBarColumn = getScaleBarColumn(layout);

                        scaleBarColumn.table = {
                            widths: [((bounding.width > bounding.height ? bounding.width : bounding.height) - leftBorder - rightBorder) * 0.75], // lo pasamos a pt
                            body: [
                                [{ border: [true, false, true, true], text: scaleCtrl.getText(), fontSize: 10, alignment: 'center' }]
                            ]
                        };

                        scaleBarColumn.layout = {
                            paddingLeft: function (i, node) { return 0; },
                            paddingRight: function (i, node) { return 0; },
                            paddingTop: function (i, node) { return 0; },
                            paddingBottom: function (i, node) { return 0; }
                        };

                        return scaleBarColumn;
                    } else {
                        onError();
                    }
                } else {
                    onError();
                }
            };
            const getLegend = function () {
                var content = [];
                var layers = self.map.workLayers.filter(function (layer) {
                    return layer.type === TC.Consts.layerType.WMS && layer.getVisibility();
                });
                var legendByGroup = [];
                var indentationIncrement = 7;

                var _process = function (value, parentLayer, treeLevel) {
                    if (parentLayer.isVisibleByScale(value.name)) { //Si la capa es visible, la mostramos en la leyenda
                        var src,
                            srcBase64;

                        //Para las capas cargadas por POST (por ejemplo la búsquedas de Comercio Pamplona)
                        if (parentLayer.options && parentLayer.options.params && parentLayer.options.params.base64LegendSrc) {
                            srcBase64 = parentLayer.options.params.base64LegendSrc;
                        }
                        else if (value.legend) {
                            src = value.legend.src;
                        }

                        result.push({ src: src, title: value.title, level: treeLevel, srcBase64: srcBase64 });
                    }
                };
                var _traverse = function (o, func, parentLayer, treeLevel) {
                    if (Array.isArray(o)) {
                        for (var i = 0; i < o.length; i++) {
                            _traverse(o[i], func, parentLayer, treeLevel);
                        }
                    } else {
                        if (o && o.hasOwnProperty('children') && o.children.length > 0) {
                            if (o.title && o.name) {
                                result.push({ header: o.title, level: treeLevel });
                            }
                            _traverse(o.children, func, parentLayer, ++treeLevel);
                        }
                    }

                    if (o && o.hasOwnProperty('children') && o.children.length == 0) {
                        func.apply(this, [o, parentLayer, treeLevel]);
                        treeLevel--;
                    }
                };
                var _getLegendImages = function () {
                    var imagePromises = [];

                    for (var i = 0; i < legendByGroup.length; i++) {
                        var layers = legendByGroup[i].layers;

                        for (var j = 0; j < layers.length; j++) {
                            (function (k, l) {
                                var layer = legendByGroup[k].layers[l];
                                var src = layer.src || layer.srcBase64;

                                if (src) {

                                    if (!TC.tool || !TC.tool.Proxification) {
                                        TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
                                    }

                                    imagePromises.push(new Promise(function (resolve, reject) {
                                        var toolProxification = new TC.tool.Proxification(TC.proxify, { allowedMixedContent: true });
                                        toolProxification.fetchImage(src, { exportable: true }).then(function (img) {
                                            if (img.complete) {
                                                var imageDetail = TC.Util.imgTagToDataUrl(img, 'image/png');
                                                layer.image = { base64: imageDetail.base64, canvas: imageDetail.canvas };
                                            } else {
                                                imageErrorHandling(src);
                                            }

                                            resolve();

                                        }, function (error) {
                                            imageErrorHandling(src);
                                            reject();
                                        });
                                    }));
                                }
                            })(i, j);
                        }
                    }

                    return imagePromises;
                };

                layers.forEach(function (layer) {
                    result = [];

                    var hideTree = layer.options.hideTree;

                    layer.tree = null;
                    layer.options.hideTree = true;

                    _traverse(layer.getTree(), _process, layer, 0);

                    layer.options.hideTree = hideTree;

                    if (result.length > 0) {
                        legendByGroup.push({ title: layer.title, layers: result });
                    }
                });

                return new Promise(function (resolve, reject) {
                    Promise.all(_getLegendImages()).then(function () {

                        const getGroupTable = function (group, index) {                            
                            var rows = [[{ text: group.title, colSpan: 2, alignment: 'left', fontSize: 11, margin: [0, index > 0 ? 10 : 0, 0, 5] }, {}]];
                            var indentation = 10;

                            rows = rows.concat(group.layers.filter(function (item) {
                                return item.hasOwnProperty('header') && item.header.trim().toLowerCase() !== group.title.trim().toLowerCase();
                            }).map(function (item) {
                                return [{ text: item.header.trim(), colSpan: 2, alignment: 'left', margin: [indentation * item.level, 0, 0, 3] }, {}];
                            }));

                            const headerRows = rows.length;
                            var headerItem = null;
                            var itemIndex = null;

                            const getLayerTable = function (item, index) {
                                if (item.header) {
                                    headerItem = item;

                                    if (itemIndex) {
                                        itemIndex = null;
                                    }
                                } else {
                                    if (!itemIndex) {
                                        itemIndex = 1;
                                    }

                                    var position;
                                    if (headerItem) {
                                        var headerIndex = rows.map(function (item) { return item[0].text }).indexOf(headerItem.header);
                                        position = headerIndex + itemIndex++;
                                    }

                                    if (item.image) {
                                        var imageWidth = item.image.canvas.width / 2;
                                        var imageHeight = (imageWidth * item.image.canvas.height / item.image.canvas.width);

                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            width: 'auto',
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {
                                            image: item.image.base64,
                                            width: imageWidth,
                                            height: imageHeight,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }

                                    } else {
                                        var data = [{
                                            text: item.title,
                                            fontSize: 9,
                                            colSpan: 2,
                                            margin: [indentation * item.level, 0, 0, 2]
                                        }, {}];

                                        if (position) {
                                            rows.splice(position, 0, data);
                                        } else {
                                            rows.push(data);
                                        }
                                    }
                                }
                            };

                            group.layers.forEach(getLayerTable);

                            content.push({
                                layout: 'noBorders',
                                table: {
                                    dontBreakRows: true,
                                    keepWithHeaderRows: 1,
                                    headerRows: headerRows,
                                    body: rows
                                }
                            });
                        };

                        legendByGroup.map(function (group, index) {
                            return {
                                groupIndex: index,
                                height: group.layers.filter(function (item) {
                                    return item.image && item.image.canvas;
                                }).reduce(function (prev, current, index, vector) {
                                    return prev + vector[index].image.canvas.height;
                                }, 0)
                            }
                        }).sort(function (a, b) {
                            if (a.height > b.height) {
                                return 1;
                            }
                            if (a.height < b.height) {
                                return -1;
                            }
                            return 0;
                        }).forEach(function (groupWithHeight, index) {
                            getGroupTable(legendByGroup[groupWithHeight.groupIndex], index)
                        });

                        resolve(content);

                    }, function () {
                        reject([]);
                    });
                });
            };
            const drawQR = function () {
                // GLS: añadimos el QR
                //QR
                if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
                    const qrTarget = document.querySelector('.' + self.CLASS + '-qrcode');
                    qrTarget.innerHTML = '';
                    return self.makeQRCode(qrTarget, options.qrCode.sideLength, options.qrCode.sideLength).then(function (qrCodeBase64) {
                        if (qrCodeBase64) {
                            return TC.Util.addToCanvas(self.canvas, qrCodeBase64, { x: self.canvas.width - options.qrCode.sideLength, y: self.canvas.height - options.qrCode.sideLength }, {width: options.qrCode.sideLength, height: options.qrCode.sideLength }).then(function (mapCanvas) {
                                return mapCanvas;
                            });
                        } else {
                            TC.error(self.getLocaleString('print.qr.error'));
                            return self.canvas;
                        }
                    });
                } else {
                    return self.canvas;
                }
            };

            const basics = [getLogo, function () {
                var titleColumn = getTitleColumn(layout);
                titleColumn.text = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                return titleColumn;
            }, getScaleBar, drawQR];

            Promise.all(basics.map(function (fn) {
                return fn();
            })).then(function (basicsDone) {

                if (basicsDone[2].table) { // GLS: ajustamos el ancho del título para arrinconar la escala
                    layout.layoutPDF.content[0].columns[1].width = layout.layoutPDF.pageSize.width - (layout.layoutPDF.pageMargins[0] + layout.layoutPDF.pageMargins[2]) - layout.layoutPDF.content[0].columns[0].width - (layout.layoutPDF.content[0].columns[2].table.widths[0] + 2);
                }

                var mapPlace = getMap(layout);
                var canvas = basicsDone[3] || self.canvas;

                mapPlace.image = canvas.toDataURL();

                if (self.options.legend &&
                    self.options.legend.visible &&
                    hasLegendToPrint.call(self) && // GLS: validamos que haya capas visibles por escala 
                    printLayout.content.length == 2) { // GLS: es la primera descarga o hemos resetado la leyenda por algún zoom por lo que no tenemos la leyenda en el layout

                    const title = self.div.querySelector('.' + self.CLASS + '-title').value.trim();
                    printLayout.content.push({
                        pageBreak: 'before',
                        pageOrientation: self.options.legend.orientation || 'portrait',
                        text: title.length > 0 ? title : '',
                        fontSize: 14,
                        margin: [0, 20, 0, 10]
                    });

                    getLegend().then(function (content) {
                        printLayout.content = printLayout.content.concat(content);
                        createPDF(printLayout);
                    });
                } else {
                    createPDF(printLayout);
                }
            });
        });
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const alertElm = self.div.querySelector('.' + self.CLASS + '-alert');
        if (document.querySelector("#" + self.CLASS + "-image-qr").checked) {
            if (maxLengthExceed.qr) {
                alertElm.classList.remove(TC.Consts.classes.HIDDEN);
            } else {
                alertElm.classList.add(TC.Consts.classes.HIDDEN);
            }
        } else {
            alertElm.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

})();
﻿
TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.Consts.event.RESULTTOOLTIP = 'resulttooltip.tc';
TC.Consts.event.RESULTTOOLTIPEND = 'resulttooltipend.tc';
TC.Consts.event.DRAWCHART = 'drawchart.tc';
TC.Consts.event.DRAWTABLE = 'drawtable.tc';
TC.Consts.event.RESULTSPANELMIN = 'resultspanelmin.tc';
TC.Consts.event.RESULTSPANELMAX = 'resultspanelmax.tc';
TC.Consts.event.RESULTSPANELCLOSE = 'resultspanelclose.tc';

TC.control.ResultsPanel = function () {
    var self = this;

    TC.Control.apply(self, arguments);

    self.wrap = new TC.wrap.control.ResultsPanel(self);

    self.data = {};
    self.classes = {
        FA: 'fa',
        SHOW_IN: 'showIn',
        SHOW_OUT: 'showOut'
    };

    self.contentType = {
        TABLE: {
            fnOpen: TC.control.ResultsPanel.prototype.openTable,
            collapsedClass: '.fa-list-alt'
        },
        CHART: {
            fnOpen: TC.control.ResultsPanel.prototype.openChart,
            collapsedClass: '.fa-area-chart'
        }
    };

    self.content = self.contentType.TABLE;

    if ($.isEmptyObject(self.options)) {
        self.options = { content: "table" };
    }

    if (self.options || { content: "table" }) {
        if (self.options.content)
            self.content = self.contentType[self.options.content.toUpperCase()];

        if (self.options.chart)
            self.chart = self.options.chart;

        if (self.options.table)
            self.table = self.options.table;

        if (self.options.save)
            self.save = self.options.save;
    }
};

TC.inherit(TC.control.ResultsPanel, TC.Control);

(function () {

    const ctlProto = TC.control.ResultsPanel.prototype;

    ctlProto.CLASS = 'tc-ctl-p-results';

    ctlProto.template = {};

    ctlProto.CHART_SIZE = {
        MIN_HEIGHT: 75,
        MAX_HEIGHT: 128,

        MIN_WIDTH: 215,
        MEDIUM_WIDTH: 310,
        MAX_WIDTH: 445
    };

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ResultsPanel.html";
        ctlProto.template[ctlProto.CLASS + '-table'] = TC.apiLocation + "TC/templates/ResultsPanelTable.html";
        ctlProto.template[ctlProto.CLASS + '-chart'] = TC.apiLocation + "TC/templates/ResultsPanelChart.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"prpanel-group prsidebar-body \" style=\"display: none\" data-no-cb><div class=\"prpanel prpanel-default\"><div class=\"prpanel-heading\"><h4 class=\"prpanel-title\"><span class=\"prpanel-title-text\"></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-close\" title=\"").h("i18n", ctx, {}, { "$key": "close" }).w("\"><i class=\"fa fa-times\"></i></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-min\" title=\"").h("i18n", ctx, {}, { "$key": "hide" }).w("\"><i class=\"fa fa-chevron-left\"></i></span><span class=\"prcollapsed-pull-right prcollapsed-slide-submenu prcollapsed-slide-submenu-csv\" hidden title=\"").h("i18n", ctx, {}, { "$key": "export.excel" }).w("\"><i class=\"fa fa-file-excel-o\"></i></span></h4></div><div id=\"results\" class=\"prpanel-collapse collapse in\"><div class=\"tc-ctl-p-results-menu\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-info\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-table\"></div><div class=\"prpanel-body list-group tc-ctl-p-results-chart\"></div></div></div></div><div class=\"prcollapsed prcollapsed-max prcollapsed-pull-left\" style=\"display: none;\" title=\"").h("i18n", ctx, {}, { "$key": "expand" }).w("\" data-no-cb><i class=\"fa-list-alt\" hidden></i><i class=\"fa-area-chart\" hidden></i></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-table'] = function () { dust.register(ctlProto.CLASS + '-table', body_0); function body_0(chk, ctx) { return chk.w("<table class=\"table\" style=\"display:none;\"><thead>").s(ctx.get(["columns"], false), ctx, { "block": body_1 }, {}).w("</thead><tbody>").s(ctx.get(["results"], false), ctx, { "block": body_2 }, {}).w("</tbody></table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<th>").f(ctx.getPath(true, []), ctx, "h").w("</th>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<tr>").h("iterate", ctx, { "block": body_3 }, { "on": ctx.getPath(true, []) }).w("</tr>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<td>").f(ctx.get(["value"], false), ctx, "h").w("</td>"); } body_3.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-chart'] = function () { dust.register(ctlProto.CLASS + '-chart', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-track-chart\">").x(ctx.get(["msg"], false), ctx, { "else": body_1, "block": body_2 }, {}).w("</div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<span id=\"elevationGain\" >").h("i18n", ctx, {}, { "$key": "geo.trk.chart.elevationGain" }).w(": +").f(ctx.get(["upHill"], false), ctx, "h").w("m, -").f(ctx.get(["downHill"], false), ctx, "h").w("m</span><div class=\"tc-chart\"></div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.f(ctx.get(["msg"], false), ctx, "h"); } body_2.__dustBody = !0; return body_0 };
    }

    const isElementVisible = function (elm) {
        const computedStyle = getComputedStyle(elm);
        return (elm && !elm.hidden && computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden');
    };

    ctlProto.isVisible = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(bodyElm) || isElementVisible(maximizeElm);
    };

    ctlProto.isMinimized = function () {
        const self = this;
        const bodyElm = self.div.querySelector('.prsidebar-body');
        const maximizeElm = self.div.querySelector('.prcollapsed-max');
        return isElementVisible(maximizeElm) && !isElementVisible(bodyElm);
    };

    const manageClassList = function (classElement, toAdd, toRemove) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.classList.add(toAdd);
            elm.classList.remove(toRemove);
        }
    };

    ctlProto.show = function (classElement) {
        const self = this;

        const elm = self.div.querySelector('.' + classElement);
        if (elm && elm.style.display === 'none') {
            elm.style.display = '';
        }

        manageClassList.call(self, classElement, self.classes.SHOW_IN, self.classes.SHOW_OUT);
    };

    ctlProto.hide = function (classElement) {
        const self = this;

        manageClassList.call(self, classElement, self.classes.SHOW_OUT, self.classes.SHOW_IN);

        const elm = self.div.querySelector('.' + classElement);
        if (elm) {
            elm.style.display = 'none';
        }
    };

    ctlProto.doVisible = function () {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);
        self.show('prsidebar-body');
    };

    ctlProto.render = function (callback) {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        return TC.Control.prototype.render.call(self, function () {

            self.mainTitleElm = self.div.querySelector('.prpanel-title-text');

            self.minimizeButton = self.div.querySelector('.prcollapsed-slide-submenu-min');
            self.minimizeButton.addEventListener('click', function () {
                self.minimize();
            });

            self.closeButton = self.div.querySelector('.prcollapsed-slide-submenu-close');
            self.closeButton.addEventListener('click', function () {
                self.close();
            });

            self.maximizeButton = self.div.querySelector('.prcollapsed-max');
            self.maximizeButton.addEventListener('click', function () {
                self.maximize();
            });

            if (self.save) {
                self.saveButton = self.div.querySelector('.prcollapsed-slide-submenu-csv');
                self.saveButton.addEventListener('click', function () {
                    self.exportToExcel();
                });
                self.saveButton.removeAttribute('hidden');
            }

            if (self.content) {
                self.content = self.content;

                if (self.options.titles) {

                    if (self.options.titles.main) {
                        self.mainTitleElm.setAttribute('title', self.options.titles.main);
                        self.mainTitleElm.innerHTML = self.options.titles.main;
                    }

                    if (self.options.titles.max) {
                        self.maximizeButton.setAttribute('title', self.options.titles.max);
                    }
                } else {
                    self.mainTitleElm.setAttribute('title', self.getLocaleString("rsp.title"));
                    self.mainTitleElm.innerHTML = self.getLocaleString("rsp.title");
                }
            }

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            //collapsedElm.hidden = false;
            collapsedElm.classList.add(self.classes.FA);

            self.infoDiv = self.div.querySelector('.' + self.CLASS + '-info');
            self.tableDiv = self.div.querySelector('.' + self.CLASS + '-table');
            //self.$divChart = self._$div.find('.' + self.CLASS + '-chart');
            self.menuDiv = self.div.querySelector('.' + self.CLASS + '-menu');

            if (Modernizr.touch) {
                TC.Util.swipe(self.div, {
                    left: function () {
                        self.minimize();
                    }
                });
            }

            if (callback && typeof (callback) === "function")
                callback.call();
        });
    };

    ctlProto.minimize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (!isElementVisible(collapsedElm)) { // ya está minimizado
            collapsedElm.classList.add(self.classes.FA);
            collapsedElm.hidden = false;

            self.hide('prsidebar-body');
            self.show('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMIN, { control: self });
        }
    };

    ctlProto.maximize = function () {
        const self = this;

        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) { // ya está maximizado
            collapsedElm.hidden = true;

            self.show('prsidebar-body');
            self.hide('prcollapsed-max');

            self.map.trigger(TC.Consts.event.RESULTSPANELMAX, { control: self });
        }
    };

    ctlProto.close = function () {
        const self = this;

        self.div.classList.add(TC.Consts.classes.HIDDEN);

        if (self.chart && self.chart.chart) {
            self.chart.chart = self.chart.chart.destroy();
        }

        const body = self.div.querySelector('.prsidebar-body');
        if (body) {
            body.style.display = 'none';
            self.div.querySelector('.prcollapsed-max').style.display = 'none';

            const collapsedElm = self.div.querySelector(self.content.collapsedClass);
            collapsedElm.hidden = true;
            collapsedElm.classList.remove(self.classes.FA);

            self.map.trigger(TC.Consts.event.RESULTSPANELCLOSE, { control: self });
        }
    };

    ctlProto.openChart = function (data) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        // Cerramos el resto de los perfiles
        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self;
            })
            .filter(function (ctl) {
                return ctl.options.content === 'chart';
            })
            .forEach(function (ctl) {
                ctl.close();
            });

        if (data) {

            if (data.msg) {
                self.map.toast(data.msg);
            }
            else {
                self.elevationProfileCoordinates = data.coords;
                self.renderElevationProfileChart({
                    data: data,
                    div: self.div.querySelector('.' + ctlProto.CLASS + '-chart')
                });
            }
        } else {
            self.map.toast(options.msg);
        }

        self.map.getLoadingIndicator().hide();
    };

    ctlProto.renderElevationProfileChart = function (options) {
        const self = this;
        options = options || {};
        TC.loadJS(!window.c3,
            TC.Consts.url.D3C3 || TC.apiLocation + 'lib/d3c3/d3c3.min.js',
            function () {
                const data = options.data;
                const div = options.div;
                var locale = TC.Util.getMapLocale(self.map);
                self.getRenderedHtml(ctlProto.CLASS + '-chart', { upHill: data.upHill.toLocaleString(locale), downHill: data.downHill.toLocaleString(locale) }, function (out) {

                    div.innerHTML = out;
                    div.style.display = '';

                    if (self.options.titles) {

                        if (self.options.titles.main) {
                            const titleElm = self.div.querySelector('.prpanel-title-text');
                            titleElm.setAttribute('title', self.options.titles.main);
                            titleElm.innerHTML = self.options.titles.main;
                        }

                        if (self.options.titles.max) {
                            self.div.querySelector('.prcollapsed-max').setAttribute('title', self.options.titles.max);
                        }
                    }
                    var chartOptions = $.extend({
                        bindto: div.querySelector('.tc-chart'),
                        padding: {
                            top: 0,
                            right: 15,
                            bottom: 0,
                            left: 45,
                        },
                        legend: {
                            show: false
                        }
                    }, self.createChartOptions(data));

                    if (self.chart.tooltip) {
                        chartOptions.tooltip = {
                            contents: function (d) {
                                var fn = self.chart.tooltip;
                                if (typeof (fn) !== "function")
                                    fn = TC.Util.getFNFromString(self.chart.tooltip);
                                return fn.call(eval(self.chart.ctx), d);
                            }
                        }
                    }

                    if (self.chart && self.chart.onmouseout) {
                        chartOptions.onmouseout = function () {
                            var fn = self.chart.onmouseout;
                            if (typeof (fn) !== "function")
                                fn = TC.Util.getFNFromString(self.chart.onmouseout);
                            fn.call(eval(self.chart.ctx));
                        };
                    }

                    chartOptions.onrendered = function () {
                        if ($.isFunction(chartOptions._onrendered)) {
                            chartOptions._onrendered.call(this);
                        }
                        self.map.trigger(TC.Consts.event.DRAWCHART, { control: self, svg: this.svg[0][0], chart: this });
                    };

                    if (window.c3) {

                        if (!c3._isOverriden) {
                            // GLS: Override de la función generateDrawLine y generateDrawArea para establecer otro tipo de interpolación en la línea
                            window.c3.chart.internal.fn.generateDrawLine = function (lineIndices, isSub) {
                                var $$ = this, config = $$.config,
                                    line = $$.d3.svg.line(),
                                    getPoints = $$.generateGetLinePoints(lineIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    yValue = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
                                if (!config.line_connectNull) { line = line.defined(function (d) { return d.value != null; }); }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x = isSub ? $$.x : $$.subX, y = yScaleGetter.call($$, d.id), x0 = 0, y0 = 0, path;
                                    if ($$.isLineType(d)) {
                                        if (config.data_regions[d.id]) {
                                            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                                        } else {
                                            if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                            path = line.interpolate('linear')(values);
                                        }
                                    } else {
                                        if (values[0]) {
                                            x0 = x(values[0].x);
                                            y0 = y(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            window.c3.chart.internal.fn.generateDrawArea = function (areaIndices, isSub) {
                                var $$ = this, config = $$.config, area = $$.d3.svg.area(),
                                    getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
                                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                                    xValue = function (d) { return (isSub ? $$.subxx : $$.xx).call($$, d); },
                                    value0 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(0);
                                    },
                                    value1 = function (d, i) {
                                        return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
                                    };
                                area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(value0).y1(value1);
                                if (!config.line_connectNull) {
                                    area = area.defined(function (d) { return d.value !== null; });
                                }
                                return function (d) {
                                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                                        x0 = 0, y0 = 0, path;
                                    if ($$.isAreaType(d)) {
                                        if ($$.isStepType(d)) { values = $$.convertValuesToStep(values); }
                                        path = area.interpolate('linear')(values);
                                    } else {
                                        if (values[0]) {
                                            x0 = $$.x(values[0].x);
                                            y0 = $$.getYScale(d.id)(values[0].value);
                                        }
                                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                                    }
                                    return path ? path : "M 0 0";
                                };
                            };
                            c3._isOverriden = true;
                        }

                        self.chart.chart = c3.generate(chartOptions);
                    }
                });
            }
        );
    };

    const closeOpenedTableResultsPanel = function () {
        const self = this;

        self.map.getControlsByClass(TC.control.ResultsPanel)
            .filter(function (ctl) {
                return ctl !== self && ctl.isVisible();
            })
            .filter(function (ctl) {
                return ctl.options.content !== self.contentType.CHART;
            })
            .forEach(function (ctl) {
                ctl.close();
            });
    };

    ctlProto.openTable = function () {
        var self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        var data = arguments[0];
        if (data) {

            var deleteColumns = function () {
                for (var i = 0; i < data.length; i++) {
                    for (var k in data[i]) {
                        if (columns.indexOf(k) < 0) {
                            delete data[i][k];
                        }
                    }
                }
            };

            var css;
            if (data.css) {
                css = data.css;
            }
            var callback = data.callback;
            var columns = data.columns, data = data.data;

            if (data && data.length > 0) {
                //Si no recibe columnas, las extrae de las claves del primer objeto de la colección de datos
                if (!columns) {
                    columns = [];
                    for (var k in data[0]) {
                        columns.push(k);
                    }
                }

                //deleteColumns();

                self.tableData = {
                    columns: columns,
                    results: data,
                    css: css,
                    callback: callback
                }
                self.getRenderedHtml(self.CLASS + '-table', self.tableData).then(function (html) {
                    const table = self.div.querySelector('.' + self.CLASS + '-table');
                    const parent = table.parentElement;
                    parent.removeChild(table);
                    table.innerHTML = html;
                    parent.appendChild(table);
                    if (self.tableData.callback) {
                        self.tableData.callback(table);
                    }

                    closeOpenedTableResultsPanel.call(self);

                    self.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
                });

                self.div.querySelector('.' + self.CLASS + '-chart').style.display = 'none';
                self.div.querySelector('.' + self.CLASS + '-info').style.display = 'none';

                self.show('prsidebar-body');
            }
        }

        self.map.getLoadingIndicator().hide();

    };

    ctlProto.open = function (html, container) {
        const self = this;

        self.div.classList.remove(TC.Consts.classes.HIDDEN);

        const toCheck = container || self.div.querySelector('.' + self.CLASS + '-table');
        var checkIsRendered = function () {
            var clientRect = toCheck.getBoundingClientRect();
            if (clientRect && clientRect.width > 100) {
                window.cancelAnimationFrame(this.requestIsRendered);

                //closeOpenedTableResultsPanel.call(self);
                this.map.trigger(TC.Consts.event.DRAWTABLE, { control: self });
            }
        };

        self.requestIsRendered = window.requestAnimationFrame(checkIsRendered.bind(self));

        const chartElm = self.div.querySelector('.' + self.CLASS + '-chart');
        chartElm.style.display = 'none';
        const tableElm = self.div.querySelector('.' + self.CLASS + '-table');
        tableElm.style.display = 'none';
        const infoElm = self.div.querySelector('.' + self.CLASS + '-info');
        infoElm.style.display = 'none';

        if (html) {
            if (container) {
                self.getTableContainer = function () {
                    return container;
                };
                container.innerHTML = html;
                container.style.display = '';
            } else {
                tableElm.innerHTML = html;
                tableElm.style.display = '';
            }
        }

        const maximizeElm = self.div.querySelector('.prcollapsed-max');

        if (self.options.titles) {

            if (self.options.titles.main) {
                const titleElm = self.div.querySelector('.prpanel-title-text');
                titleElm.setAttribute('title', self.options.titles.main);
                titleElm.innerHTML = self.options.titles.main;
            }

            if (self.options.titles.max) {
                maximizeElm.setAttribute('title', self.options.titles.max);
            }
        }

        if (self.options.classes) {
            if (self.options.classes.collapsed) {
                maximizeElm.querySelector('i.fa-list-alt').classList.add(self.options.classes.collapsed);
            }
        }

        // si está minimizado
        const collapsedElm = self.div.querySelector(self.content.collapsedClass);
        if (isElementVisible(collapsedElm)) {
            self.maximize();
        }

        self.show('prsidebar-body');
        self.hide('prcollapsed-max');

        self.map.getLoadingIndicator().hide();
    };

    ctlProto.createChartOptions = function (options) {
        const self = this;
        var result = {};
        options = options || {};
        const locale = options.locale || TC.Util.getMapLocale(self.map);
        switch (options.chartType) {
            default:
                if (options.ele != null) {
                    const getChartSize = function () {
                        const docWidth = document.documentElement.clientWidth / 100 * 40; // css panel contendor
                        return {
                            height: docWidth > 445 ? options.maxHeight || self.CHART_SIZE.MAX_HEIGHT : options.minHeight || self.CHART_SIZE.MIN_HEIGHT,
                            width: docWidth > 445 ? options.maxWidth || self.CHART_SIZE.MAX_WIDTH : docWidth > 310 ? options.mediumWidth || self.CHART_SIZE.MEDIUM_WIDTH : options.minWidth || self.CHART_SIZE.MIN_WIDTH
                        };
                    };

                    var maxy = Number.NEGATIVE_INFINITY;
                    var miny = Number.POSITIVE_INFINITY;
                    options.ele.forEach(function (y) {
                        if (typeof y === 'number') {
                            maxy = Math.max(y, maxy);
                            miny = Math.min(y, miny);
                        }
                    });

                    const gradId = 'grad' + TC.getUID();

                    result = {
                        data: {
                            x: 'x',
                            columns: [['x'].concat(options.x), ['ele'].concat(options.ele)],
                            types: { 'ele': 'area-spline' }, colors: {
                                "ele": 'url(#' + gradId + ')'
                            }
                        },
                        size: getChartSize(),
                        point: {
                            show: false
                        },
                        axis: {
                            x: {
                                tick: {
                                    outer: false,
                                    count: 5, format: function (d) {
                                        d = d / 1000;
                                        var dist;
                                        var measure;
                                        if (d < 1) {
                                            dist = Math.round(d * 1000);
                                            measure = ' m';
                                        } else {
                                            dist = Math.round(d * 100) / 100;
                                            measure = ' km';
                                        }

                                        dist = dist.toLocaleString(locale);
                                        return dist + measure;
                                    }
                                }
                            },
                            y: {
                                padding: {
                                    top: 0, bottom: 0
                                },
                                max: maxy,
                                min: miny,
                                tick: {
                                    count: 2,
                                    format: function (d) {
                                        return (parseInt(d.toFixed(0)) || 0).toLocaleString(locale) + 'm';
                                    }
                                }
                            }
                        },
                        onresize: function () {
                            this.api.resize(getChartSize());                            
                        }
                    }

                    if (options.time) result.time = ("00000" + options.time.h).slice(-2) + ':' + ("00000" + options.time.m).slice(-2) + ':' + ("00000" + options.time.s).slice(-2);

                    result._onrendered = function () {
                        const svg = this.svg[0][0];
                        var svgDefsElement = svg.getElementsByTagName('defs')[0];
                        var xmlns = "http://www.w3.org/2000/svg";
                        var grad = document.createElementNS(xmlns, "linearGradient");
                        grad.setAttributeNS(null, "id", gradId);
                        grad.setAttributeNS(null, "x1", "0%");
                        grad.setAttributeNS(null, "x2", "0%");
                        grad.setAttributeNS(null, "y1", "0%");
                        grad.setAttributeNS(null, "y2", "100%");
                        grad.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");

                        const stop0 = document.createElementNS(xmlns, "stop");
                        stop0.setAttributeNS(null, "offset", "0%");
                        stop0.setAttributeNS(null, "stop-color", "red");
                        stop0.setAttributeNS(null, "stop-opacity", "0.7");
                        grad.appendChild(stop0);

                        const stop50 = document.createElementNS(xmlns, "stop");
                        stop50.setAttributeNS(null, "offset", "50%");
                        stop50.setAttributeNS(null, "stop-color", "orange");
                        stop50.setAttributeNS(null, "stop-opacity", "0.9");
                        grad.appendChild(stop50);

                        const stop100 = document.createElementNS(xmlns, "stop");
                        stop100.setAttributeNS(null, "offset", "100%");
                        stop100.setAttributeNS(null, "stop-color", "green");
                        stop100.setAttributeNS(null, "stop-opacity", "1");
                        grad.appendChild(stop100);

                        svgDefsElement.appendChild(grad);

                        const d3Node = d3.select(".c3-brush").node();
                        if (d3Node) {
                            d3Node.parentNode.removeChild(d3Node);
                        }

                        d3.select(".c3-event-rects,.c3-event-rects-single")
                            .selectAll("rect")
                            .style("cursor", "pointer")
                            .on("click", function (e) {
                                d3.event.stopPropagation();
                                const point = self.elevationProfileCoordinates[e.index].slice(0, 2);
                                if (point) {
                                    TC.loadJS(!TC.feature || (TC.feature && !TC.feature.Point),
                                        [TC.apiLocation + 'TC/feature/Point'],
                                        function () {
                                            self.map.zoomToFeatures([new TC.feature.Point(point)]);
                                        }
                                    );
                                }
                            });

                        var pattern = d3.select('.c3-axis.c3-axis-x').select('path').attr('d');
                        var match = /^M\d\,(\d)V\dH\d{3}V(\d)$/i.exec(pattern);
                        if (match) { // quitamos las barritas de los extremos del axis-x
                            pattern = pattern.replace(/(M\d\,)\d/i, "$10").replace(/(H\d{3}V)(\d)/i, "$10");
                            d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                        } else {
                            var match = /^M\s\d\s(\d)\sV\s\d\sH\s\d{3}\sV\s(\d)$/i.exec(pattern);
                            if (match) { // quitamos las barritas de los extremos del axis-x
                                pattern = pattern.replace(/(M\s\d\s)\d/i, "$10").replace(/(H\s\d{3}\sV\s)(\d)/i, "$10");
                                d3.select('.c3-axis.c3-axis-x').select('path').attr('d', pattern);
                            }
                        }

                        const svgRect = svg.getBoundingClientRect();
                        const chartSize = {
                            width: svgRect.width,
                            height: svgRect.height
                        };

                        // ¿es necesario pasar los labels a multiline?
                        var setMultilineLabels = function () {
                            var x = d3.scale.ordinal().rangeRoundBands([0, chartSize.width], .1, .3);
                            d3.select('.c3-axis-x').selectAll('text:not(.c3-axis-x-label)')
                                .call(function (textNode, width) {
                                    textNode.each(function () {
                                        textNode.each(function (d, i) {
                                            if (i == 0) return;

                                            d3text = d3.select(this);
                                            
                                            if (d3text.node().childNodes.length === 1) {                                                
                                                var clone = d3text.select('tspan').node().cloneNode();
                                                var words = d3text.text().split(' ');

                                                d3text.select('tspan').text(words[0]);
                                                clone.textContent = words[1];
                                                var dy = clone.getAttribute('dy');
                                                dy = dy ? parseFloat(clone.getAttribute('dy')) : .71;
                                                dy = dy + 0.18 + 'em';
                                                clone.setAttribute('dy', dy);
                                                d3text.node().appendChild(clone);
                                            }
                                        });
                                    });
                                }, x.rangeBand());
                        };
                        if (!d3.select('.c3-axis-x').node().getBoundingClientRect().width) {

                            if (self.elevationChartLabelsRAF) {
                                window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                self.elevationChartLabelsRAF = undefined;
                            }

                            function hasSize() {
                                if (d3.select('.c3-axis-x').length && !(d3.select('.c3-axis-x').node())) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                }
                                else if (d3.select('.c3-axis-x').length && d3.select('.c3-axis-x').node() &&
                                    !d3.select('.c3-axis-x').node().getBoundingClientRect().width) {
                                    self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                                } else {
                                    window.cancelAnimationFrame(self.elevationChartLabelsRAF);
                                    self.elevationChartLabelsRAF = undefined;

                                    if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                                        (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                                        setMultilineLabels();
                                    }
                                }
                            }

                            self.elevationChartLabelsRAF = requestAnimationFrame(hasSize);
                        }
                        else if (((d3.select('.c3-axis-x').node().getBoundingClientRect().width >= chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) ||
                            (d3.select('.c3-axis-x').node().getBoundingClientRect().width * 100 / (chartSize.width - d3.select('.c3-axis-y').node().getBoundingClientRect().width) > 90))) {
                            setMultilineLabels();
                        }

                        if (!self.isMinimized()) {
                            self.show('prsidebar-body');
                            self.hide('prcollapsed-max');
                        }


                        self.div.querySelector('.' + self.CLASS + '-table').style.display = '';
                        self.div.querySelector('.' + self.CLASS + '-info').style.display = '';
                    }
                }
                else {
                    result = {
                        msg: self.getLocaleString("geo.trk.chart.chpe.empty")
                    };
                }
                break;
        }
        return result;
    };

    const getTime = function (timeFrom, timeTo) {
        var diff = timeTo - timeFrom;
        var d = {};
        var daysDifference = Math.floor(diff / 1000 / 60 / 60 / 24);
        diff -= daysDifference * 1000 * 60 * 60 * 24;

        var hoursDifference = Math.floor(diff / 1000 / 60 / 60);
        diff -= hoursDifference * 1000 * 60 * 60;

        d.h = hoursDifference + (daysDifference * 24);

        var minutesDifference = Math.floor(diff / 1000 / 60);
        diff -= minutesDifference * 1000 * 60;

        d.m = minutesDifference;

        d.s = Math.floor(diff / 1000);

        return $.extend({}, d, { toString: ("00000" + d.h).slice(-2) + ':' + ("00000" + d.m).slice(-2) + ':' + ("00000" + d.s).slice(-2) });
    };

    ctlProto.getElevationChartTooltip = function (data) {
        const self = this;
        const coords = self.elevationProfileCoordinates;
        var distance = data[0].x;
        distance = distance / 1000;

        const p = coords[data[0].index];
        var doneTime;
        if (coords[0].length == 4 && coords[0][3] > 0) {
            doneTime = getTime(coords[0][3], p[3]);
        }

        const locale = self.map.options.locale && self.map.options.locale.replace('_', '-') || undefined;
        const ele = parseInt(data[0].value.toFixed(0)).toLocaleString(locale);
        var dist;
        var measure;
        if (distance < 1) {
            dist = Math.round(distance * 1000);
            measure = ' m';
        } else {
            dist = Math.round(distance * 100) / 100;
            measure = ' km';
        }
        dist = dist.toLocaleString(locale);
        return '<div class="track-elevation-tooltip"><div><span>' + ele + ' m </span><br><span>' + dist + measure + ' </span></div>' + (doneTime ? '<span>' + doneTime.toString + '</span><div/>' : '');
    };

    ctlProto.getTableContainer = function () {
        return this.tableDiv;
    };

    ctlProto.getInfoContainer = function () {
        return this.infoDiv;
    };

    ctlProto.getMenuElement = function () {
        return this.menuDiv;
    };

    ctlProto.getContainerElement = function () {
        return this.div || null;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        self.wrap.register(map);

        if (self.openOn) {
            self.map.one(self.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.closeOn) {
            self.map.one(self.closeOn, function (e, args) {
                self.close();
            });
        }

        if (self.options.openOn) {
            self.map.on(self.options.openOn, function (e, args) {
                self.content.fnOpen.call(self, e.data);
            });
        }

        if (self.options.closeOn) {
            self.map.on(self.options.closeOn, function (e, args) {
                self.close();
            });
        }

        //map.on(TC.Consts.event.VIEWCHANGE, function () {

        //    map.getControlsByClass(TC.control.ResultsPanel).filter(function (ctl) {
        //        return ctl.options.content !== "chart" && ($(ctl.div).find('.' + ctl.CLASS + '-info:visible').length === 1 || $(ctl.div).find('.' + ctl.CLASS + '-table:visible').length === 1);
        //    }).forEach(function (ctl) {
        //        ctl.close();
        //    });
        //});

        return result;
    };

    ctlProto.exportToExcel = function () {
        var _ctl = this;

        var rows = [_ctl.tableData.columns];

        $.each(_ctl.tableData.results, function (index, value) {
            var row = [];
            for (var k in value) {
                if (value.hasOwnProperty(k) && k !== "Id" && k !== "Geom") { //Las columnas ID y Geom no aparece en la exportaci\u00f3n
                    row.push(value[k]);
                }
            }
            rows.push(row);
        });
        var _fncSave = function (exporter) {
            var fileName = _ctl.save.fileName ? _ctl.save.fileName : 'resultados.xls';
            var title = (_ctl.options.titles && _ctl.options.titles.main ? _ctl.options.titles.main : null);
            exporter.Save(fileName, rows, title);
        }
        if (!TC.Util.ExcelExport) {
            TC.loadJS(true, TC.apiLocation + 'TC/TC.Util.ExcelExport', function () {
                _fncSave(new TC.Util.ExcelExport());
            });
        }
        else {
            _fncSave(new TC.Util.ExcelExport());
        }
    };
})();
﻿TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.ScaleBar = function () {
    TC.Control.apply(this, arguments);
};

TC.inherit(TC.control.ScaleBar, TC.Control);

(function () {
    var ctlProto = TC.control.ScaleBar.prototype;

    ctlProto.CLASS = 'tc-ctl-sb';

    ctlProto.render = function () {
        var self = this;
        if (!self.wrap) {
            self.wrap = new TC.wrap.control.ScaleBar(self);
        }
        self.wrap.render();
        return self._set1stRenderPromise(Promise.resolve());
    };

    ctlProto.register = function (map) {
        const self = this;
        return new Promise(function (resolve, reject) {
            Promise.all([TC.Control.prototype.register.call(self, map), map.wrap.getMap()]).then(function (objects) {
                objects[1].addControl(self.wrap.ctl);
                resolve(self);
            });
        });
    };

    ctlProto.getText = function () {
        var self = this;

        return self.wrap.getText();
    };

})();
﻿TC.control = TC.control || {};

if (!TC.control.Scale) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/Scale');
}

TC.control.ScaleSelector = function () {
    var self = this;

    TC.control.Scale.apply(self, arguments);

    self.scales = null;
};

TC.inherit(TC.control.ScaleSelector, TC.control.Scale);

(function () {
    var ctlProto = TC.control.ScaleSelector.prototype;

    ctlProto.CLASS = 'tc-ctl-ss';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/ScaleSelector.html";
    }
    else {
        ctlProto.template = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"ol-scale-line ol-unselectable\"><nobr><select>").s(ctx.get(["scales"], false), ctx, { "block": body_1 }, {}).w("</select> <input type=\"button\" value=\"").f(ctx.get(["screenSize"], false), ctx, "h").w("''\" title=\"").h("i18n", ctx, {}, { "$key": "estimatedMapSize" }).w("\" /></nobr></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<option value=\"").f(ctx.getPath(true, []), ctx, "h").w("\"").h("eq", ctx, { "block": body_2 }, { "key": body_3, "value": body_4 }).w(">1:").h("math", ctx, {}, { "key": body_5, "method": "round" }).w("</option>\n"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w(" selected=\"true\""); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h"); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.f(ctx.get(["scale"], false), ctx, "h"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.getPath(true, []), ctx, "h"); } body_5.__dustBody = !0; return body_0 };
    }

    ctlProto.render = function (callback) {
        var self = this;
        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            if (self.map) {
                if (!self.scales && self.map.options.resolutions) {
                    self.scales = self.map.options.resolutions.map(self.getScale, self);
                }
                var render = function () {
                    self.scales = self.map.wrap.getResolutions().map(self.getScale, self);
                    self.renderData({ scale: self.getScale(), screenSize: TC.Cfg.screenSize, scales: self.scales }, function () {

                        self.div.querySelectorAll('option').forEach(function (option) {
                            option.textContent = '1:' + self.format(option.textContent.substr(2));
                        });

                        self.div.querySelector('input[type="button"]').addEventListener(TC.Consts.event.CLICK, function () { self.setScreenSize(); });

                        self.div.querySelector('select').addEventListener('change', function () {
                            self.setScale($(this).val());
                        });
                        if ($.isFunction(callback)) {
                            callback();
                        }
                        resolve();
                    }).catch(function (err) {
                        reject(err instanceof Error ? err : Error(err));
                    });
                };
                if (self.scales) {
                    render();
                }
                else {
                    self.map.wrap.getMap().then(render);
                }
            }
            else {
                reject(Error('ScaleSelector no registrado'));
            }
        }));
    };

    /*
    *  setScale: Sets the resolution of the map from a scale denominator and estimated screen DPI
    *  Parameters: number, the scale denominator
    *  Returns: number, the resolution
    */
    ctlProto.setScale = function (scale) {
        var self = this;
        var result = scale * .0254 / self.getDpi(TC.Cfg.screenSize);
        if (window.devicePixelRatio) {
            result = result / window.devicePixelRatio;
        }
        if (self.metersPerDegree) {
            result = result / self.metersPerDegree;
        }
        self.map.wrap.setResolution(result);
        return result;
    };

})();
﻿(function () {
    // Polyfill window.performance.now
    if (!window.performance) {
        window.performance = {
            offset: Date.now(),
            now: function () {
                return Date.now() - this.offset;
            }
        };
    } else if (window.performance && !window.performance.now) {
        window.performance.offset = Date.now();
        window.performance.now = function () {
            return Date.now() - window.performance.offset;
        };
    }
}());

TC.control = TC.control || {};

if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}


var SearchType = function (type, options, parent) {
    var self = this;

    self.parent = parent;

    self._featureTypes = [];

    $.extend(self, options);

    self.typeName = type;

    self._throwConfigError = function () {
        var self = this;

        throw new Error('Error en la configuración de la búsqueda: ' + self.typeName);
    };

    self.getFeatureTypes = function (toFilter) {
        var self = this;

        if (toFilter) {
            return self.featureType instanceof Array ? self.featureType : [self.featureType];
        }

        if (self._featureTypes.length === 0) {
            var type_featureType = self.featureType instanceof Array ? self.featureType : [self.featureType];
            var type_renderFeatureType = self.renderFeatureType ? self.renderFeatureType instanceof Array ? self.renderFeatureType : [self.renderFeatureType] : [];
            self._featureTypes = type_featureType.concat(type_renderFeatureType);
        }

        return self._featureTypes;
    };

    self.isFeatureOfThisType = function (id) {
        var self = this;

        return self.getFeatureTypes().indexOf(id) > -1;
    };

    self.getStyleByFeatureType = function (featureType) {
        var self = this;

        if (self.getFeatureTypes().indexOf(featureType) > -1) {
            return self.styles[self.getFeatureTypes().indexOf(featureType)];
        }

        return null;
    };

    var getColor = function (css, geomType, featureType) {
        var self = this;

        var getValue = function (style, geomType, css) {
            if (geomType) {
                if (style.hasOwnProperty(geomType) && style[geomType].hasOwnProperty(css)) {
                    return style[geomType][css];
                }
            } else {
                for (var geomType in style) {
                    if (style[geomType].hasOwnProperty(css)) {
                        return style[geomType][css];
                    }
                }
            }
        };

        if (featureType) {
            var style = self.getStyleByFeatureType(featureType);
            return getValue(style, geomType, css);
        } else {
            for (var i = 0; i < self.styles.length; i++) {
                var style = self.styles[i];
                var color = getValue(style, geomType, css);
                if (color) {
                    return color;
                }
            }
        }
    };

    self.getSuggestionListHead = function () {
        var self = this;

        var headerData, label, color;

        if (typeof self.suggestionListHead === "function") {
            headerData = self.suggestionListHead();
            label = headerData.label;
            color = [{
                color: headerData.color,
                title: headerData.label
            }];
        } else {
            headerData = self.suggestionListHead;
            label = self.parent.getLocaleString(headerData.label);

            // color es string que es el atributo CSS. El valor se obtiene de la 1º coincidencia encontrada en styles
            if (typeof headerData.color === "string") {
                color = [{
                    color: getColor.call(self, headerData.color),
                    title: label
                }];
            } else if (headerData.color instanceof Array) { // color es un array de objetos, con nombre de featureType como clave
                var featureTypes = self.getFeatureTypes();
                if (headerData.color.length === featureTypes.length) {
                    color = headerData.color.map(function (elm, i) {
                        return {
                            color: getColor.call(self, elm[featureTypes[i]].color.css, elm[featureTypes[i]].color.geomType, featureTypes[i]),
                            title: self.parent.getLocaleString(elm[featureTypes[i]].title) || label
                        }
                    });
                } else {
                    self._throwConfigError();
                }
            } else if (typeof headerData.color === "object") { // color es un objeto con atributo css y tipo de geometría
                color = [{
                    color: getColor.call(self, headerData.color.css, headerData.color.geomType),
                    title: label
                }];
            }
        }

        if (label && color) {
            var liHTML = '<li header><span class="header">' + label + '</span>';

            liHTML += color.map(function (elm) {
                if (elm.color) {
                    return '<span class="header-color" title="' + elm.title + '" style="color: ' + elm.color + ';"></span>';
                }
            }).join('') + '</li>';

            return liHTML;

        } else {
            self._throwConfigError();
        }
    };

    self.getSuggestionListElements = function (data) {
        var self = this;
        var results = [];

        var areSame = function (a, b) {
            switch (true) {
                case typeof (a) === "number":
                    if (a === b) {
                        return true;
                    }
                    break;
                case typeof (a) === "string":
                    if (!isNaN(a) || !isNaN(b)) {
                        if (a === b) {
                            return true;
                        }
                    } else {
                        if (a.trim() === b.trim()) {
                            return true;
                        }
                    }
                    break;
            }

            return false;
        };
        var getUnique = function (inputArray) {
            var outputArray = [];
            for (var i = 0; i < inputArray.length; i++) {
                if ((jQuery.inArray(inputArray[i], outputArray)) == -1) {
                    outputArray.push(inputArray[i]);
                }
            }

            return outputArray;
        };
        var intoResults = function (compareData) {
            for (var r = 0; r < results.length; r++) {
                var length = 0;
                var isThere = [];
                for (var property in compareData) {
                    isThere.push(areSame(compareData[property], results[r].properties[property]));
                    length++;
                }
                if (isThere.filter(function (i) { return i; }).length === length) {
                    return true;
                }

            }

            return false;
        };

        var features = self.parseFeatures(data);

        features.forEach(function (feature) {
            var attributes = [], ids = [];
            var valueToAdd = '';

            var properties = self.outputProperties;
            var dataIdProperties = self.dataIdProperty;

            var strFormat = self.outputFormatLabel;
            var dataLayer = feature.id.split('.').slice(0, 1).shift();

            if (!(self.outputProperties instanceof Array)) {
                properties = self.outputProperties[dataLayer];
                dataIdProperties = self.dataIdProperty[dataLayer];
                strFormat = strFormat[dataLayer];
            }

            for (var j = 0; j < properties.length; j++) {
                attributes.push(feature.data[properties[j]]);
            }

            for (var j = 0; j < dataIdProperties.length; j++) {
                ids.push(feature.data[dataIdProperties[j]]);
            }

            var compareData = {};
            for (var p = 0; p < self.outputProperties.length; p++) {
                compareData[self.outputProperties[p]] = attributes[p];
            }

            if (attributes instanceof Array && strFormat && getUnique(attributes).length > 1) {
                valueToAdd = strFormat.tcFormat(attributes);
            }
            else if (attributes instanceof Array && getUnique(attributes).length == 1) {
                valueToAdd = attributes[0];
            }

            var text = valueToAdd.toCamelCase();

            if (!(intoResults(compareData))) {

                results.push({
                    text: text,
                    label: text,
                    id: ids.join('#'),
                    dataRole: self.typeName,
                    dataLayer: dataLayer,
                    properties: compareData
                });
            }
        });

        return results;
    };

    self.parseFeatures = function (data) {
        var parser;
        if (self.outputFormat === TC.Consts.format.JSON) {
            parser = new TC.wrap.parser.JSON();
        }
        else {
            parser = new TC.wrap.parser.WFS({
                featureNS: self.featurePrefix,
                featureType: self.featureType
            });
        }
        return parser.read(data);
    };

    self.getPattern = function () {
        var self = this;

        if (typeof self.pattern === "function") {
            return self.pattern();
        } else {
            return self.pattern;
        }
    };

    self.filter = (function (self) {

        const bindRootFilterNode = function (filtersArr, dataT) {
            var rootFilters = [];

            if (dataT != self.parent.rootCfg.active.root) {
                // GLS: Si llego aquí, significa que el usuario está indicando la población
                if (dataT.indexOf('#') === -1 && !self.parent.rootCfg.active.limit) { // si no está limitada la búsqueda, indico la población

                    var filterNode = self.parent.rootCfg.active.queryProperties.firstQueryWord.map(function (queryWord, index) {
                        return self.filter.getFilterNode(queryWord, self.parent._LIKE_PATTERN + dataT + self.parent._LIKE_PATTERN);
                    });

                    if (filterNode.length > 1) {
                        rootFilters.push('<ogc:And>');
                        rootFilters = rootFilters.concat(filterNode);
                        rootFilters.push('</ogc:And>');
                    } else {
                        rootFilters = rootFilters.concat(filterNode);
                    }

                } else { // por tanto no añado todas las raíces posibles, añado la población que ha indicado (validando antes contra rootLabel)                     
                    var item = dataT.split('#');

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }
            } else {
                for (var i = 0; i < self.parent.rootCfg.active.root.length; i++) {
                    var item = self.parent.rootCfg.active.root[i];

                    if (i == 0 && self.parent.rootCfg.active.root.length > 1) {
                        rootFilters.push('<ogc:Or>');
                    }

                    for (var j = 0; j < self.parent.rootCfg.active.dataIdProperty.length; j++) {

                        if (j == 0 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('<ogc:And>');
                        }

                        rootFilters.push(self.filter.getFilterNode(self.parent.rootCfg.active.dataIdProperty[j], item.length > j ? item[j] : item[0]));

                        if (j == self.parent.rootCfg.active.dataIdProperty.length - 1 && self.parent.rootCfg.active.dataIdProperty.length > 1) {
                            rootFilters.push('</ogc:And>');
                        }
                    }
                }

                if (self.parent.rootCfg.active.root.length > 1) {
                    rootFilters.push('</ogc:Or>');
                }
            }

            return filtersArr.concat(rootFilters);
        };

        return {
            getPropertyValue: function (role, propertyName) {
                return self.getSearchTypeByRole(role)[propertyName];
            },
            getIsLikeNode: function (name, value) {
                var toEscape = /([\-\"\.\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1)
                    return '<Or><PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toLowerCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike>' +
                        '<PropertyIsLike escape="\\" singleChar="_" wildCard="*" matchCase="false">' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.toUpperCase().replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsLike></Or>';
                else
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
            },
            getFunctionStrMatches: function (name, value) {
                var toEscape = /([\-\"\xba\(\)\/])/g;
                if (toEscape.test(value)) {
                    value = value.replace(toEscape, "\\$1");
                }

                if (value.toString().indexOf(self.parent._LIKE_PATTERN) > -1) {

                    var pattern = value;
                    pattern = pattern.replace(/a/gi, "[aáà]");
                    pattern = pattern.replace(/e/gi, "[eéè]");
                    pattern = pattern.replace(/i/gi, "[iíì]");
                    pattern = pattern.replace(/o/gi, "[oóò]");
                    pattern = pattern.replace(/u/gi, "[uúüù]");

                    return '<ogc:PropertyIsEqualTo> ' +
                        '<ogc:Function name="strMatches"> ' +
                        '<ogc:PropertyName>' + name + '</ogc:PropertyName> ' +
                        '<ogc:Literal>' + '(?i)' + pattern.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</ogc:Literal> ' +
                        '</ogc:Function> ' +
                        '<ogc:Literal>true</ogc:Literal> ' +
                        '</ogc:PropertyIsEqualTo>';
                }
                else {
                    return '<PropertyIsEqualTo>' +
                        '<PropertyName>' + name + '</PropertyName>' +
                        '<Literal>' + value.replace(/\</gi, "&lt;").replace(/\>/gi, "&gt;") + '</Literal>' +
                        '</PropertyIsEqualTo>';
                }
            },
            getFilterNode: function (propertyName, propertyValue) {
                var r;

                var fn = self.filter.getIsLikeNode;

                if (self.filterByMatch) {

                    fn = self.filter.getFunctionStrMatches;

                    var regex = new RegExp('\\' + self.parent._LIKE_PATTERN, 'gi');
                    propertyValue = propertyValue.replace(regex, self.parent._MATCH_PATTERN);
                }

                if (!(propertyName instanceof Array) && (typeof propertyName !== 'string')) {
                    var f = [];
                    for (var key in propertyName) {
                        if ((propertyName[key] instanceof Array) && propertyName[key].length > 1) {
                            r = '<Or>';
                            for (var i = 0; i < propertyName[key].length; i++) {
                                r += fn(propertyName[key][i].trim(), propertyValue);
                            }

                            r += '</Or>';
                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' + r + '</Filter>)');
                        } else {
                            var propName = propertyName[key];
                            if ((propertyName[key] instanceof Array) && propertyName[key].length == 1)
                                propName = propertyName[key][0];

                            f.push('(<Filter xmlns="http://www.opengis.net/ogc">' +
                                '<Or>' + fn(propName.trim(), propertyValue) + '</Or>' +
                                '</Filter>)');
                        }
                    }

                    return f.join('');

                } else if (propertyName instanceof Array && propertyName.length > 1) {
                    r = '<ogc:Or>';
                    for (var i = 0; i < propertyName.length; i++) {
                        r += fn(propertyName[i].trim(), propertyValue);
                    }

                    return r += '</ogc:Or>';
                } else
                    return fn((propertyName instanceof Array && propertyName.length === 1 ? propertyName[0].trim() : propertyName.trim()), propertyValue);
            },
            getFilter: function (data) {
                var r = {};
                r.multiL = false;
                r.f = '';

                var _f;

                switch (true) {
                    case self.typeName === TC.Consts.searchType.NUMBER:
                        _f = [];
                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)

                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        else {
                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            } else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }

                        _f.push(self.filter.getFilterNode(self.queryProperties.thirdQueryWord, data.p + self.parent._LIKE_PATTERN));

                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';

                        break;
                    case self.typeName === TC.Consts.searchType.STREET:
                        _f = [];

                        if (!(self.parent.rootCfg.active) && (/(\<|\>|\<\>)/gi.exec(data.t) || /(\<|\>|\<\>)/gi.exec(data.s))) {
                            var match = /(\<|\>|\<\>)/gi.exec(data.t);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t.substring(0, data.t.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else {
                                if (self.parent.rootCfg.active) {
                                    _f = bindRootFilterNode(_f, data.t);
                                }
                                else {
                                    _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                                }
                            }

                            match = /(\<|\>|\<\>)/gi.exec(data.s);
                            if (match)
                                _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s.substring(0, data.s.indexOf(match[0])).trim() + self.parent._LIKE_PATTERN));
                            else _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        } else {

                            if (self.parent.rootCfg.active) {
                                _f = bindRootFilterNode(_f, data.t);
                            }
                            else {
                                _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                            }
                            _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        }
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    case self.typeName === TC.Consts.searchType.LOCALITY:
                        r.f = self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN);
                        r.multiL = true;
                        break;                                            // GLS: consulta de 2 niveles (carretera con pk / topónimo con municipio)
                    case self.queryProperties.hasOwnProperty('secondQueryWord'):
                        var _f = [];
                        _f.push(self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN));
                        _f.push(self.filter.getFilterNode(self.queryProperties.secondQueryWord, self.parent._LIKE_PATTERN + data.s + self.parent._LIKE_PATTERN));
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + '<ogc:And>' + _f.join('') + '</ogc:And>' + '</ogc:Filter>';
                        break;
                    default: // GLS: consulta de 1 único nivel (municipio, casco urbano, carretera)
                        r.f = '<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">' + self.filter.getFilterNode(self.queryProperties.firstQueryWord, self.parent._LIKE_PATTERN + data.t + self.parent._LIKE_PATTERN) + '</ogc:Filter>';
                        break;
                }

                return r;
            },
            getParams: function (data) {
                var filters = self.filter.getFilter(data);

                var params = {
                    REQUEST: 'GetFeature',
                    SERVICE: 'WFS',
                    MAXFEATURES: 500,
                    VERSION: self.version,
                    OUTPUTFORMAT: self.outputFormat
                };

                var featureTypes = self.getFeatureTypes(true);
                if (!(featureTypes instanceof Array))
                    params.TYPENAME = self.featurePrefix ? self.featurePrefix + ':' + featureTypes.trim() : featureTypes.trim();
                else {
                    var ft = [];
                    for (var i = 0; i < featureTypes.length; i++) {
                        ft.push(self.featurePrefix ?
                            self.featurePrefix + ':' + featureTypes[i].trim() :
                            featureTypes[i].trim());
                    }

                    params.TYPENAME = ft.join(',');
                }

                var _getProperties = function (properties) {
                    if ((properties || '') !== '') {
                        if (!(properties instanceof Array)) {
                            var p = [];
                            if (properties instanceof Object) {
                                for (var key in properties) {
                                    var prop = properties[key][0];
                                    if (properties[key].length > 1)
                                        prop = properties[key].join(',');

                                    p.push(prop);
                                }
                            }
                            return p;
                        }
                        else
                            return properties.join(',');
                    }
                };
                var _properties = _getProperties(self.outputProperties);
                var _ids = _getProperties(self.dataIdProperty);

                if (_properties instanceof Array && _ids instanceof Array) {
                    params.PROPERTYNAME = '';
                    for (var i = 0; i < _properties.length; i++) {
                        params.PROPERTYNAME += '(' + _properties[i] + ',' + _ids[i] + ')';
                    }
                } else
                    params.PROPERTYNAME = _properties + ',' + _ids;

                params.FILTER = filters.f;

                return $.param(params);
            },
            getGoToFilter: function (id) {
                var props = [];
                var _id = id.split('#');

                var source = self.dataIdProperty;
                var dataLayer = self.getFeatureTypes();

                if (source && dataLayer) {

                    if (id.indexOf('#') > -1 && dataLayer instanceof Array && dataLayer.length > 1) {
                        for (var i = 0; i < dataLayer.length; i++) {

                            for (var j = 0; j < source[dataLayer[i]].length; j++) {
                                props.push({ name: source[dataLayer[i]][j], value: _id[j] });
                            }
                        }
                    } else if (id.indexOf('#') == -1 && dataLayer instanceof Array) {
                        var src = source;

                        for (var i = 0; i < dataLayer.length; i++) {
                            if (!props.hasOwnProperty(dataLayer[i])) {

                                if (src instanceof Object && source.hasOwnProperty(dataLayer[i]))
                                    src = source[dataLayer[i]];

                                for (var j = 0; j < src.length; j++) {
                                    if (j < _id.length)
                                        props.push({ name: src[j], value: _id[j] });
                                }
                            }
                        }
                    }
                    else {
                        if (source instanceof Object && source.hasOwnProperty(dataLayer)) {
                            source = source[dataLayer];
                        }

                        for (var i = 0; i < source.length; i++) {
                            props.push({ name: source[i], value: _id[i] });
                        }
                    }
                }

                return self.filter.transformFilter(props);
            },
            transformFilter: function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }
        }
    })(self);
};

TC.control.Search = function () {
    var self = this;
    TC.Control.apply(self, arguments);

    self.exportsState = true;

    TC.Consts.event.TOOLSCLOSE = TC.Consts.event.TOOLSCLOSE || 'toolsclose.tc';

    self.url = '//idena.navarra.es/ogc/wfs';
    self.version = '1.1.0';
    self.featurePrefix = 'IDENA';

    if (self.options && self.options.url) {
        self.url = self.options.url;
    }

    self._LIKE_PATTERN = '*';
    self._MATCH_PATTERN = '.*';

    self.UTMX = 'X';
    self.UTMY = 'Y';
    self.LON = 'Lon';
    self.LAT = 'Lat';

    self.UTMX_LABEL = 'X: ';
    self.UTMY_LABEL = 'Y: ';
    self.LON_LABEL = 'Lon: ';
    self.LAT_LABEL = 'Lat: ';

    self.MUN = 'Mun';
    self.POL = 'Pol';
    self.PAR = 'Par';

    self.MUN_LABEL = 'Mun: ';
    self.POL_LABEL = 'Pol: ';
    self.PAR_LABEL = 'Par: ';

    self.availableSearchTypes = {};

    self.availableSearchTypes[TC.Consts.searchType.CADASTRAL] = {
        suggestionRoot: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        searchWeight: 3,
        featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
        municipality: {
            featureType: 'CATAST_Pol_Municipio',
            labelProperty: 'MUNICIPIO',
            idProperty: 'CMUNICIPIO'
        },
        queryProperties: {
            firstQueryWord: 'CMUNICIPIO',
            secondQueryWord: 'POLIGONO',
            thirdQueryWord: 'PARCELA'
        },
        suggestionListHead: {
            label: "search.list.cadastral",
            color: [
                {
                    CATAST_Pol_ParcelaUrba: {
                        title: "search.list.cadastral.urban",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaRusti: {
                        title: "search.list.cadastral.rustic",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaMixta: {
                        title: "search.list.cadastral.mixed",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                }
            ]
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#136278',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#0c8b3d',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#e5475f',
                    strokeWidth: 2,
                    strokeOpacity: 1
                },
            }
        ],
        parser: self.getCadastralRef,
        goTo: self.goToCadastralRef,
        goToIdFormat: self.MUN + '{0}' + self.POL + '{1}' + self.PAR + '{2}',
        idPropertiesIdentifier: '#'
    };

    self.availableSearchTypes[TC.Consts.searchType.COORDINATES] = {
        parser: self.getCoordinates,
        goTo: self.goToCoordinates,
        searchWeight: 4,
        label: null,
        suggestionListHead: function (text) {
            return {
                label: self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label || self.getLocaleString('search.list.coordinates')
            };
        }
    };

    self.queryProperties = {
        QUERYWORD: 'QueryWord',
        FIRST: 'first',
        SECOND: 'second',
        THIRD: 'third'
    };

    self.availableSearchTypes[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        url: '//idena.navarra.es/ogc/wfs',
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
        },
        suggestionListHead: {
            label: "search.list.municipality",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        searchWeight: 1,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fe06a5',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.MUNICIPALITY]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    //self.availableSearchTypes[TC.Consts.searchType.LOCALITY] = {
    //    root: null,
    //    limit: false,
    //    url: self.url || '//idena.navarra.es/ogc/wfs',
    //    version: self.version || '1.1.0',
    //    outputFormat: TC.Consts.format.JSON,
    //    featurePrefix: self.featurePrefix || 'IDENA',
    //    geometryName: 'the_geom',
    //    featureType: ['CATAST_Pol_Municipio', 'ESTADI_Pol_EntidadPob'],
    //    renderFeatureType: ['CATAST_Pol_Municipio'],
    //    dataIdProperty: {
    //        CATAST_Pol_Municipio: ['CMUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['CMUNICIPIO', 'CENTIDAD']
    //    },
    //    queryProperties: {
    //        firstQueryWord: {
    //            CATAST_Pol_Municipio: ['MUNINOAC', 'MUNICIPIO'],
    //            ESTADI_Pol_EntidadPob: ['ENTINOAC', 'ENTIDAD']
    //        }
    //    },
    //    suggestionListHead: {
    //        label: "search.list.locality",
    //        color: "strokeColor"
    //    },
    //    outputProperties: {
    //        CATAST_Pol_Municipio: ['MUNICIPIO'],
    //        ESTADI_Pol_EntidadPob: ['MUNICIPIO', 'ENTIDAD']
    //    },
    //    outputFormatLabel: {
    //        CATAST_Pol_Municipio: '{0}',
    //        ESTADI_Pol_EntidadPob: '{1} ({0})'
    //    },
    //    searchWeight: 1,
    //    styles: [
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0,
    //                strokeColor: '#ffffff',
    //                strokeWidth: 5,
    //                strokeOpacity: 1
    //            }
    //        },
    //        {
    //            polygon: {
    //                fillColor: '#000000',
    //                fillOpacity: 0.1,
    //                strokeColor: '#feba1e',
    //                strokeWidth: 2,
    //                strokeOpacity: 1
    //            }
    //        }
    //    ],
    //    parser: self.getStringPattern.bind(this, [TC.Consts.searchType.LOCALITY]),
    //    goTo: self.goToStringPattern
    //};

    self.availableSearchTypes[TC.Consts.searchType.COUNCIL] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Concejo',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CCONCEJO'],
        queryProperties: {
            firstQueryWord: ['CONCEJO']
        },
        outputProperties: ['MUNICIPIO', 'CONCEJO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 4,
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.COUNCIL]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern,
        idPropertiesIdentifier: '#',
        suggestionListHead: {
            label: "search.list.council",
            color: "strokeColor"
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#49006a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.STREET] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        renderFeatureType: 'CATAST_Txt_Calle',
        featureType: 'CATAST_Lin_CalleEje',
        dataIdProperty: ['CVIA'],
        searchWeight: 5,
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
            secondQueryWord: ['VIA', 'VIANOAC']
        },
        suggestionListHead: {
            label: "search.list.street",
            color: "strokeColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1}, {0}',
        styles: [
            {
                line: {
                    strokeColor: "#CB0000",
                    strokeOpacity: 1,
                    strokeWidth: 2,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            },
            {
                point: {
                    label: "VIA",
                    angle: "CADANGLE",
                    fontColor: "#000000",
                    fontSize: 10,
                    fontWeight: "bold",
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.STREET]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.NUMBER] = {
        root: null,
        limit: null,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Txt_Portal',
        renderFeatureType: '',
        searchWeight: 6,
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
        queryProperties: {
            firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
            secondQueryWord: ['VIA', 'VIANOAC'],
            thirdQueryWord: ['PORTAL']
        },
        suggestionListHead: {
            label: "search.list.number",
            color: "fontColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1} {2}, {0}',
        styles: [
            {
                point: {
                    radius: 0,
                    label: "PORTAL",
                    angle: "CADANGLE",
                    fontColor: "#CB0000",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.NUMBER]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.URBAN] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'ESTADI_Pol_EntidadPob',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDAD']
        },
        suggestionListHead: {
            label: "search.list.urban",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO', 'ENTIDAD'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 2,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#feba1e',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.URBAN]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAME] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 7,
        /*filterByMatch: true, // si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "CADTEXT",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAME]),
        stringPatternToCheck: self.stringPatternsValidators.s_or_t,
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.PLACENAMEMUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'TOPONI_Txt_Toponimos',
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CTOPONIMO'],
        idPropertiesIdentifier: '#',
        queryProperties: {
            firstQueryWord: ['MUNICIPIO', 'MUNINOAC'],
            secondQueryWord: ['TOPONIMO', 'TOPONINOAC']
        },
        suggestionListHead: {
            label: "search.list.placeName",
            color: "fontColor"
        },
        outputProperties: ['MUNICIPIO', 'TOPONIMO', 'CMUNICIPIO', 'CTOPONIMO'],
        outputFormatLabel: '{1} ({0})',
        searchWeight: 8,
        /*filterByMatch: true, si queremos que filtre por expresión regular */
        styles: [
            {
                point: {
                    radius: 0,
                    label: "CADTEXT",
                    angle: "CADANGLE",
                    fontColor: "#ff5722",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ],
        parser: self.getStringPattern.bind(this, [TC.Consts.searchType.PLACENAMEMUNICIPALITY]),
        goTo: self.goToStringPattern
    };

    self.availableSearchTypes[TC.Consts.searchType.COMMONWEALTH] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['POLUCI_Pol_MancoRSUg'],
        renderFeatureType: '',
        dataIdProperty: ['CMANCOMUNI'],
        queryProperties: {
            firstQueryWord: ['MANCOMUNID']
        },
        outputProperties: ['MANCOMUNID'],
        outputFormatLabel: '{0}',
        searchWeight: 9,
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fc4e2a',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
    };

    self.availableSearchTypes[TC.Consts.searchType.ROAD] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Lin_CtraEje',
        dataIdProperty: ['DCARRETERA'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA']
        },
        suggestionListHead: {
            label: "search.list.road",
            color: "strokeColor"
        },
        outputProperties: ['DCARRETERA'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': ' + '{0}',
        searchWeight: 10,
        styles: [
            {
                polygon: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5
                },
                line: {
                    strokeColor: "#00b2fc",
                    strokeOpacity: 1,
                    strokeWidth: 5,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            }
        ],
        parser: self.getRoad,
        goTo: self.goToRoad,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))$", "i")
        }
    };

    self.availableSearchTypes[TC.Consts.searchType.ROADPK] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'INFRAE_Sym_CtraPK',
        dataIdProperty: ['DCARRETERA', 'CPK'],
        queryProperties: {
            firstQueryWord: ['DCARRETERA'],
            secondQueryWord: ['PK']
        },
        suggestionListHead: {
            label: "search.list.pk.larger",
            color: "fontColor"
        },
        outputProperties: ['DCARRETERA', 'PK'],
        outputFormatLabel: self.getLocaleString('search.list.road.shorter') + ': {0} ' + self.getLocaleString('search.list.pk') + ': {1}',
        searchWeight: 11,
        styles: [
            {
                point: {
                    label: ["DCARRETERA", "PK"],
                    fontColor: "#00b2fc",
                    fontSize: 14,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2
                }
            }
        ],
        parser: self.getPK,
        goTo: self.goToPK,
        pattern: function () {
            return new RegExp("^(?:(?:" + self.getLocaleString("search.list.road") + "|" + self.getLocaleString("search.list.road.shorter") + ")\\:?)?\\s*((A?|AP?|N?|R?|E?|[A-Z]{2}?|[A-Z]{1}?)\\s*\\-?\\s*(\\d{1,4})\\s*\\-?\\s*(A?|B?|C?|R?))\\s*\\,*\\s*(?:(?:" + self.getLocaleString("search.list.pk") + "\\:?)|(?:P\\:?)|(?:K\\:?)|(?:KM\\:?)|(?:\\s+|\\,+))\\s*(\\d{1,4})$", "i")
        }
    };

    self.rootCfg = {};
    self.rootCfg[TC.Consts.searchType.MUNICIPALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNICIPIO']
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {

                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.MUNICIPALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO'].concat(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.MUNICIPALITY].root.map(function (elem) {
                        return ['CMUNICIPIO'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.MUNICIPALITY].url + '?' + $.param(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (data) {
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.MUNICIPALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.MUNICIPALITY].rootLabel);
                }
            });
        }
    };
    self.rootCfg[TC.Consts.searchType.LOCALITY] = {
        root: null,
        limit: false,
        url: self.url || '//idena.navarra.es/ogc/wfs',
        version: self.version || '1.1.0',
        outputFormat: TC.Consts.format.JSON,
        featurePrefix: self.featurePrefix || 'IDENA',
        geometryName: 'the_geom',
        featureType: ['ESTADI_Pol_EntidadPob'],
        renderFeatureType: '',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC'],
        queryProperties: {
            firstQueryWord: ['ENTINOAC']
        },
        outputProperties: ['ENTINOAC'],
        getRootLabel: function () {
            return new Promise(function (resolve, reject) {
                if (self.rootCfg.active && !self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel) {

                    var params = {};
                    params.SERVICE = 'WFS';
                    params.VERSION = self.rootCfg[TC.Consts.searchType.LOCALITY].version;
                    params.REQUEST = 'GetFeature';
                    params.TYPENAME = self.rootCfg[TC.Consts.searchType.LOCALITY].featurePrefix + ':' + self.rootCfg[TC.Consts.searchType.LOCALITY].featureType;
                    params.OUTPUTFORMAT = self.rootCfg[TC.Consts.searchType.LOCALITY].outputFormat;
                    params.PROPERTYNAME = ['CMUNICIPIO', 'CENTIDAD'].concat(self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties).join(',');

                    params.CQL_FILTER = self.rootCfg[TC.Consts.searchType.LOCALITY].root.map(function (elem) {
                        return ['CMUNICIPIO', 'CENTIDAD'].map(function (id, index) {
                            return id + '=' + elem[index];
                        }).join(' AND ');
                    });

                    params.CQL_FILTER = params.CQL_FILTER.join(' OR ');

                    TC.ajax({
                        url: self.rootCfg[TC.Consts.searchType.LOCALITY].url + '?' + $.param(params),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (data) {
                        if (data.totalFeatures > 0) {

                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = data.features.map(function (feature) {
                                return {
                                    id: ['CMUNICIPIO', 'CENTIDAD'].map(function (elem) {
                                        return feature.properties[elem];
                                    }).join('#'),
                                    label: feature.properties[self.rootCfg[TC.Consts.searchType.LOCALITY].outputProperties[0]].toLowerCase()
                                };
                            });

                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);

                        } else {
                            self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel = [];
                            resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                        }
                    }).catch(function () {
                        resolve([]);
                    });
                }
                else {
                    resolve(self.rootCfg[TC.Consts.searchType.LOCALITY].rootLabel);
                }
            });
            return done;
        }
    };

    self.allowedSearchTypes = [];

    if (self.options.allowedSearchTypes) {
        for (var allowed in self.options.allowedSearchTypes) {

            if (self.availableSearchTypes[allowed] && !$.isEmptyObject(self.options.allowedSearchTypes[allowed])) {

                // GLS: gestionamos el override de featureType y renderFeatureType.
                // Si por defecto cuenta con renderFeatureType y sobrescribe featureType y no renderFeatureType, 
                // elimino la propiedad renderFeatureType y elimino el último estilo definido, que se corresponde con el de renderFeatureType.
                if (self.availableSearchTypes[allowed].renderFeatureType && self.availableSearchTypes[allowed].renderFeatureType.length > 0 &&
                    self.options.allowedSearchTypes[allowed].featureType && !self.options.allowedSearchTypes[allowed].renderFeatureType) {

                    delete self.availableSearchTypes[allowed].renderFeatureType;
                    self.availableSearchTypes[allowed].styles = self.availableSearchTypes[allowed].styles.slice(0, self.availableSearchTypes[allowed].styles.length - 1);
                }

                // GLS: override de la configuración por defecto con la del config.JSON
                $.extend(self.availableSearchTypes[allowed], self.options.allowedSearchTypes[allowed]);


                // GLS: Limitamos la búsqueda en portales y calles cuando así se establezca en la configuración de las búsquedas
                if (self.options.allowedSearchTypes[allowed].root &&
                    (allowed != TC.Consts.searchType.MUNICIPALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.MUNICIPALITY) ||
                    (allowed != TC.Consts.searchType.LOCALITY && self.options.allowedSearchTypes[allowed].rootType == TC.Consts.searchType.LOCALITY)) {

                    self.rootCfg.active = self.rootCfg[self.options.allowedSearchTypes[allowed].rootType];
                    self.rootCfg.active.root = self.options.allowedSearchTypes[allowed].root;
                    self.rootCfg.active.limit = self.options.allowedSearchTypes[allowed].limit;

                    self.availableSearchTypes[TC.Consts.searchType.STREET].queryProperties.firstQueryWord =
                        self.availableSearchTypes[TC.Consts.searchType.NUMBER].queryProperties.firstQueryWord =
                        self.rootCfg.active.dataIdProperty;
                }
            }

            // Si esta a false lo borramos de las disponibles
            if (!self.options.allowedSearchTypes[allowed]) {
                delete self.options.allowedSearchTypes[allowed];
            } else {
                self.addAllowedSearchType(allowed, self.availableSearchTypes[allowed] ? self.availableSearchTypes[allowed] : self.options.allowedSearchTypes[allowed], self);
            }
        }
    }

    if (self.rootCfg.active) {
        self.rootCfg.active.getRootLabel();
    }

    self.queryableFeatures = self.options.queryableFeatures || false;

    self.UTMX_LEN = 6;
    self.UTMY_LEN = 7;

    self.wrap = new TC.wrap.control.Search(self);

    self.interval = 500;

    self.NORMAL_PATTERNS = {
        ROMAN_NUMBER: /M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}){1,}?\S?\./i,
        ABSOLUTE_NOT_DOT: /[`~!@#$%^&*_|+\=?;:'"\{\}\[\]\\]/gi,
        ABSOLUTE: /[`~!@#$%^&*_|+\=?;:'.\{\}\[\]\\]/gi
    };
};

TC.inherit(TC.control.Search, TC.Control);

(function () {
    var ctlProto = TC.control.Search.prototype;

    ctlProto.CLASS = 'tc-ctl-search';

    TC.Consts.event.SEARCHQUERYEMPTY = TC.Consts.event.SEARCHQUERYEMPTY || 'searchqueryempty.tc';

    if (TC.isDebug) {
        ctlProto.template = TC.apiLocation + "TC/templates/Search.html";
    }
    else {
        ctlProto.template = function () {
            dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "search.1" }).w("</h2><div class=\"tc-ctl-search-content\"><input type=\"search\" class=\"tc-ctl-search-txt\" placeholder=\"").h("i18n", ctx, {}, { "$key": "search.placeholder" }).w("\" title=\"").h("i18n", ctx, {}, { "$key": "search.instructions" }).w("\" /><a title=\"").h("i18n", ctx, {}, { "$key": "search.instructions" }).w("\" class=\"tc-ctl-btn tc-ctl-search-btn\">").h("i18n", ctx, {}, { "$key": "search.2" }).w("</a><ul class=\"tc-ctl-search-list tc-hidden\"></ul></div>"); } body_0.__dustBody = !0; return body_0
        };
    }

    ctlProto.register = function (map) {
        const self = this;
        const result = TC.Control.prototype.register.call(self, map);

        self._search = {
            data: []
        };

        self.layerStyleFN = (function () {
            function getFeatureType(idFeature) {
                return idFeature.indexOf('.') > -1 ? idFeature.split('.')[0] : idFeature;
            };
            function getStyle(property, geomType, id) {

                var type = self.getSearchTypeByFeature(id);
                if (type) {
                    var style = type.getStyleByFeatureType(getFeatureType(id));

                    if (style && style.hasOwnProperty(geomType)) {
                        return style[geomType][property];
                    }
                }

                return TC.Cfg.styles[geomType][property];
            };

            return function (geomType, property, extractValue, f) {
                var self = this;

                if (TC.Feature && !(f instanceof TC.Feature)) {
                    self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, geom: f.geom });
                }

                var prop = getStyle(property, geomType, getFeatureType(f.id));
                if (extractValue) {
                    if (prop instanceof Array) {
                        var values = prop.map(function (p) {
                            return f.getData().hasOwnProperty(p) ? f.getData()[p] : '';
                        });
                        var searchType = this.getSearchTypeByFeature(getFeatureType(f.id));
                        if (searchType) {
                            return searchType.outputFormatLabel.tcFormat(values);
                        } else {
                            return values.join(' ');
                        }
                    } else {
                        return f.getData().hasOwnProperty(prop) ? f.getData()[prop] : '';
                    }
                }
                else {
                    return prop;
                }
            };
        }());

        var styleFN = self.layerStyleFN;

        self.layerPromise = map.addLayer({
            id: self.getUID(),
            title: 'Búsquedas',
            stealth: true,
            declutter: true,
            type: TC.Consts.layerType.VECTOR,
            styles: {
                polygon: {
                    fillColor: styleFN.bind(self, 'polygon', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'polygon', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'polygon', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'polygon', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'polygon', 'strokeWidth', false)
                },
                line: {
                    strokeColor: styleFN.bind(self, 'line', 'strokeColor', false),
                    strokeOpacity: styleFN.bind(self, 'line', 'strokeOpacity', false),
                    strokeWidth: styleFN.bind(self, 'line', 'strokeWidth', false)
                },
                marker: {
                    anchor: TC.Defaults.styles.marker.anchor,
                    height: TC.Defaults.styles.marker.height,
                    width: TC.Defaults.styles.marker.width
                },
                point: {
                    radius: styleFN.bind(self, 'point', 'radius', false),
                    height: styleFN.bind(self, 'point', 'height', false),
                    width: styleFN.bind(self, 'point', 'width', false),
                    fillColor: styleFN.bind(self, 'point', 'fillColor', false),
                    fillOpacity: styleFN.bind(self, 'point', 'fillOpacity', false),
                    strokeColor: styleFN.bind(self, 'point', 'strokeColor', false),
                    strokeWidth: styleFN.bind(self, 'point', 'strokeWidth', false),
                    fontSize: styleFN.bind(self, 'point', 'fontSize', false),
                    fontColor: styleFN.bind(self, 'point', 'fontColor', false),
                    labelOutlineColor: styleFN.bind(self, 'point', 'labelOutlineColor', false),
                    labelOutlineWidth: styleFN.bind(self, 'point', 'labelOutlineWidth', false),
                    label: styleFN.bind(self, 'point', 'label', true),
                    angle: styleFN.bind(self, 'point', 'angle', true)
                }
            }
        })
            .then(function (layer) {
                self.layer = layer;
                return layer;
            });

        self.EMPTY_RESULTS_LABEL = self.getLocaleString('noResults');
        self.EMPTY_RESULTS_TITLE = self.getLocaleString('checkCriterion');
        self.OUTBBX_LABEL = self.getLocaleString('outsideOfLimits');

        self.WFS_TYPE_ATTRS = ["url", "version", "geometryName", "featurePrefix", "featureType", "properties", "outputFormat"];

        return result;
    };

    ctlProto.renderData = function (data, callback) {
        var self = this;

        self._search = self._search || {};

        var _search = function () {
            self.search(self.textInput.value, function (list) {
                if (list.length === 1) {
                    self.textInput.value = list[0].label;
                    self._goToResult(list[0].id, self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
                else if (list.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                }
            });
        };

        return TC.Control.prototype.renderData.call(self, data, function () {

            // desde keypress y desde la lupa
            var _research = function () {
                self.textInput.value = self.resultsList.label || self.resultsList.querySelector('li:not([header]) > a > span').textContent;
                self.lastPattern = self.textInput.value;
                self._goToResult(self.resultsList.id || unescape(self.resultsList.querySelector('li:not([header]) > a').getAttribute('href')).substring(1), self.resultsList.querySelector('li:not([header])').getAttribute('dataRole'));
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            };

            self.textInput = self.div.querySelector('input.tc-ctl-search-txt');
            if (self.options && self.options.placeHolder) {
                self.textInput.setAttribute('placeHolder', self.options.placeHolder.trim());
            }

            self.resultsList = self.div.querySelector('.tc-ctl-search-list');
            self.$list = $(self.resultsList);
            self.button = self.div.querySelector('.tc-ctl-search-btn');
            self.button.addEventListener(TC.Consts.event.CLICK, function () {
                self.getLayer().then(function (l) {
                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length > 1) { }
                    else if (l.features.length > 0) {
                        l.map.zoomToFeatures(l.features);
                    }
                    else if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    }
                    else {
                        self.textInput.dispatchEvent(new Event("keyup"));
                    }
                });
            });
            if (self.options.instructions) {
                self.textInput.setAttribute('title', self.options.instructions.trim());
                self.button.setAttribute('title', self.options.instructions.trim());
            }

            // GLS: añadimos la funcionalidad al mensaje de "No hay resultados", al hacer click repliega el mensaje.
            self.resultsList.addEventListener(TC.Consts.event.CLICK, TC.EventTarget.listenerBySelector('a.tc-ctl-search-li-empty', function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                self.textInput.focus();
            }));


            // IE10 polyfill
            try {
                if (self.textInput.classList.contains('::-ms-clear')) {
                    var oldValue;
                    self.textInput.addEventListener('mouseup', function (e) {
                        oldValue = self.textInput.value;

                        if (oldValue === '') {
                            return;
                        }

                        // When this event is fired after clicking on the clear button
                        // the value is not cleared yet. We have to wait for it.
                        setTimeout(function () {
                            var newValue = self.textInput.value;

                            if (newValue === '') {
                                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                // Gotcha
                                _search();
                            }
                        }, 1);
                    });
                }
            }
            catch (e) { }

            self.textInput.addEventListener('keypress', function (e) {
                if (e.which == 13) {
                    e.preventDefault();
                    e.stopPropagation();

                    self.lastPattern = "";

                    if (self.resultsList.querySelectorAll('li > a:not(.tc-ctl-search-li-loading):not(.tc-ctl-search-li-empty)').length === 1) {
                        _research();
                    } else {
                        _search();
                    }
                    return false;
                }
            });
            self.textInput.addEventListener("search", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("input", function () {
                if (self.textInput.value.length === 0) {
                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                    _search();
                }
            });
            self.textInput.addEventListener("targetCleared.autocomplete", function () {
                self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
            })
            self.textInput.addEventListener("targetUpdated.autocomplete", function () {
                if (self.resultsList.querySelectorAll('li').length > 0) {
                    self.resultsList.classList.remove(TC.Consts.classes.HIDDEN);
                }
            });

            self.lastPattern = '';
            self.retryTimeout = null;
            TC.loadJS(
                !TC.UI || !TC.UI.autocomplete,
                [TC.apiLocation + 'TC/ui/autocomplete.js'],
                function () {
                    var searchDelay;

                    const source = function (text, callback) {
                        self.lastpress = performance.now();

                        if (!searchDelay) {
                            function step() {
                                var criteria = self.textInput.value.trim();

                                if (criteria.length > 0 &&
                                    (!self.lastPattern || criteria != self.lastPattern) &&
                                    performance.now() - self.lastpress > self.interval) {

                                    window.cancelAnimationFrame(searchDelay);
                                    searchDelay = undefined;

                                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);

                                    // Pendiente de afinar
                                    //if (self.lastPattern && criteria.substring(0, criteria.lastIndexOf(' ')) == self.lastPattern) {                                            

                                    //    // Si el patrón de búsqueda anterior y actual es el mismo más algo nuevo (típico en la búsqueda de un portal), lo nuevo lo separo por coma
                                    //    // self.lastPattern: "Calle Cataluña/Katalunia Kalea, Pamplona"
                                    //    // text: "Calle Cataluña/Katalunia Kalea, Pamplona 18"

                                    //    criteria = criteria.substring(0, criteria.lastIndexOf(' ')) + (self.lastPattern.trim().endsWith(',') ? "" : ",") + criteria.substring(criteria.lastIndexOf(' '));
                                    //}

                                    self.lastPattern = criteria;

                                    self.search(criteria, callback);
                                } else {
                                    searchDelay = requestAnimationFrame(step);
                                }
                            }

                            searchDelay = requestAnimationFrame(step);
                        }
                    };

                    var closest = function (el, selector) {
                        const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

                        while (el) {
                            if (matchesSelector.call(el, selector)) {
                                return el;
                            } else {
                                el = el.parentElement;
                            }
                        }
                        return null;
                    };

                    const callback = function (e) {
                        var _target = e.target;

                        if (e.target.tagName.toLowerCase() !== 'a') {
                            _target = closest(e.target, 'a');
                        }

                        if (_target.querySelector('span[hidden]')) {
                            self.textInput.value = _target.querySelector('span[hidden]').textContent;
                            self.lastPattern = self.textInput.value;
                            self._goToResult(unescape(_target.getAttribute('href')).substring(1), _target.parentNode.getAttribute('dataRole'));
                            TC.UI.autocomplete.call(self.textInput, 'clear');
                        }
                    };

                    const buildHTML = function (results) {

                        var html = [];
                        var dataRoles = [];

                        var reA = /[^a-zA-Z]/g;
                        var reN = /[^0-9]/g;
                        function sortAlphaNum(a, b) {
                            var AInt = parseInt(a, 10);
                            var BInt = parseInt(b, 10);

                            if (isNaN(AInt) && isNaN(BInt)) {
                                var aA = a.replace(reA, "");
                                var bA = b.replace(reA, "");
                                if (aA === bA) {
                                    var aN = parseInt(a.replace(reN, ""), 10);
                                    var bN = parseInt(b.replace(reN, ""), 10);
                                    return aN === bN ? 0 : aN > bN ? 1 : -1;
                                } else {
                                    return aA > bA ? 1 : -1;
                                }
                            } else if (isNaN(AInt)) {//A is not an Int
                                return 1;//to make alphanumeric sort first return -1 here
                            } else if (isNaN(BInt)) {//B is not an Int
                                return -1;//to make alphanumeric sort first return 1 here
                            } else {
                                return AInt > BInt ? 1 : -1;
                            }
                        };

                        // ordenamos por roles y alfabéticamente
                        var data = results.results.sort(function (a, b) {
                            if (this.ctx.getSearchTypeByRole(a.dataRole).searchWeight && this.ctx.getSearchTypeByRole(b.dataRole).searchWeight) {
                                if ((this.ctx.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (this.ctx.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                    return 1;
                                } else if ((this.ctx.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (this.ctx.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                    return -1;
                                }
                                else {
                                    return sortAlphaNum(a.label, b.label);
                                }
                            } else {
                                if (a.dataRole > b.dataRole) {
                                    return 1;
                                }
                                else if (a.dataRole < b.dataRole)
                                    return -1;
                                else {
                                    return sortAlphaNum(a.label, b.label);
                                }
                            }
                        }.bind(this));

                        if (self.rootCfg.active) {// si hay root, aplicamos el orden por entidades 
                            data = data.sort(function (a, b) {

                                const sort_ = function () {
                                    var first = this.rootCfg.active.root[0] instanceof Array ? this.rootCfg.active.root[0].join('-') : this.rootCfg.active.root[0];

                                    var aRoot, bRoot;
                                    if (a.properties && a.properties.length > 0 && b.properties && b.properties.length > 0) {
                                        aRoot = this.rootCfg.active.dataIdProperty.map(function (elem) { return a.properties[elem].toString(); }).join('-');
                                        bRoot = this.rootCfg.active.dataIdProperty.map(function (elem) { return b.properties[elem].toString(); }).join('-');
                                    } else {
                                        aRoot = a.id;
                                        bRoot = b.id;
                                    }

                                    if (aRoot !== first && bRoot === first) {
                                        return 1;
                                    } else if (aRoot === first && bRoot !== first) {
                                        return -1;
                                    } else {
                                        return sortAlphaNum(a.label, b.label);
                                    }
                                }.bind(this);

                                if (this.getSearchTypeByRole(a.dataRole).searchWeight && this.getSearchTypeByRole(b.dataRole).searchWeight) {
                                    if ((this.getSearchTypeByRole(a.dataRole).searchWeight || 0) > (this.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                        return 1;
                                    } else if ((this.getSearchTypeByRole(a.dataRole).searchWeight || 0) < (this.getSearchTypeByRole(b.dataRole).searchWeight || 0)) {
                                        return -1;
                                    }
                                    else {
                                        return sort_();
                                    }
                                }
                                else {
                                    return sort_();
                                }

                            }.bind(self));
                        }

                        for (var i = 0; i < data.length; i++) {
                            var elm = data[i];

                            if (dataRoles.indexOf(elm.dataRole) == -1) {

                                var type = this.ctx.getSearchTypeByRole(elm.dataRole);

                                html[html.length] = type.getSuggestionListHead();

                                dataRoles.push(elm.dataRole);
                            }

                            const highlighting = function () {
                                var highlighted = elm.label;
                                var strReg = [];

                                // eliminamos caracteres extraños del patrón ya analizado

                                if (this.ctx.lastPattern.trim().length === 0 && self.textInput.value.trim().length > 0) {
                                    this.ctx.lastPattern = self.textInput.value.trim();                                    
                                }

                                var normalizedLastPattern = this.ctx.lastPattern;
                                if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(normalizedLastPattern))
                                    normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
                                else
                                    normalizedLastPattern = normalizedLastPattern.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');


                                var querys = [];
                                var separatorChar = ',';
                                if (normalizedLastPattern.indexOf(separatorChar) == -1) {
                                    separatorChar = ' ';
                                }

                                querys = normalizedLastPattern.trim().split(separatorChar);                                

                                // si estamos tratando con coordenadas el separador es el espacio, no la coma
                                if ((elm.label.indexOf(this.ctx.LAT_LABEL) > -1 && elm.label.indexOf(this.ctx.LON_LABEL) > -1) ||
                                    (elm.label.indexOf(this.ctx.UTMX_LABEL) > -1 && elm.label.indexOf(this.ctx.UTMY_LABEL) > -1)) {
                                    querys = this.ctx.lastPattern.split(' ');

                                    for (var t = 0; t < querys.length; t++) {
                                        if (querys[t].trim().slice(-1) == ',')
                                            querys[t] = querys[t].slice(0, -1);
                                    }
                                }

                                for (var q = 0; q < querys.length; q++) {
                                    if (querys[q].trim().length > 0) {
                                        strReg.push('(' + querys[q].trim().replace(/\(/gi, "").replace(/\)/gi, "") + ')');
                                        var match = /((\<)|(\>)|(\<\>))/gi.exec(querys[q].trim());
                                        if (match) {
                                            var _strReg = querys[q].trim().replace(/((\<)|(\>)|(\<\>))/gi, '').split(' ');
                                            for (var st = 0; st < _strReg.length; st++) {
                                                if (_strReg[st].trim().length > 0)
                                                    strReg.push('(' + _strReg[st].trim().replace(/\(/gi, "\\(").replace(/\)/gi, "\\)") + ')');
                                            }
                                        }
                                    }
                                }

                                if (elm.dataRole == TC.Consts.searchType.ROAD || elm.dataRole == TC.Consts.searchType.ROADPK) {
                                    var rPattern = self.getSearchTypeByRole(elm.dataRole).getPattern();
                                    var match = rPattern.exec(this.ctx.lastPattern);

                                    if (match) {
                                        strReg = [];

                                        if (match[2] && match[3] && match[4]) {
                                            strReg.push('(' + match[2] + "-" + match[3] + "-" + match[4] + ')');
                                        } else if (match[2] && match[3]) {
                                            strReg.push('(' + match[2] + "-" + match[3] + ')');
                                        } else if (match[3] && match[4]) {
                                            strReg.push('(' + match[3] + "-" + match[4] + ')');
                                        } else if (match[2] || match[3]) {
                                            strReg.push('(' + (match[2] || match[3]) + ')');
                                        }

                                        if (match[5]) {
                                            strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
                                        }
                                    } else if (match && match[5]) {
                                        strReg = [];

                                        strReg.push("(?:" + self.getLocaleString("search.list.pk") + "\\:\\s\\d*)" + "(" + match[5] + ")" + "\\d*");
                                    }
                                }

                                var pattern = '(' + strReg.join('|') + ')';

                                pattern = pattern.replace(/á|à/gi, "a");
                                pattern = pattern.replace(/é|è/gi, "e");
                                pattern = pattern.replace(/í|ì/gi, "i");
                                pattern = pattern.replace(/ó|ò/gi, "o");
                                pattern = pattern.replace(/ú|ù/gi, "u");
                                pattern = pattern.replace(/ü/gi, "u");

                                pattern = pattern.replace(/a/gi, "[a|á|à]");
                                pattern = pattern.replace(/e/gi, "[e|é|è]");
                                pattern = pattern.replace(/i/gi, "[i|í|ì]");
                                pattern = pattern.replace(/o/gi, "[o|ó|ò]");
                                pattern = pattern.replace(/u/gi, "[u|ú|ü|ù]");
                                var rex = new RegExp(pattern, "gi");

                                var label = elm.label;

                                if (elm.dataRole !== TC.Consts.searchType.ROAD || elm.dataRole !== TC.Consts.searchType.ROADPK) {
                                    highlighted = label.replace(rex,
                                        function () {
                                            var params = Array.prototype.slice.call(arguments, 0);                                            

                                            if (params[params.length - 3]) {
                                                return params[0].replace(params[params.length - 3], "<b>" + params[params.length - 3] + "</b>");
                                            } else {
                                                return "<b>" + params[0] + "</b>";
                                            }
                                        });
                                } else {
                                    highlighted = label.replace(rex, "<b>$1</b>");
                                }

                                return highlighted;
                            }.bind(this);

                            html[html.length] = '<li dataRole="' + elm.dataRole + '"><a href="' + '#' + encodeURIComponent(elm.id) + '"><span hidden>' + elm.label + '</span>' + highlighting() + '</a></li>';
                        }



                        return html.join('');
                    };

                    TC.UI.autocomplete.call(self.textInput, {
                        link: '#',
                        target: self.resultsList,
                        minLength: 2,
                        ctx: self,
                        source: source,
                        callback: callback,
                        buildHTML: buildHTML
                    });                    

                    var getNextSibling = function (elem, selector) {

                        // Get the next sibling element
                        var sibling = elem.nextElementSibling;

                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;

                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.nextElementSibling
                        }

                    };

                    var getPreviousSibling = function (elem, selector) {

                        // Get the next sibling element
                        var sibling = elem.previousElementSibling;

                        // If there's no selector, return the first sibling
                        if (!selector) return sibling;

                        // If the sibling matches our selector, use it
                        // If not, jump to the next sibling and continue the loop
                        while (sibling) {
                            if (sibling.matches(selector)) return sibling;
                            sibling = sibling.previousElementSibling;
                        }

                    };

                    // Detect up/down arrow
                    const onKeydown = function (e) {
                        if (!e.ctrlKey && !e.altKey && !e.shiftKey) {
                            if (e.keyCode === 40) { // down arrow
                                if (self.textInput == document.activeElement && self.resultsList.querySelector('li:not([header]) a')) {
                                    // Scenario 1: We're focused on the search input; move down to the first li
                                    self.resultsList.querySelector('li:not([header]) a').focus();
                                } else if (self.resultsList.querySelector('li:not([header]):last-child a') === document.activeElement) { //} else if (self.resultsList.querySelector('li:not([header]):last a').is(':focus')) {
                                    // Scenario 2: We're focused on the last li; move up to search input
                                    self.textInput.focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the last element, simply move down
                                    getNextSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();                                    
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            } else if (e.keyCode === 38) { // up arrow
                                if (self.textInput == document.activeElement) {
                                    // Scenario 1: We're focused on the search input; move down to the last li
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else if (document.activeElement == self.resultsList.querySelector('li:not([header]) a')) {
                                    self.resultsList.querySelector('li:not([header]):last-child a').focus();
                                } else {
                                    // Scenario 3: We're in the list but not on the first element, simply move up
                                    getPreviousSibling(document.activeElement.parentElement, 'li:not([header])')
                                        .querySelector('a').focus();                                    
                                }
                                e.preventDefault(); // Stop page from scrolling
                                e.stopPropagation();
                            }
                        }
                        e.stopPropagation();
                    };

                    self.textInput.addEventListener('keydown', onKeydown);
                    self.resultsList.addEventListener('keydown', onKeydown);
                }
            );

            if ($.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.addAllowedSearchType = function (name, options) {
        var self = this;

        self.allowedSearchTypes.push(new SearchType(name, options, self));
    };

    ctlProto.getSearchTypeByRole = function (type) {
        var self = this;

        return self.allowedSearchTypes.filter(function (allowed) {
            return allowed.typeName == type;
        })[0];
    };

    ctlProto.getSearchTypeByFeature = function (id) {
        var self = this;

        var type = self.allowedSearchTypes.filter(function (allowed) {
            return allowed.isFeatureOfThisType(id);
        });

        if (type.length > 0) {
            return type[0];
        }

        return null;
    };

    ctlProto.getElementOnSuggestionList = function (id, dataRole) {
        const self = this;

        for (var i = 0; i < self._search.data.length; i++) {
            if (self._search.data[i].id == id && (!dataRole || (dataRole && self._search.data[i].dataRole === dataRole)))
                return self._search.data[i];
        }
    };

    ctlProto.getLayer = function () {
        var self = this;
        return self.layerPromise;
    };

    ctlProto.getFeatures = function () {
        var self = this;
        var features = [];

        return self.layer.features;
    };

    ctlProto.cleanMap = function () {
        var self = this;

        self.getLayer().then(function (l) {
            var features = l.features.slice();
            l.clearFeatures();

            self.map.trigger(TC.Consts.event.FEATUREREMOVE, { layer: l, feature: features });

            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                if (l.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                    delete l[self.WFS_TYPE_ATTRS[i]];
            }
        });
    };

    ctlProto.getMunicipalities = function () {
        var self = this;

        TC.cache.search = TC.cache.search || {};
        self._municipalitiesPromise = new Promise(function (resolve, reject) {
            if (TC.cache.search.municipalities) {
                resolve(TC.cache.search.municipalities);
            }
            else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

                if (type.municipality && type.municipality.featureType && type.municipality.labelProperty && type.municipality.idProperty) {
                    var params = {
                        REQUEST: 'GetFeature',
                        SERVICE: 'WFS',
                        TYPENAME: type.municipality.featureType,
                        VERSION: type.version,
                        PROPERTYNAME: type.municipality.labelProperty + "," + type.municipality.idProperty,
                        OUTPUTFORMAT: type.outputFormat
                    };
                    if (type.featurePrefix) {
                        params.TYPENAME = type.featurePrefix + ':' + params.TYPENAME;
                    }
                    var url = type.url + '?' + $.param(params);
                    TC.ajax({
                        url: url,
                        method: 'GET',
                        responseType: 'text'
                    }).then(function (data) {
                        var parser;
                        if (type.outputFormat === TC.Consts.format.JSON) {
                            parser = new TC.wrap.parser.JSON();
                        }
                        else {
                            parser = new TC.wrap.parser.WFS({
                                featureNS: type.municipality.featurePrefix,
                                featureType: type.municipality.featureType
                            });
                        }
                        var features = parser.read(data);
                        TC.cache.search.municipalities = [];
                        for (var i = 0; i < features.length; i++) {
                            var feature = features[i];
                            TC.cache.search.municipalities.push({ label: feature.data[type.municipality.labelProperty], id: feature.data[type.municipality.idProperty] });
                        }

                        TC.cache.search.municipalities.sort(function (a, b) {
                            var result;
                            if (a.label < b.label) {
                                result = -1;
                            }
                            else if (a.label > b.label) {
                                result = 1;
                            }
                            else {
                                result = 0;
                            }
                            return result;
                        });

                        resolve(TC.cache.search.municipalities);
                    }).catch(function () {
                        resolve();
                    });
                } else {
                    throw new Error("Error en la configuración de la búsqueda: " + type.typeName + ". Error en el objeto municipality");
                }
            }
        });
        return self._municipalitiesPromise;
    };

    ctlProto.getCoordinates = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp('^' + $.trim(self.UTMX_LABEL.toLowerCase()) + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + $.trim(self.UTMY_LABEL.toLowerCase()) + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[2];
            }

            match = pattern.match(new RegExp('^' + $.trim(self.LAT_LABEL.toLowerCase()) + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + $.trim(self.LON_LABEL.toLowerCase()) + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                pattern = match[1] + ' ' + match[3];
            }

            if (/\d/.test(pattern) && (new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').test(pattern) || /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.test(pattern))) {
                match = /^([-+]?\d{1,3}([.,]\d+)?)\,?\s*([-+]?\d{1,2}([.,]\d+)?)$/.exec(pattern);
                if (match && (match[1].indexOf(',') > -1 || match[3].indexOf(',') > -1)) {
                    match[1] = match[1].replace(',', '.');
                    match[3] = match[3].replace(',', '.');

                    pattern = match[1] + ' ' + match[3];
                }

                if (!match || match && ((match[1].indexOf(',') > -1 ? match[1].replace(',', '.') : match[1]) <= 180) && ((match[3].indexOf(',') > -1 ? match[3].replace(',', '.') : match[3]) <= 90)) {

                    match = new RegExp('^([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$').exec(pattern);
                    if (match && (match[1].indexOf(',') > -1 || match[2].indexOf(',') > -1)) {
                        match[1] = match[1].replace(',', '.');
                        match[2] = match[2].replace(',', '.');

                        pattern = match[1] + ' ' + match[2];
                    }

                    // parse coordinates
                    pattern = pattern.replace(self.UTMX_LABEL, '').replace(self.UTMY_LABEL, '').replace(self.LON_LABEL, '').replace(self.LAT_LABEL, '');
                    var coords = TC.Util.parseCoords(pattern);
                    if (coords) {
                        var xValue = coords[0].value;
                        var yValue = coords[1].value;
                        var xLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                        var yLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                        var id = xLabel + xValue + yLabel + yValue;

                        var point = self.getPoint(id);
                        if (point && !self.insideLimit(point)) {
                            xValue = coords[1].value;
                            yValue = coords[0].value;
                            xLabel = (coords[1].type === TC.Consts.UTM) ? self.UTMX : self.LAT;
                            yLabel = (coords[0].type === TC.Consts.UTM) ? self.UTMY : self.LON;
                            id = xLabel + xValue + yLabel + yValue;
                            point = self.getPoint(id);
                        }

                        if (point) {
                            self.availableSearchTypes[TC.Consts.searchType.COORDINATES].label = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.test(id) ? self.getLocaleString('search.list.coordinates.utm') + self.map.crs : self.getLocaleString('search.list.coordinates.geo');

                            //console.log('getCoordinates promise resuelta');
                            resolve([{
                                id: id, label: self.getLabel(id), dataRole: TC.Consts.searchType.COORDINATES
                            }]);
                        }
                        else {
                            //console.log('getCoordinates promise resuelta');
                            resolve([]);
                        }
                    } else {
                        //console.log('getCoordinates promise resuelta');
                        resolve([]);
                    }
                } else {
                    //console.log('getCoordinates promise resuelta');
                    resolve([]);
                }
            } else {
                //console.log('getCoordinates promise resuelta');
                resolve([]);
            }
        });
    };

    ctlProto.getCadastralRef = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            var match = pattern.match(new RegExp($.trim(self.MUN_LABEL.toLowerCase()) + '?\\s(.*)\\,\\s?' + $.trim(self.POL_LABEL.toLowerCase()) + '?\\s(\\d{1,2})\\,\\s?' + $.trim(self.PAR_LABEL.toLowerCase()) + '?\\s(\\d{1,4})'));
            if (match) {
                pattern = match[1] + ', ' + match[2] + ', ' + match[3];
            }

            var _pattern = pattern;
            if (!(/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(pattern)) && self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot)
                _pattern = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot + ', ' + pattern;

            if (/^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.test(_pattern) && !(new RegExp('^([0-9]{' + self.UTMX_LEN + '})\\s*\\,\\s*([0-9]{' + self.UTMY_LEN + '})$').test(pattern))) {
                self.getMunicipalities().then(function (list) {
                    var match = /^(.*)\,(\s*\d{1,2}\s*)\,(\s*\d{1,4}\s*)$/.exec(_pattern);
                    if (match) {
                        var matcher = new RegExp($.trim(match[1]).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
                        var results = [];

                        const getItem = function (mun, munLabel, pol, par) {
                            var properties = [];

                            properties.push[self.MUN] = mun;
                            properties.push[self.POL] = pol;
                            properties.push[self.PAR] = par;

                            return {
                                id: self.MUN + mun + self.POL + pol + self.PAR + par,
                                label: self.getLabel(self.MUN + munLabel + self.POL + pol + self.PAR + par),
                                dataRole: TC.Consts.searchType.CADASTRAL,
                                properties: properties
                            };
                        };

                        results = $.grep(list, function (value) {
                            value = value.label || value.id || value;
                            return matcher.test(value) || matcher.test(self.removePunctuation(value));
                        });

                        if (results.length > 0) {
                            for (var i = 0; i < results.length; i++) {
                                results[i] = getItem(results[i].id, results[i].label, $.trim(match[2]), $.trim(match[3]));
                            }
                        }

                        if (/^[0-9]*$/g.test(match[1])) {

                            if (match[1].trim() === self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot) {

                                var suggestionRoot = list.filter(function (elm) {
                                    return parseInt(elm.id) === parseInt(self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL).suggestionRoot);
                                })[0];

                                if (suggestionRoot) {
                                    resolve([getItem(suggestionRoot.id, suggestionRoot.label, $.trim(match[2]), $.trim(match[3]))]);
                                }
                            }

                            results.push(getItem($.trim(match[1]), $.trim(match[1]), $.trim(match[2]), $.trim(match[3])));
                        }

                        //console.log('getCadastralRef promise resuelta');
                        resolve(results);
                    }
                });
            } else {
                //console.log('getCadastralRef promise resuelta - no es ref catastral');
                resolve([]);
            }
        });
    };

    ctlProto.stringPatternsValidators = {
        tsp: function (text, result, root, limit) {
            // town, street, portal - street, town, portal
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) {

                var getPortal = function () {
                    return formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[2].trim(), s: match[1].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[1].trim())) result.push({
                        t: match[1].trim(), s: match[2].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[1].trim(), t: match[2].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        spt: function (text, result, root, limit) {
            // street, portal, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);
            if (match && match[6] && match[1]) {

                var getPortal = function () {
                    return formatStreetNumber((match[2] || match[3] || match[4] || match[5]).trim());
                };
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[6].trim()) && /^([^0-9]+)$/i.test(match[1].trim())) {
                    result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    result.push({
                        t: match[1].trim(), s: match[6].trim(), p: getPortal()
                    });
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles
                    if (/^([^0-9]+)$/i.test(match[6].trim())) result.push({
                        t: match[6].trim(), s: match[1].trim(), p: getPortal()
                    });
                    else result.push({
                        s: match[6].trim(), t: match[1].trim(), p: getPortal()
                    });
                }
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        tnsp: function (text, result, root, limit) {
            // town, numbers street, portal
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)(?:\s*\,\s*)(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);

            if (match && match[1] && match[2]) {
                result.push({
                    t: match[2].trim(), s: match[1].trim(), p: formatStreetNumber((match[3] || match[4] || match[5] || match[6]).trim())
                });
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        ts: function (text, result, root, limit) {
            // town, street
            var match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(text);

            // topónimo, municipio
            if (!match && /^[^0-9]*$/i.test(text.trim())) { // si no hay números reviso dándole la vuelta, si hay números que lo trate la función st
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match && match[1] && match[2]) {
                // ninguno contiene número duplicamos búsqueda
                if (/^([^0-9]+)$/i.test(match[1].trim()) && /^([^0-9]+)$/i.test(match[2].trim())) {
                    result.push({
                        t: match[1].trim(), s: match[2].trim()
                    });
                    result.push({
                        s: match[1].trim(), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit);
                }
                else {  // indicamos como calle el criterio que contiene números, ya que no existen municipios con números pero sí calles

                    var getStreet = function (s) {
                        var revS = s.split(' ').reverse();
                        // validamos si el criterio es compuesto 
                        var fs = [];
                        for (var si = 0; si < revS.length; si++) {
                            if (revS[si].length == 1) {
                                fs.push(revS[si]);
                                revS[si] = '';
                            }
                        }

                        return fs.length > 0 ? revS.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : revS.reverse().join(' ').trim();
                    };

                    if (/^([^0-9]+)$/i.test(match[1].trim()))
                        result.push({
                            t: match[1].trim(), s: getStreet(match[2].trim())
                        });
                    else result.push({
                        s: getStreet(match[1].trim()), t: match[2].trim()
                    });

                    bindRoot.call(this, result, root, limit, true);
                }

                return true;
            }

            return false;
        },
        st: function (text, result, root, limit) {
            // street, town
            var match = /^(?:([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+))(?:\s*\,\s*)([^0-9\,]+)$/i.exec(text);

            if (!match) {
                var criteria = text.split(',').reverse();
                match = /^([^0-9\,]+)(?:\s*\,\s*)(?:([^\,][a-zñáéíóúüàèìòù"\s*\-\.\(\)\/0-9]+))$/i.exec(criteria.join(','));
            }

            if (match) { // puede generar falsos positivos cuando el portal llega seguido de la calle -> calle mayor 14, pamplona
                var data = {
                };
                var criteria = text.split(',').reverse();
                for (var i = 0; i < criteria.length; i++) {
                    if (/^([^0-9\,]+)$/i.test(criteria[i].trim())) { // si no hay números se trata de municipio
                        data.t = criteria[i].trim();
                    }
                    else if (/(\s*\d+)/i.test(criteria[i].trim())) { // si contiene número, puede ser calle o calle + portal
                        if (criteria[i].trim().indexOf(' ') == -1) { // si no contiene espacios se trata de calle compuesta por números
                            data.s = criteria[i].trim();
                        } else { // si contiene espacio puede contener calle + portal
                            var _criteria = criteria[i].trim().split(' ').reverse();

                            var isPortal = function (c) {
                                var m = /^(?:(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(c.trim());
                                if (m) {
                                    data.p = formatStreetNumber(c.trim());
                                    return true;
                                }
                                return false;
                            };

                            var x = 0;
                            var p = _criteria[x].trim();
                            while (x < _criteria.length && !isPortal(p)) {
                                x++;
                                if (x < _criteria.length)
                                    p = p + _criteria[x];

                            }

                            if (data.p) {
                                var _cr = _criteria;
                                for (var h = 0; h < _cr.length; h++) {
                                    // validamos que lo que hemos deducido como portal, está en portal para no añadirlo a calle
                                    var inPortal = false;
                                    for (var c = 0; c < _cr[h].split('').length; c++) {
                                        if (data.p.indexOf(_cr[h][c]) > -1)
                                            inPortal = true;
                                    }

                                    if (inPortal) {
                                        var _p = _cr[h];

                                        _cr[h] = '';
                                        if (data.p == formatStreetNumber(p))
                                            break;
                                    }
                                }

                                if (/^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9]+)$/i.test(_criteria.reverse().join(' ').trim())) {
                                    var fs = [];
                                    var criteriaRev = _criteria.reverse();
                                    for (var chs = 0; chs < criteriaRev.length; chs++) {
                                        if (criteriaRev[chs].trim().length == 1) {
                                            fs.push(criteriaRev[chs].trim());
                                            criteriaRev[chs] = '';
                                        }
                                    }

                                    data.s = fs.length > 0 ? criteriaRev.reverse().join(' ').trim() + self._LIKE_PATTERN + fs.reverse().join(self._LIKE_PATTERN) : criteriaRev.reverse().join(' ').trim();
                                }


                                // nombre_de_calle = 137, 1, 20...
                                // duplico la búsqueda para el caso de [Calle nombre_de_calle], municipio
                                result.push({
                                    t: data.t,
                                    s: data.s + ' ' + data.p
                                });
                            } else {
                                data.s = criteria[i].trim();
                            }
                        }
                    }
                }

                result.push(data);
                bindRoot.call(this, result, root, limit);
                return true;
            }

            return false;
        },
        s_or_t: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/0-9\<\>]+)$/i.exec(text);
            if (match && match[1]) {
                if (root) {
                    result.push({
                        t: match[1].trim()
                    });

                    result.push({
                        t: root,
                        s: match[1].trim()
                    });
                }
                else result.push({
                    t: match[1].trim()
                });
                return true;
            }

            return false;
        },
        sp: function (text, result, root, limit) {
            var match = /^([^\,][a-zñáéíóúüàèìòù\s*\-\.\(\)\/]+)\s*\,?\s*((\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4}))$/i.exec(text);
            if (match && match[1] && match[2]) { // && text.indexOf(',') > -1 && text.split(',').length < 3) {
                if (root)
                    result.push({
                        t: root,
                        s: match[1].trim(),
                        p: formatStreetNumber(match[2].trim())
                    });
                else
                    result.push({
                        t: match[1].trim(),
                        s: match[2].trim()
                    });

                return true;
            }

            return false;
        },
        snp: function (text, result, root, limit) { // calle puede contener números con portal (cuando exista un municipio root establecido)
            var match = /^([^\,][0-9\s*\-\.\(\)\/]+)\s*\,?\s*(\d{1,3}\s?\-?\s?[a-z]{0,4}\s?\-?\s?[a-z]{0,4})|([a-z]{1,4}\s?\-?\s?\d{1,3})|(sn|S\/N|s\/n|s\-n)|([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(text);
            if (match && match[1] && match[2] && root) {
                result.push({
                    t: root,
                    s: match[1].trim(),
                    p: formatStreetNumber(match[2].trim())
                });
                return true;
            }

            return false;
        }
    };

    /* métodos auxiliares de getStringPattern */

    const normalizedCriteria = function (value) {
        const self = this;

        var _value = '';

        value = self.removePunctuation(value);

        // elimino los caracteres especiales
        if (self.NORMAL_PATTERNS.ROMAN_NUMBER.test(value))
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE_NOT_DOT, '');
        else
            value = value.replace(self.NORMAL_PATTERNS.ABSOLUTE, '');
        return value.toLowerCase();
    };

    const formatStreetNumber = function (value) {
        var result = value;

        var is_nc_c = function (value) {
            return /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.test(value);
        }
        var nc_c = function (value) {
            var f = [];
            var m = /^(\d{1,3})\s?\-?\s?([a-z]{0,4})\s?\-?\s?([a-z]{0,4})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_cn = function (value) {
            return /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.test(value);
        };
        var cn = function (value) {
            var f = [];
            var m = /^([a-z]{1,4})\s?\-?\s?(\d{1,3})$/i.exec(value);
            if (m) {
                for (var i = 1; i < m.length; i++) {
                    if (m[i].trim().length > 0)
                        f.push(m[i].trim());
                }

                return f.join(self._LIKE_PATTERN);
            }
            return value;
        };

        var is_sn = function (value) {
            return /^(sn|S\/N|s\/n|s\-n)$/i.test(value);
        };
        var sn = function (value) {
            var m = /^(sn|S\/N|s\/n|s\-n)$/i.exec(value);
            if (m) {
                return 's*n';
            }
            return value;
        };


        var is_cmc = function (value) {
            return /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.test(value);
        };
        var cmc = function (value) {
            var m = /^([a-z]{1,4}\s?\+\s?[a-z]{1,4})$/i.exec(value);
            if (m) {
                return value;
            }
            return value;
        };

        var isCheck = [is_nc_c, is_cn, is_sn, is_cmc];
        var check = [nc_c, cn, sn, cmc];
        var ch = 0;
        while (ch < check.length && !isCheck[ch].call(self, value)) {
            ch++;
        }

        if (ch < check.length)
            return check[ch].call(self, value);
        else return value;
    };

    const bindRoot = function (result, root, limit, addRoot) {
        const self = this;

        if (root) {
            var i = result.length;
            while (i--) {
                if (!addRoot) {
                    if (result[i].t) {
                        var indicatedRoot = self.rootCfg.active.rootLabel.filter(function (elem) {
                            return elem.label.indexOf(self.removePunctuation(result[i].t).toLowerCase()) > -1;
                        }.bind(self));

                        if (indicatedRoot.length == 1) {
                            result[i].t = indicatedRoot[0].id;
                        } else if (indicatedRoot.length > 1) {

                            indicatedRoot.map(function (elem) {
                                var newResult = $.extend({
                                }, result[i]);
                                newResult.t = elem.id;

                                result.push(newResult);
                            });

                        } else if (indicatedRoot.length == 0 && limit) {
                            result.splice(i, 1);
                        }
                    }
                }
                else {
                    result.push($.extend({}, result[i], { t: root }));
                };
            }
        }
    };

    const getObjectsFromStringToQuery = function (allowedRoles, text) {
        const self = this;
        const root = self.rootCfg.active && self.rootCfg.active.root || '';
        const limit = self.rootCfg.active && self.rootCfg.active.limit || false;

        var result = [];

        const test = function () {
            var tests = [function (text) {
                return text.length >= 3;
            },
            function (text) {
                return /^\d+$/.test(text) ? false : (/^\d+\,\s*\d+$/.test(text) ? false : true);
            }];

            for (var i = 0; i < tests.length; i++) {
                if (!tests[i].call(self, text))
                    return false;
            }

            return true;
        };

        // eliminamos espacios en blanco
        text = text.trim();

        // comprobamos si acaba con coma, si es así, la eliminamos
        if (text.charAt(text.length - 1) == ',') {
            text = text.substring(0, text.length - 1);
        }

        if (test(text)) {
            var check = [];

            check = allowedRoles.map(function (dataRole) {
                return self.getSearchTypeByRole(dataRole);
            }).filter(function (searchType) {
                return searchType.stringPatternToCheck;
            }).map(function (searchType) {
                return searchType.stringPatternToCheck;
            });

            if (check.length === 0) {
                check = [self.stringPatternsValidators.tsp, self.stringPatternsValidators.spt, self.stringPatternsValidators.tnsp, self.stringPatternsValidators.ts, self.stringPatternsValidators.st];
                if (root && text.split(',').length < 3) {
                    check = [self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t].concat(check);
                }
                else {
                    check = check.concat([self.stringPatternsValidators.sp, self.stringPatternsValidators.snp, self.stringPatternsValidators.s_or_t]);
                }
            }

            var ch = 0;
            try {
                while (ch < check.length && !check[ch].call(self, text, result, root, limit)) {
                    ch++;
                }
            }
            catch (ex) {
                TC.error("Error según el patrón: " + text, TC.Consts.msgErrorMode.EMAIL, "Error en la búsqueda del callejero");
            }

            return result;
        }

        return null;
    };

    const requestToWFS = function (type, doneCallback, data) {
        const self = this;

        self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
        self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
        return TC.ajax({
            url: type.url,
            method: 'POST',
            //contentType: "application/x-www-form-urlencoded;charset=UTF-8",
            responseType: 'text',
            data: type.filter.getParams(data)
        })
            .then(doneCallback)
            .catch(function (data) {
                if (data.statusText !== 'abort')
                    alert('error');

                //console.log('getStringPattern promise resuelta - data.statusText: ' + data.statusText);
            });
    };

    const getResultsFromWFS = function (allowedRoles, resolve, reject, objectsToQuery) {
        const self = this;

        if (objectsToQuery) {
            var results = [];

            self._search.data = results;

            if (!self.request) {
                self.request = [];
            }

            objectsToQuery.forEach(function (data, i) {

                allowedRoles.filter(function (elm) {
                    var type = self.getSearchTypeByRole(elm);
                    return Object.keys(type.queryProperties).length === Object.keys(data).length;
                }).map(function (dataRole) {
                    var type = self.getSearchTypeByRole(dataRole);
                    self.request.push(requestToWFS.call(self, type, function (data) {
                        results = results.concat(type.getSuggestionListElements(data));
                    }, data));
                });
            });

            Promise.all(self.request).then(function () {
                //self.request = [];
                //console.log('getStringPattern promise resuelta');
                resolve(results);
            });
        } else {
            //console.log('getStringPattern promise resuelta - no encaja en address');
            resolve([]);
        }
    };

    ctlProto.getStringPattern = function (allowedRoles, pattern) {
        const self = this;

        return new Promise(function (resolve, reject) {
            pattern = normalizedCriteria.call(self, pattern);

            /* gestionamos:
                Entidad de población: Irisarri Auzoa (Igantzi)
                Topónimo: Aldabeko Bidea (Arbizu)
            */
            var combinedCriteria = /(.*)\((.*)\)/.exec(pattern);
            if (combinedCriteria && combinedCriteria.length > 2) {

                // búsqueda de entidad de población
                var objectsToQuery = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1]);

                // búsqueda de topónimo
                var bothSearchObjects = getObjectsFromStringToQuery.call(self, allowedRoles, combinedCriteria[1] + ',' + combinedCriteria[2]);

                bothSearchObjects = (bothSearchObjects || []).concat(objectsToQuery || []);

                getResultsFromWFS.call(self, allowedRoles, resolve, reject, bothSearchObjects);
            } else {
                var objectsToQuery = getObjectsFromStringToQuery.call(self, allowedRoles, pattern);

                getResultsFromWFS.call(self, allowedRoles, resolve, reject, objectsToQuery);
            }
        });
    };

    ctlProto.getRoad = function (pattern) {
        const self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 2) {
                resolve([]);
            } else {
                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

                var roadPattern = type.getPattern();
                var match = roadPattern.exec(pattern);
                if (match && match[3]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    TC.ajax({
                        url: type.url + '?' + type.filter.getParams({ t: _pattern }),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON
                    }).then(function (data) {
                        var result = [];                        

                        if (data.totalFeatures > 0) {
                            data.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.text == feature.properties[properties[0]]);
                                })) {
                                    var label = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));

                                    var text = type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }).join('-');

                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: label,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });

                            //console.log('getRoad promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoad promise resuelta');
                            resolve([]);
                        }
                    }).catch(function (data) {
                        //console.log('getRoad promise resuelta - xhr fail');
                        resolve([]);
                    });
                } else {
                    //console.log('getRoad promise resuelta - no encaja en road');
                    resolve([]);
                }
            }
        });
    };

    ctlProto.getPK = function (pattern) {
        var self = this;
        return new Promise(function (resolve, reject) {
            pattern = pattern.trim();
            if (pattern.length < 3) {
                resolve([]);
            } else {

                var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

                var roadPKPattern = type.getPattern();
                var match = roadPKPattern.exec(pattern);
                if (match && match[3] && match[5]) {

                    var _pattern = match[2] ? match[2].trim() + "-" + match[3].trim() : match[3].trim();
                    if (match[4] && match[4].length > 0) {
                        _pattern = _pattern + "-" + match[4].trim();
                    }

                    self.resultsList.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + self.getLocaleString('searching') + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>';
                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    TC.ajax({
                        url: type.url + '?' + type.filter.getParams({ t: _pattern, s: match[5].trim() }),
                        method: 'GET',
                        responseType: TC.Consts.mimeType.JSON                        
                    }).then(function (data) {
                        var result = [];
                        if (data.totalFeatures > 0) {
                            data.features.map(function (feature) {
                                var properties = type.outputProperties;
                                if (!result.some(function (elem) {
                                    return (elem.label == feature.properties[properties[0]]);
                                })) {
                                    var text = type.outputFormatLabel.tcFormat(type.outputProperties.map(function (outputProperty) {
                                        return feature.properties[outputProperty];
                                    }));
                                    result.push({
                                        id: type.dataIdProperty.map(function (elem) {
                                            return feature.properties[elem];
                                        }).join('#'),
                                        label: text,
                                        text: text,
                                        dataLayer: feature.id.split('.')[0],
                                        dataRole: type.typeName
                                    });
                                }
                            });
                            //console.log('getRoadPK promise resuelta');
                            resolve(result);
                        } else {
                            //console.log('getRoadPK promise resuelta');
                            resolve([]);
                        }
                    }).catch(function (data) {
                        //console.log('getRoadPK promise resuelta - xhr fail');
                        resolve([]);
                    });
                } else {
                    //console.log('getRoadPK promise resuelta - no encaja en pk');
                    resolve([]);
                }
            }
        });
    };

    ctlProto.search = function (pattern, callback) {
        var self = this;
        var results = [];

        if (self.request) {

            for (var i = 0; i < self.request.length; i++) {
                console.log("new criteria: search promise/s aborted");
                //self.request[i].abort();
            }

            self.request = [];
        }

        pattern = $.trim(pattern);
        if (pattern.length > 0) {
            pattern = pattern.toLowerCase();

            var waiting = [];
            var addWaiting = function (fn) {
                waiting.push(new Promise(function (resolve, reject) {
                    fn.call(self, pattern).then(function (result) {
                        results = results.concat(result);
                        resolve(results);
                    });
                }));
            };

            var addressSearched = false;

            self.allowedSearchTypes.forEach(function (allowed) {
                if (allowed.parser) {
                    addWaiting(allowed.parser);
                } else {
                    console.log('Falta implementación del método parser');
                }
            });

            Promise.all(waiting).then(function () {
                if (results)
                    self._search.data = results = results.sort(function (a, b) {
                        var pattern = /(\d+)/;
                        var _a, _b = '';
                        if (pattern.test(a.label) && pattern.test(b.label)) {
                            _a = a.label.match(pattern)[1];
                            _b = b.label.match(pattern)[1];
                        } else {
                            _a = a.label;
                            _b = b.label;
                        }

                        if (_a > _b)
                            return 1;
                        else
                            if (_a < _b)
                                return -1;
                            else
                                return 0;
                    }.bind(self));

                if (callback)
                    callback(results);

                if (results.length === 0) {
                    self.cleanMap();

                    if (!self.layer ||
                        (self.layer && self.layer.features.length === 0)) {
                        self.resultsList.innerHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';
                        self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));
                    }
                }

                self.lastPattern = "";
            });
        }
        else self.cleanMap();
    };

    var setQueryableFeatures = function (features) {
        var self = this;

        if (features && features.length > 0) {
            for (var i = 0; i < features.length; i++) {
                if (features[i].showsPopup != self.queryableFeatures)
                    features[i].showsPopup = self.queryableFeatures;
            }
        }
    };
    ctlProto._goToResult = function (id, dataRole) {
        var self = this;
        var goTo = null;
        return new Promise(function (resolve, reject) {
            if (!self.loading)
                self.loading = self.map.getControlsByClass("TC.control.LoadingIndicator")[0];

            var wait;
            wait = self.loading.addWait();

            // en pantallas pequeñas, colapsamos el panel de herramientas
            if (Modernizr.mq('(max-width: 30em)')) {
                self.textInput.blur();
                self.map.trigger(TC.Consts.event.TOOLSCLOSE);
            }

            self.cleanMap();

            var customSearchType = false;
            var keepOnLooping = true;

            self.allowedSearchTypes.forEach(function (allowed) {
                if (keepOnLooping) {

                    if (!self.availableSearchTypes[allowed.typeName]) {

                        if (allowed.goTo) {
                            customSearchType = true;

                            goTo = allowed.goTo.call(self, id);
                            if (goTo !== null) {
                                keepOnLooping = false;
                            }
                        } else console.log('Falta implementación del método goTo');

                    } else {

                        var dr = dataRole || self.getElementOnSuggestionList.call(self, id).dataRole;
                        if (dr) {

                            var searchType = self.getSearchTypeByRole(dr);

                            if (self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else if (!self.availableSearchTypes[dr] && searchType && searchType.goTo) {
                                customSearchType = true;

                                goTo = searchType.goTo.call(self, id, dr);
                                if (goTo !== null) {
                                    keepOnLooping = false;
                                }
                            } else console.log('Falta implementación del método goTo');
                        }
                    }
                }
            });

            self.loading.removeWait(wait);

            if (goTo) {

                self.getLayer().then(function (layer) {
                    switch (true) {
                        case goTo.params.type == TC.Consts.layerType.VECTOR:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                if (layer.hasOwnProperty(self.WFS_TYPE_ATTRS[i]))
                                    delete layer[self.WFS_TYPE_ATTRS[i]];
                            }
                            break;
                        case goTo.params.type == TC.Consts.layerType.WFS:
                            for (var i = 0; i < self.WFS_TYPE_ATTRS.length; i++) {
                                layer[self.WFS_TYPE_ATTRS[i]] = goTo.params[self.WFS_TYPE_ATTRS[i]];
                            }

                            wait = self.loading.addWait();
                            break;
                        default:
                    }

                    layer.type = goTo.params.type;

                    self.map.on(TC.Consts.event.FEATURESADD, function (e) {
                        if (e.layer === self.layer) {
                            setQueryableFeatures.call(self, e.features);
                        }
                    });

                    layer.refresh().then(function () {
                        self.map.one(TC.Consts.event.LAYERUPDATE, function (e) {
                            if (e.layer == layer) {
                                // Salta cuando se pinta una feature que no es de tipo API porque la gestión de estilos salta antes (no es controlable)
                                self.map.one(TC.Consts.event.FEATURESADD, function (e) {
                                    if (e.layer == layer) {
                                        if (!e.layer.features || e.layer.features.length == 0 && e.layer.wrap.layer.getSource().getFeatures()) {
                                            self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                            var bounds = e.layer.wrap.layer.getSource().getExtent();
                                            var radius = e.layer.map.options.pointBoundsRadius;

                                            if (bounds[2] - bounds[0] === 0) {
                                                bounds[0] = bounds[0] - radius;
                                                bounds[2] = bounds[2] + radius;
                                            }
                                            if (bounds[3] - bounds[1] === 0) {
                                                bounds[1] = bounds[1] - radius;
                                                bounds[3] = bounds[3] + radius;
                                            }
                                            e.layer.map.setExtent(bounds);

                                            // GLS: Necesito diferenciar un zoom programático de un zoom del usuario para la gestión del zoom en 3D
                                            self.map.trigger(TC.Consts.event.ZOOMTO, {
                                                extent: bounds, layer: e.layer
                                            });
                                        }
                                        else if (e.layer.features && e.layer.features.length > 0) {
                                            self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                            self.layer.map.zoomToFeatures(e.layer.features);

                                            self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                        } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                            self.resultsList.inner = goTo.emptyResultHTML;
                                            self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                            self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                        }

                                        self.loading.removeWait(wait);
                                    }
                                });

                                if (e.layer.features && e.layer.features.length > 0) {
                                    self.resultsList.classList.add(TC.Consts.classes.HIDDEN);
                                    self.layer.map.zoomToFeatures(self.layer.features);

                                    self.map.trigger(TC.Consts.event.FEATURESADD, { layer: self.layer, features: self.layer.features });

                                    self.loading.removeWait(wait);
                                } else if (e.layer.features && e.layer.features.length == 0 && goTo.params.type == TC.Consts.layerType.WFS) {
                                    self.resultsList.innerHTML = goTo.emptyResultHTML;
                                    self.textInput.dispatchEvent(new CustomEvent("targetUpdated.autocomplete"));

                                    if (!(e.newData && e.newData.features && e.newData.features.length > 0)) {
                                        self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                                    }

                                    self.loading.removeWait(wait);
                                }
                            }
                        });
                    });
                });

                resolve(goTo);
            } else {
                reject();
                if (!customSearchType) {
                    self.map.trigger(TC.Consts.event.SEARCHQUERYEMPTY);
                }
            }
        });
    };

    ctlProto.goToResult = function (id, dataRole) {
        var self = this;
        // si está habilitada
        if (self.getSearchTypeByRole(dataRole)) {
            return self._goToResult(id, dataRole);
            // si no está habilitada pero está disponible
        } else if (self.availableSearchTypes[dataRole]) {
            self.addAllowedSearchType(dataRole, self.availableSearchTypes[dataRole], self);
            return self._goToResult(id, dataRole);
        } else {
            alert('No se reconoce el tipo de búsqueda: ' + dataRole);
        }
    };

    var drawPoint = function (id) {
        var self = this;

        wait = self.loading.addWait();

        var point = self.getPoint(id);
        var delta;
        var title;
        var promise;

        if (point) {
            title = self.getLabel(id);
            promise = self.layer.addMarker(point, $.extend({}, self.map.options.styles.point, { title: title, group: title }));
        } else {
            var match = /^Lat((?:[+-]?)\d+(?:\.\d+)?)Lon((?:[+-]?)\d+(?:\.\d+)?)$/.exec(id);
            id = self.LAT + match[2] + self.LON + match[1];
            point = self.getPoint(id);

            if (point) {
                title = self.getLabel(id);
                promise = self.layer.addMarker(point, $.extend({}, self.map.options.styles.point, { title: title, group: title }));

                self.textInput.value = title;
            }
        }

        promise.then(function (feat) {
            self.map.trigger(TC.Consts.event.FEATURESADD, {
                layer: self.layer, features: [feat]
            });

            self.map.zoomToFeatures([feat]);

            self.loading.removeWait(wait);
        });

    };
    ctlProto.goToCoordinates = function (id) {
        var self = this;
        var goTo = {};
        if (/^X(\d+(?:[\.\,]\d+)?)Y(\d+(?:[\.\,]\d+)?)$/.test(id) || /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.test(id)) {

            goTo.params = {
                type: TC.Consts.layerType.VECTOR,
                styles: {
                    marker: {
                        url: self.layerStyleFN.bind(self, 'marker', 'url', true)
                    }
                }
            };

            goTo.emptyResultHTML = '<li><a class="tc-ctl-search-li-empty">' + self.OUTBBX_LABEL + '</a></li>';

            drawPoint.call(self, id);

            return goTo;
        }

        return null;
    };

    ctlProto.goToCadastralRef = function (id) {
        var self = this;
        var goTo = {};

        var regex = new RegExp("^" + self.MUN + "(\\d+)" + self.POL + "(\\d{1,2})" + self.PAR + "{1}(\\d{1,4})");
        if (regex.test(id)) {
            var match = regex.exec(id);

            if (!TC.filter) {
                TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
            }

            var type = self.getSearchTypeByRole(TC.Consts.searchType.CADASTRAL);

            goTo.params = {
                type: TC.Consts.layerType.WFS,
                url: type.url,
                version: type.version,
                geometryName: type.geometryName,
                featurePrefix: type.featurePrefix,
                featureType: type.featureType,
                properties: new TC.filter.and(
                    new TC.filter.equalTo(type.queryProperties.firstQueryWord, $.trim(match[1])),
                    new TC.filter.equalTo(type.queryProperties.secondQueryWord, $.trim(match[2])),
                    new TC.filter.equalTo(type.queryProperties.thirdQueryWord, $.trim(match[3]))),
                outputFormat: type.outputFormat,
                styles: type.styles
            };

            goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

            return goTo;
        }

        return null;
    };

    ctlProto.goToRoad = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROAD);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToPK = function (id) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(TC.Consts.searchType.ROADPK);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        goTo.emptyResultHTML = '<li><a title="' + self.EMPTY_RESULTS_TITLE + '" class="tc-ctl-search-li-empty">' + self.EMPTY_RESULTS_LABEL + '</a></li>';

        return goTo;
    };

    ctlProto.goToStringPattern = function (id, dataRole) {
        var self = this;
        var goTo = {};

        var type = self.getSearchTypeByRole(dataRole);

        goTo.params = {
            type: TC.Consts.layerType.WFS,
            url: type.url,
            version: type.version,
            geometryName: type.geometryName,
            featurePrefix: type.featurePrefix,
            featureType: type.getFeatureTypes(),
            maxFeatures: 3000,
            properties: type.filter.getGoToFilter(id),
            outputFormat: type.outputFormat,
            styles: type.styles
        };

        return goTo;
    };

    ctlProto.getPoint = function (pattern) {
        var self = this;
        var isMapGeo = self.map.wrap.isGeo();
        var point;
        var match = /^X(\d+(?:\.\d+)?)Y(\d+(?:\.\d+)?)$/.exec(pattern);
        if (match && match.length === 3) {
            point = [parseFloat(match[1]), parseFloat(match[2])];
            if (isMapGeo) {
                point = TC.Util.reproject(point, self.map.options.utmCrs, self.map.crs);
            }
        }
        else {
            match = /^Lat((?:[+-]?)\d+(?:[.,]\d+)?)Lon((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }

            match = /^Lon((?:[+-]?)\d+(?:[.,]\d+)?)Lat((?:[+-]?)\d+(?:[.,]\d+)?)$/.exec(pattern);
            if (match && match.length === 3) {
                point = [parseFloat(match[2]), parseFloat(match[1])];
                if (!isMapGeo) {
                    return TC.Util.reproject(point, self.map.options.geoCrs, self.map.crs);
                }
            }
        }

        return point;
    };

    ctlProto.insideLimit = function (point) {
        var self = this;
        var getIntersectsBounds = function (extent, point) {
            if (extent instanceof Array)
                return point[0] >= extent[0] && point[0] <= extent[2] && point[1] >= extent[1] && point[1] <= extent[3];
            else return true;
        };

        if (getIntersectsBounds(self.map.options.maxExtent, point)) {
            return true;
        }

        return false;
    };

    ctlProto.getPattern = function () {
        var self = this;
        return self.textInput.value;
    };

    ctlProto.getLabel = function (id) {
        var self = this;
        var result = id;
        var locale = TC.Util.getMapLocale(self.map);

        if (id.match(new RegExp('^(?:' + self.LAT + '[-\\d])|(?:' + self.UTMX + '[\\d])'))) {
            result = result.replace(self.LAT, self.LAT_LABEL).replace(self.LON, ' ' + self.LON_LABEL).replace(self.UTMX, self.UTMX_LABEL).replace(self.UTMY, ' ' + self.UTMY_LABEL);
            var match = result.match(new RegExp('^' + $.trim(self.LAT_LABEL) + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + $.trim(self.LON_LABEL) + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

            var localeDecimalSeparator = 1.1.toLocaleString(locale).substring(1, 2);
            var match = result.match(new RegExp('^' + $.trim(self.UTMX_LABEL) + '*\\s*([0-9]{' + self.UTMX_LEN + '}(?:[.,]\\d+)?)\\s*\\,?\\s*' + $.trim(self.UTMY_LABEL) + '*\\s*([0-9]{' + self.UTMY_LEN + '}(?:[.,]\\d+)?)$'));
            if (match) {
                if (!Number.isInteger(parseFloat(match[1])))
                    result = result.replace(match[1], match[1].replace('.', localeDecimalSeparator));
                if (!Number.isInteger(parseFloat(match[2])))
                    result = result.replace(match[2], match[2].replace('.', localeDecimalSeparator));
            }

        } else if (id.match(new RegExp('^(?:' + self.LON + '[-\\d])'))) {
            result = result.replace(self.LON, self.LON_LABEL).replace(self.LAT, ' ' + self.LAT_LABEL);

            var match = result.match(new RegExp('^' + $.trim(self.LON_LABEL) + '*\\s*([-+]?\\d{1,3}([.,]\\d+)?)\\,?\\s*' + $.trim(self.LAT_LABEL) + '*\\s*([-+]?\\d{1,2}([.,]\\d+)?)$'));
            if (match) {
                result = result.replace(match[1], parseFloat(match[1]).toLocaleString(locale));
                result = result.replace(match[3], parseFloat(match[3]).toLocaleString(locale));
            }

        } else if (id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'))) {
            var match = id.match(new RegExp('^(?:(\\' + self.MUN + '{1})(.*)' + '(\\' + self.POL + '{1})' + '(\\d{1,2})' + '(\\' + self.PAR + '{1})' + '(\\d{1,4}))'));
            result = self.MUN_LABEL + match[2] + ', ' + self.POL_LABEL + match[4] + ', ' + self.PAR_LABEL + match[6];
        }
        return result;
    };

    ctlProto.removePunctuation = function (text) {
        text = text || '';
        var result = new Array(text.length);
        var map = {
            'á': 'a',
            'à': 'a',
            'Á': 'A',
            'À': 'A',
            'é': 'e',
            'è': 'e',
            'É': 'E',
            'È': 'E',
            'í': 'i',
            'ì': 'i',
            'Í': 'I',
            'Ì': 'I',
            'ó': 'o',
            'ò': 'o',
            'Ó': 'O',
            'Ò': 'O',
            'ú': 'u',
            'ù': 'u',
            'ü': 'u',
            'Ú': 'U',
            'Ù': 'U',
            'Ü': 'U'
        };
        for (var i = 0, len = text.length; i < len; i++) {
            result[i] = map[text.charAt(i)] || text.charAt(i);
        }
        return result.join('');
    };    

    ctlProto.exportState = function () {
        const self = this;
        if (self.exportsState) {
            return {
                id: self.id,
                searchText: self.textInput.value,
                layer: self.layer.exportState({
                    exportStyles: false
                })
            };
        }
        return null;
    };

    ctlProto.importState = function (state) {
        const self = this;
        self.textInput.value = state.searchText;
        self.layer.importState(state.layer).then(function () {
            self.layer.features.forEach(function (f) {
                f.setStyle(null); // Los estilos vienen dados exclusivamente por la capa, borramos estilos propios de la feature
            });
        });
    };

})();


if (!String.prototype.tcFormat) {
    String.prototype.tcFormat = function () {
        var args = (arguments || [""])[0];
        return this.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined' ?
                args[number]
                : match
                ;
        });
    };
}


if (!String.prototype.splitRemoveWhiteSpaces) {
    String.prototype.splitRemoveWhiteSpaces = function (separator) {
        var _arr = [];
        var arr = this.split(separator);
        for (var i = 0; i < arr.length; i++)
            if (arr[i].trim().length > 0)
                _arr.push(arr[i].trim());

        return _arr;
    };
}


if (!String.prototype.toCamelCase) {
    String.prototype.toCamelCase = function () {
        var _value = this.toLowerCase();
        var match = this.toLowerCase().match(/[^A-ZÁÉÍÓÚÜÀÈÌÒÙáéíóúüàèìòùa-z0-9_]+(.)/g);
        if (match) {
            for (var i = 0; i < match.length; i++) {
                if (/[-;:.<>\{\}\[\]\/\s()]/g.test(match[i]))
                    _value = _value.replace(match[i], match[i].toUpperCase());
            }
        }

        return _value.charAt(0).toUpperCase() + _value.substring(1);
    };
}


if (!Array.prototype.hasOwnProperty('findByProperty')) {
    Object.defineProperty(Array.prototype, "findByProperty", {
        enumerable: false,
        writable: true,
        value: function (propertyName, value) {
            for (var i = 0; i < this.length; i++) {
                if (this[i][propertyName] == value)
                    return this[i];
            }
        }
    });
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}

﻿TC.control = TC.control || {};

if (!TC.control.TabContainer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/TabContainer');
}

TC.control.SelectContainer = TC.control.TabContainer;
﻿TC.control = TC.control || {};

if (!TC.control.MapInfo) {
    TC.syncLoadJS(TC.apiLocation + 'TC/control/MapInfo');
}

TC.control.Share = function (options) {
    var self = this;
    self._classSelector = '.' + self.CLASS;

    TC.Control.apply(self, arguments);

    self.exportsState = true;

    var opts = options || {};
    self._dialogDiv = TC.Util.getDiv(opts.dialogDiv);
    self._$dialogDiv = $(self._dialogDiv);
    if (!opts.dialogDiv) {
        document.body.appendChild(self._dialogDiv);
    }

    self.render();
};

TC.inherit(TC.control.Share, TC.control.MapInfo);

(function () {
    var ctlProto = TC.control.Share.prototype;

    ctlProto.CLASS = 'tc-ctl-share';
    ctlProto.MAILTO_MAX_LENGTH = 256;
    ctlProto.IFRAME_WIDTH = '600px';
    ctlProto.IFRAME_HEIGHT = '450px';
    ctlProto.FEATURE_PARAM = 'showfeature';

    ctlProto.MOBILEFAV = 'Siga las instrucciones del navegador del dispositivo móvil para añadir como favorito. Se guardará el estado actual del mapa.';
    ctlProto.NAVALERT = ' +D para guardar en marcadores.';


    ctlProto.render = function (callback) {
        const self = this;
        return self.getRenderedHtml(self.CLASS + '-dialog', null, function (html) {
            self._dialogDiv.innerHTML = html;
        }).then(function () {
            return TC.Control.prototype.render.call(self, function () {
                //Si el navegador no soporta copiar al portapapeles, ocultamos el botón de copiar
                if (TC.Util.detectChrome() || TC.Util.detectIE() >= 10 || TC.Util.detectFirefox() >= 41) {
                    self.div.querySelectorAll('button').forEach(function (btn) {
                        btn.classList.remove('hide');
                    });
                    self.div.querySelectorAll('input[type=text]').forEach(function (input) {
                        delete input.dataset.dataOriginalTitle;
                    });
                }

                // Si el SO no es móvil, ocultamos el botón de compartir a WhatsApp
                if (!TC.Util.detectMobile()) {
                    self.div.querySelector(".share-whatsapp").classList.add(TC.Consts.classes.HIDDEN);
                }

                const options = self.div.querySelectorAll('.' + self.CLASS + '-url-box');
                self.div.querySelectorAll('span:not(.tc-beta)').forEach(function (span) {
                    span.addEventListener(TC.Consts.event.CLICK, function (e) {
                        var label = this;
                        while (label && label.tagName !== 'LABEL') {
                            label = label.parentElement;
                        }
                        const newFormat = label.querySelector('input[type=radio][name=format]').value;

                        options.forEach(function (option) {
                            if (option.matches('.tc-' + newFormat)) {
                                option.classList.remove(TC.Consts.classes.HIDDEN);
                            }
                            else {
                                option.classList.add(TC.Consts.classes.HIDDEN);
                            }
                        });
                    });
                });
                if ($.isFunction(callback)) {
                    callback();
                }
            });
        });
    };

    /**
     * Obtiene una URL "limpia" para compartir el mapa.
     */
    ctlProto.getLocation = function () {
        var result = window.location.href;
        if (window.location.hash) {
            result = result.substr(0, result.indexOf(window.location.hash));
        }
        return result;
    };

    ctlProto.manageMaxLengthExceed = function (maxLengthExceed) {
        const self = this;

        const browserAlert = self.div.querySelector('.' + self.CLASS + '-alert');
        if (maxLengthExceed.browser) { //Si la URL sobrepasa el tamaño máximo avisamos que puede fallar en IE
            browserAlert.classList.remove(TC.Consts.classes.HIDDEN);
        } else {
            browserAlert.classList.add(TC.Consts.classes.HIDDEN);
        }

        const qrAlert = self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert');
        if (maxLengthExceed.qr) {
            qrAlert.classList.remove(TC.Consts.classes.HIDDEN);
        } else {
            qrAlert.classList.add(TC.Consts.classes.HIDDEN);
        }
    };

    ctlProto.generateIframe = function (url) {
        var self = this;
        var urlString = url || this.generateLink();
        if (urlString) {
            return '<iframe style="width:' + self.IFRAME_WIDTH + ';height:' + self.IFRAME_HEIGHT + ';" src="' + urlString + '"></iframe>';
        }
    }

    ctlProto.loadParamFeature = function () {
        const self = this;
        var result = null;
        var featureToShow = TC.Util.getParameterByName(self.FEATURE_PARAM);
        if (featureToShow) {
            var featureObj;
            try {
                featureObj = JSON.parse(decodeURIComponent(escape(window.atob(featureToShow))));
            }
            catch (error) {
                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);
            }
            if (featureObj && self.map) {
                if (featureObj.geom) {
                    self.map.addLayer({
                        id: self.getUID(),
                        type: TC.Consts.layerType.VECTOR,
                        title: self.getLocaleString('foi'),
                        stealth: true
                    }).then(function (layer) {
                        self.paramFeatureLayer = layer;
                        layer.importState({ features: [featureObj] }).then(function () {
                            self.map.zoomToFeatures(layer.features);
                        });
                    });
                }
                else {
                    result = featureObj;
                }
            }
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.control.MapInfo.prototype.register.call(self, map);

        self.exportsState = true;

        self.MOBILEFAV = self.getLocaleString('mobileBookmarks.instructions');
        self.NAVALERT = self.getLocaleString('bookmarks.instructions');

        var selectInputField = function (elm) {
            const input = elm.parentElement.querySelector("input[type=text]");
            input.value = input.classList.contains('tc-url') ? self.generateLink() : self.generateIframe();
            input.select();
        };

        var unselectInputField = function () {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        };

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('h2', function (evt) {
            const link = self.generateLink();
            self.registerListeners();
            self.div.querySelector('.tc-url input[type=text]').value = link;
            self.div.querySelector('.tc-iframe input[type=text]').value = self.generateIframe(link);
        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.tc-ctl-share-url-box button', function (evt) {
            const copyBtn = evt.target;
            selectInputField(copyBtn);
            document.execCommand('copy');

            copyBtn.textContent = self.getLocaleString('copied');


            setTimeout(function () {
                copyBtn.textContent = self.getLocaleString('copy');
                unselectInputField();
            }, 1000);

        }));

        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('input[type=text]', function (evt) {
            selectInputField(evt.target);
        }));

        //Deshabilitar el click de ratón en los enlaces de compartir cuando están deshabilitados
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('.ga-share-icon.disabled', function (evt) {
            evt.stopImmediatePropagation();
            evt.preventDefault();
            return false;
        }));

        //Enviar por e-mail
        self.div.addEventListener('click', TC.EventTarget.listenerBySelector('a.share-email', function (evt) {
            evt.preventDefault();
            var url = self.generateLink();

            if (url) {
                const body = encodeURIComponent(url + "\n");
                if (body.length > self.MAILTO_MAX_LENGTH) {
                    map.toast(self.getLocaleString('urlTooLongForMailto'), { type: TC.Consts.msgType.WARNING });
                }
                window.location.href = 'mailto:?body=' + body;
            }
        }));

        //Generar código QR        
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.qr-generator", function (evt) {
            evt.preventDefault();
            const qrContainer = self._dialogDiv.querySelector(".qrcode");
            qrContainer.innerHTML = '';

            if (self._dialogDiv.querySelector('.' + self.CLASS + '-qr-alert').classList.contains(TC.Consts.classes.HIDDEN)) {                
                self.makeQRCode(qrContainer, 256, 256).then(function (qrCodeBase64) {
                    if (qrCodeBase64) {
                        TC.Util.showModal(self._$dialogDiv.get(0).querySelector(self._classSelector + '-qr-dialog'));
                    }
                });
            } else {
                TC.Util.showModal(self._$dialogDiv.get(0).querySelector(self._classSelector + '-qr-dialog'));
            }
        }));

        
        const openSocialMedia = function (win, url, process) {
            if (url && url.trim().length > 0) {
                win.location.href = process(url);
            } else {
                TC.error(self.getLocaleString('urlTooLongForShortener'));
                win.close();
            }
        };

        //Compartir en Facebook
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-fb", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    return "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(url)
                });
            });

            return false;
        }));

        //Compartir en Twitter
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-twitter", function (evt) {
            evt.preventDefault();

            const w = window.open();
            self.shortenedLink().then(function (url) {
                openSocialMedia(w, url, function (url) {
                    var titulo = encodeURIComponent(window.document.title ? window.document.title : "Visor API SITNA");
                    return "https://twitter.com/intent/tweet?text=" + titulo + "&amp;url=" + encodeURIComponent(url);
                });
            });

            return false;
        }));

        //Compartir en Whatsapp
        if (TC.Util.detectMobile()) {
            self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-whatsapp", function (evt) {
                evt.preventDefault();

                self.shortenedLink().then(function (url) {
                    var waText = 'whatsapp://send?text=';
                    if (url !== undefined) {
                        location.href = waText + encodeURIComponent(url);
                    } else {
                        location.href = waText + encodeURIComponent(self.generateLink());
                    }
                });

                return false;
            }));
        }

        //Guardar en marcadores
        self.div.addEventListener("click", TC.EventTarget.listenerBySelector("a.share-star", function (evt) {
            evt.preventDefault();

            var bookmarkURL = self.generateLink();
            var bookmarkTitle = document.title;

            if (TC.Util.detectMobile()) {
                // Mobile browsers
                alert(ctlProto.MOBILEFAV);
            } else if (window.sidebar && window.sidebar.addPanel) {
                // Firefox version < 23
                window.sidebar.addPanel(bookmarkTitle, bookmarkURL, '');
            } else if ((window.sidebar && /Firefox/i.test(navigator.userAgent)) || (window.opera && window.print)) {
                // Firefox version >= 23 and Opera Hotlist                

                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);

            } else if (window.external && ('AddFavorite' in window.external)) {
                // IE Favorite
                window.external.AddFavorite(bookmarkURL, bookmarkTitle);
            } else {
                // Other browsers (mainly WebKit - Chrome/Safari)                
                window.location.href = bookmarkURL;
                alert((/Mac/i.test(navigator.userAgent) ? 'Cmd' : 'Ctrl') + ctlProto.NAVALERT);
            }

            return false;
        }));

        //Cuando se añada o borre una capa, comprobamos de nuevo si la URL cumple los requisitos de longitud para habilitar el control
        //map.on(TC.Consts.event.MAPLOAD, function () {
        //    map.on(TC.Consts.event.LAYERREMOVE + ' ' + TC.Consts.event.LAYERADD, function (e) {
        //        self.generateLink();
        //    });
        //});        

        return result;
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/Share.html";
        ctlProto.template[ctlProto.CLASS + '-dialog'] = TC.apiLocation + "TC/templates/ShareDialog.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<h2>").h("i18n", ctx, {}, { "$key": "share" }).w(" </h2><div><div class=\"ga-share-icons\"><a class=\"ga-share-icon share-email\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "sendMapByEmail" }).w("\"href=\"#\"><i class=\"icon-envelope-alt\"></i></a><a class=\"ga-share-icon qr-generator\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "createQrCode" }).w("\"href=\"#\"><i class=\"icon-qrcode\"></i></a><a class=\"ga-share-icon share-fb\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToFacebook" }).w("\"href=\"#\"><i class=\"icon-facebook\"></i></a><a class=\"ga-share-icon share-twitter\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToTwitter" }).w("\"href=\"#\"><i class=\"icon-twitter\"></i></a><a class=\"ga-share-icon share-whatsapp\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareMapToWhatsapp" }).w("\"href=\"#\"><i class=\"icon-whatsapp\"></i></a><a class=\"ga-share-icon share-star\" target=\"_blank\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "addToBookmarks" }).w("\"href=\"#\"><i class=\"icon-star\"></i></a></div><div class=\"tc-ctl-share-select\"><form><label class=\"tc-ctl-share-btn-url\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink" }).w("\"><input type=\"radio\" checked=\"checked\" name=\"format\" value=\"url\" /><span>").h("i18n", ctx, {}, { "$key": "shareLink" }).w("</span></label><label class=\"tc-ctl-share-btn-iframe\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap" }).w("\"><input type=\"radio\" name=\"format\" value=\"iframe\" /><span>").h("i18n", ctx, {}, { "$key": "embedMap" }).w("</span></label></form></div><div class=\"tc-ctl-share-url-box tc-group tc-url\"><input type=\"text\" class=\"tc-textbox tc-url\" readonly data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink.tip.1" }).w("\" /><button class=\"tc-button hide\" title=\"").h("i18n", ctx, {}, { "$key": "shareLink.tip.2" }).w("\">").h("i18n", ctx, {}, { "$key": "copy" }).w("</button></div><div class=\"tc-ctl-share-url-box tc-group tc-iframe tc-hidden\"><input type=\"text\" class=\"tc-textbox tc-iframe\" readonly data-toggle=\"tooltip\" data-placement=\"top\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap.tip.1" }).w("\" /><button class=\"tc-button hide\" title=\"").h("i18n", ctx, {}, { "$key": "embedMap.tip.2" }).w("\">").h("i18n", ctx, {}, { "$key": "copy" }).w("</button></div><div class=\"tc-ctl-share-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "tooManyLayersLoaded|s" }).w("</p></div> </div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () { dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-share-qr-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window\"><div class=\"tc-modal-header\"><h3>").h("i18n", ctx, {}, { "$key": "qrCode" }).w("</h3><div class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\"><div class=\"qrcode\"></div> <div class=\"tc-ctl-share-qr-alert tc-alert alert-warning tc-hidden\"><p>").h("i18n", ctx, {}, { "$key": "qrAdvice|s" }).w("</p></div></div><div class=\"tc-modal-footer\"><button type=\"button\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "close" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; return body_0 };
    }
})();
﻿/// <reference path="../feature/Marker.js" />
/// <reference path="../feature/Point.js" />
/// <reference path="../ol/ol.js" />


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

(function () {
    TC.Consts.url.GOOGLEMAPS = '//maps.googleapis.com/maps/api/js?v=3';
    var gMapsUrl = TC.Consts.url.GOOGLEMAPS;
    TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];
    TC.Cfg.proxyExceptions.push(TC.Consts.url.GOOGLEMAPS);

    TC.control.StreetView = function () {
        var self = this;
        self._sv = null;
        self._mapActiveControl = null;

        TC.Control.apply(self, arguments);

        if (self.options.googleMapsKey) {
            gMapsUrl += '&key=' + self.options.googleMapsKey;
        }

        self.viewDiv = null;
        self._startLonLat = null;

        //self.render();
    };

    TC.inherit(TC.control.StreetView, TC.Control);

    var ctlProto = TC.control.StreetView.prototype;

    ctlProto.CLASS = 'tc-ctl-sv';

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/StreetView.html";
        ctlProto.template[ctlProto.CLASS + '-view'] = TC.apiLocation + "TC/templates/StreetViewView.html";
    } else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-sv-btn\" title=\"").h("i18n", ctx, {}, { "$key": "sv.tip" }).w("\"><div class=\"tc-ctl-sv-drag\"></div></div>"); } body_0.__dustBody = !0; return body_0 };
        ctlProto.template[ctlProto.CLASS + '-view'] = function () { dust.register(ctlProto.CLASS + '-view', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-sv-btn-close\" title=\"").h("i18n", ctx, {}, { "$key": "closeStreetView" }).w("\"></div>"); } body_0.__dustBody = !0; return body_0 };
    }

    const dispatchCanvasResize = function () {
        var event = document.createEvent('HTMLEvents');
        event.initEvent('resize', true, false);
        this.map.div.querySelector('canvas').dispatchEvent(event);
    };

    var preset = function (ctl) {
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.add(TC.Consts.classes.CHECKED);
        ctl.map.div.classList.add(ctl.CLASS + '-active');
    };

    var reset = function (ctl) {
        const view = ctl.viewDiv;
        const transitionEvents = ['webkitTransitionEnd', 'msTransitionEnd', 'oTransitionEnd', 'transitionend'];
        const onTransitionend = function () {
            if (!TC.Util.detectSafari()) {
                transitionEvents.forEach(function (eventName) {
                    view.removeEventListener(eventName, onTransitionend);
                });
            }

            dispatchCanvasResize.call(ctl);
        };

        // Safari no lanza transitionend
        if (TC.Util.detectSafari()) {
            setTimeout(function () {
                dispatchCanvasResize.call(ctl);
            }, 500);
        } else {
            transitionEvents.forEach(function (eventName) {
                view.addEventListener(eventName, onTransitionend);
            });
        }

        ctl.layer.clearFeatures();
        ctl.div.querySelector('.' + ctl.CLASS + '-btn').classList.remove(TC.Consts.classes.CHECKED);
        ctl.div.querySelector('.' + ctl.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
        ctl.map.div.classList.remove(ctl.CLASS + '-active');
        ctl._startLonLat = null;
    };

    var resolve = function (ctl) {
        var result = false;
        const btn = ctl.div.querySelector('.' + ctl.CLASS + '-btn');
        const drag = ctl.div.querySelector('.' + ctl.CLASS + '-drag');

        var btnRect = btn.getBoundingClientRect();
        var dragRect = drag.getBoundingClientRect();
        drag.classList.add(TC.Consts.classes.HIDDEN);
        if (dragRect.top < btnRect.top || dragRect.top > btnRect.bottom ||
            dragRect.left < btnRect.left || dragRect.left > btnRect.right) {
            // Hemos soltado fuera del botón: activar StreetView
            result = true;
            // Precarga de marcadores
            var extent = ctl.map.getExtent();
            var xy = [extent[2], extent[3]];
            var deferreds = new Array(16);
            for (var i = 0; i < 16; i++) {
                ctl.layer.addMarker(xy, {
                    cssClass: 'tc-marker-sv-' + i,
                    width: 48,
                    height: 48,
                    anchor: [0, 1]
                });
            }
            /////////////////////
            // Activamos StreetView
            var mapRect = ctl.map.div.getBoundingClientRect();
            var xpos = (((dragRect.left * window.devicePixelRatio) + (dragRect.right * window.devicePixelRatio)) / 2) - (mapRect.left * window.devicePixelRatio);
            var ypos = (dragRect.bottom * window.devicePixelRatio) - (mapRect.top * window.devicePixelRatio);
            var coords = ctl.map.wrap.getCoordinateFromPixel([xpos, ypos]);
            ctl.callback(coords);
        }
        else {
            reset(ctl);
        }
        return result;
    };

    ctlProto.register = function (map) {
        const self = this;

        if (!self.viewDiv) {
            self.viewDiv = TC.Util.getDiv(self.options.viewDiv);
            self.viewDiv.classList.add(self.CLASS + '-view');
            self.viewDiv.classList.add(TC.Consts.classes.HIDDEN);
            if (!self.options.viewDiv) {
                map.div.insertAdjacentElement('beforebegin', self.viewDiv);
            }
        }

        const result = TC.Control.prototype.register.call(self, map);

        self.layer = null;
        var layerId = self.getUID();
        for (var i = 0; i < map.workLayers.length; i++) {
            var layer = map.workLayers[i];
            if (layer.type === TC.Consts.layerType.VECTOR && layer.id === layerId) {
                self.layer = layer;
                break;
            }
        }
        if (!self.layer) {
            map.loaded(function () {
                map.addLayer({
                    id: layerId,
                    stealth: true,
                    type: TC.Consts.layerType.VECTOR
                }).then(function (layer) {
                    self.layer = layer;
                });
            });
        }

        self.renderPromise().then(function () {
            TC.loadJS(
                !window.Draggabilly,
                [TC.apiLocation + 'lib/draggabilly/draggabilly.pkgd.min.js'],
                function () {
                    const drag = new Draggabilly(self.div.querySelector('.' + self.CLASS + '-drag'), {
                        containment: self.map.div
                    });
                    drag.on('dragStart', function (e) {
                        preset(self);
                    });
                    drag.on('dragEnd', function (e) {
                        resolve(self);
                        drag.setPosition(0, 0);
                    });
                }
            );

            const view = self.viewDiv;
            view.querySelector('.' + self.CLASS + '-btn-close').addEventListener(TC.Consts.event.CLICK, function (e) {
                const mapDiv = self.map.div;
                const endProcess = function () {
                    mapDiv.classList.remove(TC.Consts.classes.COLLAPSED);
                    const resizeEvent = document.createEvent('HTMLEvents');
                    resizeEvent.initEvent('resize', false, false);
                    mapDiv.dispatchEvent(resizeEvent); // Para evitar que salga borroso el mapa tras cerrar SV.
                };
                const transitionend = 'transitionend';
                const onTransitionend = function (e) {
                    if (e.propertyName === 'width' || e.propertyName === 'height') {
                        view.removeEventListener(transitionend, onTransitionend);
                        endProcess();
                    }
                };
                view.removeEventListener(transitionend, onTransitionend);
                view.addEventListener(transitionend, onTransitionend);
                setTimeout(endProcess, 1000); // backup por si falla la transición.

                view.classList.add(TC.Consts.classes.HIDDEN);
                view.classList.remove(TC.Consts.classes.VISIBLE);
                self.div.querySelector('.' + self.CLASS + '-drag').classList.remove(TC.Consts.classes.HIDDEN);
                self.layer.wrap.setDraggable(false);
                reset(self);
                self._sv.setVisible(false);
                e.stopPropagation();
                const header = document.body.querySelector('header');
                if (header) {
                    header.style.display = '';
                }

                if (self._previousActiveControl) {
                    self._previousActiveControl.activate();
                }
            });
        }
            , function (a, b, c) {
                TC.error("Error de renderizado StreetView");
            });

        return result;
    };



    ctlProto.render = function () {
        const self = this;

        return self._set1stRenderPromise(new Promise(function (resolve, reject) {
            self.renderData(null, function () {
                if (dust.cache[self.CLASS + '-view']) {
                    dust.render(self.CLASS + '-view', null, function (err, out) {
                        //lo normal sería hacer el resolve después de volcar out en viewDiv
                        //pero a veces fallaba
                        //no se detonaba, sin dar error alguno
                        //así que lo arreglo como a mí me gusta:
                        setTimeout(function () {
                            self.viewDiv.innerHTML = out;
                            if (err) {
                                TC.error(err);
                            }
                            resolve(self);
                        }
                            , 300);


                        //console.log("Casi resuelto... " + out.length);
                        //self._$viewDiv.html(out);
                        //if (err)
                        //{
                        //    TC.error(err);
                        //}
                        //resolve(self);
                        //console.log("Resuelto!");

                    });
                }
                else {
                    TC.error("No hay dust.cache para StreetView");
                    resolve(self);
                }
            });
        }));
    };

    var waitId = 0;

    ctlProto.callback = function (coords) {
        var self = this;
        var geogCrs = 'EPSG:4326';

        var ondrop = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();                
                lonLat = TC.Util.reproject([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2], self.map.crs, geogCrs);                
                self._sv.setPosition({ lng: lonLat[0], lat: lonLat[1] });
            }
        }

        var ondrag = function (feature) {
            if (self._sv) {
                var bounds = feature.getBounds();
                self._startLonLat = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2];
            }
        }

        var li = self.map.getLoadingIndicator();
        if (li) {
            waitId = li.addWait(waitId);
        }

        const mapDiv = self.map.div;

        var setMarker = function (sv, center) {
            self.layer.clearFeatures();

            var xy;
            var heading;
            if (sv) {
                var latLon = sv.getPosition();
                xy = TC.Util.reproject([latLon.lng(), latLon.lat()], geogCrs, self.map.crs);
                heading = sv.getPov().heading;
            }
            else {
                xy = coords;
                heading = 0;
            }
            self.map.addMarker(xy, {
                cssClass: 'tc-marker-sv-' + (Math.round(16.0 * heading / 360) + 16) % 16,
                width: 48,
                height: 48,
                anchor: [0.4791666666666667, 0.7083333333333333],
                layer: self.layer,
                showsPopup: false
            });
            Promise.all(self.map._markerPromises).then(function () {
                // Para poder arrastrar a pegman                
                self.layer.wrap.setDraggable(true, ondrop, ondrag);
            });

            if (center) {
                var setCenter = function () {
                    self.map.setCenter(xy);
                };
                // Esperamos a que el mapa esté colapsado para centrarnos: ahorramos ancho de banda
                if (mapDiv.classList.contains(TC.Consts.classes.COLLAPSED)) {
                    setCenter();
                }
                else {
                    setTimeout(setCenter, 1200);
                }
            }
        };

        TC.loadJS(
            !window.google || !google.maps,
            gMapsUrl,
            function () {

                if (window.google) {

                    setMarker();

                    const view = self.viewDiv;
                    var lonLat = TC.Util.reproject(coords, self.map.crs, geogCrs);
                    var svDone = view.classList.contains(TC.Consts.classes.VISIBLE);

                    var svOptions = {
                        position: new google.maps.LatLng(lonLat[1], lonLat[0]),
                        pov: {
                            heading: 0,
                            pitch: 0
                        },
                        zoom: 1,
                        fullscreenControl: false,
                        zoomControlOptions: {
                            position: google.maps.ControlPosition.LEFT_TOP
                        },
                        panControlOptions: {
                            position: google.maps.ControlPosition.LEFT_TOP
                        }
                    };

                    if (!self._sv) {
                        self._sv = new google.maps.StreetViewPanorama(view, svOptions);
                        google.maps.event.addListener(self._sv, 'position_changed', function () {
                            setMarker(self._sv, view.classList.contains(TC.Consts.classes.VISIBLE));
                        });
                        google.maps.event.addListener(self._sv, 'pov_changed', function () {
                            if (self.layer.features && self.layer.features.length > 0) {
                                var pegmanMarker = self.layer.features[0];

                                delete pegmanMarker.options.url;
                                pegmanMarker.options.cssClass = 'tc-marker-sv-' + ((Math.round(16.0 * self._sv.getPov().heading / 360) + 16) % 16);
                                pegmanMarker.setStyle(pegmanMarker.options);

                                self.layer.refresh();
                            }
                        });
                        google.maps.event.addListener(self._sv, 'status_changed', function () {
                            var svStatus = self._sv.getStatus();
                            if (li) {
                                li.removeWait(waitId);
                            }
                            if (svStatus === google.maps.StreetViewStatus.OK) {

                                mapDiv.classList.add(TC.Consts.classes.COLLAPSED);
                                const resizeEvent = document.createEvent('HTMLEvents');
                                resizeEvent.initEvent('resize', false, false);
                                mapDiv.dispatchEvent(resizeEvent);

                                const endProcess = function () {
                                    google.maps.event.trigger(self._sv, 'resize');

                                    dispatchCanvasResize.call(self);
                                };
                                var transitionend = 'transitionend';
                                const onTransitionend = function (e) {
                                    if (e.propertyName === 'width' || e.propertyName === 'height') {
                                        if (!svDone) {
                                            svDone = true;
                                            view.removeEventListener(transitionend, onTransitionend);
                                            endProcess();
                                        }
                                    }
                                };
                                view.removeEventListener(transitionend, onTransitionend);
                                view.addEventListener(transitionend, onTransitionend);

                                setTimeout(endProcess, 1000); // Backup por si no salta el transitionend.

                                if (!view.classList.contains(TC.Consts.classes.VISIBLE)) {
                                    self._sv.setVisible(true);
                                    setMarker(self._sv, true);

                                    //apagar lo que sea que esté encendido (probablemente featInfo)
                                    //al cerrar con el aspa, volverá a detonarse StreetView.deactivate()
                                    //que, a su vez, restaurará el control anterior (FeatureInfo)
                                    if (self.map.activeControl) {
                                        self._previousActiveControl = self.map.activeControl;
                                        self.map.activeControl.deactivate(true);
                                    }

                                    setTimeout(function () {
                                        view.style.left = '';
                                        view.style.top = '';
                                        // triggers transitionend
                                        view.classList.remove(TC.Consts.classes.HIDDEN);
                                        view.classList.add(TC.Consts.classes.VISIBLE);
                                    }, 200);

                                    const header = document.body.querySelector('header');
                                    if (header) {
                                        header.style.display = 'none';
                                    }
                                }
                            }
                            else {
                                TC.alert(svStatus === google.maps.StreetViewStatus.ZERO_RESULTS ? self.getLocaleString('noStreetView') : self.getLocaleString('streetViewUnknownError'));
                                if (self._startLonLat) {
                                    self.callback(self._startLonLat);
                                }
                                else {
                                    self.layer.wrap.setDraggable(false);
                                    reset(self);
                                }
                            }
                        });
                    }
                    else {
                        self._sv.setOptions(svOptions);
                    }
                    setMarker(self._sv);
                }
                else {
                    reset(self);
                }
            }, false, true);
    };
})();
﻿TC.control = TC.control || {};

(function () {

    TC.control.ThreeD = function () {
        var self = this;

        TC.Control.apply(self, arguments);
    };

    TC.inherit(TC.control.ThreeD, TC.Control);

    var ctlProto = TC.control.ThreeD.prototype;

    ctlProto.CLASS = 'tc-ctl-threed';
    ctlProto.classes = {
        BETA: 'tc-beta-button',
        BTNACTIVE: 'active'
    };

    ctlProto.template = {};

    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS] = TC.apiLocation + "TC/templates/ThreeD.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS] = function () { dust.register(ctlProto.CLASS, body_0); function body_0(chk, ctx) { return chk.w("<button class=\"tc-ctl-threed-btn tc-beta-button\" title=\"").h("i18n", ctx, {}, { "$key": "threed.tip" }).w("\"></button>"); } body_0.__dustBody = !0; return body_0 };
    }

    ctlProto.register = function (map) {
        const self = this;

        const result = TC.Control.prototype.register.call(self, map);

        map.on(TC.Consts.event.VIEWCHANGE, function (e) {
            if (e.view == TC.Consts.view.THREED) { // cargamos la vista 3D desde el estado actualizamos el estado del botón
                self.activate();
            }
        });

        return result;
    };

    ctlProto.renderData = function (data, callback) {
        const self = this;

        return TC.Control.prototype.renderData.call(self, data, function () {
            self.button = self.div.querySelector('.' + self.CLASS + '-btn');

            if (Number.isInteger(TC.Util.detectIE()) && TC.Util.detectIE() < 12) {
                self.button.setAttribute('title', self.getLocaleString("threed.not.supported"));
                self.button.classList.remove(self.classes.BETA);
            }

            self.button.addEventListener(TC.Consts.event.CLICK, function () {

                if (self.button.getAttribute("disabled") === "disabled") {
                    return;
                }

                if (Number.isInteger(TC.Util.detectIE()) && TC.Util.detectIE() < 12) {
                    self.map.toast(self.getLocaleString("threed.not.supported"), { type: TC.Consts.msgType.ERROR });
                } else {
                    if (!self.map.on3DView) {
                        self.activate();
                    } else {
                        self.button.setAttribute("disabled", "disabled");

                        TC.view.ThreeD.unapply({
                            callback: function () {
                                self.button.setAttribute('title', self.getLocaleString("threed.tip"));

                                self.button.classList.remove(self.classes.BTNACTIVE);

                                self.button.removeAttribute("disabled");
                            }
                        });
                    }
                }
            });

            if ($.isFunction(callback)) {
                callback();
            }
        });
    };

    ctlProto.activate = function () {
        var self = this;

        self.button.setAttribute("disabled", "disabled");

        self.browserSupportWebGL.call(self);

        const manageButton = function () {
            self.button.setAttribute('title', self.getLocaleString('threed.two.tip'));
            self.button.classList.remove(self.classes.BETA);

            self.button.classList.add(self.classes.BTNACTIVE);
        };

        const removeDisabled = function () {
            self.button.removeAttribute("disabled");
        };

        if (!self.map.view3D) {
            TC.loadJS(
                !TC.view || !TC.view.ThreeD,
                TC.apiLocation + 'TC/view/ThreeD',
                function () {                                                           /* provisional */
                    TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
                });
        } else if (!self.map.on3DView) {                                               /* provisional */
            TC.view.ThreeD.apply({ map: self.map, options: self.options, getRenderedHtml: self.getRenderedHtml, callback: removeDisabled });
        }

        manageButton();

        //TC.Control.prototype.activate.call(self);
    };

    ctlProto.deactivate = function () {
        var self = this;

        TC.Control.prototype.deactivate.call(self);
    };

    ctlProto.browserSupportWebGL = function () {
        var self = this;
        var result = false;

        //Check for webgl support and if not, then fall back to leaflet
        if (!window.WebGLRenderingContext) {
            // Browser has no idea what WebGL is. Suggest they
            // get a new browser by presenting the user with link to
            // http://get.webgl.org
            result = false;
        } else {
            var canvas = document.createElement('canvas');

            var webglOptions = {
                alpha: false,
                stencil: false,
                failIfMajorPerformanceCaveat: true
            };

            try {
                var gl = canvas.getContext("webgl", webglOptions) ||
                    canvas.getContext("experimental-webgl", webglOptions) ||
                    canvas.getContext("webkit-3d", webglOptions) ||
                    canvas.getContext("moz-webgl", webglOptions);
                if (!gl) {
                    // We couldn't get a WebGL context without a major performance caveat.  Let's see if we can get one at all.
                    webglOptions.failIfMajorPerformanceCaveat = false;
                    gl = canvas.getContext("webgl", webglOptions) ||
                        canvas.getContext("experimental-webgl", webglOptions) ||
                        canvas.getContext("webkit-3d", webglOptions) ||
                        canvas.getContext("moz-webgl", webglOptions);
                    if (!gl) {
                        // No WebGL at all.
                        result = false;
                    } else {
                        // We can do WebGL, but only with software rendering (or similar).
                        result = 'slow';
                        self.isSlower = true;
                    }
                } else {
                    // WebGL is good to go!
                    result = true;
                }
            } catch (e) {
                console.log(E);
            }

            if (result === "slow" || !result) {
                var warning = result === "slow" ? "threed.slowSupport.supported" : "threed.not.supported";
                self.map.toast(self.getLocaleString(warning), {
                    type: TC.Consts.msgType.WARNING,
                    duration: 10000
                });
            }

            return result;
        }
    };

})();
﻿TC.control = TC.control || {};

/*pollyfill*/
if (!HTMLElement.prototype.appendHTML) {
    HTMLElement.prototype.appendHTML = function (html) {
        var d = document.createElement("div");
        d.innerHTML = html;
        if (d.childNodes.length > 1) {
            for (var i = 0; i < d.childNodes.length; i++) {
                this.appendChild(d.childNodes[i]);
            }
        }
        if (d.childNodes.length > 0)
            this.appendChild(d.firstChild);
        return null;
    };
};
if (!Document.prototype.createHTMLElement) {
    Document.prototype.createHTMLElement = function (html) {
        var d = document.createElement("div");
        d.innerHTML = html;
        if (d.childNodes.length > 0)
            return d.firstChild;
        return null;
    };
};
if (!HTMLElement.prototype.empty) {
    HTMLElement.prototype.empty = function () {
        while (this.children.length) {
            this.removeChild(this.children[0]);
        }
    };
};

if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}


if (!TC.Control) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Control');
}

TC.control.WFSQuery = function (options) {
    var self = this;
    TC.Control.apply(this, arguments);
    self.styles = self.options.styles;
    self.highLightStyles = self.options.highLightStyles;
};

TC.inherit(TC.control.WFSQuery, TC.Control);

(function () {
    var ctlProto = TC.control.WFSQuery.prototype;

    var cssClassLoading = "tc-loading";
    var cssClassUnavailable = "tc-unavailable";
    var modalBody = null;
    var modalDialog = null;
    var ctlResultsPanel = null;
    var resultLayer = null;
    var logicalOperator = TC.Consts.logicalOperator.AND;
    var timer = null;
    var autoCompletePromise = null;
    var locale = null;

    var filterByOperation = {
        eq: TC.filter.equalTo,
        not: TC.filter.notEqualTo,
        gt: TC.filter.greaterThan,
        lt: TC.filter.lessThan,
        ge: TC.filter.greaterThanOrEqualTo,
        le: TC.filter.lessThanOrEqualTo,
        like: TC.filter.like,
        contains: TC.filter.like,
        start: TC.filter.like,
        end: TC.filter.like,
        bw: TC.filter.between
    }
    var map = null;
    var _currentLayer = null;
    var _currentLayercapabilities = null;
    var _currentLayerTitle = null;
    var _currentLayerURL = null;
    var _maxRecordCount = null;
    var _getStyles = function () { return null };
    var _getHighLightStyles = function () { return null };
    var getLocaleString=null;
    ctlProto.CLASS = 'tc-ctl-wfsquery';
    ctlProto.template = {};
    if (TC.isDebug) {
        ctlProto.template[ctlProto.CLASS + "-dialog"] = TC.apiLocation + "TC/templates/WFSQueryDialog.html";
        ctlProto.template[ctlProto.CLASS + "-form"] = TC.apiLocation + "TC/templates/WFSQueryForm.html";
        ctlProto.template[ctlProto.CLASS + "-filter"] = TC.apiLocation + "TC/templates/WFSQueryfilter.html";
    }
    else {
        ctlProto.template[ctlProto.CLASS + '-dialog'] = function () {
            dust.register(ctlProto.CLASS + '-dialog', body_0); function body_0(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-dialog tc-modal\"><div class=\"tc-modal-background tc-modal-close\"></div><div class=\"tc-modal-window tc-ctl-wfsquery-modal-window\" ><div class=\"tc-modal-header\"><h3>").f(ctx.get(["layerName"], false), ctx, "h").w("</h3><div title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipCloseDialogBtn" }).w("\" class=\"tc-modal-close\"></div></div><div class=\"tc-modal-body\">").h("gt", ctx, { "block": body_1 }, { "key": ctx.getPath(false, ["layers", "length"]), "value": 1 }).w("<div class=\"tc-modal-form\"></div><div class=\"tc-ctl-wfsquery-message tc-hidden\"></div> </div><div class=\"tc-modal-footer\"><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipSendQueryBtn" }).w("\" class=\"tc-button tc-ctl-wlm-btn-launch\">").h("i18n", ctx, {}, { "$key": "query.sendQueryBtnText" }).w("</button><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.cancelQueryTooltip" }).w("\" class=\"tc-button tc-modal-close\">").h("i18n", ctx, {}, { "$key": "query.cancelQueryButton" }).w("</button></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w(" <div><select class=\"tc-combo\" name=\"availableLayers\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "query.chooseALayerCombo" }).w("</option>").s(ctx.get(["layers"], false), ctx, { "block": body_2 }, {}).w("</select></div> "); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["name"], false), ctx, "h").w("\">").f(ctx.get(["title"], false), ctx, "h").w("</option>"); } body_2.__dustBody = !0; return body_0;
        };
        ctlProto.template[ctlProto.CLASS + '-form'] = function () {
            dust.register(ctlProto.CLASS + '-form', body_0); function body_0(chk, ctx) { return chk.w("<div>").h("countif", ctx, { "else": body_1, "block": body_2 }, { "key": ctx.get(["attributes"], false), "excludedKeys": "the_geom,FEATURE" }).w("</div><div class=\"tc-ctl-wfsquery-operacion tc-hidden\"><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-numeric tc-hidden\"><input type=\"radio\" id=\"cond_1\" name=\"codicion\" value=\"eq\" /><label for=\"cond_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_2\" name=\"codicion\" value=\"not\" /><label for=\"cond_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.notEqualToBtn" }).w("</label><input type=\"radio\" id=\"cond_3\" name=\"codicion\" value=\"gt\" /><label for=\"cond_3\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherThanBtn" }).w("</label><input type=\"radio\" id=\"cond_4\" name=\"codicion\" value=\"lt\" /><label for=\"cond_4\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerThanBtn" }).w("</label><input type=\"radio\" id=\"cond_5\" name=\"codicion\" value=\"ge\" /><label for=\"cond_5\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherOrEqualThanBtn" }).w("</label><input type=\"radio\" id=\"cond_6\" name=\"codicion\" value=\"le\" /><label for=\"cond_6\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerOrEqualThanBtn" }).w("</label><!--<input type=\"radio\" id=\"cond_7\" name=\"codicion\" value=\"like\" /><label for=\"cond_7\" class=\"tc-ctl-wfsquery-cond\">es como</label>--></div><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-text tc-hidden\"><input type=\"radio\" id=\"cond_8\" name=\"codicion\" value=\"eq\" /><label for=\"cond_8\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_9\" name=\"codicion\" value=\"contains\" /><label for=\"cond_9\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.containsBtn" }).w("</label><input type=\"radio\" id=\"cond_10\" name=\"codicion\" value=\"start\" /><label for=\"cond_10\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.startsByBtn" }).w("</label><input type=\"radio\" id=\"cond_11\" name=\"codicion\" value=\"end\" /><label for=\"cond_11\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.endsByBtn" }).w("</label></div><div class=\"tc-ctl-wfsquery tc-ctl-wfsquery-date tc-hidden\"><input type=\"radio\" id=\"cond_12\" name=\"codicion\" value=\"bw\" /><label for=\"cond_12\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.equalToBtn" }).w("</label><input type=\"radio\" id=\"cond_13\" name=\"codicion\" value=\"nbw\" /><label for=\"cond_13\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.notEqualToBtn" }).w("</label><input type=\"radio\" id=\"cond_14\" name=\"codicion\" value=\"gt\" /><label for=\"cond_14\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherThanBtn" }).w("</label><input type=\"radio\" id=\"cond_15\" name=\"codicion\" value=\"lt\" /><label for=\"cond_15\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerThanBtn" }).w("</label><input type=\"radio\" id=\"cond_16\" name=\"codicion\" value=\"ge\" /><label for=\"cond_16\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.greatherOrEqualThanBtn" }).w("</label><input type=\"radio\" id=\"cond_17\" name=\"codicion\" value=\"le\" /><label for=\"cond_17\" class=\"tc-ctl-btn tc-ctl-wfsquery-cond\">").h("i18n", ctx, {}, { "$key": "query.lowerOrEqualThanBtn" }).w("</label><!--<input type=\"radio\" id=\"cond_7\" name=\"codicion\" value=\"like\" /><label for=\"cond_7\" class=\"tc-ctl-wfsquery-cond\">es como</label>--></div><div class=\"tc-ctl-wfsquery-where tc-hidden\"><input type=\"search\" placeholder=\"").h("i18n", ctx, {}, { "$key": "query.searchFieldPhd" }).w("\" class=\"tc-textbox\" /><button type=\"button\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipAddCondBtn" }).w("\" class=\"tc-button\">").h("i18n", ctx, {}, { "$key": "query.textAddCondBtn" }).w("</button><ul class=\"tc-ctl-wfsquery-list tc-ctl-search-list tc-hidden\"></ul><div class=\"tc-ctl-wfsquery-key\"><label>").h("i18n", ctx, {}, { "$key": "query.logicalOpLbl" }).w("</label></div><div class=\"tc-ctl-wfsquery-value\"><input type=\"radio\" id=\"log_op_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOpRadio\" checked name=\"log_op\" value=\"AND\" /><label for=\"log_op_1\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOp\">").h("i18n", ctx, {}, { "$key": "query.logicalOpAndLbl" }).w("</label><input type=\"radio\" id=\"log_op_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOpRadio\" name=\"log_op\" value=\"OR\" /><label for=\"log_op_2\" class=\"tc-ctl-btn tc-ctl-wfsquery-logOp\">").h("i18n", ctx, {}, { "$key": "query.logicalOpOrLbl" }).w("</label></div><div class=\"tc-ctl-wfsquery-whereList\"></div></div></div>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">").h("i18n", ctx, {}, { "$key": "query.noAttributes" }).w("</div>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<select class=\"tc-combo\" id=\"attributes\" name=\"attributes\"><option value=\"\">").h("i18n", ctx, {}, { "$key": "query.chooseAttrCombo" }).w("</option>").h("iterate", ctx, { "block": body_3 }, { "on": ctx.get(["attributes"], false), "excludedKeys": "the_geom,FEATURE" }).w("</select>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("<option value=\"").f(ctx.get(["key"], false), ctx, "h").w("\">").f(ctx.get(["key"], false), ctx, "h").w("</option>"); } body_3.__dustBody = !0; return body_0
        };
        ctlProto.template[ctlProto.CLASS + '-filter'] = function () {
            dust.register(ctlProto.CLASS + '-filter', body_0); function body_0(chk, ctx) { return chk.s(ctx.get(["conditions"], false), ctx, { "block": body_1 }, {}); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<div class=\"tc-ctl-wfsquery-where-cond\">").f(ctx.get(["field"], false), ctx, "h").w("&nbsp;").f(ctx.get(["opText"], false), ctx, "h").w("&nbsp;").x(ctx.get(["isString"], false), ctx, { "block": body_2 }, {}).f(ctx.get(["valueToShow"], false), ctx, "h", ["numberSeparator"]).x(ctx.get(["isString"], false), ctx, { "block": body_3 }, {}).w("</div><div class=\"tc-ctl-wfsquery-del-cond\" title=\"").h("i18n", ctx, {}, { "$key": "query.tooltipRemoveCond" }).w("\"></div>\t"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("&quot;"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.w("&quot;"); } body_3.__dustBody = !0; return body_0; 
        };        
    }

    var checkInput = function (type) {
        var input = document.createElement("input");
        input.setAttribute("type", type);
        return input.type == type;
    };

    var _loadDatePolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    };
    var _loadNumberPolyFill = function () {
        return new Promise(function (resolve, reject) {
            if (typeof (IMask) !== "undefined") {
                setTimeout(function () {
                    resolve();
                }, 10);
            }
            else {
                TC.loadJS(true,
                    [TC.apiLocation + '/lib/polyfill/IMask' + (TC.isDebug ? '' : '.min') + '.js'],
                    function () {
                        console.log("Imask loaded");
                        resolve();
                    });
            }
        });
    }
    var _renderModalDialog = function (layer, layerName, capabilities, callback) {        
        var layers = [];
        layer.getDisgregatedLayerNames().forEach(function (value, index) {
            var path = layer.getPath(value);
            //quitamos aquellas que no estén disponibles en el WFS
            if (capabilities.FeatureTypes.hasOwnProperty(value.substring(value.indexOf(":") + 1)))
                layers.push({ name: value, title: path[path.length - 1] });
        });
        layers.sort(function (a, b) {
            if (a.title < b.title) return -1;
            if (a.title > b.title) return 1;
            return 0;
        });

        ctlProto.getRenderedHtml(ctlProto.CLASS + "-dialog",
            {
                layerName: getLocaleString("query.titleDialog", { "layerName": layerName }),
                layers: layers
            }, function (html) {
                var modal = document.createHTMLElement(html);
                document.body.appendChild(modal);
                modalBody = modal.getElementsByClassName("tc-modal-body")[0]
                modalBody.classList.add(cssClassLoading);

                TC.Util.showModal(modal, {
                    closeCallback: function () {
                        modal.parentElement.removeChild(modal);
                    }
                });
                //IE me hace la puñeta con los estilos, no me fuciona el calc el el max-height así que lo calculo cada vez que muestro el dialogo
                if (TC.Util.detectIE()) {
                    var coef = 1;
                    switch (true) {
                        case document.body.clientWidth > 768 && document.body.clientWidth < document.body.clientHeight:
                        case document.body.clientWidth > 1024:
                            coef = 0.8;
                        case document.body.clientWidth > 1140:
                            coef = 0.7;
                            break;
                    }
                    modalBody.style.maxHeight = (document.body.clientHeight * coef) - modalBody.nextElementSibling.clientHeight - modalBody.previousElementSibling.clientHeight;
                }
                modalDialog = modal;
                modal.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].addEventListener("click", function () {
                    _sendQuery();
                })
                if (callback) callback(modal);
            });
    }

    var _renderQueryForm = function (args) {
        var layer = args[0], dialog = args[1], capabilities = args[2];
        _currentLayercapabilities = capabilities;
        _currentLayerURL = capabilities.Operations.DescribeFeatureType.DCP.HTTP.Get["xlink:href"];
        if (capabilities.Operations.GetFeature.CountDefault)
            _maxRecordCount = capabilities.Operations.GetFeature.CountDefault.DefaultValue;
        else
            _maxRecordCount = null;
        //analizamos si es una o varias capas, si es una agrupación la disgregamos 
        var layers = layer.getDisgregatedLayerNames();
        //quitamos aquellas que no estén disponibles en el WFS
        layers = layers.filter(function (l) {
            return capabilities.FeatureTypes.hasOwnProperty(l.substring(l.indexOf(":") + 1));
        });
        if (layers.length > 1) {
            modalBody.classList.remove(cssClassLoading);
            //bindeamos el onchange de combo
            dialog.getElementsByClassName("tc-combo")[0].addEventListener("change", function () {
                if (!this.value) {
                    var form = dialog.getElementsByClassName("tc-modal-form")[0];
                    form.empty();
                    for (var i = 0; i < form.children.length; i++) form.removeChild(form.children[i]);
                    _clear();
                    return;
                }
                dialog.querySelector(".tc-modal-body .tc-ctl-wfsquery-message", dialog).classList.add(TC.Consts.classes.HIDDEN);
                _currentLayerTitle = this.options[this.selectedIndex].text;
                modalBody.classList.add(cssClassLoading);
                _getDescribeFeature(this.value, capabilities).then(function (data) { _manageDescribeFeature(data, dialog); }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    tbody.empty();
                });
            });
        }
        else {
            //comprabamos que la capa existe en el capabilities
            var layerCapabilities = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)];
            if (layerCapabilities) {
                _currentLayerTitle = capabilities.FeatureTypes[layers[0].substring(layers[0].indexOf(":") + 1)].Title;
                _getDescribeFeature(layers[0], capabilities).then(function (data) { _manageDescribeFeature(data, dialog); }, function () {
                    var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                    tbody.classList.remove(cssClassLoading);
                    tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                    tbody.empty();
                });
            }
            else {
                var tbody = dialog.getElementsByClassName("tc-modal-body")[0];
                tbody.classList.remove(cssClassLoading);
                tbody.appendHTML("<div class=\"tc-ctl-wfsquery-message tc-msg-warning\">" + getLocaleString("query.LayerNotAvailable") + "</div>");
                //TC.Util.closeModal();
                //layer.map.toast("Mal", { type: TC.Consts.msgType.WARNING });
            }

        }
    }

    var _getDescribeFeature = function (layerName, capabilities) {
        _currentLayer = layerName;
        return new Promise(function (resolve, reject) {
            if (!capabilities.Operations.DescribeFeatureType) {
                TC.error("No está habilitado DescribeFeatureType en este servicio", TC.Consts.msgErrorMode.TOAST);
                return;
            }
            var url = capabilities.Operations.DescribeFeatureType.DCP.HTTP.Get["xlink:href"] + "?REQUEST=DescribeFeatureType&TYPENAME=" + layerName + "&OUTPUTFORMAT=" + capabilities.Operations.DescribeFeatureType.outputFormat
            TC.ajax({
                url: url,
                method: "GET",
                responseType: "application/xml"
                /*,error: function (xhr, err, message) {
                    TC.error(message);
                },*/
            }).then(function (response) {
                var obj = xml2json(response);
                var objLayer = obj[layerName.substring(layerName.indexOf(":") + 1)];
                if (objLayer) {
                    var type = objLayer.type
                    resolve(obj[type.substring(type.indexOf(":") + 1)].complexContent.extension.sequence);
                }
                else {
                    reject();
                }
                }).catch(function (error) {
                    TC.error(error);
                });
        });
    }
    var _getValue = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.unmaskedValue;

        } else if (dateInputMask) {
            //si es texto con mascara de fecha convertierto la fecha de dd/mm/yyyy a yyyy-mm-dd
            return dateInputMask.unmaskedValue.substring(4) + "-" + dateInputMask.unmaskedValue.substring(2, 4) + "-" + dateInputMask.unmaskedValue.substring(0, 2)
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var _getValueToShow = function (input) {
        if (inputMaskNumber) {
            return inputMaskNumber.value;
        }
        else if (dateInputMask) {
            //si es de tipo date devolvemos la fecha en formato dd/mm/yyyy
            return dateInputMask.value;
        }
        else if (input.type === "date") {
            return new Date(input.value).toLocaleDateString(locale)
        }
        else if (input.type === "number") {
            var dotOrComma = 1.1.toLocaleString(locale).substring(1, 2);
            return input.value.replace(".", dotOrComma);
        }
        return input.value;//en el resto de los casos la devuelvo tal cual

    }
    var dateInputMask = null;
    var inputMaskNumber = null;
    var _createDateMask = function (txtBox) {
        if (checkInput("date"))
            txtBox.type = "date";
        else {
            txtBox.type = "search";
            _loadDatePolyFill().then(function () {
                //construir el polyfill
                dateInputMask = new IMask(txtBox, {
                    mask: Date,
                    pattern: ((!locale || locale === "es-ES") ? 'd/`m/`Y' : (locale === "eu-ES" ? 'Y/`m/`d' : 'm/`d/`Y')),
                    lazy: false,
                    format: function (date) {
                        var day = date.getDate();
                        var month = date.getMonth() + 1;
                        var year = date.getFullYear();
                        if (day < 10) day = "0" + day;
                        if (month < 10) month = "0" + month;
                        switch (locale) {
                            case "eu-ES":
                                return [year, month, day].join('/');
                                break;
                            case "en-US":
                                return [month, day, year].join('/');
                                break;
                            case "es-ES":
                            default:
                                return [day, month, year].join('/');
                                break;
                        }

                    },
                    // define str -> date convertion
                    parse: function (str) {
                        switch (locale) {
                            case "eu-ES":
                                return new Date(str.split('/')[1] + "/" + str.split('/')[2] + "/" + str.split('/')[0])
                                break;
                            case "en-US":
                                return new Date(str)
                                break;
                            case "es-ES":
                            default:
                                return new Date(str.split('/')[1] + "/" + str.split('/')[0] + "/" + str.split('/')[2])
                                break;
                        }

                    },
                    blocks: {
                        d: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 31,
                            maxLength: 2,
                        },
                        m: {
                            mask: IMask.MaskedRange,
                            from: 1,
                            to: 12,
                            maxLength: 2,
                        },
                        Y: {
                            mask: IMask.MaskedRange,
                            from: 1900,
                            to: 9999,
                        }
                    }
                });
            });
        }
    };
    var _destroyDateMask = function () {
        if (dateInputMask) {
            var input = dateInputMask.el.input;
            dateInputMask.destroy();
            dateInputMask = null;
            input.value = "";
            input.type = "search";
        }
    };
    var destroyNumberMask = function () {
        if (inputMaskNumber) {
            var input = inputMaskNumber.el.input;
            inputMaskNumber.destroy();
            inputMaskNumber = null;
            input.value = "";
            input.type = "search";
        }
    };
    var _getDataTypes = function () {
        return _internalGetDataTypes();
    }
    var _manageDescribeFeature = function (data, dialog) {
        _clear();
        _internalGetDataTypes = function () {
            return data;
        };
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-form",
            {
                attributes: data
            }, function (html) {
                var form = dialog.getElementsByClassName("tc-modal-form")[0];
                form.empty();
                form.appendHTML(html);
                modalBody.classList.remove(cssClassLoading);
                TC.loadJS(
                    true,
                    [TC.apiLocation + 'TC/ui/autocomplete.js'],
                    function () {
                        console.log("autocomplete loaded");
                    });
                var type = null;
                var combo = form.getElementsByClassName("tc-combo");
                if (combo.length == 0)
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].setAttribute("disabled", "");
                else {
                    dialog.getElementsByClassName("tc-button tc-ctl-wlm-btn-launch")[0].removeAttribute("disabled");
                    combo[0].addEventListener("change", function () {
                        var valueField = form.querySelector(".tc-ctl-wfsquery-where .tc-textbox");
                        if (valueField.dataset["autocomplete"])
                            TC.UI.autocomplete.call(valueField, "clear");
                        if (!data[this.value]) {
                            form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.add("tc-hidden");
                            form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.add("tc-hidden");
                            return;
                        }
                        type = data[this.value].type;
                        form.getElementsByClassName("tc-ctl-wfsquery-operacion")[0].classList.remove("tc-hidden");
                        TC.UI.autocomplete.call(valueField, "clear");
                        //$(valueField).unbind("keydown");
                        destroyNumberMask();
                        valueField.type = "search";
                        switch (true) {
                            case type.indexOf("int") >= 0:
                            case type.indexOf("float") >= 0:
                            case type.indexOf("double") >= 0:
                            case type.indexOf("long") >= 0:
                            case type.indexOf("decimal") >= 0:
                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-numeric input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-numeric :first-child").checked = true;                                
                                _destroyDateMask();
                                
                                if (checkInput("number")) {
                                    if (TC.Util.detectIE()) {
                                        valueField.type = "text";
                                        _loadNumberPolyFill().then(function () {
                                            inputMaskNumber = new IMask(valueField, {
                                                mask: Number,  // enable number mask
                                                scale: (type.indexOf("int") >= 0 || type.indexOf("long") >= 0) ? 0 : 2,  // digits after point, 0 for integers
                                                signed: false,  // disallow negative
                                                thousandsSeparator: (locale && locale === "en-US") ? ',' : '.',  // any single char
                                                padFractionalZeros: false,  // if true, then pads zeros at end to the length of scale
                                                normalizeZeros: true,  // appends or removes zeros at ends
                                                radix: (locale && locale === "en-US") ? '.' : ',',  // fractional delimiter
                                            })
                                        });
                                    }
                                    else {
                                        valueField.type = "number";
                                        if (type.indexOf("int") >= 0 || type.indexOf("long") >= 0)
                                            valueField.step = "1";
                                        else
                                            valueField.step = "0.0001";
                                    }
                                }
                                break
                            case type.indexOf("dateTime") >= 0:

                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-date input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-date :first-child").checked = true;
                                _createDateMask(valueField);
                                break;
                            case type.indexOf("string") >= 0:
                                form.getElementsByClassName("tc-ctl-wfsquery-numeric")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-text")[0].classList.remove("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-date")[0].classList.add("tc-hidden");
                                form.getElementsByClassName("tc-ctl-wfsquery-where")[0].classList.remove("tc-hidden");

                                if (form.querySelectorAll("tc-ctl-wfsquery-text input:checked").length === 0)
                                    form.querySelector(".tc-ctl-wfsquery-text :first-child").checked = true;
                                _destroyDateMask();                                
                                _autocompleteConstructor(valueField, this.value, form.getElementsByClassName(ctlProto.CLASS + "-list tc-ctl-search-list")[0]);
                                break;
                        }
                    });
                    form.querySelector(".tc-ctl-wfsquery-where  input[type='radio']").addEventListener("change", function () {
                        logicalOperator = this.value === "OR" ? TC.Consts.logicalOperator.OR : TC.Consts.logicalOperator.AND
                        //reemplazar en la lista
                        form.getElementsByClassName("tc-ctl-wfsquery-whereList-op")[0].innerHTML = this.nextElementSibling.innerHTML;
                    });
                    
                    form.querySelector(".tc-button").addEventListener("click", function () {
                        var valueField = form.querySelector('input.tc-textbox');
                        TC.UI.autocomplete.call(valueField, "clear");
                        if (inputMaskNumber)
                            inputMaskNumber.masked.remove();
                        if (!_validate(form)) {
                            return;
                        }
                        var field = form.querySelector('.tc-combo').value;
                        var checkeOp = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');
                        var op = checkeOp.value;
                        var opText = checkeOp.nextElementSibling.innerText;

                        var value = _getValue(valueField);
                        var valueToShow = _getValueToShow(valueField);
                        var logOp = form.querySelector('.tc-ctl-wfsquery-where  input[type="radio"]:checked').nextElementSibling.innerText;
                                               
                        //reemplazo < y > por y &lt;&gt;
                        value = value.replace("<", "&lt;").replace(">", "&gt;");
                        //escapo los caracteres no alfamericos                    
                        //value = value.replace(/[^a-z\dáéíóúü]/gi, '!' + '$&');
                        //se añade asterisco al principio y/o final del valor para las busquedas: "empieza por", "termina en" o "contiene"
                        var f;
                        if (type.indexOf("dateTime") >= 0) {
                            if (op !== "nbw")
                                f = new filterByOperation[op](field, value + "T00:00:00Z", value + "T23:59:59Z");
                            else//el not bettween es un caso es especial por que concatena un filtro not y otro between
                            {
                                f = new TC.filter.not(TC.filter.between(field, value + "T00:00:00Z", value + "T23:59:59Z"));
                            }
                        }
                        else
                            f = new filterByOperation[op](
                                field,
                                (((op === "end" || op === "contains") ? '*' : '') + value + ((op === "start" || op === "contains") ? '*' : '')));
                        f.matchCase = false;
                        whereObjList.push(f);
                        switch (true) {
                            case type.indexOf("int") >= 0:
                                valueToShow = parseInt(value,10)
                                break;
                            case type.indexOf("float") >= 0:
                            case type.indexOf("double") >= 0:
                            case type.indexOf("long") >= 0:
                            case type.indexOf("decimal") >= 0:
                                valueToShow = parseFloat(value, 10)
                                break;
                        }
                        whereFilterList.push({
                            "field": field,
                            "opText": opText,
                            "isString": type.indexOf("string")>=0,
                            "valueToShow": valueToShow
                        });
                        
                        _renderFiltersConditions(form);
                        valueField.value = "";
                    });
                }
            });
    };
    var _renderFiltersConditions = function (form) {

        if (!dust.filters.numberSeparator)
            dust.filters.numberSeparator = function (value) {
                return value.toLocaleString(locale);
            };

        var whereDiv = form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0];
        whereDiv.empty();
        ctlProto.getRenderedHtml(ctlProto.CLASS + "-filter", {
            conditions: whereFilterList
        }, function (html) {
            form.getElementsByClassName("tc-ctl-wfsquery-whereList")[0].innerHTML = html;
            var delBtnCollection = form.getElementsByClassName("tc-ctl-wfsquery-del-cond");
            for (var i = 0; i < delBtnCollection.length; i++) {
                delBtnCollection[i].addEventListener("click", function () {
                    var index = Array.prototype.indexOf.call(delBtnCollection, this);
                    whereObjList.splice(index, 1);
                    whereFilterList.splice(index, 1);
                    _renderFiltersConditions(form);
                });
            }
        });
    }
    var _clear = function () {
        whereObjList = [];
        whereFilterList = [];
    };
    var _validate = function (form) {
        var opcion = form.querySelector('.tc-ctl-wfsquery input[type="radio"]:checked');

        if (dateInputMask && !dateInputMask.masked.isComplete) {
            if (/^(?=\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\x20|$))|(?:2[0-8]|1\d|0?[1-9]))([-.\/])(?:1[012]|0?[1-9])\1(?:1[6-9]|[2-9]\d)?\d\d(?:(?=\x20\d)\x20|$))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$/.test(str) === false)
                _showMessage("Fecha " + str + " inválida", TC.Consts.msgType.ERROR);
            return false;
        }
        if (opcion.length == 0) {
            _showMessage(getLocaleString("query.msgNoCondition"));
            return false;
        }
        if (form.querySelectorAll('input[type=\'date\']').length && !form.querySelector('input[type=\'date\']').checkValidity()) {
            _showMessage(getLocaleString("query.msgNoValidDate"));
            return false;
        }
        var number
        if (form.querySelectorAll('input[type=\'number\']').length && ((number = form.querySelector('input[type=\'number\']')) != null) && !number.checkValidity()) {
            if (number.step === "1")
                _showMessage(getLocaleString("query.msgNoValidNumberMustInt"));
            else
                _showMessage(getLocaleString("query.msgNoValidNumber"));
            return false;
        }
        if (form.querySelector('input.tc-textbox').value.trim() === "") {
            _showMessage(getLocaleString("query.msgNoValueCondition"));
            return false;
        }
        return true;
    };
    var _sendQuery = function () {

        if (!_validateQuery()) {
            _showMessage(getLocaleString("query.msgNoQueryFilter"));
            return;
        }
        modalDialog.getElementsByClassName("tc-modal-body")[0].classList.add(cssClassLoading);
        var _fncLoadVectorLayer = function () {
            var filtro = filterConstructor();

            _createResultPanel(_currentLayerTitle);

            if (!resultLayer) {
                _createVectorLayer({
                    id: "WFSQueryResults",
                    type: TC.Consts.layerType.WFS,
                    url: _currentLayerURL,
                    version: "1.1.0",
                    stealth: true,
                    geometryName: "the_geom",
                    featurePrefix: _currentLayer.substring(0, _currentLayer.indexOf(":")),
                    featureType: _currentLayer.substring(_currentLayer.indexOf(":") + 1),
                    maxFeatures: _maxRecordCount,
                    properties: filtro,
                    outputFormat: TC.Consts.format.JSON,
                    styles: _getStyles()
                });
                map.on(TC.Consts.event.RESULTSPANELCLOSE, function (e) {
                    if (e.control !== ctlResultsPanel)
                        return;
                    if (Modernizr.touch) {
                        TC.Util.swipe(e.control.div, "enable");
                    }
                    resultLayer.clearFeatures();
                    resultLayer.setVisibility(false);
                    map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                });
            }
            else {
                resultLayer.setVisibility(false);
                resultLayer.clearFeatures();
                //borro el evento featureUpdate por si hago una búsqueda sin cerra el panel previamente
                map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
                resultLayer.url = _currentLayerURL;
                resultLayer.featurePrefix = _currentLayer.substring(0, _currentLayer.indexOf(":"));
                resultLayer.featureType = _currentLayer.substring(_currentLayer.indexOf(":") + 1);
                resultLayer.maxFeatures = _maxRecordCount;
                resultLayer.properties = filtro;
                resultLayer.setVisibility(true);
                resultLayer.refresh();
            }

        }

        if (_maxRecordCount)
            _numHits().then(_fncLoadVectorLayer, function (error) {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading)
                if (error.err === "NumMaxFeatures") {
                    _showMessage(getLocaleString("query.msgTooManyResults", { limit: error.limit }), TC.Consts.msgType.WARNING)
                }
                else if (error.err === "Empty") {
                    _showMessage(getLocaleString("query.msgNoResults"), TC.Consts.msgType.INFO);
                }
                else {
                    console.error(error.errorThrown)
                    _showMessage(getLocaleString("query.errorUndefined"), TC.Consts.msgType.ERROR);
                }

            });
        else
            _fncLoadVectorLayer();
        //si está disponible el atributo CountDefault compruebo que no se sobrepasa la longitud

    }
    var _createVectorLayer = function (layerOptions) {
        map.addLayer(layerOptions).then(function (layer) {
            resultLayer = layer;
            layer.map.on(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
        });
    };
    var filterConstructor = function () {
        if (whereObjList.length > 1) {
            var condicion = document.querySelector(".tc-ctl-wfsquery-logOpRadio:checked").value;
            return TC.filter[TC.Consts.logicalOperator[condicion]].apply(null, whereObjList);
        }
        else if (whereObjList.length === 0)
            return null
        else
            return whereObjList[0];
    }
    var _featuresUpdate = function (e) {
        if (e.layer == resultLayer) {
            var features = e.layer.features;
            if (features.length > 0) {
                map.zoomToFeatures(features);
                _showResultPanel(
                    (features.length > 1 ?
                        features.reduce(function (vi, va, index) {
                            return (vi instanceof Array ? vi : [vi.data]).concat([va.data])
                        })
                        :
                        [features[0].data])
                    , resultLayer, _currentLayerTitle);
            }
            else {
                modalDialog.getElementsByClassName("tc-modal-body")[0].classList.remove(cssClassLoading);
                _showMessage("No hay resultados", TC.Consts.msgType.INFO);
                e.layer.map.off(TC.Consts.event.LAYERUPDATE, _featuresUpdate);
            }
        }
    };
    var _createResultPanel = function (layerName) {
        var _layerName = layerName;
        new Promise(function (resolve, reject) {
            if (!TC.control.ResultsPanel) {
                TC.loadJS(true, TC.apiLocation + 'TC/control/ResultsPanel', function () {
                    resolve(TC.control.ResultsPanel);
                });
            }
            else
                resolve(TC.control.ResultsPanel);
        }).then(function (ResultsPanel) {
            if (!ctlResultsPanel) {
                var fncResultPanelAdded = function (ctl) {
                    ctlResultsPanel = ctl;
                    delete dust.cache[ctlResultsPanel.CLASS + "-table"];
                    if (TC.isDebug) {
                        ctlResultsPanel.template[ctlResultsPanel.CLASS + "-table"] = TC.apiLocation + "TC/templates/WFSQueryResultsTable.html";
                    }
                    else {
                        ctlResultsPanel.template[ctlResultsPanel.CLASS + "-table"] = dust.register(ctlResultsPanel.CLASS + "-table", body_0); function body_0(chk, ctx) { return chk.w("<table class=\"table\"><thead>").s(ctx.get(["columns"], false), ctx, { "block": body_1 }, {}).w("</thead><tbody>").s(ctx.get(["results"], false), ctx, { "block": body_2 }, {}).w("</tbody></table>"); } body_0.__dustBody = !0; function body_1(chk, ctx) { return chk.w("<th>").f(ctx.getPath(true, []), ctx, "h").w("</th>"); } body_1.__dustBody = !0; function body_2(chk, ctx) { return chk.w("<tr title=\"").h("i18n", ctx, {}, { "$key": "zoomToFeature" }).w("\" data-id=\"").f(ctx.get(["Id"], false), ctx, "h").w("\" data-index=\"").f(ctx.get(["$idx"], false), ctx, "h").w("\" class=\"tc-selectable\">").h("iterate", ctx, { "block": body_3 }, { "on": ctx.getPath(true, []) }).w("</tr>"); } body_2.__dustBody = !0; function body_3(chk, ctx) { return chk.h("select", ctx, { "block": body_4 }, { "key": ctx.get(["key"], false) }); } body_3.__dustBody = !0; function body_4(chk, ctx) { return chk.w("<td class=\"").f(ctx.get(["key"], false), ctx, "h", ["removeAccents", "downcase"]).w("\">").h("startsWith", ctx, { "else": body_5, "block": body_6 }, { "key": ctx.get(["value"], false), "value": "http" }).w("</td>"); } body_4.__dustBody = !0; function body_5(chk, ctx) { return chk.f(ctx.get(["value"], false), ctx, "h", ["numberSeparator"]); } body_5.__dustBody = !0; function body_6(chk, ctx) { return chk.w("<a href=\"").f(ctx.get(["value"], false), ctx, "h").w("\" target=\"_blank\" title=\"").h("i18n", ctx, {}, { "$key": "query.linkOpenAtNewTab" }).w("\">").h("i18n", ctx, {}, { "$key": "query.linkText" }).w("</a>"); } body_6.__dustBody = !0; return body_0
                    }
                    ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');                    
                }
                var ccontainer = map.getControlsByClass(TC.control.ControlContainer);
                if (ccontainer.length == 0) {
                    map.addControl("ResultsPanel",
                        {
                            "content": "table",
                            "titles": {
                                "main": "",
                                "max": ""
                            },
                            "save": {
                                "fileName": _layerName + ".xls"
                            }
                        }).then(fncResultPanelAdded);
                }
                else {
                    ccontainer[0].addControl("ResultsPanel", {
                        "content": "table",
                        "titles": {
                            "main": "",
                            "max": ""
                        },
                        "save": {
                            "fileName": _layerName + ".xls"
                        }, "side": "right"
                    }).then(fncResultPanelAdded);
                }
            }
            else {
                ctlResultsPanel.options.save.fileName = _layerName + ".xls";
                ctlResultsPanel.options.titles.max = ctlResultsPanel.getLocaleString('geo.trk.chart.exp');
            }
        });
    };
    var _showResultPanel = function (data, layer, layername) {

        //map.$events.trigger(TC.Consts.event.SEARCHDONE, { data: data } );

        var truthTest = function (name, test) {
            return function (chunk, context, bodies, params) {
                return filter(chunk, context, bodies, params, name, test);
            };
        }        
        
        //en funcion del número de elementos cargo un título en singular o plural

        ctlResultsPanel.div.querySelector(".prpanel-title-text").innerText = ctlResultsPanel.getLocaleString(data.length > 1 ? 'query.titleResultPaneMany' : 'query.titleResultPanelOne', { "numero": data.length, "layerName": layername });
                
        ctlResultsPanel.div.classList.add("tc-ctl-wfsquery-results");
        
        modalDialog.parentElement.removeChild(modalDialog);
        
        ctlResultsPanel.openTable({
            data: data,
            css: {
                trClass: "trClass",
                tdClass: "tdClass",
                thClass: "thClass",
            },
            callback: function (tabla) {
                
                ctlResultsPanel.maximize();
                console.log("render del panel de resultados");
                var col = tabla.getElementsByTagName("tr");
                var dataTypes = _getDataTypes();
                var j = 1;
                for (var i in data[0]) {
                    if (dataTypes.hasOwnProperty(i)) {
                        if (dataTypes[i].type.indexOf("int") >= 0 ||
                            dataTypes[i].type.indexOf("float") >= 0 ||
                            dataTypes[i].type.indexOf("double") >= 0 ||
                            dataTypes[i].type.indexOf("long") >= 0 ||
                            dataTypes[i].type.indexOf("decimal") >= 0) {
                            var tdNumeric = tabla.querySelectorAll("td:nth-child(" + j + ")");
                            for (var k = 0; k < tdNumeric.length; k++) {
                                tdNumeric[k].classList.add("tc-numeric");
                            }
                        }
                    }
                    j++;
                }

                
                for (var i = 0; i < col.length; i++) {
                    col[i].addEventListener("click", function (e) {
                        e.stopPropagation();
                        var index = this.dataset.index;
                        if (index != undefined)
                            layer.map.zoomToFeatures([layer.features[index]]);
                    });
                    col[i].addEventListener("mouseenter", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.select();
                            _select(feat);
                        }
                        for (var i = 0; i < this.children.length; i++) {
                            var td = this.children[i];
                            if (td.offsetWidth < td.scrollWidth)
                                td.title = td.innerText;
                        }

                    });
                    col[i].addEventListener("mouseleave", function () {
                        var index = this.dataset.index;
                        if (index == undefined) return;
                        var feat = layer.features[index]
                        if (feat && feat.geometry) {
                            //feat.unselect();
                            _unselect(feat)
                            //esto es porque el unselect no devulve al estilo por defecto
                            //feat.setStyle(TC.Cfg.styles[feat.STYLETYPE]);
                        }
                    });
                }

                //se deshabilita el swipe para que se pueda hacer scroll horizontal del panel de resultados
                if (Modernizr.touch) {
                    TC.Util.swipe(ctlResultsPanel.div, 'disable');
                }
                //politica para replegar el panel de herramientas:
                //si el panel de herramientas se superpone al panel de resultados lo repliego
                var toolPanel = document.getElementById("tools-panel") || document.body.querySelector(".tools-panel");
                if (toolPanel && ctlResultsPanel.div.getElementsByClassName("prpanel-group")[0].colliding(toolPanel))
                        toolPanel.classList.add("right-collapsed");
            }
        });

    }
    var _validateQuery = function () {
        return whereObjList.length > 0;
    };
    var _showMessage = function (Message, type) {
        var messageDiv = modalBody.getElementsByClassName("tc-ctl-wfsquery-message")[0];
        if (timer) {
            clearTimeout(timer);
        }
        else {
            messageDiv.innerHTML=Message;
            switch (type) {
                case TC.Consts.msgType.INFO:
                    messageDiv.classList.add("tc-msg-info")
                    break;
                case TC.Consts.msgType.WARNING:
                    messageDiv.classList.add("tc-msg-warning")
                    break;
                case TC.Consts.msgType.ERROR:
                default:
                    messageDiv.classList.add("tc-msg-error")
                    break;
            }
            messageDiv.classList.remove(TC.Consts.classes.HIDDEN);
        }
        timer = setTimeout(function () {
            timer = null;
            messageDiv.classList.add(TC.Consts.classes.HIDDEN);
        }, 3000)
    };
    var _getPossibleValues = function (field, value) {
        return new Promise(function (resolve, reject) {
            var _capabilities = Object.assign({}, _currentLayercapabilities);
            _capabilities.version = "1.1.0";
            switch (document.querySelector(".tc-ctl-wfsquery.tc-ctl-wfsquery-text input:checked").value) {
                case "start":
                    value = (value + "*");
                    break;
                case "contains":
                case "eq":
                    value = ("*" + value + "*");
                    break;
                case "end":
                    value = ("*" + value);
                    break;
            }
            if (autoCompletePromise) {
                autoCompletePromise = null;
            }
            autoCompletePromise = TC.ajax({
                url: _currentLayerURL + '?' + Date.now(),
                data: TC.Util.WFSQueryBuilder([_currentLayer], TC.filter.like(field, value, undefined, undefined, undefined, false), _capabilities, "JSON", false),
                contentType: "application/xml",
                responseType: "application/json",
                method: "POST",
            });
            autoCompletePromise.then(function (response) {
                if (response.features && response.features.length > 0) {
                    var arr;
                    if (response.features.length === 1)
                        arr = [response.features[0].properties[field]];
                    if (response.features.length > 1)
                        arr = response.features.reduce(function (pv, cv) {
                            if (pv && pv instanceof Array) {
                                if (pv.indexOf(cv.properties[field]) < 0)
                                    return pv.concat(cv.properties[field]);
                                else
                                    return pv;
                            }
                            else {
                                if (pv.properties[field] === cv.properties[field])
                                    return [pv.properties[field]]
                                else
                                    return [pv.properties[field], cv.properties[field]]
                            }
                        });
                    //arr.sort();
                    resolve(arr);
                } else reject(null);
            });
        });
    };
    var _autocompleteConstructor = function (control, property, listCtrl) {

        TC.UI.autocomplete.call(control, {
            minLength: 3,
            target: listCtrl,
            source: function (text, callback) {
                var _self = this;
                _self.target.innerHTML = '<li><a class="tc-ctl-search-li-loading" href="#">' + getLocaleString("searching") + '<span class="tc-ctl-search-loading-spinner tc-ctl-search-loading"></span></a></li>'
                _self.target.classList.remove("tc-hidden");
                _getPossibleValues(property, text).then(callback).catch(function () {
                    _self.target.classList.add("tc-hidden");
                });
            },
            callback: function (e) {
                control.value = e.currentTarget.dataset["value"];
                this.target.classList.add("tc-hidden");
            },
            buildHTML: function (data) {
                var pattern = control.value;
                this.target.style.maxHeight = "";
                if (data.results.length > 1)
                    return data.results.reduce(function (pv, cp, i) {
                        return (i > 1 ? pv : _highlightText(pv, pattern)) + _highlightText(cp, pattern);
                    });
                else
                    return _highlightText(data.results[0], pattern);
            }
        });
        control.addEventListener("targetCleared.autocomplete", function () {
            listCtrl.classList.add("tc-hidden");
        });
        control.addEventListener('keypress', function (e) {
            if (e.which == 13) {
                TC.UI.autocomplete.call(control, "clear");
            }
        });
        control.addEventListener("search", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
        control.addEventListener("input", function (e) {
            if (control.value.length === 0) {
                TC.UI.autocomplete.call(control, "clear")
            }
        });
    };
    var _highlightText = function (text, pattern) {
        pattern = new RegExp(pattern, "gi");
        return "<li><a href=\"#\" data-value=\"" + text + "\">" + text.replace(pattern, '<b>$&</b>') + "</a></li>";
    };
    var _numHits = function () {
        return new Promise(function (resolve, reject) {
            var filtro = filterConstructor();
            var _capabilities = Object.assign({}, _currentLayercapabilities);
            _capabilities.version = "1.1.0";
            TC.ajax({
                url: _currentLayerURL,
                data: TC.Util.WFSQueryBuilder([_currentLayer], filtro, _capabilities, null, true),
                contentType: "application/xml",
                method: "POST"
            }).then(function () {
                var capabilitiesAsJSON = xml2json(new DOMParser().parseFromString(arguments[0], 'application/xml'));
                if (capabilitiesAsJSON.Exception) {
                    reject({
                        err: capabilitiesAsJSON.Exception.exceptionCode, errorThrown: capabilitiesAsJSON.Exception.ExceptionText
                    });
                    return;
                }
                var featFounds = parseInt(capabilitiesAsJSON.numberMatched || capabilitiesAsJSON.numberOfFeatures, 10)
                if (isNaN(featFounds) || featFounds >= parseInt(_maxRecordCount, 10)) {
                    reject({
                        err: "NumMaxFeatures", limit: _maxRecordCount
                    });
                    return;
                }
                else if (!isNaN(featFounds) && featFounds === 0) {
                    reject({
                        err: "Empty"
                    });
                    return;
                }
                resolve();
            }, function (xhr, state, message) {
                reject({
                    err: state, errorThrown: message
                });
            });
        });
    };
    var _select = function (feature) {
        var _addFeature = function (layer, feature) {
            var result
            if (feature instanceof TC.feature.Point) {
                result = layer.addPoint(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polyline) {
                result = layer.addPolyline(feature.getCoords());
            }
            else if (feature instanceof TC.feature.Polygon) {
                result = layer.addPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolygon) {
                result = layer.addMultiPolygon(feature.getCoords());
            }
            else if (feature instanceof TC.feature.MultiPolyline) {
                result = layer.addMultiPolyline(feature.getCoords());
            }
            return result;
        };
        if (!feature.layer)
            return;
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (!layer) {
            feature.layer.map.addLayer({
                id: "WFSQueryResultsHighlight",
                type: TC.Consts.layerType.VECTOR,
                stealth: true,
                styles: _getHighLightStyles()
            }, function (layer) {
                _addFeature(layer, feature);
            });
        }
        else
            _addFeature(layer, feature);             
    };
    var _unselect = function (feature) {
        var layer = feature.layer.map.getLayer("WFSQueryResultsHighlight");
        if (layer) {
            layer.clearFeatures();
        }
    };
    ctlProto.render = function (callback) {
        const self = this;
        const result = TC.Control.prototype.render.call(self, callback);
        return result;
    };

    ctlProto.register = function (_map) {
        const self = this;
        map = _map;
        return new Promise(function (resolve) {

            //condición IF si una coleccion de atributos tiene 1 o mas elementos. Tiene una lista negra llamada excludedKeys
            dust.helpers.countif = function (chunk, context, bodies, params) {
                params = params || {};
                var body = bodies.block, skip = bodies['else'], key = params["key"] || context.current();
                var excludedKeys = params.excludedKeys != null ? params.excludedKeys.split(',') : null;
                var _count = 0
                for (var k in key) {
                    if (excludedKeys == null || excludedKeys.indexOf(k) < 0) {
                        _count++;
                    }
                }
                if (_count > 0) {
                    chunk = chunk.render(body, context);
                }
                else if (skip) {
                    chunk = chunk.render(skip, context);
                }
                return chunk;
            }

            TC.Control.prototype.register.call(self, map).then(function () {                
                _getStyles = function () {
                    var _default = $.extend(true, {}, TC.Cfg.styles, {
                        "polygon": {
                            fillColor: "#ffffff",
                            fillOpacity: 0,
                            strokeColor: "#ff0000",
                            strokeWidth: 2
                        },
                        "polyline": {
                            strokeColor: "#ff0000",
                            strokeWidth: 2
                        },
                        "point": {
                            strokeColor: "#ff0000"
                        }
                    });
                    return self.styles ? Object.assign(_default, self.styles) : _default;
                };
                _getHighLightStyles = function () {
                    var _default = $.extend(true, {}, TC.Cfg.styles, {
                        "polygon": {
                            fillColor: "#0099FF",
                            fillOpacity: 0,
                            strokeColor: "#0099FF",
                            strokeWidth: 4
                        },
                        "polyline": {
                            strokeColor: "#0099FF",
                            strokeWidth: 4
                        },
                        "point": {
                            strokeColor: "#0099FF"
                        }
                    });
                    return self.highLightStyles ? Object.assign(_default, self.highLightStyles) : _default;
                };

                locale = map.options.locale;

                getLocaleString = function (key, texts) {
                    return TC.Util.getLocaleString(locale, key, texts);
                }
                resolve();
            });
        });
    };
    ctlProto.renderModalDialog = function (layer) {
        var path = layer.getPath();
        var renderDialogPromise = new Promise(function (resolve, reject) {
            layer.getWFSCapabilitiesPromise().then(function (capabilities) {
                _renderModalDialog(layer, path[path.length - 1], capabilities, function (modal) {
                    resolve(modal);
                });
            })
        });

        Promise.all([layer, renderDialogPromise, layer.getWFSCapabilitiesPromise()]).then(_renderQueryForm);
    };

})();
﻿
TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

TC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';

(function () {

    var capabilitiesPromises = {};

    const isWebWorkerEnabled = !TC.isLegacy && window.hasOwnProperty('Worker');
    const wwPromise = new Promise(function (resolve, reject) {
        if (isWebWorkerEnabled) {
            // Para evitar problemas con IE10 y Opera evitamos el uso de blobs cuando es evitable
            var wwLocation = TC.apiLocation + 'TC/workers/tc-caps-web-worker.js';
            if (TC.Util.isSameOrigin(TC.apiLocation)) {
                resolve(wwLocation);
            }
            else {
                TC.ajax({
                    url: wwLocation,
                    method: 'GET',
                    responseType: 'text'
                }).then(
                    function (data) {
                        var blob = new Blob([data], { type: "text/javascript" });
                        var url = window.URL.createObjectURL(blob);
                        resolve(url);
                    },
                    function (e) {
                        reject(Error(e));
                    }
                    );
            }
        }
    });

    const parseCapabilities = function (layer, data) {
        var capabilities;

        if (data.documentElement) {

            const serviceException = data.getElementsByTagName('ServiceException')[0];
            if (serviceException) {
                capabilities = { error: serviceException.textContent };
            }
            else {
                var format = (layer.type === TC.Consts.layerType.WMTS) ? new layer.wrap.WmtsParser() : new layer.wrap.WmsParser();
                capabilities = format.read(data);

                //parsear a manija los tileMatrixSetLimits, que openLayers no lo hace (de momento)
                if (layer.type === TC.Consts.layerType.WMTS) {
                    if (capabilities.Contents && capabilities.Contents.Layer) {
                        const layerCollection = data.getElementsByTagName('Layer');
                        for (var i = 0, len = layerCollection.length; i < len; i++) {
                            const curXmlLy = layerCollection[i];
                            var nd = TC.Util.getElementByNodeName(curXmlLy, "ows:Identifier")[0];
                            var id = nd.firstChild.data;

                            var capLy = capabilities.Contents.Layer.filter(function (ly) {
                                return ly.Identifier == id;
                            });

                            if (capLy.length) {
                                capLy = capLy[0];
                                for (var j = 0; j < capLy.TileMatrixSetLink.length; j++) {
                                    var capLink = capLy.TileMatrixSetLink[j];
                                    matrixId = capLink.TileMatrixSet;

                                    xmlLink = curXmlLy.getElementsByTagName('TileMatrixSetLink').each(function (ix, curLink) {
                                        return $(curLink).find("TileMatrixSet:first").text() == matrixId;
                                    });

                                    if (xmlLink.length) {
                                        xmlLink = xmlLink[0];
                                        capLink.TileMatrixSetLimits = [];
                                        const tmlCollection = xmlLink.getElementsByTagName('TileMatrixLimits');
                                        for (var k = 0, kk = tmlCollection.length; k < kk; k++) {
                                            const lim = tmlCollection[k];
                                            capLink.TileMatrixSetLimits.push({
                                                TileMatrix: lim.getElementsByTagName('TileMatrix')[0].textContent,
                                                MinTileRow: parseInt(lim.getElementsByTagName('MinTileRow')[0].textContent),
                                                MinTileCol: parseInt(lim.getElementsByTagName('MinTileCol')[0].textContent),
                                                MaxTileRow: parseInt(lim.getElementsByTagName('MaxTileRow')[0].textContent),
                                                MaxTileCol: parseInt(lim.getElementsByTagName('MaxTileCol')[0].textContent)
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            storeCapabilities(layer, capabilities);
            return Promise.resolve(capabilities);
        }
        else {
            return new Promise(function (resolve, reject) {
                if (isWebWorkerEnabled && typeof data === 'string') {
                    wwPromise.then(function (wwUrl) {
                        var worker = new Worker(wwUrl);
                        worker.onmessage = function (e) {
                            if (e.data.state === 'success') {
                                capabilities = e.data.capabilities;

                                // GLS: Sólo almacenamos si el capabilities es correcto
                                storeCapabilities(layer, capabilities);
                            }
                            else {
                                capabilities = {
                                    error: 'Web worker error'
                                }
                                reject(capabilities.error);
                            }

                            resolve(capabilities);
                            worker.terminate();
                        };
                        worker.postMessage({
                            type: layer.type,
                            text: data
                        });
                    })
                }
                else {
                    capabilities = data;
                    resolve(capabilities);
                }
            });
        }
    };

    const capabilitiesError = function (layer, reason) {
        const msg = 'No se pudo obtener el documento de capacidades del servicio ' + layer.url + ': [' + reason + ']';
        TC.error(msg);
        if (layer.map) {
            layer.map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: 'couldNotGetCapabilities' });
        }
        layer.wrap.setLayer(null);
        return msg;
    };

    const getCapabilitiesOnline = function (layer) {
        const serviceUrl = layer.url;
        return new Promise(function (resolve, reject) {
            var url;
            const params = {};
            if (layer.type === TC.Consts.layerType.WMTS) {
                if (layer.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {
                    var suffix = '/1.0.0/WMTSCapabilities.xml';
                    const suffixIdx = serviceUrl.indexOf(suffix);
                    if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {
                        if (serviceUrl[serviceUrl.length - 1] === '/') {
                            suffix = suffix.substr(1);
                        }
                        url = serviceUrl + suffix;
                    }
                    else {
                        url = serviceUrl;
                    }
                }
                else {
                    url = serviceUrl;
                    params.SERVICE = 'WMTS';
                    params.VERSION = '1.0.0';
                    params.REQUEST = 'GetCapabilities';
                }
            }
            else {
                url = serviceUrl;
                params.SERVICE = 'WMS';
                params.VERSION = '1.3.0';
                params.REQUEST = 'GetCapabilities';
            }
            url = url + '?' + $.param($.extend(params, layer.queryParams));

            layer.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {
                parseCapabilities(layer, data.responseText)
                    .then(function (capabilities) {
                        if (capabilities.error) {
                            reject(Error(capabilitiesError(layer, capabilities.error)));
                            return;
                        }
                        resolve(capabilities);
                    })
                    .catch(function (error) {
                        reject(Error(error));
                    });
            }).catch(function (dataError) {
                reject(Error(capabilitiesError(layer, dataError)));
            });

        });
    };

    const getCapabilitiesFromStorage = function (layer) {
        return new Promise(function (resolve, reject) {
            // Obtenemos el capabilities almacenado en caché
            TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {
                localforage.getItem(layer.CAPABILITIES_STORE_KEY_PREFIX + layer.url)
                    .then(function (value) {
                        if (value) {
                            resolve(value);
                        }
                        else {
                            reject('Capabilities not in storage');
                        }
                    })
                    .catch(function () {
                        reject('Undefined storage error');
                    });
            });
        });
    };

    const storeCapabilities = function (layer, capabilities) {
        TC.loadJS(!window.localforage, [TC.Consts.url.LOCALFORAGE], function () {

            // Esperamos a que el mapa se cargue y entonces guardamos el capabilities.
            // Así evitamos que la operación, que es bastante pesada, ocupe tiempo de carga 
            // (con el efecto secundario de que LoadingIndicator esté un tiempo largo apagado durante la carga)
            var capKey = layer.CAPABILITIES_STORE_KEY_PREFIX + layer.options.url;
            var setItem = function () {
                // GLS: antes de guardar, validamos que es un capabilities sin error
                if (capabilities.hasOwnProperty("error")) {
                    return;
                } else {

                    layer.getCapabilitiesPromise().then(function () {
                        localforage.setItem(capKey, capabilities).then(function () { }).catch(function (err) {
                            console.log(err);
                        });
                    });
                }
            };
            if (layer.map) {
                layer.map.loaded(setItem);
            }
            else {
                setItem();
            }
        });
    };

    const _createWMSLayer = function (layer) {

        var layerNames = $.isArray(layer.names) ? layer.names.join(',') : layer.names;
        var format = layer.options.format;
        var options = layer.options;

        var params = {
            LAYERS: layerNames,
            FORMAT: format,
            TRANSPARENT: layer.transparent,
            VERSION: layer.capabilities.version || '1.3.0'
        };

        if (layer.params) {
            $.extend(params, layer.params);
        }

        if (layer.queryParams) {
            $.extend(params, layer.queryParams);
        }

        var infoFormat = layer.getPreferredInfoFormat();
        if (infoFormat !== null) {
            params.INFO_FORMAT = infoFormat;
        }

        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);
    };

    const _createWMTSLayer = function (layer) {
        return layer.wrap.createWMTSLayer(layer.options);
    };

    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {

        var result = $.inArray(treeNode.name, layer.availableNames);
        if (result === -1) {
            for (var i = 0, len = treeNode.children.length; i < len; i++) {
                result = _getLayerNodeIndex(layer, treeNode.children[i]);
                if (result !== -1) {
                    break;
                }
            }
        }
        return result;
    }

    const _sortTree = function _sortTree(layer, treeNode) {
        var _sortFunction = function (n1, n2) {
            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);
        }
        treeNode.children.sort(_sortFunction);
        for (var i = 0, len = treeNode.children.length; i < len; i++) {
            _sortTree(layer, treeNode.children[i]);
        }
    };

    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {
        var result = false;
        counter.count = counter.count + 1;
        if (treeNode.name === name) {
            result = true;
        }
        else {
            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés
            for (var i = treeNode.children.length - 1; i >= 0; i--) {
                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Opciones de nombre de capa.
     * Esta clase no tiene constructor.
     * @class TC.cfg.LayerNameOptions
     * @static
     */
    /**
     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.
     * @property aggregate
     * @type boolean
     * @default true
     */
    /**
     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}} (valor <code>false</code>) 
     * o se espera a que la capa se actualice (valor <code>true</code>).
     * @property lazy
     * @type boolean
     * @default false
     */
    /**
     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/availableNames:property"}}{{/crossLink}} (valor <code>false</code>) se restablece 
     * al actualizar la propiedad TC.layer.Raster.{{#crossLink "TC.layer.Raster/names:property"}}{{/crossLink}}.
     * @property reset
     * @type boolean|undefined
     */

    /**
     * Opciones de capa raster.
     * Esta clase no tiene constructor.
     * @class TC.cfg.RasterOptions
     * @extend TC.cfg.LayerOptions
     * @static
     */
    /**
     * Tipo de capa.
     * @property type
     * @type TC.consts.LayerType
     * @default TC.Consts.layerType.WMS
     */
    /**
     * URL del servicio OGC que define la capa.
     * @property url
     * @type string
     */
    /**
     * Indica si la capa tiene transparencia.
     * @property transparent
     * @type boolean|undefined
     */
    /**
     * Lista separada por comas de los nombres de capa del servicio OGC.
     * @property layerNames
     * @type string|undefined
     */
    /**
     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.
     * @property matrixSet
     * @type string|undefined
     */

    /**
     * Capa de tipo raster, como la de un WMS o un WMTS.
     * @class TC.layer.Raster
     * @extends TC.Layer
     * @constructor
     * @async
     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.
     */
    TC.layer.Raster = function () {
        var self = this;

        if (!TC.tool || !TC.tool.Proxification) {
            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');
        }

        this.toolProxification = new TC.tool.Proxification(TC.proxify);

        //esta promise se resolverá cuando el capabilities esté descargado y parseado
        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa
        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)
        this._capabilitiesPromise = null;

        TC.Layer.apply(self, arguments);

        self.wrap = new TC.wrap.layer.Raster(self);

        /**
         * Indica si la capa tiene transparencia.
         * @property transparent
         * @type boolean
         * @default true
         */
        self.transparent = (self.options.transparent === false) ? false : true;

        /**
         * URL del servicio al que pertenenece la capa.
         * @property url
         * @type string
         */
        self.url = self.options.url;
        self.capabilities = TC.capabilities[self.url];

        self.params = self.options.params;
        /**
         * Lista de nombres de capa.
         * @property names
         * @type array
         * @default []
         */
        /**
         * Lista de nombres de capa disponibles inicialmente.
         * @property availableNames
         * @type array
         * @default []
         */
        if (typeof self.options.layerNames === 'string') {
            self.names = self.availableNames = self.options.layerNames.split(',');
        }
        else {
            self.names = [];
            self.availableNames = [];
            if ($.isArray(self.options.layerNames)) {
                for (var i = 0; i < self.options.layerNames.length; i++) {
                    var name = self.options.layerNames[i];
                    if (typeof name === 'string') {
                        self.names.push(name);
                        self.availableNames.push(name);

                    }
                    else if (name.hasOwnProperty('name')) {
                        self.availableNames.push(name.name);
                        if (name.isVisible === undefined || name.isVisible) {
                            self.names.push(name.name);
                        }
                    }
                }
            } else {
                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado
                // cuando queremos instanciar una capa pasándole un SLD en la petición
                var sldBody = self.options.params ? self.options.params.sld_body : null;

                if (sldBody) {
                    var sldBodyToXml = $.parseXML(sldBody);
                    var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');
                    if (namedLayerElm && namedLayerElm.length > 0) {
                        var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');

                        if (names && names.length > 0) {
                            var name = names[0].textContent;
                            self.names.push(name);
                            self.availableNames.push(name);
                        }
                    }
                }
            }
        }

        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;

        self._capabilitiesNodes = {};

        /**
      * Árbol del documento de capabilities del servicio.
      * @property capabilities
      * @type object
      */
        self.wrap._promise = new Promise(function (resolve, reject) {
            /*
             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo
             */
            var _createOLLayer = function () {
                var ollyr;
                if (!self.wrap.layer) {
                    switch (self.type) {
                        case TC.Consts.layerType.GROUP:
                            break;
                        case TC.Consts.layerType.WMTS:
                            ollyr = _createWMTSLayer(self);
                            break;
                        default:
                            ollyr = _createWMSLayer(self);
                            break;
                    }
                    self.wrap.setLayer(ollyr);
                    resolve(ollyr);
                }
            };

            const processedCapabilities = function (capabilities) {
                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.
                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.
                self.capabilities = self.capabilities || capabilities;

                var actualUrl = self.getGetMapUrl();
                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;
                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;

                _createOLLayer();
            };

            if (self.capabilities) {
                processedCapabilities(self.capabilities);
                self._capabilitiesPromise = Promise.resolve(self.capabilities);
                return;
            }

            const cachePromise = capabilitiesPromises[self.url];
            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {
                var onlineFail = false;
                var storageFail = false;
                const onlinePromise = getCapabilitiesOnline(self);
                const storagePromise = getCapabilitiesFromStorage(self);

                onlinePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function (error) {
                        onlineFail = true;
                        if (storageFail) {
                            rej(Error(error));
                        }
                    });
                storagePromise
                    .then(function (capabilities) {
                        res(capabilities);
                    })
                    .catch(function (error) {
                        storageFail = true;
                        if (onlineFail) {
                            rej(Error(error));
                        }
                    });
            });

            self.getCapabilitiesPromise()
                .then(function (capabilities) {
                    processedCapabilities(capabilities);
                })
                .catch(function (error) {
                    reject(Error(error));
                });
        });

        self._disgregatedLayerNames = null;

        if (TC.Consts.layerType.WMTS == self.type) {
            self.wrap.setWMTSUrl();
        }
    };

    TC.inherit(TC.layer.Raster, TC.Layer);

    var layerProto = TC.layer.Raster.prototype;

    layerProto.PROTOCOL_REGEX = /^(f|ht)tp?:\/\//i;
    layerProto.capabilitiesState_ = {
        PENDING: 0,
        DONE: 1
    };

    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';

    layerProto.getByProxy_ = function (url) {
        return TC.proxify(url);
    };

    layerProto.getBySSL_ = function (url) {
        var self = this;

        return url.replace(self.PROTOCOL_REGEX, "https://");
    };

    layerProto.getByUrl_ = function (url) {
        return url;
    };


    layerProto.setVisibility = function (visible) {
        var layer = this;
        layer.tree = null;
        layer._cache.visibilityStates = {
        };
        TC.Layer.prototype.setVisibility.call(layer, visible);
    };

    /*
     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)
     */
    var _getLimitedMatrixSet = function (layer) {
        var layerId = layer.layerNames;
        var matrixId = layer.matrixSet;
        var cap = layer.capabilities;

        var ret = [];

        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {
            return elto.Identifier == matrixId;
        });
        if (tset.length) {
            tset = tset[0];
            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];
            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {
                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;
                for (var i = 0; i < limits.length; i++) {
                    limit = limits[i];
                    var matrix = tset.TileMatrix.filter(function (elto) {
                        return elto.Identifier == limit.TileMatrix
                    });
                    if (matrix.length) {
                        var combi = $.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);
                        ret.push(combi);
                    }
                }

                return ret;
            }
            else {
                return tset.TileMatrix;
            }
        }
        else
            return null;
    };


    /*
     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen
     */
    var _aggregateLayerNames = function (layer, layerNames) {
        if (layer.type !== TC.Consts.layerType.WMS) {
            return layerNames;
        }
        else {
            var ln = layerNames.slice();
            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());
            return ln;
        }
    };

    /*
     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.
     * Se parte de un nodo del árbol de capas del capabilities
     */
    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {
        var result = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        if (children.length) {
            for (var i = 0, len = children.length; i < len; i++) {
                if (_aggregateLayerNodeNames(layer, names, children[i])) {
                    result = true;
                }
            }

            var nodeNames = $.map(children, function (elm) {
                return layer.wrap.getName(elm);
            }).reverse();
            var idx, firstIdx;
            var fail = false;

            firstIdx = idx = $.inArray(nodeNames[0], names);
            if (idx < 0) {
                fail = true;
            }
            else {
                for (var i = 1, len = nodeNames.length; i < len; i++) {
                    if (nodeNames[i] != names[++idx]) {
                        fail = true;
                        break;
                    }
                }
            }
            if (!fail) {
                var nodeName = layer.wrap.getName(layerNode);
                if (nodeName && nodeNames.length > 1) {
                    names.splice(firstIdx, nodeNames.length, nodeName);
                    result = true;
                }
            }
        }
        return result;
    };

    /*
     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.
     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible
     */
    var _disgregateLayerNames = function (layer, layerNames) {
        var result = [];
        var ln = layerNames.slice();
        var rootNode = layer.wrap.getRootLayerNode();
        for (var i = 0, len = ln.length; i < len; i++) {
            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));
        }
        return result;
    };

    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {
        var result = [];
        var nodeName = layer.wrap.getName(layerNode);
        var nodeVisible = layer.compareNames(name, nodeName);
        var hasEmptyChildren = false;
        var children = layer.wrap.getLayerNodes(layerNode);
        for (var i = 0; i < children.length; i++) {
            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);
            if (!names.length) {
                hasEmptyChildren = true;
            }
            else {
                result = result.concat(names);
            }
        }
        if (!children.length || hasEmptyChildren) {
            if (ancestorVisible || nodeVisible) {
                result = [nodeName];
            }
        }
        return result;
    };

    var _extendLayerNameOptions = function (options) {
        return $.extend({ aggregate: true, lazy: false }, options);
    };

    var _combineArray = function (source, add, rem) {
        var result = [];
        var s, a, r;
        s = source ? source : [];
        a = add ? add : [];
        r = rem ? rem : [];
        var sa = s.concat(a);
        for (var i = 0; i < sa.length; i++) {
            if ($.inArray(sa[i], sa) === i && $.inArray(sa[i], r) === -1) {
                result[result.length] = sa[i];
            }
        }
        return result;
    };

    var _sortLayerNames = function (layer, layerNames) {
        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;
        if (layer.capabilities) {
            var tree = layer.getTree();
            ln.sort(function (a, b) {
                var idxa = {
                    count: 0
                };
                var idxb = {
                    count: 0
                };
                _getLayerNamePosition(tree, a, idxa);
                _getLayerNamePosition(tree, b, idxb);
                return idxa.count - idxb.count;
            });
        }
        return ln;
    };

    var _isNameInArray = function (layer, name, names, looseComparison) {
        return $.grep(names, function (elm) {
            return layer.compareNames(name, elm, looseComparison);
        }).length > 0;
    };


    layerProto.getLimitedMatrixSet = function () {
        return _getLimitedMatrixSet(this);
    };

    /**
     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.
     * @method setLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  setLayerNames: sets the visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.setLayerNames = function (layerNames, options) {
        var layer = this;
        return new Promise(function (resolve, reject) {
            layer.wrap.getLayer().then(function () {
                var ln = $.isArray(layerNames) ? layerNames : layerNames.split(',');
                layer.names = ln;
                var opts = _extendLayerNameOptions(options);
                if (opts.aggregate) {
                    ln = _aggregateLayerNames(layer, ln);
                }
                layer._disgregatedLayerNames = null;
                var newParams = {
                    LAYERS: ln.join(','), TRANSPARENT: true
                };
                // Si no hay capas ocultamos la capa de servicio
                if (!ln.length) {
                    layer.setVisibility(false);
                }
                if (opts.lazy) {
                    var params = layer._newParams || layer.wrap.getParams();
                    layer._newParams = $.extend(params, newParams);
                }
                else {
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });
                    }
                    layer.tree = null;
                    layer._cache.visibilityStates = {
                    };
                    layer.wrap.setParams(newParams);
                    if (opts.reset || !layer.map) {
                        // layerNames se fija cuando se añade al mapa o cuando reset = true.
                        layer.availableNames = layer.names;
                    }
                    if (layer.map) {
                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });
                    }
                }
                resolve(layer.names);
            });
        });
    };

    /**
     * Añade capas por nombre a las que ya están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.addLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2a = $.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2a = _disgregateLayerNames(self, ln2a);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Elimina capas por nombre de las que están visibles en el WMS
     * @method addLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.removeLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2r = $.isArray(layerNames) ? layerNames : layerNames.split(',');
                var ln = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2r = _disgregateLayerNames(self, ln2r);
                    ln = self.getDisgregatedLayerNames();
                }
                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {
                    resolve(names);
                });
            });
        });
    };

    /**
     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.
     * @method toggleLayerNames
     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.
     * @param {TC.cfg.LayerNameOptions} [options]
     */
    /*
     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer
     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }
     *  aggregate option replaces layer name sets by layer group names when possible
     *  lazy option does not update OpenLayers layer
     */
    layerProto.toggleLayerNames = function (layerNames, options) {
        const self = this;
        return new Promise(function (resolve, reject) {
            self.wrap.getLayer().then(function () {
                var opts = _extendLayerNameOptions(options);
                var ln2t = $.isArray(layerNames) ? layerNames : layerNames.split(',');
                var currentLayerNames = self.wrap.getParams().LAYERS;
                if (opts.aggregate) {
                    ln2t = _disgregateLayerNames(self, ln2t);
                    currentLayerNames = self.getDisgregatedLayerNames();
                }
                var ln2a = [];
                var ln2r = [];
                for (var i = 0; i < ln2t.length; i++) {
                    var l = ln2t[i];
                    if ($.inArray(l, currentLayerNames) < 0) {
                        ln2a[ln2a.length] = l;
                    }
                    else {
                        ln2r[ln2r.length] = l;
                    }
                }
                var promises = [];
                if (ln2a.length > 0) {
                    promises.push(self.addLayerNames(ln2a, opts));
                }
                if (ln2r.length > 0) {
                    promises.push(self.removeLayerNames(ln2r, opts));
                }
                Promise.all(promises).then(function (arrays) {
                    const a1 = arrays[0];
                    const a2 = arrays[1];
                    if (a1) {
                        if (a2) {
                            resolve(a1.concat(a2));
                        }
                        else {
                            resolve(a1);
                        }
                    }
                    else {
                        resolve([]);
                    }
                });
            });
        });
    };

    /**
     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
     * @method getDisgregatedLayerNames
     * @return {array}
     */
    /*
     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names
     */
    layerProto.getDisgregatedLayerNames = function () {
        ///<summary>
        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.
        ///</summary>
        ///<returns type="array" elementType="string"></returns>
        var self = this;
        var olLayer = self.wrap.layer;
        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {
            if (!self._disgregatedLayerNames) {
                var layerNames = self.wrap.getParams().LAYERS;
                layerNames = $.isArray(layerNames) ? layerNames : layerNames.split(',');
                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);
            }
        }
        else {
            self._disgregatedLayerNames = self.names;
        }
        return self._disgregatedLayerNames.slice();
    };

    layerProto.isValidFromNames = function () {
        var self = this;
        var result = true;
        for (var i = 0, len = self.names.length; i < len; i++) {
            if (!self.getLayerNodeByName(self.names[i])) {
                result = false;
                break;
            }
        }
        return result;
    };

    layerProto.isCompatible = function (crs) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;
                break;
            case TC.Consts.layerType.WMS:
                result = self.wrap.isCompatible(crs);
                break;
            default:
                break;
        }
        return result;
    };

    layerProto.getCompatibleCRS = function (options) {
        const self = this;
        options = options || {};
        var result = self.wrap.getCompatibleCRS();
        if (options.includeFallback && self.fallbackLayer) {
            const fbLayer = self.getFallbackLayer();
            if (fbLayer instanceof TC.Layer) {
                result = result.concat(fbLayer.wrap.getCompatibleCRS());
            }
        }
        if (options.normalized) {
            result = result
                .map(function (crs) {
                    return TC.Util.getCRSCode(crs);
                }) // códigos numéricos
                .filter(function (code) {
                    return code !== null;
                })
                .reduce(function (prev, cur) {
                    if (prev.indexOf(cur) < 0) {
                        prev[prev.length] = cur;
                    }
                    return prev;
                }, []) // códigos numéricos sin duplicados
                .map(function (code) {
                    return 'EPSG:' + code;
                }); // códigos normalizados
        }
        return result;
    };

    layerProto.getProjection = function () {
        var self = this;

        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                return self.wrap.layer.getSource().getProjection().getCode();
            case TC.Consts.layerType.WMS:
                return self.map.crs;
        }
    };

    layerProto.setProjection = function (options) {
        var self = this;
        options = options || {};
        if (options.crs) {
            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];
                    if (matrixSet) {
                        self.matrixSet = matrixSet;
                        self.wrap.setMatrixSet(matrixSet);
                    }
                    else {
                        self.wrap.setProjection(options);
                    }
                    self.mustReproject = !matrixSet;
                    break;
                case TC.Consts.layerType.WMS:
                    self.wrap.setProjection(options);
                    self.mustReproject = !self.isCompatible(options.crs);
                    break;
                default:
                    break;
            }
        }
    };

    /*
     *  isVisibleByScale: return wether the WMS layer is visible at current scale
     *  Parameter: WMS layer name or UID
     */
    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {
        var self = this;
        var result;
        var _getOgcScale = function () {
            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel
        };
        var currentScale;
        var i;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                result = false;
                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);
                if (tileMatrix) {
                    currentScale = _getOgcScale();
                    for (i = 0; i < tileMatrix.length; i++) {
                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);
                        if (scaleDenominators[0] === currentScale) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            case TC.Consts.layerType.WMS:                
                result = true;
                var layers = self.wrap.getAllLayerNodes();
                if (layers.length > 0) {
                    currentScale = _getOgcScale();
                    var node;
                    if (typeof nameOrUid === 'number') {
                        node = self._capabilitiesNodes[nameOrUid];
                    }
                    else {
                        for (i = 0; i < layers.length; i++) {
                            var layer = layers[i];
                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {
                                node = layer;
                                break;
                            }
                        }
                    }
                    if (node) {
                        var scaleDenominators = self.wrap.getScaleDenominators(node);
                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);

                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.
                        if (!result) {
                            if (node.Layer && node.Layer.length > 0) {
                                return node.Layer.some(function (nodeLayer) {
                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);
                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)
                                });
                            }
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    /*
     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names
     *  Parameter: WMS layer name
     */
    layerProto.isVisibleByName = function (name, looseComparison) {
        var self = this;
        var result = false;
        switch (self.type) {
            case TC.Consts.layerType.WMTS:
                if (self.wrap.getWMTSLayer()) {
                    result = true;
                    break;
                }
                break;
            case TC.Consts.layerType.WMS:
                var _getLayerPath = function _getLayerPath(name) {
                    return __getLayerPath(name, self.wrap.getRootLayerNode());
                };

                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {
                    var result = null;
                    var n = self.wrap.getName(capabilitiesNode);
                    if (self.compareNames(n, name, looseComparison)) {
                        result = [n];
                    }
                    else {
                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                        for (var i = 0; i < layerNodes.length; i++) {
                            var item = layerNodes[i];
                            var r = __getLayerPath(name, item);
                            if (r) {
                                TC.Util.fastUnshift(r, n);
                                result = r;
                                break;
                            }
                        }
                    }
                    return result;
                };

                var path = _getLayerPath(name);
                if (path) {
                    for (var i = 0; i < path.length; i++) {
                        if (_isNameInArray(self, path[i], self.names)) {
                            result = true;
                            break;
                        }
                    }
                }
                break;
            default:
                result = true;
                break;
        }
        return result;
    };

    layerProto.getTree = function () {
        var self = this;
        var result = self.tree;

        var addChild = function (node, child) {
            if (self.options.inverseTree) {
                // Versión rápida de unshift
                TC.Util.fastUnshift(node.children, child);
            }
            else {
                node.children[node.children.length] = child;
            }
        }

        if (!result) {
            var rootNode;
            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {
                var uid;
                for (var key in self._capabilitiesNodes) {
                    if (self._capabilitiesNodes[key] === capabilitiesNode) {
                        uid = key;
                        break;
                    }
                }
                if (!uid) {
                    uid = TC.getUID();
                    self._capabilitiesNodes[uid] = capabilitiesNode;
                }
                var r = {
                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: []
                };
                if (isRootNode) {
                    rootNode = r;
                }

                if (_isNameInArray(self, r.name, self.availableNames)) {
                    forceAddition = true;
                }

                if (!self.options.isBase) {
                    if (r === rootNode) {
                        r.isVisible = self.getVisibility();
                    }
                    else {
                        r.isVisible = self.isVisibleByName(r.name);
                    }
                    var i;
                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);
                    for (i = 0; i < layerNodes.length; i++) {
                        var treeNode = getTreeNode(layerNodes[i], forceAddition);
                        if (treeNode) {
                            addChild(r, treeNode);
                        }
                    }

                    r.legend = self.wrap.getLegend(capabilitiesNode);

                    // No muestra ramas irrelevantes si hideTree = true
                    if (!forceAddition && !isRootNode) {
                        // Eliminamos la rama hasta el nodo de interés
                        rootNode.children = rootNode.children.concat(r.children);
                        r = null;
                    }
                }
                else {
                    r.name = self.names.join(',');
                    r.title = self.title || r.title;
                    r.isBase = self.isDefault;
                    if (self.options.thumbnail) {
                        r.legend = {
                            src: self.options.thumbnail
                        };
                    }
                }
                return r;
            };

            switch (self.type) {
                case TC.Consts.layerType.WMTS:
                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);
                    break;
                case TC.Consts.layerType.WMS:
                    if (self.capabilities) {
                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);

                        var cache = self._cache.visibilityStates;

                        var _setNodeState = function _setNodeState(node) {
                            var _result = TC.Consts.visibility.NOT_VISIBLE;
                            if (node) {
                                if (cache[node.uid] !== undefined) {
                                    _result = cache[node.uid];
                                }
                                else {
                                    if (node.children) {
                                        var hasVisible = false;
                                        var hasNotVisible = false;
                                        for (var i = 0, len = node.children.length; i < len; i++) {
                                            var r = _setNodeState(node.children[i]);
                                            switch (r) {
                                                case TC.Consts.visibility.VISIBLE:
                                                    hasVisible = true;
                                                    break;
                                                case TC.Consts.visibility.NOT_VISIBLE:
                                                    hasNotVisible = true;
                                                    break;
                                                case TC.Consts.visibility.HAS_VISIBLE:
                                                    hasVisible = true;
                                                    hasNotVisible = true;
                                                    break;
                                                default:
                                                    break;
                                            }
                                            if (hasVisible) {
                                                if (hasNotVisible) {
                                                    _result = TC.Consts.visibility.HAS_VISIBLE;
                                                }
                                                else {
                                                    _result = TC.Consts.visibility.VISIBLE;
                                                }
                                            }
                                        }
                                    }
                                    if (node.isVisible) {
                                        _result = TC.Consts.visibility.VISIBLE;
                                    }
                                    cache[node.uid] = _result;
                                }
                                node.visibilityState = _result;
                            }
                            return _result;
                        };
                        _setNodeState(result);

                        if (self.options.hideTree) {
                            _sortTree(self, result);
                        }
                    }
                    break;
                default:
                    break;
            }
            if (!result) {
                result = {
                    name: self.name, title: self.title
                };
            }
            result.title = self.title || result.title;
            result.customLegend = self.customLegend || result.customLegend;
            self.tree = result;
        }
        return result;
    };

    layerProto.setNodeVisibility = function (id, visible) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }

        var _getNames = function _getNames(node) {
            var result = [];
            if (node.name) {
                result[0] = node.name;
            }
            else {
                for (var i = 0; i < node.children.length; i++) {
                    result = result.concat(_getNames(node.children[i]));
                }
            }
            return result;
        };

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            if (visible && self.names.length === 0) {
                // Prevent pink error tile
                self.addLayerNames(self.availableNames).then(function () {
                    self.setVisibility(true);
                });
            }
            else {
                self.setVisibility(visible);
            }
        }
        else {
            var names = _getNames(node);
            if (visible) {
                self.addLayerNames(names);
            }
            else {
                self.removeLayerNames(names);
            }
        }
    };

    layerProto.getNodeVisibility = function (id) {
        var self = this;
        if (!self.tree) {
            self.tree = self.getTree();
        }
        return self._cache.visibilityStates[id];
    };

    layerProto.getNodePath = function (layerName, ignorePrefix) {
        var self = this;
        var result = [];
        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {
            layerName = layerName || self.names[0];

            var _getPath = function _getPath(node) {
                var res = [];
                var nodeName = self.wrap.getName(node);
                if (self.compareNames(nodeName, layerName, ignorePrefix)) {
                    res.push(node);
                }
                else {
                    var children = self.wrap.getLayerNodes(node);
                    for (var i = 0; i < children.length; i++) {
                        var r = _getPath(children[i]);
                        if (r.length) {
                            res = r;
                            TC.Util.fastUnshift(res, node);
                            break;
                        }
                    }
                }
                return res;
            };
            result = _getPath(self.wrap.getRootLayerNode());
        }
        return result;
    };

    layerProto.getPath = function (layerName, ignorePrefix) {
        return $.map(this.getNodePath(layerName, ignorePrefix), function (node) {
            return node.title || node.Title;
        });
    };

    layerProto.getLayerNodeByName = function (name) {
        var result = null;
        var self = this;
        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName
        var nodes = self.wrap.getAllLayerNodes();
        for (var i = 0, len = nodes.length; i < len; i++) {
            if (self.compareNames(getName(nodes[i]), name)) {
                result = nodes[i];
                break;
            }
        }
        return result;
    };

    layerProto.getChildrenLayers = function (layer) {
        var self = this;
        var result = [];
        var _fnRecursiva = function (lyr, arr) {
            if (lyr && lyr.Layer && lyr.Layer.length) {
                for (var i = 0; i < lyr.Layer.length; i++) {
                    arr[arr.length] = lyr.Layer[i];
                    _fnRecursiva(lyr.Layer[i], arr)
                }
            }
        };
        _fnRecursiva(layer, result);
        return result;
    };

    layerProto.compareNames = function (n1, n2, looseComparison) {
        var result = n1 === n2;
        var self = this;
        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes
        if (!result && lc && n1 && n2) {
            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación
            var idx1 = n1.indexOf(':');
            var idx2 = n2.indexOf(':');
            if (idx1 >= 0 && idx2 < 0) {
                result = n1.substr(idx1 + 1) === n2;
            }
            else if (idx2 >= 0 && idx1 < 0) {
                result = n1 === n2.substr(idx2 + 1);
            }
        }
        return result;
    };

    layerProto.getCapabilitiesPromise = function () {
        return this._capabilitiesPromise;
    };

    layerProto.getResolutions = function () {
        return this.wrap.getResolutions();
    };

    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado
    //case insensitive
    layerProto.searchSubLayers = function (text) {
        if (!this.patternFn) {
            this.patternFn = function (t) {
                t = t.replace(/[^a-z\dáéíóúüñ]/gi, '\\' + '$&');
                t = t.replace(/(a|á)/gi, "(a|á)");
                t = t.replace(/(e|é)/gi, "(e|é)");
                t = t.replace(/(i|í)/gi, "(i|í)");
                t = t.replace(/(o|ó)/gi, "(o|ó)");
                t = t.replace(/(u|ú|ü)/gi, "(u|ú|ü)");
                t = t.replace(/n/gi, "(n|ñ)");
                return t;
            }
        }
        if (text && text.length && text.length >= 3) {
            var self = this;
            var layers = null;
            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado "cat" y ahora busco "cata" porque esto escribiendo "catastro" ...
            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */
            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {
                layers = this.lastMatches
            }
            else {
                /*si se ha definido el parametro layers de esta capa en configuraci\u00f3n filtro las capas del capability para que busque solo en las capas que est\u00e9n en 
                configuraci\u00f3n y sus hijas*/
                if (self.availableNames && self.availableNames.length > 0) {
                    layers = []
                    for (var i = 0; i < self.availableNames.length; i++) {
                        var layer = self.getLayerNodeByName(self.availableNames[i]);
                        if (layer) {
                            layers[layers.length] = layer;
                            layers = layers.concat(self.getChildrenLayers(layer));
                        }
                    }
                }
                else {
                    layers = self.wrap.getAllLayerNodes();
                }
            }

            var filter = this.patternFn(text);
            var re = new RegExp(filter, "i");

            var matches = layers.map(function (ly, ix) {
                delete ly.tcScore;

                ly.tcPosition = ix;

                self.wrap.normalizeLayerNode(ly);

                var title = ly.Title.trim();
                var res = re.exec(title);
                var titleIx = res ? res.index : -1;
                var abstractIx = -1;
                if (ly.Abstract) {
                    var abs = ly.Abstract.trim();
                    var res2 = re.exec(abs);
                    abstractIx = res2 ? res2.index : -1;
                }

                if (res && title == res[0])
                    ly.tcScore = 20;
                else if (titleIx == 0)
                    ly.tcScore = 15;
                else if (titleIx > -1)
                    ly.tcScore = 10;
                else if (abstractIx == 0)
                    ly.tcScore = 5;
                else if (abstractIx > -1)
                    ly.tcScore = 1;

                if (ly.tcScore)
                    return ly;
                else
                    return null;
            })
                .filter(function (elto) {
                    return elto != null;
                })
                .sort(function (a, b) {
                    if (b.tcScore === a.tcScore) {
                        //si la puntuación es la misma reordenamos por título
                        var titleA = TC.Util.replaceAccent(a.Title);
                        var titleB = TC.Util.replaceAccent(b.Title);
                        if (titleA < titleB) return -1;
                        if (titleA > titleB) return 1;
                        return 0;
                    }
                    else
                        return b.tcScore - a.tcScore;
                });

            this.lastPattern = text;
            this.lastMatches = matches;

            return matches;
        }
        else {
            return [];
        }

    };

    var cleanOgcUrl = function (url) {
        var result = url;
        if (url) {
            var match = url.match(/\??SERVICE=\w+&/i);
            if (match) {
                result = result.replace(match[0], '');
            }
        }
        return result;
    };

    layerProto.getGetMapUrl = function () {
        return cleanOgcUrl(this.wrap.getGetMapUrl());
    };

    layerProto.getPreferredInfoFormat = function () {
        var layer = this;
        var result = null;

        var infoFormats = layer.wrap.getInfoFormats();
        if (infoFormats) {
            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {
                var format = TC.wrap.layer.Raster.infoFormatPreference[i];
                if ($.inArray(format, infoFormats) >= 0) {
                    result = format;
                    break;
                }
            }
        }
        return result;
    };

    /**
     * Carga la imagen de leyenda de una capa por POST.
     */
    layerProto.getLegendGraphicImage = function () {
        const self = this;
        return new Promise(function (resolve, reject) {
            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta
            if (self.options.params.base64LegendSrc) {
                return resolve(self.options.params.base64LegendSrc);
            }

            if (typeof window.btoa === 'function') {
                var name = self.names[0];
                var info = self.wrap.getInfo(name);
                var xhr = new XMLHttpRequest();
                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL
                var dataEntries = url[1].split("&"); // Separamos clave/valor de cada parámetro
                var params = self.options.params.sld_body ? "sld_body=" + self.options.params.sld_body : '';

                for (var i = 0; i < dataEntries.length; i++) {
                    var chunks = dataEntries[i].split('=');

                    if (chunks && chunks.length > 1 && chunks[1]) {
                        params += "&" + dataEntries[i];
                    }
                }
                if (self.options.params.env) {
                    params += "&" + self.options.params.env;
                }

                xhr.open('POST', url[0], true);
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

                xhr.responseType = 'arraybuffer';
                xhr.onload = function (e) {
                    if (this.status === 200) {
                        var uInt8Array = new Uint8Array(this.response);
                        var i = uInt8Array.length;
                        var binaryString = new Array(i);
                        while (i--) {
                            binaryString[i] = String.fromCharCode(uInt8Array[i]);
                        }
                        var data = binaryString.join('');
                        var type = xhr.getResponseHeader('content-type');
                        if (type.indexOf('image') === 0) {
                            var imageSrc;
                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);
                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta
                            resolve(imageSrc);
                        }
                    }
                };
                xhr.send(params);
            } else {
                reject(Error("Función window.btoa no soportada por el navegador"));
            }
        });
    };

    layerProto.getUrl = function (src) {
        var self = this;

        return src;
    };

    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL
    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; 
    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.

    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.
    layerProto.getWebGLUrl = function (src, location) {
        const self = this;
        return new Promise(function (resolve, reject) {

            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;

            if (self.ignoreProxification) {
                resolve(_src);
            } else {
                const options = {
                    exportable: true,
                    ignoreProxification: self.ignoreProxification
                };

                self.toolProxification.fetchImage(_src, options).then(function () {
                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {
                        if (cache && cache.action) {
                            resolve(cache.action.call(self.toolProxification, _src));
                        }
                    });
                }).catch(function (e) {
                    reject(Error(e));
                });
            }

            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más
            //if (self.ignoreProxification) {
            //    setSRC({ src: TC.Consts.BLANK_IMAGE });
            //    return;
            //}

            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        
        });
    };

    layerProto.getFeatureUrl = function (url) {
        var self = this;

        return self.toolProxification.cacheHost.getAction(url).then(function (cache) {
            return cache.action.call(self.toolProxification, url);
        });
    };

    // GLS:
    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. 
    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.
    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {
        var self = this;

        if (!self.map) {
            return null;
        } else {
            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));

            const matchingLayer = layers.filter(function (elem) {
                return (elem.type === TC.Consts.layerType.WMS ||
                    elem.type === TC.Consts.layerType.WMTS) &&
                    (elem.capabilities === self.capabilities || elem.url === self.url) &&
                    (dynamicStatement && $.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);
            })[0];

            return matchingLayer || null;
        }
    };

    layerProto.getImageLoad = function (image, src, location) {
        const self = this;

        // Viene sin nombre desde el control TOC, si es así lo ignoramos.
        if (self.names && self.names.length > 0) {

            const setSRC = function (data) {
                var olImg = image.getImage();

                if (!TC.Util.isSameOrigin(data.src)) {
                    if (!self.map || (self.map && self.map.mustBeExportable)) {
                        olImg.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : "anonymous";
                    }
                }

                // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.
                olImg.setAttribute("src", data.src);

                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
            };

            const error = function (error) {
                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                setSRC({ src: TC.Consts.BLANK_IMAGE });
            };

            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404
            if (self.type === TC.Consts.layerType.WMTS) {
                var z, x, y;
                if (self.encoding != "KVP") {
                    var _src = src.replace('.' + self.format.split('/')[1], '');
                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });
                    z = parts[0];
                    x = parts[1];
                    y = parts[2];
                } else {
                    var parts = /.*TileMatrix=(\d*)&TileCol=(\d*)&TileRow=(\d*)/i.exec(src);
                    if (parts && parts.length == 4) {
                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });
                        z = parts[0];
                        x = parts[2];
                        y = parts[1];
                    }
                }

                if (z && x && y) {
                    var wmtsOptions = self.wrap.getWMTSLayer();
                    if (wmtsOptions) {
                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });
                        if (matrixSet.length > 0) {

                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {
                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {
                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))
                                        return 1;
                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))
                                        return -1;
                                    else return 0;
                                });

                                var level = matrixSetLimits[z];
                                if (level && self.map && self.map.on3DView) {
                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {
                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');
                                        setSRC({ src: TC.Consts.BLANK_IMAGE });
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });

            var params = "";
            var isPOST = self.options.method === "POST";
            if (isPOST) {
                var url = src.split('?');
                params = url[1].split("&").filter(function (param) {
                    const values = param.split('=');
                    // eliminamos los valores en blanco y el parámetro layers
                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== "layers";
                }).join('&');

                self.toolProxification.fetchImageAsBlob(url[0], {
                    type: "POST",
                    data: params,
                    contentType: "application/x-www-form-urlencoded"
                }).then(function (blob) {
                    const imageUrl = URL.createObjectURL(blob);
                    const img = image.getImage();
                    img.onload = function (evt) {
                        URL.revokeObjectURL(imageUrl);
                    };
                    setSRC({ src: imageUrl });
                }).catch(error);

            } else {
                if (!self.ignoreProxification) {
                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {
                        setSRC(img);
                    }).catch(error);
                } else {
                    setSRC({ src: src });
                    var img = image.getImage();

                    if (!TC.Util.isSameOrigin(src)) {
                        if (!self.map || (self.map && self.map.mustBeExportable)) {
                            img.crossOrigin = "anonymous";
                        }
                    }                    

                    img.onload = function () {
                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
                    };
                    img.onerror = function (error) {                        
                        img.src = TC.Consts.BLANK_IMAGE;
                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });
                    };

                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;
                }
            }
        } else {
            // lanzamos el evento para gestionar el loading
            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });
        }
    };

    var _get$events = function () {
        const self = this;
        if (self.wrap && self.wrap.$events) {
            return self.wrap.$events;
        }
        return null;
    };

    layerProto.getWFSCapabilitiesPromise = function () {
        const self = this;

        if (typeof (WFSCapabilities) === "undefined") {
            TC.syncLoadJS(TC.apiLocation + 'TC/layer/WFSCapabilitiesParser');
        }
        var url = this.options.url.replace(/service=wms/i, "service=wfs").replace(/\/wms(\/|\?|\b)/i, "$'/wfs/")
        var _src = !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(url)) ? self.getBySSL_(url) : url;
        var basicUrl = url.substring(url.indexOf("://") < 0 ? 0 : url.indexOf("://") + 3);
        if (TC.WFScapabilities[basicUrl]) {
            if (TC.WFScapabilities[basicUrl] instanceof Promise)
                return TC.WFScapabilities[basicUrl];
            else
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        resolve(TC.WFScapabilities[basicUrl]);
                    }, 100);
                });
        }
        TC.WFScapabilities[basicUrl] = new Promise(function (resolve, reject) {
            var params = {
            }
            params.SERVICE = 'WFS';
            params.VERSION = '2.0.0';
            params.REQUEST = 'GetCapabilities';

            var url = self.getUrl(_src + '?' + TC.Util.getParamString(params));

            self.toolProxification.fetch(url, { retryAttempts: 2 }).then(function (data) {

                var capabilities
                var xmlDoc;
                const documentElement = data.responseText && (data.responseText.ownerDocument || data.responseText).documentElement;
                const isXMLDoc = documentElement ? documentElement.nodeName !== 'HTML' : false;
                if (isXMLDoc) {
                    xmlDoc = data.responseText;
                }
                else {
                    xmlDoc = (new DOMParser()).parseFromString(data.responseText, 'text/xml');
                }
                //comprueba si el servidor ha devuelto una excepcion

                var errorNode = xmlDoc.getElementsByTagName('ServiceException')[0];
                if (!errorNode) {
                    errorNode = xmlDoc.getElementsByTagName('ExceptionText')[0];
                }
                if (errorNode) {
                    reject(Error(errorNode.innerHTML));
                    return;
                }
                try {
                    capabilities = WFSCapabilities.Parse(xmlDoc);
                }
                catch (err) {
                    reject(err instanceof Error ? err : Error(err));
                    return;
                }

                if (!capabilities.Operations) {
                    reject(null);
                    return;
                }
                var _url = (capabilities.Operations.GetCapabilities.DCP && capabilities.Operations.GetCapabilities.DCP.HTTP.Get["xlink:href"]) || capabilities.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource
                TC.WFScapabilities[_url] = capabilities;
                TC.WFScapabilities[basicUrl] = capabilities;
                resolve(capabilities);
            }).catch(function (error) {
                //reject(Error(capabilitiesError(layer, dataError)));
                reject(error instanceof Error ? error : Error(error));
            });
        });
        return TC.WFScapabilities[basicUrl];
    };

    layerProto.getFallbackLayer = function () {
        const self = this;
        if (self.fallbackLayer instanceof TC.Layer) {
            return self.fallbackLayer;
        }
        if (self.options.fallbackLayer) {
            var fbLayer = self.options.fallbackLayer;
            if (typeof fbLayer === 'string') {
                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;
                ablCollection.forEach(function (baseLayer) {
                    if (self.options.fallbackLayer === baseLayer.id) {
                        self.fallbackLayer = new TC.layer.Raster($.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));
                        self.fallbackLayer.firstOption = self;
                    }
                });
            }
            else if (fbLayer instanceof TC.Layer) {
                self.fallbackLayer = fbLayer;
                self.fallbackLayer.firstOption = self;
            }
            else {
                self.fallbackLayer = new TC.layer.Raster($.extend({}, fbLayer, {
                    id: TC.getUID(),
                    isBase: true,
                    stealth: true,
                    title: layer.title,
                    map: self.map
                }));
                self.fallbackLayer.firstOption = self;
            }
            return self.fallbackLayer;
        }
        return null;
    };
})();
var esriParser = {
    parse: function (text) {
        var result = [];
        var dom = (new DOMParser()).parseFromString(text, 'text/xml');
        if (dom.documentElement.tagName === 'FeatureInfoResponse') {
            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');
            for (var i = 0, len = fiCollections.length; i < len; i++) {
                var fic = fiCollections[i];
                var layerName = fic.getAttribute('layername');
                var fInfos = fic.getElementsByTagName('FeatureInfo');
                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {
                    var fields = fInfos[j].getElementsByTagName('Field');
                    var attributes = {};
                    for (var k = 0, lenk = fields.length; k < lenk; k++) {
                        var field = fields[k];
                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);
                    }
                    var feature = new ol.Feature(attributes);
                    feature.setId(layerName + '.' + TC.getUID());
                    result[result.length] = feature;
                }
            }
        }
        return result;
    }
};
﻿TC.layer = TC.layer || {};

if (!TC.Layer) {
    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');
}

/**
 * Opciones de capa vectorial.
 * Esta clase no tiene constructor.
 * @class TC.cfg.VectorOptions
 * @extend TC.cfg.LayerOptions
 * @static
 */
/**
 * Tipo de capa.
 * @property type
 * @type TC.consts.LayerType
 * @default TC.Consts.layerType.VECTOR
 */
/**
 * URL del servicio WFS o del documento que define la capa.
 * @property url
 * @type string|undefined
 */

/**
 * Capa de tipo vectorial, como la de un WFS o un KML.
 * @class TC.layer.Vector
 * @extends TC.Layer
 * @constructor
 * @async
 * @param {TC.Cfg.layer} [options] Objeto de opciones de configuración de la capa.
 */
TC.layer.Vector = function () {
    var self = this;
    TC.Layer.apply(self, arguments);

    self.type = self.options.type || TC.Consts.layerType.VECTOR;
    /**
     * Lista de entidades geográficas que hay en la capa.
     * @property features
     * @type array
     * @default []
     */
    self.features = [];
    /**
     * Lista de entidades geográficas seleccionadas en la capa.
     * @property selectedFeatures
     * @type array
     * @default []
     */
    self.selectedFeatures = [];

    const getFileExtension = function (url) {
        url = url || '';
        var idx = url.indexOf('?');
        if (idx >= 0) {
            url = url.substr(0, idx);
        }
        else {
            idx = url.indexOf('#');
            if (idx >= 0) {
                url = url.substr(0, idx);
            }
        }
        return url.substr(url.lastIndexOf('.')).toLowerCase();
    };

    const getFormatFromExtension = function (extension) {
        switch (extension) {
            case '.kml':
                return TC.Consts.format.KML;
            case '.gpx':
                return TC.Consts.format.GPX;
            case '.json':
            case '.geojson':
                return TC.Consts.format.GEOJSON;
            case '.gml':
                return TC.Consts.format.GML;
            case '.wkt':
                return TC.Consts.format.WKT;
            case '.topojson':
                return TC.Consts.format.TOPOJSON;
            default:
                return null;
        }
    };
    const getFormatFromMimeType = function (mimeType) {
        switch (mimeType) {
            case TC.Consts.mimeType.KML:
                return TC.Consts.format.KML;
            case TC.Consts.mimeType.GPX:
                return TC.Consts.format.GPX;
            case TC.Consts.mimeType.JSON:
            case TC.Consts.mimeType.GEOJSON:
                return TC.Consts.format.GEOJSON;
            case TC.Consts.mimeType.GML:
                return TC.Consts.format.GML;
            default:
                return null;
        }
    };
    /**
     * URL del servicio o documento al que pertenenece la capa.
     * @property url
     * @type string
     */
    const extension = getFileExtension(self.url);
    const format = getFormatFromMimeType(self.options.format) || getFormatFromExtension(extension);
    if (format || self.type === TC.Consts.layerType.KML) {
        if (format === TC.Consts.format.KML) {
            self.type = TC.Consts.layerType.KML;
        }

        var getFileName = function (url) {
            url = url || '';
            var result = url;
            var regexp = new RegExp('([^/]+' + extension + ')', 'i');
            for (var i = 0; i < 3; i++) {
                url = decodeURIComponent(url);
                var match = regexp.exec(url);
                if (match.length > 1) {
                    result = match[1];
                    break;
                }

            }
            return result;
        };
        self.title = self.options.title || getFileName(self.url);
    }

    self.wrap = new TC.wrap.layer.Vector(self);

    var ollyr = self.wrap.createVectorLayer();
    self.wrap.setLayer(ollyr);
    self.wrap._promise = Promise.resolve(ollyr);
};

TC.inherit(TC.layer.Vector, TC.Layer);

(function () {
    var layerProto = TC.layer.Vector.prototype;

    /*
     *  getTree: returns service layer tree { name, title, children }
     */
    layerProto.getTree = function () {
        var self = this;
        var result = null;
        if (!self.options.stealth) {
            result = {};
            result.children = [];
            for (var i = 0; i < self.features.length; i++) {
                var path = self.features[i].getPath();
                if (path.length) {
                    var node = TC.Util.addArrayToTree(path, result);
                    if (node) {
                        node.legend = self.features[i].getLegend();
                    }
                }
            }
            result.name = self.name || result.name;
            result.customLegend = self.options.customLegend; //Atributo para pasar una plantilla HTML diferente a la por defecto (LegendNode.html)
            result.title = self.title || result.title;
            result.uid = self.id;
        }
        return result;
    };

    var addFeatureInternal = function (layer, multipleFeatureFunction, coord, options) {
        return new Promise(function (resolve, reject) {
            multipleFeatureFunction.call(layer, [coord], options).then(function (features) {
                resolve(features[0]);
                if (layer.map) {
                    layer.map.trigger(TC.Consts.event.FEATUREADD, { layer: layer, feature: features[0] });
                }
            });
        });
    };

    var addFeaturesInternal = function (layer, coordsArray, constructorName, styleType, options) {
        var style = (layer.options.styles && layer.options.styles[styleType]) || TC.Cfg.styles[styleType];
        var opts = $.extend(true, {}, style, options);
        return new Promise(function (resolve, reject) {
            var FeatureConstructor;
            const endFn = function () {
                FeatureConstructor = FeatureConstructor || TC.feature[constructorName];
                var features = new Array(coordsArray.length);
                var nativeFeatures = [];
                for (var i = 0, len = coordsArray.length; i < len; i++) {
                    var coords = coordsArray[i];
                    var feature;
                    const isNative = TC.wrap.Feature.prototype.isNative(coords);
                    if (coords instanceof FeatureConstructor || "TC.feature." + constructorName === coords.CLASSNAME) {
                        feature = coords;
                    }
                    else {
                        opts.layer = layer;
                        if (isNative) {
                            feature = coords._wrap && coords._wrap.parent;
                        }
                        if (!feature) {
                            feature = new FeatureConstructor(coords, opts);
                        }
                    }
                    feature.layer = layer;
                    features[i] = feature;
                    layer.features[layer.features.length] = feature;
                    if (!isNative) {
                        nativeFeatures[nativeFeatures.length] = feature.wrap.feature;
                    }
                    if (feature.options.showPopup) {
                        feature.showPopup();
                    }
                    // Este evento mata el rendimiento
                    //self.map.trigger(TC.Consts.event.FEATUREADD, { layer: self, feature: marker });
                }
                if (nativeFeatures.length) {
                    layer.wrap.addFeatures(nativeFeatures);
                }
                resolve(features);
            };
            if (constructorName) {
                TC.loadJS(
                    !TC.feature || (TC.feature && !TC.feature[constructorName]),
                    [TC.apiLocation + 'TC/feature/' + constructorName],
                    endFn
                );
            }
            else {
                FeatureConstructor = TC.Feature;
                endFn();
            }
        });
    };

    /**
     * Añade un punto a la capa.
     * @method addPoint
     * @async
     * @param {array|TC.feature.Point|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
     * @param {TC.cfg.PointStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Point
     */
    layerProto.addPoint = function (coord, options) {
        return addFeatureInternal(this, this.addPoints, coord, options);
    };

    /**
     * Añade una lista de puntos a la capa.
     * @method addPoints
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPoint:method"}}{{/crossLink}}.
     * @param {TC.cfg.PointStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Point
     */
    layerProto.addPoints = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Point', TC.Consts.geom.POINT, options);
    };

    /**
     * Añade un marcador a la capa.
     * @method addMarker
     * @async
     * @param {array|TC.feature.Marker|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).
     * @param {TC.cfg.MarkerStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Marker
     */
    layerProto.addMarker = function (coord, options) {
        return addFeatureInternal(this, this.addMarkers, coord, options);
    };

    /**
     * Añade una lista de marcadores a la capa.
     * @method addMarkers
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addMarker:method"}}{{/crossLink}}.
     * @param {TC.cfg.MarkerStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Marker
     */
    layerProto.addMarkers = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Marker', 'marker', options);
    };

    /**
     * Añade una polilínea a la capa.
     * @method addPolyline
     * @async
     * @param {array|TC.feature.Polyline|ol.geom.MultiLineString|OpenLayers.Geometry.LineString} coords Si es un array, contiene arrays de dos números (coordenadas de puntos).
     * @param {TC.cfg.PolylineOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polyline
     */
    layerProto.addPolyline = function (coords, options) {
        return addFeatureInternal(this, this.addPolylines, coords, options);
    };


    /**
     * Añade una lista de polilíneas a la capa.
     * @method addPolylines
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolyline:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolylineOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polyline
     */
    layerProto.addPolylines = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Polyline', TC.Consts.geom.POLYLINE, options);
    };

    layerProto.addMultiPolyline = function (coords, options) {
        return addFeatureInternal(this, this.addMultiPolylines, coords, options);
    };


    layerProto.addMultiPolylines = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'MultiPolyline', TC.Consts.geom.POLYLINE, options);
    };

    /**
     * Añade un polígono a la capa.
     * @method addPolygon
     * @async
     * @param {array|TC.feature.Polygon|ol.geom.Polygon|OpenLayers.Geometry.Polygon} coords Si es un array, contiene arrays de coordenadas, que son a su vez arrays de dos números. El primer
     * elemento de ese array es el anillo exterior, los siguientes son anillos interiores.
     * @param {TC.cfg.PolygonOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polygon
     */
    layerProto.addPolygon = function (coords, options) {
        return addFeatureInternal(this, this.addPolygons, coords, options);
    };

    /**
     * Añade una lista de polígonos a la capa.
     * @method addPolygons
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addPolygon:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolygonOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polygon
     */
    layerProto.addPolygons = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Polygon', TC.Consts.geom.POLYGON, options);
    };

    layerProto.addMultiPolygon = function (coords, options) {
        return addFeatureInternal(this, this.addMultiPolygons, coords, options);
    };


    layerProto.addMultiPolygons = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'MultiPolygon', TC.Consts.geom.POLYGON, options);
    };

    /**
     * Añade un círculo a la capa.
     * @method addCircle
     * @async
     * @param {array|TC.feature.Circle|ol.geom.Circle} coord Si es un array, contiene un array de dos números (la coordenada del centro) y un número (el radio).
     * @param {TC.cfg.PolygonStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Circle
     */
    layerProto.addCircle = function (coord, options) {
        return addFeatureInternal(this, this.addCircles, coord, options);
    };

    /**
     * Añade una lista de círculos a la capa.
     * @method addCircles
     * @async
     * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink "TC.layer.Vector/addCircle:method"}}{{/crossLink}}.
     * @param {TC.cfg.PolygonStyleOptions} [options]
     * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Circle
     */
    layerProto.addCircles = function (coordsArray, options) {
        return addFeaturesInternal(this, coordsArray, 'Circle', TC.Consts.geom.POLYGON, options);
    };
    /**
     * Añade una entidad geográfica a la capa.
     * @method addFeature
     * @async
     * @param {TC.Feature} feature 
     * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.Feature
     */
    layerProto.addFeature = function (feature) {
        const self = this;
        var result;
        if (TC.feature) {
            if (TC.feature.Point && feature instanceof TC.feature.Point || feature.CLASSNAME === "TC.feature.Point") {
                result = self.addPoint(feature);
            }
            else if (TC.feature.Polyline && feature instanceof TC.feature.Polyline || feature.CLASSNAME === "TC.feature.Polyline") {
                result = self.addPolyline(feature);
            }
            else if (TC.feature.Polygon && feature instanceof TC.feature.Polygon || feature.CLASSNAME === "TC.feature.Polygon") {
                result = self.addPolygon(feature);
            }
            else if (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon || feature.CLASSNAME === "TC.feature.MultiPolygon") {
                result = self.addMultiPolygon(feature);
            }
            else if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline || feature.CLASSNAME === "TC.feature.MultiPolyline") {
                result = self.addMultiPolyline(feature);
            }
            else if (TC.feature.Circle && feature instanceof TC.feature.Circle || feature.CLASSNAME === "TC.feature.Circle") {
                result = self.addCircle(feature);
            }
            else {
                result = addFeaturesInternal(self, [feature])
            }
        }
        return result;
    };

    /**
     * Elimina una entidad geográfica de la capa.
     * @method removeFeature
     * @param {TC.Feature} feature 
     */
    layerProto.removeFeature = function (feature) {
        const self = this;
        if (feature.layer && self.features.indexOf(feature) >= 0) {
            if (self.map) {
                const popups = self.map.getControlsByClass('TC.control.Popup');
                popups.forEach(function (pu) {
                    if (pu.isVisible() && pu.currentFeature === feature) {
                        pu.hide();
                    }
                });

                const panels = self.map.getControlsByClass('TC.control.ResultsPanel');
                panels.forEach(function (p) {
                    if (p.isVisible() && p.currentFeature === feature) {
                        p.close();
                    }
                });
            }
            self.wrap.removeFeature(feature);
            feature.layer = null;
        }
    };

    layerProto.getFeatureById = function (id) {
        var result = null;
        var olFeat = this.wrap.getFeatureById(id);
        if (olFeat) {
            result = olFeat._wrap.parent;
        }
        return result;
    };

    /**
     * Borra todas las entidades geográficas de la capa.
     * @method clearFeatures
     */
    layerProto.clearFeatures = function () {
        var self = this;
        if (self.features && self.wrap) {
            if (self.map) {
                const popups = self.map.getControlsByClass('TC.control.Popup');
                popups.forEach(function (pu) {
                    if (pu.isVisible() && self.features.indexOf(pu.currentFeature) >= 0) {
                        pu.hide();
                    }
                });
            }
            self.features.length = 0;
            self.wrap.clearFeatures();
        }
    };

    layerProto.describeFeatureType = function (callback, error) {
        const self = this;
        const promise = new Promise(function (resolve, reject) {
            TC.ajax({
                url: self.wrap.getDescribeFeatureTypeUrl(),
                method: 'GET',
                responseType: TC.Consts.mimeType.XML
            })
                .then(function (data) {
                    var ns = 'http://www.w3.org/2001/XMLSchema';
                    var complexType = data.getElementsByTagNameNS(ns, 'complexType')[0];
                    if (complexType) {
                        var elements = complexType.getElementsByTagNameNS(ns, 'element');
                        var result = new Array(elements.length);
                        for (var i = 0, len = elements.length; i < len; i++) {
                            var element = elements[i];
                            result[i] = {
                                name: element.getAttribute('name'),
                                type: element.getAttribute('type'),
                                nillable: element.getAttribute('nillable') === 'true' ? true : false,
                                minOccurs: parseInt(element.getAttribute('minOccurs')),
                                maxOccurs: parseInt(element.getAttribute('maxOccurs'))
                            }
                        }
                        resolve(result);
                    }
                    else {
                        var exception = data.getElementsByTagName('Exception')[0];
                        if (exception) {
                            reject(exception.getElementsByTagName('ExceptionText')[0].innerHTML);
                        }
                    }
                })
                .catch(function (jqXHR, textStatus, errorThrown) {
                    reject(Error(errorThrown));
                });
        });
        promise.then(
            function (data) {
                if ($.isFunction(callback)) {
                    callback(data);
                }
            },
            function (errorText) {
                if ($.isFunction(error)) {
                    error(errorText);
                }
            }
        );
    };

    layerProto.import = function (options) {
        this.wrap.import(options);
    };

    layerProto.setNodeVisibility = function (id, visible) {
        var self = this;

        self.state = TC.Layer.state.LOADING;
        self.map.trigger(TC.Consts.event.BEFOREUPDATE);
        self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });

        if (!self.tree) {
            self.tree = self.getTree();
        }

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            self.setVisibility(visible);
        }
        else {
            var cache = self._cache.visibilityStates;
            cache[id] = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;

            var found = false;
            var i;
            var f;
            for (i = 0; i < self.features.length; i++) {
                f = self.features[i];
                if (f.id == id) {
                    found = true;
                    f.setVisibility(visible);
                    break;
                }
            }
            if (!found) {
                for (i = 0; i < self.features.length; i++) {
                    f = self.features[i];
                    if (f._path === undefined) {
                        f._path = '/' + f.getPath().join('/');
                    }
                    if (f._path === id) {
                        f.setVisibility(visible);
                    }
                }
            }
        }
        self.state = TC.Layer.state.IDLE;
        self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
        self.map.trigger(TC.Consts.event.UPDATE);
    };

    layerProto.getNodeVisibility = function (id) {
        var self = this;
        var result = TC.Layer.prototype.getNodeVisibility.call(self, id);
        if (!self.tree) {
            self.tree = self.getTree();
        }

        var node = self.findNode(id, self.tree);
        if (node === self.tree) {
            result = self.getVisibility() ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;
        }
        else {
            var cache = self._cache.visibilityStates;
            var r = cache[id];
            if (r !== undefined) {
                result = r;
            }
        }
        return result;
    };

    layerProto.setModifiable = function (modifiable) {
        this.wrap.setModifiable(modifiable);
    };

    layerProto.applyEdits = function (inserts, updates, deletes) {
        return this.wrap.sendTransaction(inserts, updates, deletes);
    };

    layerProto.refresh = function () {
        var self = this;
        return this.wrap.reloadSource();
    };

    layerProto.getFeaturesInCurrentExtent = function (tolerance) {
        var self = this;

        var extent = self.map.getExtent();
        return this.getFeaturesInExtent(extent, tolerance);
    };

    layerProto.getFeaturesInExtent = function (extent, tolerance) {
        return this.wrap.getFeaturesInExtent(extent, tolerance);
    };

    layerProto.setProjection = function (options) {
        const self = this;
        self.wrap.setProjection(options);
        if (options.crs && options.oldCrs) {
            self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });
            self.features.forEach(function (feat) {
                feat.wrap.setGeometry(TC.Util.reproject(feat.geometry, options.oldCrs, options.crs));
                feat.geometry = feat.wrap.getGeometry();
            });
            self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });
        }
    };
   

    

    layerProto.exportState = function (options) {
        const self = this;
        options = options || {};
        const lObj = {
            id: self.id
        };
        if (self.map && self.map.crs !== self.map.options.crs) {
            lObj.crs = self.map.crs;
        }

        // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado
        var precision = Math.pow(10, (self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) + 1);

        const features = options.features || self.features;
        lObj.features = features
            .map(function (f) {
                const fObj = {};
                var layerStyle;
                switch (true) {
                    case TC.feature.Marker && f instanceof TC.feature.Marker:
                        fObj.type = TC.Consts.geom.POINT;
                        layerStyle = self.options.styles && self.options.styles.marker;
                        break;
                    case TC.feature.Point && f instanceof TC.feature.Point:
                        fObj.type = TC.Consts.geom.POINT;
                        layerStyle = self.options.styles && self.options.styles.point;
                        break;
                    //case TC.feature.MultiPoint && f instanceof TC.feature.MultiPoint:
                    //    fObj.type = TC.Consts.geom.MULTIPOINT;
                    //    break;
                    case TC.feature.Polyline && f instanceof TC.feature.Polyline:
                        fObj.type = TC.Consts.geom.POLYLINE;
                        layerStyle = self.options.styles && self.options.styles.line;
                        break;
                    case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:
                        fObj.type = TC.Consts.geom.MULTIPOLYLINE;
                        layerStyle = self.options.styles && self.options.styles.line;
                        break;
                    case TC.feature.Polygon && f instanceof TC.feature.Polygon:
                        fObj.type = TC.Consts.geom.POLYGON;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    case TC.feature.MultiPolygon && f instanceof TC.feature.MultiPolygon:
                        fObj.type = TC.Consts.geom.MULTIPOLYGON;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    case TC.feature.Circle && f instanceof TC.feature.Circle:
                        fObj.type = TC.Consts.geom.CIRCLE;
                        layerStyle = self.options.styles && self.options.styles.polygon;
                        break;
                    default:
                        break;
                }
                fObj.id = f.id;
                fObj.geom = TC.Util.compactGeometry(f.geometry, precision);
                fObj.data = f.getData();
                fObj.showsPopup = f.showsPopup;
                if (options.exportStyles === undefined || options.exportStyles) {
                    layerStyle = $.extend({}, layerStyle);
                    for (var key in layerStyle) {
                        var val = layerStyle[key];
                        if ($.isFunction(val)) {
                            layerStyle[key] = val(f);
                        }
                    }
                    fObj.style = $.extend(layerStyle, f.getStyle());
                }
                return fObj;
            });
        return lObj;
    };
    

    layerProto.importState = function (obj) {
        const self = this;
        return new Promise(function (resolve, reject) {
            const promises = new Array(obj.features.length);
            obj.features.forEach(function (f, idx) {
                const featureOptions = $.extend(f.style, { data: f.data, id: f.id, showsPopup: f.showsPopup });
                var addFn;
                switch (f.type) {
                    case TC.Consts.geom.POLYGON:
                        addFn = self.addPolygon;
                        break;
                    case TC.Consts.geom.MULTIPOLYGON:
                        addFn = self.addMultiPolygon;
                        break;
                    case TC.Consts.geom.POLYLINE:
                        addFn = self.addPolyline;
                        break;
                    case TC.Consts.geom.MULTIPOLYLINE:
                        addFn = self.addMultiPolyline;
                        break;
                    case TC.Consts.geom.CIRCLE:
                        addFn = self.addCircle;
                        break;
                    case TC.Consts.geom.POINT:
                        if (f.style && (f.style.url || f.style.className)) {
                            addFn = self.addMarker;
                        }
                        else {
                            addFn = self.addPoint;
                        }
                        break;
                    default:
                        break;
                }
                if (addFn) {
                    var geom = TC.Util.explodeGeometry(f.geom);
                    if (obj.crs && self.map.crs !== obj.crs) {
                        promises[idx] = new Promise(function (res, rej) {
                            self.map.one(TC.Consts.event.PROJECTIONCHANGE, function (e) {
                                addFn.call(self, geom, featureOptions).then(
                                    function () {
                                        res();
                                    },
                                    function () {
                                        rej();
                                    }
                                );
                            });
                        });
                    }
                    else {
                        promises[idx] = addFn.call(self, geom, featureOptions);
                    }
                }
            });
            Promise.all(promises).then(
                function () {
                    resolve();
                },
                function (err) {
                    reject(err instanceof Error ? err : Error(err));
                });
        });
    };
})();
﻿/*	This work is licensed under Creative Commons GNU LGPL License.

	License: http://creativecommons.org/licenses/LGPL/2.1/
   Version: 0.9
	Author:  Stefan Goessner/2006
	Web:     http://goessner.net/ 
*/
function xml2json(e) { var n = { toObj: function (e) { var t = {}; if (1 == e.nodeType) { if (e.attributes.length) for (var i = 0; i < e.attributes.length; i++) "name" !== e.attributes[i].nodeName && (t[e.attributes[i].nodeName] = (e.attributes[i].nodeValue || "").toString()); if (e.firstChild) { for (var r = 0, o = 0, l = !1, a = e.firstChild; a; a = a.nextSibling) 1 == a.nodeType ? l = !0 : 3 == a.nodeType && a.nodeValue.match(/[^ \f\n\r\t\v]/) ? r++ : 4 == a.nodeType && o++; if (l) if (2 > r && 2 > o) { n.removeWhite(e); for (var a = e.firstChild; a; a = a.nextSibling) { var s = n.removePrefix(a.nodeName); if (3 == a.nodeType) t["#text"] = n.escape(a.nodeValue); else if (4 == a.nodeType) t["#cdata"] = n.escape(a.nodeValue); else if (t[s]) t[s] instanceof Array ? t[s][t[s].length] = n.toObj(a) : t[s] = [t[s], n.toObj(a)]; else { var f = null; a.attributes.getNamedItem("name") && (f = a.attributes.getNamedItem("name").nodeValue), t[f ? f : s] = n.toObj(a) } } } else e.attributes.length ? t["#text"] = n.escape(n.innerXml(e)) : t = n.escape(n.innerXml(e)); else if (r) e.attributes.length ? t["#text"] = n.escape(n.innerXml(e)) : t = n.escape(n.innerXml(e)); else if (o) if (o > 1) t = n.escape(n.innerXml(e)); else for (var a = e.firstChild; a; a = a.nextSibling) t["#cdata"] = n.escape(a.nodeValue) } e.attributes.length || e.firstChild || (t = null) } else 9 == e.nodeType ? t = n.toObj(e.documentElement) : 8 == e.nodeType ? console.log(e.textContent) : alert("unhandled node type: " + e.nodeType); return t }, toJson: function (e, t, i) { var r = t ? '"' + t + '"' : ""; if (e instanceof Array) { for (var o = 0, l = e.length; l > o; o++) e[o] = n.toJson(e[o], "", i + "	"); r += (t ? ":[" : "[") + (e.length > 1 ? "\n" + i + "	" + e.join(",\n" + i + "	") + "\n" + i : e.join("")) + "]" } else if (null == e) r += (t && ":") + "null"; else if ("object" == typeof e) { var a = []; for (var s in e) a[a.length] = n.toJson(e[s], s, i + "	"); r += (t ? ":{" : "{") + (a.length > 1 ? "\n" + i + "	" + a.join(",\n" + i + "	") + "\n" + i : a.join("")) + "}" } else r += "string" == typeof e ? (t && ":") + '"' + e.toString() + '"' : (t && ":") + e.toString(); return r }, innerXml: function (e) { var n = ""; if ("innerHTML" in e) n = e.innerHTML; else for (var t = function (e) { var n = ""; if (1 == e.nodeType) { n += "<" + e.nodeName; for (var i = 0; i < e.attributes.length; i++) n += " " + e.attributes[i].nodeName + '="' + (e.attributes[i].nodeValue || "").toString() + '"'; if (e.firstChild) { n += ">"; for (var r = e.firstChild; r; r = r.nextSibling) n += t(r); n += "</" + e.nodeName + ">" } else n += "/>" } else 3 == e.nodeType ? n += e.nodeValue : 4 == e.nodeType && (n += "<![CDATA[" + e.nodeValue + "]]>"); return n }, i = e.firstChild; i; i = i.nextSibling) n += t(i); return n }, escape: function (e) { return e.replace(/[\\]/g, "\\\\").replace(/[\"]/g, '\\"').replace(/[\n]/g, "\\n").replace(/[\r]/g, "\\r") }, removeWhite: function (e) { e.normalize(); for (var t = e.firstChild; t;) if (3 == t.nodeType) if (t.nodeValue.match(/[^ \f\n\r\t\v]/)) t = t.nextSibling; else { var i = t.nextSibling; e.removeChild(t), t = i } else 1 == t.nodeType ? (n.removeWhite(t), t = t.nextSibling) : t = t.nextSibling; return e }, removePrefix: function (e) { return e.substring(e.indexOf(":") + 1) } }; return 9 == e.nodeType && (e = e.documentElement), n.toObj(n.removeWhite(e)) }

var WFSCapabilities = function () { var e = { V1_0_0: "1.0.0", V1_1_0: "1.1.0", V2_0_0: "2.0.0" }, r = function () { var r, n = [], u = [], p = [], _ = xml2json(arguments[0]); switch (_.version) { case e.V1_0_0: r = e.V1_0_0; break; case e.V1_1_0: r = e.V1_1_0; break; case e.V2_0_0: r = e.V2_0_0 } n = t(_, r), u = a(_, r), p = i(_, r); var o = s(_, r), l = { Operations: n, FeatureTypes: u, Filters: p }; return $.extend(l, o), l }, t = function (r, t) { switch (t) { case e.V1_0_0: var a = r.Capability.Request; if (a.GetFeature) { var i = []; for (var s in a.GetFeature.ResultFormat) i.push(s.toLowerCase()); a.GetFeature.outputFormat = i, delete a.GetFeature.ResultFormat, a.GetFeature.Operations = r.FeatureTypeList.Operations } return a; case e.V1_1_0: return {}; case e.V2_0_0: var n = {}; for (var s in r.OperationsMetadata) { var u = {}; u[s] = r.OperationsMetadata[s]; for (var p in u[s]) u[s][p] && u[s][p].hasOwnProperty("AllowedValues") && (u[s][p] = u[s][p].AllowedValues.Value); $.extend(n, u) } return n } return null }, a = function (r, t) { switch (t) { case e.V1_0_0: for (var a = {}, i = 0; i < r.FeatureTypeList.FeatureType.length; i++) { var s = r.FeatureTypeList.FeatureType[i].Name; a[s.substring(s.indexOf(":") + 1)] = r.FeatureTypeList.FeatureType[i] } return a; case e.V1_1_0: return {}; case e.V2_0_0: for (var a = {}, i = 0; i < r.FeatureTypeList.FeatureType.length; i++) { var s = r.FeatureTypeList.FeatureType[i].Name; a[s.substring(s.indexOf(":") + 1)] = r.FeatureTypeList.FeatureType[i] } return a } return null }, i = function (r, t) { switch (t) { case e.V1_0_0: return r.Filter_Capabilities; case e.V1_1_0: return {}; case e.V2_0_0: var a = r.Filter_Capabilities; return a } return null }, s = function (r, t) { switch (t) { case e.V1_0_0: var a = {}; for (var i in r) "string" == typeof r[i] && (a[i] = r[i]); return a; case e.V1_1_0: return {}; case e.V2_0_0: var a = {}; for (var i in r) "string" == typeof r[i] && (a[i] = r[i]); return a } return {} }, n = function (e) { var e = e, t = e.substring(e.indexOf("://") < 0 ? 0 : e.indexOf("://") + 3); if (TC.capabilities[t]) return Promise.resolve(TC.capabilities[t]); var a = {}; return a.SERVICE = "WFS", a.VERSION = "2.0.0", a.REQUEST = "GetCapabilities", new Promise(function (x, y) { TC.ajax({ url: TC.proxify(e) + "?" + $.param(a), method: "GET" }).then(function () { var e = WFSCapabilities.Parse(arguments[0]), a = e.Operations.GetCapabilities.DCP && e.Operations.GetCapabilities.DCP.HTTP.Get["xlink:href"] || e.Operations.GetCapabilities.DCPType[0].HTTP.Get.onlineResource; TC.capabilities[a] = e, TC.capabilities[t] = e, x(WFSCapabilities.Parse(arguments[0])) }) }) }; return { Promises: n, Parse: r } }();
﻿; var TC = TC || {};
(function (root, factory) {
    if (typeof exports === "object") { // CommonJS
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) { // AMD
        define([], factory);
    } else {
        root.Geometry = factory();
    }
})(TC, function () {
        const Geometry = {
            isPoint: function (geometry) {
                return $.isArray(geometry) && geometry.length >= 2 && typeof geometry[0] === 'number' && typeof geometry[1] === 'number';
            },
            isRing: function (geometry) {
                return $.isArray(geometry) && (geometry.length === 0 || Geometry.isPoint(geometry[0]));
            },
            isRingCollection: function (geometry) {
                return $.isArray(geometry) && (geometry.length === 0 || Geometry.isRing(geometry[0]));
            },
            isMultiRingCollection: function (geometry) {
                return $.isArray(geometry) && (geometry.length === 0 || Geometry.isRingCollection(geometry[0]));
            },
            getNearest: function getNearest(point, candidates) {
                return TC.wrap.Geometry.getNearest(point, candidates);
            },
            isInside: function isInside(point, ring) {
                var result = false;
                if (Geometry.isPoint(point)) {
                    if (Geometry.isPoint(ring)) {
                        result = point[0] === ring[0] && point[1] === ring[1];
                    }
                    else if (Geometry.isRing(ring)) {
                        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                            var xi = ring[i][0], yi = ring[i][1];
                            var xj = ring[j][0], yj = ring[j][1];

                            var intersect = ((yi > point[1]) != (yj > point[1]))
                                && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                            if (intersect) result = !result;
                        }
                    }
                    else if (Geometry.isRingCollection(ring) && ring.length > 0) {
                        // polígono con agujeros
                        // miramos si está en el polígono exterior
                        if (isInside(point, ring[0])) {
                            var insideHole = false;
                            // miramos si está en un agujero
                            for (var i = 1; i < ring.length; i++) {
                                if (isInside(point, ring[i])) {
                                    insideHole = true;
                                    break;
                                }
                            }
                            if (!insideHole) {
                                result = true;
                            }
                        }
                    }
                    else if (Geometry.isMultiRingCollection(ring) && ring.length > 0) {
                        // multipolígono
                        // miramos si está en alguno de los polígonos
                        for (var i = 0, len = ring.length; i < len; i++) {
                            if (isInside(point, ring[i])) {
                                result = true;
                                break;
                            }
                        }
                    }
                }
                return result;
            }
        };
        return Geometry;
    });
﻿

/**
Para crear la interfaz de usuario, la API SITNA dibuja en la página una gran cantidad de elementos HTML. Para marcarlos como elementos de la
interfaz de usuario de los objetos de la API SITNA, se les añade una serie de clases CSS con un nombre convenido, de forma que es fácil modificar
el aspecto de los controles de la API mediante reglas CSS, e identificar elementos de interfaz mediante selectores CSS.

El nombre de las clases CSS usadas en la API SITNA es sistemático: todas empiezan con el prefijo `tc-`, y si un elemento está anidado dentro de otro,
generalmente su nombre empieza con el nombre del elemento padre (p.e. el elemento con la clase `tc-ctl-lcat-search` está dentro del elemento
con la clase `tc-ctl-lcat`). Esta no es una regla estricta, porque ciertos elementos son muy genéricos y tienen un nombre más sencillo
(p. e., dentro de un elemento con clase `tc-ctl-lcat` existe un elemento con clase `tc-textbox`, que se utiliza para dar estilo a todas las cajas
de texto de la API SITNA).

Aparte de las clases CSS que definen elementos de la interfaz de usuario, hay otras clases CSS que definen estados de elementos que son relevantes
desde el punto de vista de esa interfaz (p. e., el elemento está oculto, o es un nodo de un árbol que está replegado, o es una herramienta que está
activa).

En general, cualquier cambio de estado en la interfaz de usuario se define añadiendo o quitando clases de este tipo a elementos HTML de la aplicación
(p. e., si un elemento debe ocultarse de la interfaz, en vez de ponerle una regla de estilo `display:none` la API le añade la clase `tc-hidden`).

Para comprobar la estructura de elementos HTML y clases CSS de los controles de la API SITNA puede consultar el siguiente
[ejemplo](../../examples/CSS.html).

@module 3. Clases CSS
 */
/**
A continuación se describen todas las clases CSS que definen la estructura y/o afectan el comportamiento y aspecto del control
{{#crossLink "SITNA.cfg.MapControlOptions/layerCatalog:property"}}{{/crossLink}}.

## Clases que definen elementos de interfaz

| Clase CSS | Función que desempeña el elemento que tiene la clase |
|-----------|------------------------------------------------------|
| `tc-map` | Interfaz de una instancia de la clase SITNA.Map. Generalmente un `<div>`, es el elemento cuyo id se pasa como parámetro al constructor de la clase SITNA.Map. En él se dibuja el viewport del mapa y todos los elementos del layout. |
| `tc-ctl` | Interfaz de un control. Los controles se renderizan en un elemento definido por la opción div de la configuración propia del control. |
| `tc-ctl-lcat` | Interfaz del control layerCatalog. |
| `tc-ctl-lcat-search` | Parte de la interfaz que contiene el buscador de capas disponibles, con su cuadro de texto y su lista de resultados. |
| `tc-group` | Un elemento de interfaz que contiene un grupo de subelementos. |
| `tc-ctl-lcat-input` | Un elemento de introducción de texto en el control layerCatalog. |
| `tc-textbox` | Un elemento de introducción de texto de un control. |
| `tc-ctl-lcat-search-group` | En los resultados de búsqueda de capas, el conjunto de resultados que se corresponden con uno de los nodos raíz del árbol de capas disponibles. En la práctica, suele ser el conjunto de resultados de búsqueda de uno de los servicios WMS que tenemos añadidos al catálogo. |
| `tc-ctl-lcat-search-btn-info` | Botón junto al nombre de la capa que nos abre el panel de información adicional de la capa. |
| `tc-ctl-lcat-tree` | Elemento donde se muestra el árbol de capas disponibles. |
| `tc-ctl-lcat-branch` | Lista de nodos del árbol de capas disponibles. |
| `tc-ctl-lcat-node` | Nodo del árbol de capas disponibles. |
| `tc-ctl-lcat-info` | Panel que muestra información adicional de la capa (descripción, enlaces a metadatos) |
| `tc-ctl-lcat-info-close` | Botón para cerrar el panel de información adicional de la capa |
| `tc-ctl-lcat-title` | En el panel de información adicional de la capa, título de la capa |
| `tc-ctl-lcat-abstract` | Texto descriptivo de la capa. |
| `tc-ctl-lcat-metadata` | Sección con los enlaces a los metadatos de la capa. |

## Clases que definen estados

| Clase CSS | Función que desempeña el elemento que tiene la clase |
|-----------|------------------------------------------------------|
| `tc-collapsed` | Un elemento desplegable de la interfaz (por ejemplo, una rama del árbol de capas disponibles) está replegado. |
| `tc-checked` | En un nodo de capas disponibles, indica que la capa ya está añadida. |
| `tc-hidden` | El elemento está oculto a la vista del usuario. |
| `tc-selectable` | El elemento corresponde a una capa que es elegible para ser añadida al mapa. |
| `tc-loading` | El elemento es un nodo del árbol o de los resultados de búsqueda que ha sido seleccionado por el usuario para añadirse al mapa, pero la carga de la capa en el mapa no ha terminado todavía. |
| `tc-active` | Elemento biestado que está activo. Por ejemplo, el botón del idioma en el que está el visor actualmente. |
  
#### Ejemplo:

```javascript
   <div id="catalog" class="tc-ctl tc-ctl-lcat">
     <h2>Capas disponibles<button class="tc-ctl-lcat-btn-search" title="Buscar capas por texto"></button></h2>
     <div class="tc-ctl-lcat-search tc-hidden tc-collapsed">
       <div class="tc-group"><input type="search" class="tc-ctl-lcat-input tc-textbox" placeholder="Texto para buscar en las capas"></div>
       <ul></ul>
     </div>
     <div class="tc-ctl-lcat-tree">
       <ul class="tc-ctl-lcat-branch">
         <li class="tc-ctl-lcat-node" data-tc-layer-name="" data-tc-layer-uid="10"><span>IDENA</span>
           <ul class="tc-ctl-lcat-branch">
             <li class="tc-ctl-lcat-node tc-collapsed" data-tc-layer-name="nombresGeograficos" data-tc-layer-uid="656"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Nombres geográficos</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed">
                 <li class="tc-ctl-lcat-node tc-collapsed" data-tc-layer-name="IDENA:toponimia" data-tc-layer-uid="657"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Toponimia</span><button class="tc-ctl-lcat-btn-info"></button>
                   <ul class="tc-ctl-lcat-branch tc-collapsed">
                     <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-tc-layer-name="IDENA:TOPONI_Txt_Toponimos" data-tc-layer-uid="658"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Nombres de lugar (topónimos)</span><button class="tc-ctl-lcat-btn-info"></button>
                       <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
                     </li>
                   </ul>
                 </li>
               </ul>
             </li>
           </ul>
         </li>
         <li class="tc-ctl-lcat-node tc-collapsed" data-tc-layer-name="" data-tc-layer-uid="962"><span>IGN - Unidades administrativas</span>
           <ul class="tc-ctl-lcat-branch tc-collapsed">
             <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-tc-layer-name="AU.AdministrativeBoundary" data-tc-layer-uid="963"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Límite administrativo</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
             </li>
             <li class="tc-ctl-lcat-node tc-ctl-lcat-leaf" data-tc-layer-name="AU.AdministrativeUnit" data-tc-layer-uid="964"><span data-tooltip="Pulse para añadir al mapa" class="tc-selectable">Unidad administrativa</span><button class="tc-ctl-lcat-btn-info"></button>
               <ul class="tc-ctl-lcat-branch tc-collapsed"></ul>
             </li>
           </ul>
         </li>
       </ul>
     </div>
     <div class="tc-ctl-lcat-info tc-hidden"><a class="tc-ctl-lcat-info-close"></a>
       <h2>Información de capa</h2>
       <h3 class="tc-ctl-lcat-title"></h3>
     </div>
   </div>
    ```


@module 3. Clases CSS
@submodule 3.1. layerCatalog
 */

/**
### 1.6.0

- Añadida capacidad de compartir las entidades vectoriales existentes en el mapa.
- Cambiada interfaz de usuario del control de información del mapa.
- Corrección de errores.

### 1.5.1

- Cambiada la interfaz de usuario del control de mapas de fondo para mostrar una preselección de mapas.
- Corrección de errores.

### 1.5.0

- Añadido el control de catálogo de capas.
- Añadido el control de administración de capas de trabajo.
- Añadido el control para añadir datos geográficos externos.
- Añadido el control de impresión de mapas en PDF.
- Las capas de tipo VECTOR soportan más formatos de archivos geográficos.
- Se ha eliminado la limitación de extensión máxima por defecto del mapa.
- Corrección de errores.

### 1.4.0

- Añadida la capacidad de cambiar la proyección del mapa.
- Añadidos mapas de fondo de OpenStreetMap, Carto y Mapbox.
- Mejora de soporte a peticiones CORS.
- Corrección de errores.

### 1.3.0

- Añadida opción de clustering para capas de puntos.
- Añadido soporte multiidioma.
- El control de búsqueda soporta nuevos tipos de búsqueda: vías, direcciones postales y parcelas catastrales.
- Mejora de soporte a peticiones CORS.
- Corrección de errores.

### 1.2.2

- Actualización a OpenLayers 4.
- Corrección de errores.

### 1.2.1

- Corrección de errores.

### 1.2.0

- Añadida la capacidad de exportar el mapa a una imagen.
- Añadido a la documentación ejemplo de exportación de imagen.
- El control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}} permite compartir entidades geográficas o descargarlas en distintos formatos.
- Corrección de errores.

### 1.1.3

- Añadidos a la clase {{#crossLink "SITNA.Map"}}{{/crossLink}} métodos de consulta y visualización de entidades geográficas.
- Añadidos ejemplos a la documentación para los métodos anteriores.
- Mejorada la interfaz del control de búsquedas añadiendo a los resultados distinción por tipo.
- Añadido registro centralizado de errores JavaScript.
- Corrección de errores.

### 1.1.2

- El control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}} pasa a estar incluido por defecto en el mapa.
- La [página de incrustación de visores con KML](//sitna.tracasa.es/kml/) pasa a usar OpenLayers 3.
- Correción de errores de la [página de incrustación de visores con KML](//sitna.tracasa.es/kml/).
- Añadido ejemplo a la documentación de {{#crossLink "SITNA.cfg.ClickOptions"}}{{/crossLink}}.
- Añadido ejemplo a la documentación de {{#crossLink "SITNA.cfg.CoordinatesOptions"}}{{/crossLink}}.
- Mejorada con botones triestado la usabilidad del control de medición.
- Añadido indicador de carga de los elementos del visor.
- Añadido registro centralizado de errores JavaScript.
- Corrección de errores.

### 1.1.1

- Añadido el control de Google StreetView ({{#crossLink "SITNA.cfg.MapControlOptions/streetView:property"}}{{/crossLink}}).
- Añadido el control de gestión de clics en el mapa ({{#crossLink "SITNA.cfg.MapControlOptions/click:property"}}{{/crossLink}}).
- Añadidas [opciones](./classes/SITNA.cfg.CoordinatesOptions.html) de representación de coordenadas en el control {{#crossLink "SITNA.cfg.MapControlOptions/coordinates:property"}}{{/crossLink}}.
- Compatibilidad mejorada con dispositivos móviles.
- Mejoras de rendimiento en el layout por defecto.
- Mejoras en la documentación.
- Corrección de errores.

### 1.1.0

- Mejoras en el control {{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}}: visualización de geometrías
 de las entidades geográficas, bocadillo arrastrable.
- Se retira el soporte a OpenLayers 2.
- Corrección de errores.

### 1.0.6

- Añadido el control de información de entidades basado en la petición `getFeatureInfo` de WMS, activable con la opción
 SITNA.cfg.MapControlOptions.{{#crossLink "SITNA.cfg.MapControlOptions/featureInfo:property"}}{{/crossLink}}.
- Añadidas las opciones de zoom al método SITNA.Map.{{#crossLink "SITNA.Map/zoomToMarkers:method"}}{{/crossLink}}: radio del
 área alrededor del marcador a mostrar y margen a dejar en los bordes.
- Corregido error en el layout por defecto que impedía la funcionalidad de deslizar dedo para colapsar paneles.

### 1.0.5

- Corregido error que impedía en ver en la tabla de contenidos si una capa cargada es visible a la escala actual.
- Corregido error que impedía que se pudieran ocultar desde la tabla de contenidos todas las entidades de una capa KML.
- Correcciones de estilo en Internet Explorer.
- Eliminada la necesidad de que el mapa de situación tenga un mapa de fondo de los disponibles en el mapa principal.
- Cambios menores del estilo por defecto.

### 1.0.4

- Añadidas etiquetas `form` en el HTML de la tabla de contenidos.
- Añadida compatibilidad con OpenLayers 3.
- Actualizada para la maquetación por defecto la fuente [FontAwesome](http://fortawesome.github.io/Font-Awesome/) a la versión 4.3.0.
- La leyenda ahora oculta los servicios que no tienen capas visibles.
- Cambios en el estilo por defecto.
- Corrección de errores.

### 1.0.3

- Añadida la opción de deshabilitar el zoom en el mapa con la rueda de ratón mediante la propiedad SITNA.Cfg.{{#crossLink "SITNA.Cfg/mousewWheelZoom:property"}}{{/crossLink}}.
- Añadida la posibilidad de mostrar un marcador con su bocadillo de información asociada visible por defecto, mediante la propiedad SITNA.cfg.MarkerOptions.{{#crossLink "SITNA.cfg.MarkerOptions/showPopup:property"}}{{/crossLink}}.
- Corrección de errores.

### 1.0

- Despliegue inicial.

@module 4. Historial de cambios
 */

var SITNA = window.SITNA || {};
var TC = window.TC || {};
TC.isDebug = true;

(function () {
    if (!window.TC || !window.TC.Cfg) {
        var script;
        if (document.currentScript) {
            script = document.currentScript;
        }
        else {
            var scripts = document.getElementsByTagName('script');
            script = scripts[scripts.length - 1];
        }
        var src = script.getAttribute('src');
        TC.apiLocation = src.substr(0, src.lastIndexOf('/') + 1);
        var url = TC.apiLocation + (TC.isDebug ? 'tcmap.js' : 'tcmap.min.js');
        var req = new XMLHttpRequest();
        req.open("GET", url, false); // 'false': synchronous.
        req.send(null);

        var head = document.getElementsByTagName("head")[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.text = req.responseText;
        head.appendChild(script);
    }
})();

/**
La dirección principal de acceso a la API es **[//sitna.tracasa.es/api/](//sitna.tracasa.es/api/)**. No obstante, hay otras direcciones disponibles para
otras necesidades concretas:

- Lógica de la API compilada en un solo archivo:
  + OpenLayers 4 como motor, minimizada: [//sitna.tracasa.es/api/sitna.ol.min.js](//sitna.tracasa.es/api/sitna.ol.min.js).
  + OpenLayers 4 como motor, sin minimizar: [//sitna.tracasa.es/api/sitna.ol.debug.js](//sitna.tracasa.es/api/sitna.ol.debug.js).
  + OpenLayers 2 como motor, minimizada: [//sitna.tracasa.es/api/sitna.ol2.min.js](//sitna.tracasa.es/api/sitna.ol2.min.js).
  + OpenLayers 2 como motor, sin minimizar: [//sitna.tracasa.es/api/sitna.ol2.debug.js](//sitna.tracasa.es/api/sitna.ol2.debug.js).

- Lógica de la API repartida en varios archivos que se solicitan bajo demanda. En este caso se utiliza OpenLayers 4 como motor a no ser que el navegador sea incompatible,
 en cuyo caso será OpenLayers 2:
  + Minimizada: [//sitna.tracasa.es/api/sitna.min.js](//sitna.tracasa.es/api/sitna.min.js).
  + Sin minimizar: [//sitna.tracasa.es/api/sitna.js](//sitna.tracasa.es/api/sitna.js).

_Aviso: a las opciones basadas en OpenLayers 2 se les ha retirado el soporte desde la versión 1.1.0 de la API SITNA._

@module 1. Direcciones de la API
 */


/**
La configuración por defecto de {{#crossLink "SITNA.cfg.SearchOptions"}}{{/crossLink}} tiene como origen de datos el WFS de IDENA. Es posible establecer un origen de datos distinto en el que consultar, para ello en lugar de indicar un booleano, que activa o desactiva la búsqueda, se indicará un objeto con las propiedades a sobrescribir. Las propiedades a sobrescribir no siempre serán las mismas, variarán en función de la configuración que tenga la búsqueda que se quiera modificar.


@module 2.3. Objeto de configuración global
@submodule 2.3.1. Objeto de configuración de opciones del buscador
 */

/**
  Opciones de configuración del origen de datos de la búsqueda de direcciones postales.

  Esta clase no tiene constructor.
  
  Puede consultar el ejemplo [online](../../examples/Cfg.SearchPostalAddressSource.html). 
  #### Ejemplo:

  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Txt_Portal',
        dataIdProperty: ['CMUNICIPIO', 'CENTIDADC', 'CVIA', 'PORTAL'],
        queryProperties: {
            firstQueryWord: ['ENTIDADC', 'ENTINOAC'],
            secondQueryWord: ['VIA', 'VIANOAC'],
            thirdQueryWord: ['PORTAL']
        },
        suggestionListHead: {
            label: "search.list.number",
            color: "fontColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'PORTAL', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1} {2}, {0}',
        styles: [
            {
                point: {
                    radius: 0,
                    label: "PORTAL",
                    angle: "CADANGLE",
                    fontColor: "#CB0000",
                    fontSize: 14,
                    labelOutlineColor: "#FFFFFF",
                    labelOutlineWidth: 4
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchPostalAddressSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).  
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de direcciones postales. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la entidad de población.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la vía.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/thirdQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el número de portal.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la dirección postal.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a la dirección postal. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputProperties:property"}}{{/crossLink}} como `[EntidadPoblacion, Via, Numero]` y {{#crossLink "SITNA.cfg.SearchPostalAddressSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1} {2}, {0}”` mostrará en la lista resultados del tipo: <em>Calle Estafeta 13, Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchPostalAddressSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de parcelas catastrales.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchCadastralSource.html). 
  #### Ejemplo:

  ```javascript
  {   
    url:'//idena.navarra.es/ogc/wfs',                
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',        
        featureType: ['CATAST_Pol_ParcelaUrba', 'CATAST_Pol_ParcelaRusti', 'CATAST_Pol_ParcelaMixta'],
        municipality: {
            featureType: 'CATAST_Pol_Municipio',
            labelProperty: 'MUNICIPIO',
            idProperty: 'CMUNICIPIO'
        },
        queryProperties: {
            firstQueryWord: 'CMUNICIPIO',
            secondQueryWord: 'POLIGONO',
            thirdQueryWord: 'PARCELA'
        },
        suggestionListHead: {
            label: "search.list.cadastral",
            color: [
                {
                    CATAST_Pol_ParcelaUrba: {
                        title: "search.list.cadastral.urban",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaRusti: {
                        title: "search.list.cadastral.rustic",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                },
                {
                    CATAST_Pol_ParcelaMixta: {
                        title: "search.list.cadastral.mixed",
                        color: {
                            geomType: "polygon",
                            css: "strokeColor"
                        }
                    }
                }
            ]
        },
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#136278',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#0c8b3d',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            },
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#e5475f',
                    strokeWidth: 2,
                    strokeOpacity: 1
                },
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchCadastralSource
  @static
 */

/**
  Definición de la fuente de datos para la búsqueda de parcela por nombre de municipio en lugar de por código del mismo.
  @property municipality
  @type SITNA.cfg.SearchCadastralSourceExt
  @required
*/

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs").
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchCadastralSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de parcelas. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el código de municipio.</pre>
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el polígono.</pre>
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/thirdQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar la parcela. </pre>
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la parcela catastral.
  @property geometryName
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}.
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchCadastralSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchCadastralSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de municipios.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchMunicipalitySource.html). 
  #### Ejemplo:

  ```javascript
  {
    url:'//idena.navarra.es/ogc/wfs',        
        url: '//idena.navarra.es/ogc/wfs',
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'CATAST_Pol_Municipio',
        dataIdProperty: ['CMUNICIPIO'],
        queryProperties: {
            firstQueryWord: ['MUNINOAC', 'MUNICIPIO']
        },
        suggestionListHead: {
            label: "search.list.municipality",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO'],
        outputFormatLabel: '{0}',        
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#fe06a5',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchMunicipalitySource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace). 
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de municipios. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre del municipio.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría del municipio.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un municipio. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputProperties:property"}}{{/crossLink}} como `[NombreMunicipio]` y {{#crossLink "SITNA.cfg.SearchMunicipalitySource/outputFormatLabel:property"}}{{/crossLink}} como `“{0}”` mostrará en la lista resultados del tipo: <em>Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
  
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchMunicipalitySource/featureType:property"}}{{/crossLink}}.  
  
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}. 
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de cascos urbanos.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchTownSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        featureType: 'ESTADI_Pol_EntidadPob',        
        dataIdProperty: ['CMUNICIPIO', 'CENTIDAD'],        
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDAD']
        },
        suggestionListHead: {
            label: "search.list.urban",
            color: "strokeColor"
        },
        outputProperties: ['MUNICIPIO', 'ENTIDAD'],
        outputFormatLabel: '{1} ({0})',        
        styles: [
            {
                polygon: {
                    fillColor: '#000000',
                    fillOpacity: 0.1,
                    strokeColor: '#feba1e',
                    strokeWidth: 2,
                    strokeOpacity: 1
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchTownSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace). 
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchTownSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Definición de los campos por los que filtrar la búsqueda de cascos urbanos. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre del casco urbano.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría del casco urbano.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a un casco urbano. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchTownSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchTownSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchTownSource/outputProperties:property"}}{{/crossLink}} como `[NombreMunicipio, NombreCascoUrbano]` y {{#crossLink "SITNA.cfg.SearchTownSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1} ({0})”` mostrará en la lista resultados del tipo: <em>Salinas de Pamplona (Galar)</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en la colección en {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchTownSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como capas definidas en {{#crossLink "SITNA.cfg.SearchTownSource/featureType:property"}}{{/crossLink}}.  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Opciones de configuración del origen de datos de la búsqueda de vías.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchStreetSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//idena.navarra.es/ogc/wfs',        
        featurePrefix: 'IDENA',
        geometryName: 'the_geom',
        renderFeatureType: 'CATAST_Txt_Calle',
        featureType: 'CATAST_Lin_CalleEje',
        dataIdProperty: ['CVIA'],        
        queryProperties: {
            firstQueryWord: ['ENTINOAC', 'ENTIDADC'],
            secondQueryWord: ['VIA', 'VIANOAC']
        },
        suggestionListHead: {
            label: "search.list.street",
            color: "strokeColor"
        },
        outputProperties: ['ENTIDADC', 'VIA', 'CVIA', 'CENTIDADC', 'CMUNICIPIO'],
        outputFormatLabel: '{1}, {0}',
        styles: [
            {
                line: {
                    strokeColor: "#CB0000",
                    strokeOpacity: 1,
                    strokeWidth: 2,
                    strokeLinecap: "round",
                    strokeDashstyle: "solid"
                }
            },
            {
                point: {
                    label: "VIA",
                    angle: "CADANGLE",
                    fontColor: "#000000",
                    fontSize: 7,
                    labelOutlineColor: "#ffffff",
                    labelOutlineWidth: 2
                }
            }
        ]
  }
  ``` 
  @class SITNA.cfg.SearchStreetSource
  @static
 */

/**
  Dirección del servicio WFS (las búsquedas en el API SITNA están implementadas sobre el estándar [OGC Web Feature Service](http://www.opengeospatial.org/standards/wfs).
  @property url
  @type String 
 */

/**
  Prefijo del nombre de la capa o capas a definir en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}. En caso de ser un WFS de GeoServer, se trata del nombre del espacio de trabajo (workspace).  
  @property featurePrefix
  @type String
 */

/**
  Colección con el nombre de la capa o capas a consultar. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/queryProperties:property"}}{{/crossLink}}.
  @property featureType
  @type Array
*/

/**
  Colección con los nombres de las capas auxiliares a añadir al resultado de la búsqueda en el mapa. Es posible indicar más de una capa si todas ellas cuentan con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/dataIdProperty:property"}}{{/crossLink}}.
   
No se muestran sugerencias en base a las capas auxiliares, únicamente se añade información en el momento de pintar en el mapa, es por ello que debe existir relación en los datos entre las capas definidas en {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}} y que ambas cuenten con los campos definidos en {{#crossLink "SITNA.cfg.SearchStreetSource/dataIdProperty:property"}}{{/crossLink}}. 
  @property renderFeatureType
  @type Array
  @optional
*/

/**
  Definición de los campos por los que filtrar la búsqueda de vías. 
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la entidad de población.</pre>  
  <pre><strong>Requerido</strong> {{#crossLink "SITNA.cfg.SearchQueryProperties/secondQueryWord:property"}}{{/crossLink}}: se indicará el campo o campos en los que buscar el nombre de la vía.</pre>  
  @property queryProperties
  @type SITNA.cfg.SearchQueryProperties
 */

/**
  Nombre del campo de la geometría de la vía.
  @property geometryName
  @type String
*/

/**
  Colección con el nombre del campo o campos que nos servirán para identificar unívocamente a una vía. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}.
  @property dataIdProperty
  @type Array
*/

/**
  Colección con los nombres de campos a mostrar (según el patrón indicando en {{#crossLink "SITNA.cfg.SearchStreetSource/outputFormatLabel:property"}}{{/crossLink}}) en la lista de sugerencias. Los campos indicados también se usan para controlar los posibles registros duplicados en la lista de sugerencias. Es decir, indicando código y nombre los resultados se agruparán por los 2 campos. Los campos definidos deben existir en la capa o capas definidas en la propiedad {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}}.
  @property outputProperties
  @type Array
*/

/**
  Cadena con el patrón a mostrar en la lista de sugerencias. Reemplaza el valor numérico (entre llaves) que corresponde con el índice de la colección {{#crossLink "SITNA.cfg.SearchStreetSource/outputProperties:property"}}{{/crossLink}} con el valor del campo. Las llaves de cierre y apertura son necesarias.
  
Por ejemplo: {{#crossLink "SITNA.cfg.SearchStreetSource/outputProperties:property"}}{{/crossLink}} como `[EntidadPoblacion, Via]` y {{#crossLink "SITNA.cfg.SearchStreetSource/outputFormatLabel:property"}}{{/crossLink}} como `“{1}, {0}”` mostrará en la lista resultados del tipo: <em>Calle Estafeta, Pamplona</em>.
  @property outputFormatLabel
  @type String
*/

/**
  Colección de instancias {{#crossLink "SITNA.cfg.StyleOptions"}}{{/crossLink}}. 
   
La relación entre capa y estilo se hace mediante el índice en las colecciones 1 y 2 siendo 1 la concatenación de {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}} y 2 {{#crossLink "SITNA.cfg.SearchStreetSource/styles:property"}}{{/crossLink}}, por tanto, deberá haber tantas instancias como la suma de las capas definidas en {{#crossLink "SITNA.cfg.SearchStreetSource/featureType:property"}}{{/crossLink}} y en {{#crossLink "SITNA.cfg.SearchStreetSource/renderFeatureType:property"}}{{/crossLink}}  
   
No está disponible {{#crossLink "SITNA.cfg.StyleOptions/cluster:property"}}{{/crossLink}}.  
  @property styles
  @type Array
*/

/**
  Configuración de la cabecera a mostrar en la lista de sugerencias. La cabecera consta de un literal y de un color. El literal indica el tipo de búsqueda y el color será el que mejor representa a las entidades correspondientes en el mapa.
  @property suggestionListHead
  @type SITNA.cfg.SearchSuggestionListProperties
*/

/**
  Definición del color en la cabecera de la lista de sugerencias (para una capa concreta) de una búsqueda con resultados posibles de varias capas. Se establece como clave el nombre de la capa a la cual afecta ésta configuración.
  
Esta clase no tiene constructor.
  #### Ejemplo:

  ```javascript
    CATAST_Pol_ParcelaUrba: {
      title: "search.list.cadastral.urban",
      color: {
        geomType: "polygon",
        css: "strokeColor"
      }
    }
  ```
  @class SITNA.cfg.SearchSuggestionListColorByFeatureType
  @static
 */

/**
  Title para identificar al color. Se define con la clave del diccionario de traducciones. Revisar la sección "Soporte multiidioma" en {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}. 
  @property title
  @type String
  @required
 */

/**
  Configuración para obtener el color. 
  @property color
  @type SITNA.cfg.SearchSuggestionListColor
  @required
 */

/**
  Definición del color en la cabecera de la lista de sugerencias de una búsqueda con resultados posibles de una sola capa.
  
Esta clase no tiene constructor.
  #### Ejemplo:

  ```javascript
     {
        geomType: "point",
        css: "fontColor"
     }
  ```
  @class SITNA.cfg.SearchSuggestionListColor
  @static
 */

/**
  Nombre del tipo de geometría.
  @property geomType
  @type SITNA.consts.Geom
  @required
 */

/**
  Nombre de la propiedad de las sugerencias de la cual extraer el color. Ha de ser alguna de las distintas propiedades de colores presentes en {{#crossLink "SITNA.cfg.PointStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.LineStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.PolygonStyleOptions"}}{{/crossLink}}.
  @property css
  @type String
  @required
 */


/**
  Opciones de configuración del origen de datos de una búsqueda.
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.SearchQueryProperties
  @static
 */

/**
  Colección de nombre de campo o campos a consultar para el 1º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property firstQueryWord
  @type Array
  @required
 */

/**
  Colección de nombre de campo o campos a consultar para el 2º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property secondQueryWord
  @type Array
  @optional
*/

/**
  Colección de nombre de campo o campos a consultar para el 3º término del criterio de búsqueda, deben existir en la capa o capas definidas en la propiedad {{#crossLink "featureType"}}{{/crossLink}}.
  @property thirdQueryWord
  @type Array
  @optional
*/

/**
  Opciones de configuración para la composición de la cabecera de una lista de sugerencias de búsqueda.
  
Esta clase no tiene constructor.
  #### Ejemplo:
  ```javascript
  {
    label: "search.list.town",
    color: "strokeColor"
  }
  @class SITNA.cfg.SearchSuggestionListProperties
  @static
 */

/**
  Clave del diccionario de traducciones que indica qué tipo de búsqueda es: Parcela Catastral, Municipio, Calle… Revisar la sección "Soporte multiidioma" en {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}. 
  @property label
  @type String
  @required
 */

/**
  Configuración para obtener el color que representa al tipo de búsqueda. Se establece como color la primera coincidencia en {{#crossLink "SITNA.cfg.SearchCadastralSource/styles:property"}}{{/crossLink}} que cumpla con la configuración. 
  
La definición como String String ha de ser para indicar el nombre de una propiedad presente en {{#crossLink "SITNA.cfg.PointStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.LineStyleOptions"}}{{/crossLink}} o {{#crossLink "SITNA.cfg.PolygonStyleOptions"}}{{/crossLink}}.
  @property color
  @type SITNA.cfg.SearchSuggestionListColorByFeatureType|SITNA.cfg.SearchSuggestionListColor|String
  @required
 */

/**
  Configuración del origen de datos auxiliar a la búsqueda de parcelas catastrales para la codificación de los nombres de municipio.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/Cfg.SearchCadastralSource.html). 
  #### Ejemplo:
 
  ```javascript
  {
    url: '//miServicioWFS/ogc/wfs',
    featurePrefix: 'IDENA',    
    featureType: ['Pol_ParcelaUrbana', 'Pol_ParcelaRustica', 'Pol_ParcelaMixta'],
    municipality: {
      featureType: 'Pol_Municipio',
      labelProperty: 'MUNICIPIO',
      idProperty: 'COD_MUNICIPIO'      
    },
    queryProperties: {
      firstQueryWord: 'COD_MUNICIPIO',
      secondQueryWord: 'POLIGONO',
      thirdQueryWord: 'PARCELA'
    }
  }
  @class SITNA.cfg.SearchCadastralSourceExt
  @static
 */

/**
  Colección de nombre de capa o capas a consultar.
  @property featureType
  @type Array
  @required
 */

/**
  Nombre de campo que identifica unívocamente el municipio cuyos valores deben coincidir con los posibles valores del campo indicado en {{#crossLink "SITNA.cfg.SearchQueryProperties/firstQueryWord:property"}}{{/crossLink}}.
  @property idProperty
  @type String
  @required
*/

/**
  Nombre de campo en el que buscar el texto indicado.
  @property labelProperty
  @type String
  @required
*/


/**
  Colección de identificadores de tipo de geometría.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.Geom
  @static
 */

/**
  Identificador de geometría de tipo polígono.
  @property polygon
  @type string
  @final
 */

/**
  Identificador de geometría de tipo línea.
  @property line
  @type string
  @final
 */

/**
  Identificador de geometría de tipo punto.
  @property point
  @type string
  @final
 */



/**
Para modificar el aspecto y los datos del mapa existen varias opciones de configuración. Estas opciones se le pueden pasar por tres medios
no excluyentes. Son los siguientes:

1. Parámetros del constructor de [SITNA.Map](../classes/SITNA.Map.html).
2. Maquetación del visor (ver [SITNA.Cfg.layout](../classes/SITNA.Cfg.html#property_layout)).
3. Objeto de configuración global (ver [SITNA.Cfg](../classes/SITNA.Cfg.html)).

Esta lista está ordenada por orden de mayor a menor prevalencia, de manera que si una configuración por un medio entra en conflicto por otra los
conflictos se resuelven en ese orden.

@module 2. Configuración
 */

/**
  Colección de constantes utilizadas por la API. Se recomienda utilizar las propiedades de esta clase estática para referirse a valores conocidos.
  
No deberían modificarse las propiedades de esta clase.
  @class SITNA.Consts
  @static
 */
SITNA.Consts = TC.Consts;
/**
  Identificadores de capas útiles de IDENA y otros servicios de terceros.
  @property layer
  @type SITNA.consts.Layer
  @final
 */
/**
  Identificadores de tipo de capa.
  @property layerType
  @type SITNA.consts.LayerType
  @final
 */
/*
  Identificadores de tipo de consulta al mapa.
  property mapSearchType
  type SITNA.consts.MapSearchType
  final
 */
/**
  Tipos MIME de utilidad.
  @property mimeType
  @type SITNA.consts.MimeType
  @final
 */

/**
  Colección de identificadores de tipo de capa.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.LayerType
  @static
 */
/**
  Identificador de capa de tipo WMS.
  @property WMS
  @type string
  @final
 */
/**
  Identificador de capa de tipo WMTS.
  @property WMTS
  @type string
  @final
 */
/**
  Identificador de capa de tipo WFS.
  @property WFS
  @type string
  @final
 */
/**
  Identificador de capa de tipo KML.
  @property KML
  @type string
  @final
  @deprecated En lugar de esta propiedad es recomendable usar VECTOR para cargar archivos KML.
 */
/**
  Identificador de capa de tipo vectorial. Este tipo de capa es la que se utiliza para dibujar marcadores o para cargar
  archivos de datos geográficos vectoriales de los siguientes tipos: KML, GeoJSON, GPX, GML, WKT y TopoJSON.
  @property VECTOR
  @type string
  @final
 */

/**
  Colección de identificadores de capas útiles de IDENA y otros servicios de terceros.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.Layer
  @static
 */
/**
  Identificador de la capa de ortofoto de máxima actualidad del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de mapa base del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_BASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa de catastro del WMS de IDENA.
  @property IDENA_CADASTER
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía topográfica del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_CARTO
  @type string
  @final
 */
/**
  Identificador de la capa de la combinación de ortofoto de máxima actualidad y mapa base del WMS de IDENA.
  @property IDENA_BASEMAP_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de relieve en blanco y negro del WMS de IDENA.
  @property IDENA_BW_RELIEF
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2018 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2018
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2017 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2017
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2014 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2014
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2012 del WMTS de IDENA. Esta capa solo es compatible con el sistema de referencia EPSG:25830.
  @property IDENA_ORTHOPHOTO2012
  @type string
  @final
 */
/**
  Identificador de la capa de mapa base del WMS de IDENA.
  @property IDENA_DYNBASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía topográfica del WMS de IDENA.
  @property IDENA_DYNCARTO
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto de máxima actualidad del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2018 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2018
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2017 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2017
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2014 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2014
  @type string
  @final
 */
/**
  Identificador de la capa de ortofoto 2012 del WMS de IDENA.
  @property IDENA_DYNORTHOPHOTO2012
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía raster del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_CARTO
  @type string
  @final
 */
/**
  Identificador de la capa del callejero del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_BASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa del callejero en gris del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_BASEMAP_GREY
  @type string
  @final
 */
/**
  Identificador de la capa de relieve del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_RELIEF
  @type string
  @final
 */
/**
  Identificador de la capa del PNOA del WMTS del Instituto Geográfico Nacional.
  @property IGN_ES_ORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de cartografía raster del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNCARTO
  @type string
  @final
 */
/**
  Identificador de la capa del callejero del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNBASEMAP
  @type string
  @final
 */
/**
  Identificador de la capa del callejero en gris del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNBASEMAP_GREY
  @type string
  @final
 */
/**
  Identificador de la capa de relieve del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNRELIEF
  @type string
  @final
 */
/**
  Identificador de la capa del PNOA del WMS del Instituto Geográfico Nacional.
  @property IGN_ES_DYNORTHOPHOTO
  @type string
  @final
 */
/**
  Identificador de la capa de OpenStreetMap a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property OSM
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Voyager a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_VOYAGER
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Light a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_LIGHT
  @type string
  @final
 */
/**
  Identificador de la capa de Carto Dark a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property CARTO_DARK
  @type string
  @final
 */
/**
  Identificador de la capa de Mapbox Streets a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property MAPBOX_STREETS
  @type string
  @final
 */
/**
  Identificador de la capa de Mapbox Satellite a través del WMTS de la API SITNA. Esta capa solo es compatible con el sistema de referencia EPSG:3857.
  @property MAPBOX_SATELLITE
  @type string
  @final
 */
/**
  Identificador de una capa en blanco.
  @property BLANK
  @type string
  @final
 */

/**
  Colección de tipos MIME de utilidad.
  
No se deberían modificar las propiedades de esta clase.
  @class SITNA.consts.MimeType
  @static
 */
/**
  Tipo MIME de imagen PNG (`image/png`).
  @property PNG
  @type string
  @final
 */
/**
  Tipo MIME de imagen JPEG (`image/jpeg`).
  @property JPEG
  @type string
  @final
 */
/**
  Tipo MIME de documento GeoJSON (`application/vnd.geo+json`).
  @property GEOJSON
  @type string
  @final
 */
/**
  Tipo MIME de documento KML (`application/vnd.google-earth.kml+xml`).
  @property KML
  @type string
  @final
 */
/**
  Tipo MIME de documento GML (`application/gml+xml`).
  @property GML
  @type string
  @final
 */
/**
  Tipo MIME de documento GPX (`application/gpx+xml`).
  @property GPX
  @type string
  @final
 */

/*
  Colección de tipos de filtros.
  
No se deberían modificar las propiedades de este objeto.
  @class SITNA.consts.MapSearchType
  @static
 */
/*
  Identificador de filtro de consulta de tipo municipio.
  @property MUNICIPALITY
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo concejo.
  @property COUNCIL
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo casco urbano.
  @property URBAN
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo mancomunidad.
  @property COMMONWEALTH
  @type string
  @final
 */
/*
  Identificador de filtro de consulta de tipo genérico.
  @property GENERIC
  @type string
  @final
 */

/**
Un objeto {{#crossLink "SITNA.Cfg"}}{{/crossLink}} está accesible para todas las instancias del la clase {{#crossLink "SITNA.Map"}}{{/crossLink}}.

Por tanto, se puede configurar un mapa asignando valores a las propiedades de ese objeto:
  #### Ejemplo:

```javascript
SITNA.Cfg.crs = "EPSG:4326";
SITNA.Cfg.initialExtent = [
  -2.84820556640625,
  41.78912492257675,
  -0.32135009765625,
  43.55789822064767
];
var map = new SITNA.Map("mapa");
```
@module 2. Configuración
@submodule 2.3. Objeto de configuración global
 */


/**
  Configuración general de la API. Cualquier llamada a un método o un constructor de la API sin parámetro de opciones toma las opciones de esta clase. 
  Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

La clase es estática. 
  @class SITNA.Cfg
  @static
 */
SITNA.Cfg = TC.Cfg;
/**
  URL del proxy utilizado para peticiones a dominios remotos. 
  
Debido a restricciones de seguridad implementadas en Javascript, a través de `XMLHttpRequest` no es posible obtener información de dominios distintos al de la página web. 

  Hay dos maneras de solventar esta restricción. La primera es que el servidor remoto permita el acceso entre dominios estableciendo la cabecera `Access-Control-Allow-Origin` a 
  la respuesta HTTP. Dado que esta solución la implementan terceras personas (los administradores del dominio remoto), no siempre es aplicable. 

  La segunda solución es desplegar en el dominio propio un proxy. Un proxy es un servicio que recibe peticiones HTTP y las redirige a otra URL. 

  Si la propiedad `proxy` está establecida, todas las peticiones a dominios remotos las mandará al proxy para que este las redirija. De esta manera no infringimos las reglas de
  seguridad de Javascript, dado que el proxy está alojado en el dominio propio. 
 #### Ejemplo:

  ```javascript
    SITNA.Cfg.proxy = ""; // Las peticiones a http://www.otrodominio.com se hacen directamente
 
    SITNA.Cfg.proxy = "/cgi-bin/proxy.cgi?url="; // Las peticiones a http://www.otrodominio.com se convierten en peticiones a /cgi-bin/proxy.cgi?url=http://www.otrodominio.com
  ```
  @property proxy
  @type string
  @default ""  
 */
/**
  Código EPSG del sistema de referencia espacial del mapa. 

  Puede consultar el ejemplo [online](../../examples/Cfg.crs.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, lo cambiamos por SITNA.Consts.layer.IDENA_DYNBASEMAP.
      SITNA.Cfg.baseLayers[0] = SITNA.Consts.layer.IDENA_DYNBASEMAP;
      SITNA.Cfg.defaultBaseLayer = SITNA.Consts.layer.IDENA_DYNBASEMAP;
  
      // WGS 84
      SITNA.Cfg.crs = "EPSG:4326";
      // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
      SITNA.Cfg.initialExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
      SITNA.Cfg.maxExtent = [-2.848205, 41.789124, -0.321350, 43.557898];
  
      var map = new SITNA.Map("mapa", {
        // SITNA.Cfg.baseLayers[0] (capa por defecto) no es compatible con WGS 84, establecer la capa SITNA.Consts.layer.IDENA_DYNBASEMAP en el control de mapa de situación.
        controls: {
          overviewMap: {
            layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
          }
        }
      });
    </script>
 ```
  @property crs
  @type string
  @default "EPSG:25830"  
 */
/**
  Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. Estos valores deben estar en las unidades definidas por 
  el sistema de referencia espacial del mapa. Por defecto la extensión es la de Navarra.
  @property initialExtent
  @type array
  @default [541084.221, 4640788.225, 685574.4632, 4796618.764]
 */
/**
  Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima, de forma que el centro del mapa nunca saldrá fuera de estos límites.
  Estos valores deben estar en las unidades definidas por el sistema de referencia espacial del mapa.

  Si en vez de un array el valor es `false`, el mapa no tiene limitada la extensión máxima.
  @property maxExtent
  @type array|boolean
  @default false
 */
/**
  Si se establece a `true`, la rueda de scroll del ratón se puede utilizar para hacer zoom en el mapa. 
  @property mouseWheelZoom
  @type boolean
  @default true
 */
/**
  Tolerancia en pixels a las consultas de información de capa. 
  
En ciertas capas, por ejemplo las que representan geometrías de puntos, puede ser difícil pulsar precisamente en el punto donde está la entidad geográfica que interesa.

  La propiedad `pixelTolerance` define un área de un número de pixels hacia cada lado del punto de pulsación, de forma que toda entidad geográfica que se interseque con ese área se incluye en el resultado de la consulta. 

  Por ejemplo, si el valor establecido es 10, toda entidad geográfica que esté dentro de un cuadrado de 21 pixels de lado (10 pixels por cuadrante más el pixel central) centrado en el punto de pulsación 
  se mostrará en el resultado. 
  <em>A tener en cuenta:</em> Esta propiedad establece el valor de los llamados "parámetros de vendedor" que los servidores de mapas admiten para modificar el comportamiento de las peticiones
  `getFeatureInfo` del standard WMS. Pero este comportamiento puede ser modificado también por otras circunstancias, como los estilos aplicados a las capas en el servidor. 
  
Como estas circunstancias están fuera del ámbito de alcance de esta API, es posible que los resultados obtenidos desde algún servicio WMS sean inesperados en lo referente a `pixelTolerance`. 
  @property pixelTolerance
  @type number
  @default 10
 */
/**
  Lista de objetos de definición de capa (instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}}) para incluir dichas capas como mapas de fondo. 

  Puede consultar el ejemplo [online](../../examples/Cfg.baseLayers.html). 
  #### Ejemplo:
    ```javascript
        <div id="mapa"></div>
        <script>
          // Establecer un proxy porque se hacen peticiones a otro dominio.
          SITNA.Cfg.proxy = "proxy.ashx?";
  
          // Añadir PNOA y establecerla como mapa de fondo por defecto.
          SITNA.Cfg.baseLayers.push({
            id: "PNOA",
            url: "http://www.ign.es/wms-inspire/pnoa-ma",
            layerNames: "OI.OrthoimageCoverage",
            isBase: true
          });
          SITNA.Cfg.defaultBaseLayer = "PNOA";
  
          var map = new SITNA.Map("mapa");
        </script>
  ```
  @property baseLayers
  @type array
  @default La lista incluye las siguientes capas de IDENA: Ortofoto 2014 (capa por defecto), Mapa base, Catastro, Cartografía topográfica.
  
 */
/**
  Identificador de la capa base por defecto o índice de la capa base por defecto en la lista de capas base del mapa (Consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/baseLayers:property"}}{{/crossLink}}).
  @property defaultBaseLayer
  @type string|number
  @default SITNA.consts.Layer.IDENA_ORTHOPHOTO
 */
/**
  Lista de objetos de definición de capa (instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}}) para incluir dichas capas como contenido del mapa. 

  Puede consultar el ejemplo [online](../../examples/Cfg.workLayers.html). 
    #### Ejemplo:
  ```javascript
    <div id="mapa"></div>
    <script>
      // Establecer un proxy porque se hacen peticiones a otro dominio.
      SITNA.Cfg.proxy = "proxy.ashx?";

      SITNA.Cfg.workLayers = [{
        id: "csantiago",
        title: "Camino de Santiago",
        url: "http://www.ign.es/wms-inspire/camino-santiago",
        layerNames: "PS.ProtectedSite,GN.GeographicalNames,AU.AdministrativeUnit"
      }];
      var map = new SITNA.Map("mapa");
    </script>
  ```
  @property workLayers
  @type array
  @default []  
 */
/**
  Opciones de controles de mapa.
  @property controls
  @type SITNA.cfg.MapControlOptions
  @default Se incluyen controles de indicador de espera de carga, atribución, indicador de coordenadas.
 */
/**
URL de la carpeta de maquetación. Para prescindir de maquetación, establecer esta propiedad a `null`.

Puede consultar el ejemplo [online](../../examples/Cfg.layout.html). 

Sus archivos de maquetación son
[markup.html](../../examples/layout/example/markup.html), [config.json](../../examples/layout/example/config.json),
[style.css](../../examples/layout/example/style.css), [resources/es-ES.json](../../examples/layout/example/resources/es-ES.json),
[resources/eu-ES.json](../../examples/layout/example/resources/eu-ES.json) y [resources/en-US.json](../../examples/layout/example/resources/en-US.json).

Para saber cómo utilizar maquetaciones, consulte la sección {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}}.

#### Ejemplo:
```javascript
  <!-- layout/example/markup.html -->
   <div id="controls">
     <h1>{{stJamesWayInNavarre}}</h1>
     <div id="toc" />
     <div id="legend" />
   </div>
  <div id="languages">
    <a class="lang" href="?lang=es-ES" title="{{spanish}}">ES</a>
    <a class="lang" href="?lang=eu-ES" title="{{basque}}">EU</a>
    <a class="lang" href="?lang=en-US" title="{{english}}">EN</a>
  </div>
```
```javascript
  resources/es-ES.json
  {
    "stJamesWayInNavarre": "Camino de Santiago en Navarra",
    "spanish": "castellano",
    "basque": "euskera",
    "english": "inglés"
  }
```
```javascript
  resources/eu-ES.json
  {
    "stJamesWayInNavarre": "Nafarroan Donejakue bidea",
    "spanish": "gaztelania",
    "basque": "euskara",
    "english": "ingelesa"
  }
```
```javascript
  resources/en-US.json
  {
    "stJamesWayInNavarre": "St. James' Way in Navarre",
    "spanish": "spanish",
    "basque": "basque",
    "english": "english"
  }
```
```javascript
  <div id="mapa"></div>
  <script>
    // Obtener el idioma de interfaz de usuario
    var selectedLocale = location.search.substr(location.search.indexOf("?lang=") + 6) || "es-ES";
    // Establecer un proxy porque se hacen peticiones a otro dominio.
    SITNA.Cfg.proxy = "proxy.ashx?";

    SITNA.Cfg.layout = "layout/example";
    var map = new SITNA.Map("mapa", {
      locale: selectedLocale
    });
  </script>
```


@property layout
@type string
@default "//sitna.tracasa.es/api/tc/layout/responsive"
 */
SITNA.Cfg.layout = TC.apiLocation + 'TC/layout/responsive';
/**
  Opciones de estilo de entidades geográficas.
  @property styles
  @type SITNA.cfg.StyleOptions
 */

/**
  Opciones de capa.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.LayerOptions
  @static
 */
/**
  Identificador único de capa.
  @property id
  @type string
 */
/**
  Título de capa. Este valor se mostrará en la tabla de contenidos y la leyenda.
  @property title
  @type string|undefined
 */
/**
  Tipo de capa. Si no se especifica se considera que la capa es WMS. La lista de valores posibles está definida en {{#crossLink "SITNA.consts.LayerType"}}{{/crossLink}}.
  @property type
  @type string|undefined
 */
/**
  URL del servicio OGC o del archivo de datos geográficos que define la capa. Propiedad obligatoria en capas de tipo
  {{#crossLink "SITNA.consts.LayerType/WMS:property"}}{{/crossLink}}, {{#crossLink "SITNA.consts.LayerType/WMTS:property"}}{{/crossLink}},
  {{#crossLink "SITNA.consts.LayerType/WFS:property"}}{{/crossLink}} y {{#crossLink "SITNA.consts.LayerType/KML:property"}}{{/crossLink}}. 
  
En las capas de tipo VECTOR los archivos de datos geográficos soportados son KML, GeoJSON, GPX, GML, WKT y TopoJSON.

  El formato se deduce de la extensión del nombre de archivo, pero también se puede especificar utilizando la propiedad {{#crossLink "SITNA.cfg.LayerOptions/format:property"}}{{/crossLink}}. 
  
  Puede consultar el ejemplo [online](../../examples/cfg.LayerOptions.url.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de tabla de contenidos en la primera posición.
      SITNA.Cfg.controls.TOC = {
        div: "slot1"
      };
      // Añadimos una capa raster desde un servicio WMS y cuatro capas vectoriales
      // a partir de archivos geográficos: GeoJSON, GPX, KML y GML.
      SITNA.Cfg.workLayers = [
        {
          id: "wms",
          title: "Camino de Santiago",
          type: SITNA.Consts.layerType.WMS,
          url: "//idena.navarra.es/ogc/wms",
          layerNames: "IDENA:PATRIM_Lin_CaminoSantR",
          format: SITNA.Consts.mimeType.PNG
        },
        {
          id: "geojson",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/PARQUESNATURALES.json",
          format: SITNA.Consts.mimeType.GEOJSON
        },
        {
          id: "gpx",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/CAMINOFRANCES.gpx"
        },
        {
          id: "kml",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/MUSEOSNAVARRA.kml"
        },
        {
          id: "gml",
          type: SITNA.Consts.layerType.VECTOR,
          url: "data/ESTACIONESTREN.gml"
        },
      ];
      var map = new SITNA.Map("mapa");
    </script>
```
  @property url
  @type string|undefined  
 */
/**
  Lista separada por comas de los nombres de capa del servicio OGC.
  @property layerNames
  @type string|undefined
 */
/**
  Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.
  @property matrixSet
  @type string|undefined
 */
/**
  En las capas de tipo {{#crossLink "SITNA.consts.LayerType/WMS:property"}}{{/crossLink}} y {{#crossLink "SITNA.consts.LayerType/WMTS:property"}}{{/crossLink}},
  es el tipo MIME del formato de archivo de imagen a obtener del servicio. En las capas de tipo {{#crossLink "SITNA.consts.LayerType/VECTOR:property"}}{{/crossLink}},
  es el tipo MIME del formato de archivo de datos geográficos que queremos cargar (GeoJSON, KML, etc.). 
  
Si esta propiedad no está definida, si la capa es un mapa de fondo (consultar propiedad {{#crossLink "SITNA.cfg.LayerOptions/isBase:property"}}{{/crossLink}}),
  se asume que el formato es `"image/jpeg"`, en caso contrario se asume que el formato es `"image/png"`. 
  @property format
  @type SITNA.consts.MimeType|undefined
 */
/**
  Si se establece a `true`, la capa se muestra por defecto si forma parte de los mapas de fondo.
  @property isDefault
  @type boolean|undefined
  @deprecated En lugar de esta propiedad es recomendable usar SITNA.Cfg.defaultBaseLayer.
 */
/**
  Si se establece a `true`, la capa es un mapa de fondo.
  @property isBase
  @type boolean|undefined
 */
/**
  Aplicable a capas de tipo WMS y KML. Si se establece a `true`, la capa no muestra la jerarquía de grupos de capas en la tabla de contenidos ni en la leyenda.
  @property hideTree
  @type boolean|undefined
 */
/**
  Si se establece a `true`, la capa no aparece en la tabla de contenidos ni en la leyenda. De este modo se puede añadir una superposición de capas de trabajo que el usuario la perciba como parte del mapa de fondo.
  @property stealth
  @type boolean|undefined
 */
/**
  URL de una imagen en miniatura a mostrar en el selector de mapas de fondo.
  @property thumbnail
  @type string|undefined
 */
/**
  La capa agrupa sus entidades puntuales cercanas entre sí en grupos (clusters). Aplicable a capas de tipo VECTOR, WFS y KML. 

  Puede consultar el ejemplo [online](../../examples/cfg.LayerOptions.cluster.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Creamos un mapa con una capa de puntos de un KML,
      // clustering activado a 50 pixels y transiciones animadas.
      var map = new SITNA.Map("mapa", {
        workLayers: [
         {
           id: "cluster",
           type: SITNA.Consts.layerType.KML,
           url: "data/PromocionesViviendas.kml",
           title: 'Clusters',
           cluster: {
             distance: 50,
             animate: true
           }
         }
       ]
      });
    </script>
```
  @property cluster
  @type SITNA.cfg.ClusterOptions|undefined  
 */
///**
//  Propiedad que establece si deseamos que el título de la capa se oculte cuando esté cargada como capa de trabajo. La utilizan controles como
//  {{#crossLink "SITNA.cfg.MapControlOptions/layerCatalog:property"}}{{/crossLink}} para componer los elementos que la representan.
//  @property hideTitle
//  @type boolean|undefined
// */

/**
  Opciones de clustering de puntos de una capa, define si los puntos se tienen que agrupar cuando están más cerca entre sí que un valor umbral.
  
Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.ClusterOptions
  @static
 */
/**
  Distancia en píxels que tienen que tener como máximo los puntos entre sí para que se agrupen en un cluster.
  @property distance
  @type number
 */
/**
  Si se establece a `true`, los puntos se agrupan y desagrupan con una transición animada.
  @property animate
  @type boolean|undefined
 */
/**
  Opciones de estilo de los clusters.
  @property styles
  @type SITNA.cfg.ClusterStyleOptions|undefined
 */

/**
  Opciones de controles de mapa, define qué controles se incluyen en un mapa y qué opciones se pasan a cada control.
  
Las propiedades de esta clase son de tipo boolean, en cuyo caso define la existencia o no del control asociado, o una instancia de la clase {{#crossLink "SITNA.cfg.ControlOptions"}}{{/crossLink}}.

  Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.MapControlOptions
  @static
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador de espera de carga.
  @property loadingIndicator
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una barra de navegación con control de zoom.
  @property navBar
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una barra de escala.
  @property scaleBar
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador numérico de escala.
  @property scale
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un selector numérico de escala.
  @property scaleSelector
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un mapa de situación.
  @property overviewMap
  @type boolean|SITNA.cfg.OverviewMapOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un selector de mapas de fondo.
  @property basemapSelector
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene atribución. La atribución es un texto superpuesto al mapa que actúa como reconocimiento de la procedencia de los datos que se muestran.
  @property attribution
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene una tabla de contenidos mostrando las capas de trabajo y los grupos de marcadores.
.* Los controles TOC y {{#crossLink "SITNA.cfg.MapControlOptions/workLayerManager:property"}}{{/crossLink}} realizan varias funciones comunes, así
  rara vez será necesario tener los dos a la vez en un visor. 
  @property TOC
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un indicador de coordenadas y de sistema de referencia espacial.
  @property coordinates
  @type boolean|SITNA.cfg.CoordinatesOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene leyenda.
  @property legend
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa muestra los datos asociados a los marcadores cuando se pulsa sobre ellos.
  @property popup
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un buscador. El buscador localiza coordenadas y busca entidades geográficas tales como: municipios, cascos urbanos, vías, portales y parcelas catastrales de IDENA. Es posible establecer un origen de datos distinto a IDENA en el que buscar, consultar la sección: {{#crossLinkModule "2.3.1. Objeto de configuración de opciones del buscador"}}{{/crossLinkModule}} 
  @property search
  @type boolean|SITNA.cfg.SearchOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un medidor de longitudes, áreas y perímetros.
  @property measure
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa tiene un control que gestiona los clics del usuario en ellos. 
  @property click
  @type boolean|SITNA.cfg.ClickOptions|undefined
  @default false
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa puede abrir una ventana de Google StreetView. 
  @property streetView
  @type boolean|SITNA.cfg.StreetViewOptions|undefined
  @default true
 */
/**
  Si se establece a un valor <em>truthy</em>, el mapa responde a los clics con un información de las capas cargadas de tipo WMS. Se usa para ello la petición `getFeatureInfo` del standard WMS.

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.featureInfo.html).
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Añadimos el control featureInfo.
      SITNA.Cfg.controls.featureInfo = true;
      // Añadimos una capa WMS sobre la que hacer las consultas.
      SITNA.Cfg.workLayers = [
        {
          id: "terremotos",
          title: "Terremotos últimos 365 días",
          type: SITNA.Consts.layerType.WMS,
          url: "https://www.ign.es/wms-inspire/geofisica",
          layerNames: ["Ultimos365dias"]
        }
      ];
      var map = new SITNA.Map("mapa");
    </script>
```
  @property featureInfo
  @type boolean|SITNA.cfg.ClickOptions|undefined
  @default true  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra una herramienta para imprimir el mapa en PDF. 
  
El control permite al usuario elegir entre varios tamaños de hoja y orientación horizontal o vertical, además se le puede poner un título al documento de impresión. 

  Al pulsar el botón de imprimir se abre una previsualización como paso previo a la impresión. Ahí el usuario puede realizar unos últimos ajustes a la extensión del mapa.

  El PDF se generará al pulsar en el botón dentro de la previsualización. 

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.printMap.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de impresión en el primer contenedor.
      SITNA.Cfg.controls.printMap = {
        div: "slot1"
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property printMap
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false
  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para consultar y gestionar las capas de trabajo que están cargadas en el mapa. Con este control
  se dispone de las siguientes funcionalidades: 
  <ul>
    <li>Consultar qué capas están cargadas en el mapa</li>
    <li>Ver en qué orden están superpuestas y modificar ese orden</li>
    <li>Comprobar si una capa es visible al nivel de zoom actual</li>
    <li>Activar y desactivar la visibilidad de las capas</li>
    <li>Establecer el grado de transparencia de cada capa</li>
    <li>Borrar capas cargadas</li>
    <li>Consultar metadatos asociados a la capa</li>
  </ul>
  
Los controles workLayerManager y {{#crossLink "SITNA.cfg.MapControlOptions/TOC:property"}}{{/crossLink}} realizan varias funciones comunes, así
  rara vez será necesario tener los dos a la vez en un visor. 

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
#### Ejemplo:
````javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property workLayerManager
  @type boolean|SITNA.cfg.ControlOptions|undefined
  @default false  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para añadir datos externos, en concreto servicios WMS y archivos locales de datos geográficos. 

  Se pueden añadir WMS escribiendo la dirección del servicio o eligiendo un servicio de la lista de sugerencias de servicios de interés. 

  Se pueden añadir datos de archivos buscándolos en el cuadro de diálogo que se abre tras pulsar “Abrir archivo” o arrastrándolos y soltándolos dentro del área del mapa. 

  Puede consultar el ejemplo [online](../../examples/cfg.DataLoaderOptions.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Activamos el proxy para poder acceder a servicios de otro dominio.
      SITNA.Cfg.proxy = "proxy.ashx?";
      // Añadimos el control de tabla de contenidos en el primer contenedor.
      SITNA.Cfg.controls.TOC = {
        div: "slot1"
      };
      // Añadimos el control de datos externos en el segundo contenedor.
      SITNA.Cfg.controls.dataLoader = {
        div: "slot2",
        enableDragAndDrop: true,
        wmsSuggestions: [
          {
            group: "Estatales",
            items: [
              {
                name: "Mapa Base (IGN)",
                url: "https://www.ign.es/wms-inspire/ign-base"
              },
              {
                name: "Unidades Administrativas (IGN)",
                url: "https://www.ign.es/wms-inspire/unidades-administrativas"
              },
              {
                name: "Cartografía Topográfica (IGN)",
                url: "https://www.ign.es/wms-inspire/mapa-raster"
              },
              {
                name: "Ortofotos PNOA Máxima Actualidad (IGN)",
                url: "https://www.ign.es/wms-inspire/pnoa-ma"
              }
            ]
          },
          {
            group: "Comunidades limítrofes",
            items: [
              {
                name: "Aragón",
                url: "http://idearagon.aragon.es/Visor2D"
              },
              {
                name: "La Rioja",
                url: "https://ogc.larioja.org/wms/request.php"
              },
              {
                name: "País Vasco",
                url: "http://www.geo.euskadi.eus/WMS_KARTOGRAFIA"
              }
            ]
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property dataLoader
  @type boolean|SITNA.cfg.DataLoaderOptions|undefined
  @default false
  
 */
/**
  Si se establece a un valor <em>truthy</em>, se muestra un control para añadir capas de trabajo desde uno o varios servicios WMS. Con este control
  se dispone de las siguientes funcionalidades: 
  <ul>
    <li>Consultar las capas disponibles en uno o varios WMS.</li>
    <li>Buscar capas mediante texto libre. Se busca el texto en los títulos y los resúmenes descriptivos de cada capa, que se publican en el
    [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities") del servicio.</li>
    <li>Añadir capas al mapa como capas de trabajo.</li>
  </ul>

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property layerCatalog
  @type boolean|SITNA.cfg.LayerCatalogOptions|undefined
  @default false  
 */

/**
  Opciones de control.
  Esta clase no tiene constructor.
  @class SITNA.cfg.ControlOptions
  @static
 */
/**
  Elemento del DOM en el que crear el control o valor de atributo id de dicho elemento.
  @property div
  @type HTMLElement|string|undefined
 */

/**
  Opciones de control de mapa de situación.
  Esta clase no tiene constructor.
  @class SITNA.cfg.OverviewMapOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Identificador de capa para usar como mapa de fondo u objeto de opciones de capa. 
  @property layer
  @type string|SITNA.cfg.LayerOptions
 */

/**
  Opciones de control de coordenadas.
  Esta clase no tiene constructor. 

  Puede consultar el ejemplo [online](../../examples/cfg.CoordinatesOptions.html). 
  @class SITNA.cfg.CoordinatesOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Determina si se muestran coordenadas geográficas (en EPSG:4326) además de las del mapa, que por defecto son UTM (EPSG:25830). 
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <script>
     // Hacemos que el control que muestra las coordenadas en pantalla
     // muestre también las coordenadas geográficas
     SITNA.Cfg.controls.coordinates = {
       showGeo: true
     };
     var map = new SITNA.Map('map');
    </script>
```
  @property showGeo
  @type boolean|undefined  
 */

/**
  Opciones de control de clic.
  
Esta clase no tiene constructor.

  Estas opciones se utilizan si se desea tener un control en el mapa que reaccione a los clic del ratón o los toques en el mapa. 

  Puede consultar el ejemplo [online](../../examples/cfg.ClickOptions.html). 
  @class SITNA.cfg.ClickOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Si se establece a `true`, el control asociado está activo, es decir, responde a los clics hechos en el mapa desde que se carga.
  @property active
  @type boolean|undefined
 */
/**
  Función de callback que gestiona la respuesta al clic. Es válida cualquier función que acepta un parámetro de coordenada, que es un array de dos números.
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <script>
     // Creamos un mapa con el control de gestión de clics, con una función de callback personalizada
     var map = new SITNA.Map("mapa", {
       controls: {
         click: {
           active: true,
           callback: function (coord) {
             alert("Has pulsado en la posición " + coord[0] + ", " + coord[1]);
           }
         }
       }
     });
    </script>
```  
@property callback
  @type function|undefined
  @default Una función que escribe en consola las coordenadas pulsadas  
 */

/**
  Opciones de control de Google StreetView.
  
Esta clase no tiene constructor.

  Para incrustar StreetView en el visor se utiliza la versión 3 de la API de Google Maps. Esta se carga automáticamente al instanciar el control. 

  Puede consultar el ejemplo [online](../../examples/cfg.StreetViewOptions.html). 
  @class SITNA.cfg.StreetViewOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Elemento del DOM en el que mostrar la vista de StreetView o valor de atributo id de dicho elemento.
#### Ejemplo:
```javascript
    <div id="mapa"/>
    <div id="sv"/>
    <script>
      // Creamos un mapa con el control de StreetView.
      // La vista de StreetView se debe dibujar en el elemento con identificador "sv".
      // Se utilizará la clave de Google Maps para el SITNA.
      var map = new SITNA.Map("mapa", {
        controls: {
          streetView: {
            viewDiv: "sv",
            googleMapsKey: "AIzaSyDyXgqllcajbMjx8yQxEX28VgA9nQOhtCM"
          }
        }
      });
    </script>
```
  @property viewDiv
  @type HTMLElement|string|undefined
  
 */
/**
  El control de StreetView hace uso de la API de Google Maps para funcionar. Esta propiedad establece la clave de uso asociada al sitio
  donde está alojada la aplicación que usa la API SITNA. No es necesaria para hacer funcionar el control pero es recomendable obtener una para garantizar el servicio por parte de Google. 
  
Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key">).
  @property googleMapsKey
  @type string|undefined
 */

/**
  Opciones de control de búsquedas.
  Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.SearchOptions.html). 
#### Ejemplo:
  ```javascript      
        <script>
          // Creamos un mapa con el control de búsquedas. 
          // Configuramos el buscador desactivando la búsqueda de parcelas y la localización de coordenadas.
          // Indicamos un placeHolder y tooltip (propiedad "instructions") acorde con las búsquedas configuradas.
          var map = new SITNA.Map("mapa", {
            controls: {
              search: { 
                coordinates: false,
                cadastralParcel: false,
                municipality: true,
                town: true,
                street: true,
                postalAddress: true,
                placeHolder: "Municipio, casco urbano, calle o portal",
                instructions: "Buscar municipio, casco urbano, calle o portal"
              }
            }
          });
        </script> 
  ```
  @class SITNA.cfg.SearchOptions
  @extends SITNA.cfg.ControlOptions
  @static 
 */
/**
  Esta propiedad establece el atributo "placeHolder" del cajetín del buscador del mapa. 
  @property placeHolder
  @type string
  @default Municipio, casco urbano, calle, dirección… 
 */
/**
  Esta propiedad establece el atributo "title" del cajetín y del botón del buscador del mapa. 
  @property instructions
  @type string
  @default Buscar municipio, casco urbano, calle, dirección, referencia catastral, coordenadas UTM o latitud-longitud
 */
/**
  Esta propiedad activa/desactiva la localización de coordenadas en Sistema de Referencia ETRS89, bien UTM Huso 30 Norte (EPSG:25830) o latitud-longitud (EPSG:4258, EPSG:4326 o CRS:84) en el buscador del mapa. 
  @property coordinates
  @type boolean
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de municipios en el buscador del mapa. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchMunicipalitySource"}}{{/crossLink}}. 
  @property municipality
  @type boolean|SITNA.cfg.SearchMunicipalitySource
  @default true
 */

/**
  Esta propiedad activa/desactiva la búsqueda de cascos urbanos en el buscador del mapa. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchTownSource"}}{{/crossLink}}. 
  @property town
  @type boolean|SITNA.cfg.SearchTownSource
  @default true 
    
 */

/**
  Esta propiedad activa/desactiva la búsqueda de vías en el buscador del mapa. Formato: entidad de población, vía 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchStreetSource"}}{{/crossLink}}. 
  @property street
  @type boolean|SITNA.cfg.SearchStreetSource
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de direcciones postales en el buscador del mapa. Formato: entidad de población, vía, portal. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchPostalAddressSource"}}{{/crossLink}}. 
  @property postalAddress
  @type boolean|SITNA.cfg.SearchPostalAddressSource
  @default true
 */
/**
  Esta propiedad activa/desactiva la búsqueda de parcelas catastrales en el buscador del mapa. Formato: municipio, polígono, parcela. 
  
Para configurar un origen de datos distinto a IDENA, establecer como valor una instancia de {{#crossLink "SITNA.cfg.SearchCadastralSource"}}{{/crossLink}}. 
  @property cadastralParcel
  @type boolean|SITNA.cfg.SearchCadastralSource
  @default true 
 */

/**
  Opciones de control de catálogo de capas.

  Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.MapControlOptions.layerCatalog_workLayerManager.html). 
  @class SITNA.cfg.LayerCatalogOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Propiedad que establece si se puede buscar capas por texto. La búsqueda del texto se realiza en los títulos y los resúmenes descriptivos de cada capa, que se publican en el
  [documento de capacidades](https://github.com/7o9/implementer-friendly-standards/blob/master/introduction.rst#getcapabilities") del servicio.
  @property enableSearch
  @type boolean|undefined
 */

/**
  Lista de objetos {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} que se corresponden con capas de servicios WMS que queremos añadir al catálogo.
  
En estos objetos, si se asigna un valor a la propiedad {{#crossLink "SITNA.cfg.LayerOptions/layerNames:property"}}{{/crossLink}}, solo las capas
  especificadas y sus hijas estarán disponibles para ser añadidas al mapa. Sin embargo, si esta propiedad se deja sin asignar, todas las capas publicadas
  en el servicio WMS estarán disponibles para ser añadidas. 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Establecemos un layout simplificado apto para hacer demostraciones de controles.
      SITNA.Cfg.layout = "layout/ctl-container";
      // Añadimos el control de capas cargadas en la primera posición.
      SITNA.Cfg.controls.workLayerManager = {
        div: "slot1"
      };
      // Añadimos en la segunda posición el catálogo de capas con dos servicios.
      SITNA.Cfg.controls.layerCatalog = {
        div: "slot2",
        enableSearch: true,
        layers: [
          {
            id: "idena",
            title: "IDENA",
            hideTitle: true,
            type: SITNA.Consts.layerType.WMS,
            url: "//idena.navarra.es/ogc/wms",
            hideTree: false
          },
          {
            id: "sismica",
            title: "Información sísmica y volcánica",
            type: SITNA.Consts.layerType.WMS,
            url: "//www.ign.es/wms-inspire/geofisica",
            layerNames: ["Ultimos10dias", "Ultimos30dias", "Ultimos365dias"],
            hideTree: false
          }
        ]
      };
      var map = new SITNA.Map("mapa");
    </script>
```
  @property layers
  @type Array
  @default []
  
 */

/**
  Opciones de control para añadir datos geográficos.
  
Esta clase no tiene constructor.

  Puede consultar el ejemplo [online](../../examples/cfg.DataLoaderOptions.html). 
  @class SITNA.cfg.DataLoaderOptions
  @extends SITNA.cfg.ControlOptions
  @static
 */
/**
  Lista de grupos de sugerencias de servicios WMS ofrecidos por el control. Es un array de instancias de la clase {{#crossLink "SITNA.cfg.WMSGroupOptions"}}{{/crossLink}},
  que establece grupos de servicios WMS sugeridos. Por ejemplo se puede establecer un grupo de servicios WMS estatales y otro de servicios WMS mundiales.
  @property wmsSuggestions
  @type Array|undefined
 */
/**
  Propiedad que establece si está permitido arrastrar y soltar archivos al área del mapa, además de abrirlos de la manera convencional abriendo el cuadro de diálogo de búsqueda de archivos.
  @property enableDragAndDrop
  @type boolean|undefined
 */

/**
  Opciones de grupo de sugerencias de servicios externos WMS.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.WMSGroupOptions
  @static
 */
/**
  Nombre del grupo de sugerencias. Se mostrará como una sección en la lista de opciones del control.
  @property group
  @type String
 */
/**
  Lista de sugerencias de servicios externos WMS. Es un array de instancias de la clase {{#crossLink "SITNA.cfg.WMSOptions"}}{{/crossLink}}.
  @property items
  @type String
 */

/**
  Opciones de sugerencia de servicio externo WMS.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.WMSOptions
  @static
 */
/**
  Nombre del servicio WMS. Se mostrará como un elemento en la lista de opciones del control.
  @property name
  @type String
 */
/**
  URL de acceso al servicio WMS.
  @property url
  @type String
 */

/**
  Opciones de estilo de entidades geográficas.
  
Esta clase no tiene constructor.
  @class SITNA.cfg.StyleOptions
  @static
 */
/**
  Opciones de estilo de marcador (punto de mapa con icono).
  @property marker
  @type SITNA.cfg.MarkerStyleOptions|undefined
 */
/**
  Opciones de estilo de punto.
  @property marker
  @type SITNA.cfg.PointStyleOptions|undefined
 */
/**
  Opciones de estilo de línea.
  @property line
  @type SITNA.cfg.LineStyleOptions|undefined
 */
/**
  Opciones de estilo de polígono.
  @property polygon
  @type SITNA.cfg.PolygonStyleOptions|undefined
 */
/**
  Opciones de estilo de cluster de puntos. Consultar SITNA.cfg.LayerOptions.{{#crossLink "SITNA.cfg.LayerOptions/cluster:property"}}{{/crossLink}}
  para saber cómo mostrar clusters.
  @property cluster
  @type SITNA.cfg.ClusterStyleOptions|undefined
 */

/**
  Opciones de estilo de marcador (punto de mapa con icono).
  
Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.MarkerStyleOptions
  @static
 */
/**
  Lista de nombres de clase CSS a utilizar para los iconos de los marcadores. La API extraerá la URL de las imágenes del atributo `background-image` asociado a la clase.
  @property classes
  @type Array
  @default ["tc-marker1", "tc-marker2", "tc-marker3", "tc-marker4", "tc-marker5"]
 */
/**
  Posicionamiento relativo del icono respecto al punto del mapa, representado por un array de dos números entre 0 y 1, siendo [0, 0] la esquina superior izquierda del icono.
  @property anchor
  @type Array
  @default [.5, 1]
 */
/**
  Anchura en píxeles del icono.
  @property width
  @type number
  @default 32
 */
/**
  Altura en píxeles del icono.
  @property height
  @type number
  @default 32
 */

/**
  Opciones de estilo de línea. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.LineStyleOptions
  @static
 */
/**
  Color de trazo de la línea, representado en formato hex triplet (`"#RRGGBB"`).
  @property strokeColor
  @type string
  @default "#f00" en polígonos y líneas
 */
/**
  Anchura de trazo en píxeles de la línea.
  @property strokeWidth
  @type number
  @default 2 en polígonos y líneas
 */
/**
  Opacidad de trazo, valor de 0 a 1.
  @property strokeOpacity
  @type number
  @default 1 en polígonos y líneas
 */

/**
  Opciones de estilo de polígono. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.PolygonStyleOptions
  @extends SITNA.cfg.LineStyleOptions
  @static
 */
/**
  Color de relleno, representado en formato hex triplet (`"#RRGGBB"`).
  @property fillColor
  @type string
  @default "#000" en polígonos, "#336" en clusters
 */
/**
  Opacidad de relleno, valor de 0 a 1.
  @property fillOpacity
  @type number
  @default 0.3 en polígonos, 0.6 en clusters
 */

/**
  Opciones de estilo de punto. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.PointStyleOptions
  @extends SITNA.cfg.PolygonStyleOptions
  @static
 */
/**
  Colección de nombre de campo o campos de los cuales extraer el valor de la etiqueta.
  @property label
  @type string|undefined
  @default null
 */
/**
  Nombre del campo del cual extraer la rotación a aplicar a la etiqueta.
  @property angle
  @type string|undefined
  @default null
 */
/**
  Radio en pixels del símbolo que representa el punto.
  @property radius
  @type number|undefined
  @default 6 en puntos
 */
/**
  Color del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`"#RRGGBB"`).
  @property fontColor
  @type string|undefined
  @default "#fff" en clusters
 */
/**
  Color del contorno del texto de la etiqueta descriptiva del punto, representado en formato hex triplet (`"#RRGGBB"`).
  @property labelOutlineColor
  @type string|undefined
  @default null
 */
/**
  Anchura de trazo del contorno del texto de la etiqueta en píxeles.
  @property labelOutlineWidth
  @type number|undefined
  @default null
 */
/**
  Tamaño de fuente del texto de la etiqueta descriptiva del punto.
  @property fontSize
  @type number|undefined
  @default 9 en clusters
 */

/**
  Opciones de estilo de cluster de puntos. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  @class SITNA.cfg.ClusterStyleOptions
  @static
 */
/**
  Opciones de estilo del punto que representa el cluster. Hay que tener en cuenta que el archivo `config.json` de una maquetación puede sobreescribir los valores por defecto de las propiedades de esta clase
  (consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones). 

Esta clase no tiene constructor. 
  
Puede consultar también el ejemplo [online](../../examples/cfg.ClusterStyleOptions.point.html). 
#### Ejemplo:
```javascript
    <div id="mapa"></div>
    <script>
      // Creamos un mapa con una capa vectorial,
      // clustering activado a 50 pixels y estilos personalizados.
      var map = new SITNA.Map("mapa", {
        workLayers: [
         {
           id: "cluster",
           type: SITNA.Consts.layerType.VECTOR,
           title: "Clusters",
           cluster: {
             distance: 50,
             styles: {
               point: {
                 fillColor: "#f90",
                 fillOpacity: 1,
                 strokeColor: "#c60",
                 strokeWidth: 2,
                 fontColor: "#f90"
               }
             }
           }
         }
       ]
      });

     map.loaded(function () {
       // Añadimos puntos aleatorios
       var extent = TC.Cfg.initialExtent;
       var dx = extent[2] - extent[0];
       var dy = extent[3] - extent[1];

       var randomPoint = function () {
         var x = extent[0] + Math.random()  dx;
         var y = extent[1] + Math.random()  dy;
         return [x, y];
       }

       for (var i = 0; i < 200; i++) {
         var point = randomPoint();
         map.addMarker(point, {
           layer: "cluster",
           data: {
             x: point[0],
             y: point[1]
           }
         });
       }
     });
    </script>
```
  @property point
  @type SITNA.cfg.PointStyleOptions|undefined  
 */

/**
  Opciones de marcador. El icono se obtiene de las propiedades {{#crossLink "SITNA.cfg.MarkerOptions/url:property"}}{{/crossLink}}, 
  {{#crossLink "SITNA.cfg.MarkerOptions/cssClass:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.MarkerOptions/group:property"}}{{/crossLink}}, por ese orden de preferencia. 
  
Esta clase no tiene constructor. 
  @class SITNA.cfg.MarkerOptions
  @extends SITNA.cfg.MarkerStyleOptions
  @static
 */
/**
  Nombre de grupo en el que incluir el marcador. Estos grupos se muestran en la tabla de contenidos y en la leyenda.

  Todos los marcadores pertenecientes al mismo grupo tienen el mismo icono. Los iconos se asignan automáticamente, rotando por la lista disponible en
  SITNA.cfg.MarkerStyleOptions.{{#crossLink "SITNA.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
  @property group
  @type string|undefined
 */
/**
  Nombre de clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
  @property cssClass
  @type string|undefined
 */
/**
  URL de archivo de imagen que se utilizará para el icono.
  @property url
  @type string|undefined
 */
/**
  Identificador de la capa vectorial a la que añadir el marcador.
  @property layer
  @type string|undefined
 */
/**
  Objeto de datos en pares clave/valor para mostrar cuando se pulsa sobre el marcador.
  @property data
  @type object|undefined
 */
/**
  Si se establece a `true`, al añadirse el marcador al mapa se muestra con el bocadillo de información asociada visible por defecto.
  @property showPopup
  @type boolean|undefined
 */

/*
  Búsqueda realizada de entidades geográficas en el mapa. Define el tipo de consulta y a qué capa afecta. 
  Esta clase no tiene constructor. 
  class SITNA.Search
  static
/*
  Tipo de consulta que se está realizando al mapa.
  property type
  type SITNA.consts.MapSearchType
 */
/*
  Capa del mapa sobre la que se hace la consulta.
  property layer
  type SITNA.consts.Layer
 */

/**
Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Nótese que el constructor es asíncrono, por tanto cualquier código
que haga uso de este objeto debería estar dentro de una función de callback pasada como parámetro al método {{#crossLink "SITNA.Map/loaded:method"}}{{/crossLink}}.

Las opciones de configuración del mapa son una combinación de las opciones de configuración global (definidas en {{#crossLink "SITNA.Cfg"}}{{/crossLink}}),
las opciones definidas por el {{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}} que utilicemos, y las opciones pasadas como parámetro al
constructor. Estas opciones están ordenadas de menor a mayor prevalencia, de modo que por ejemplo una opción pasada como parámetro del constructor
siempre sobreescribirá una opción de la configuración global.

Puede consultar también online el [ejemplo 1](../../examples/Map.1.html), el [ejemplo 2](../../examples/Map.2.html) y el [ejemplo 3](../../examples/Map.3.html).
  #### Ejemplo 1:
```javascript
  <div id="mapa"/>
  <script>
    // Crear un mapa con las opciones por defecto.
    var map = new SITNA.Map("mapa");
  </script>
```
  #### Ejemplo 2:
```javascript
  <div id="mapa"/>
  <script>
    // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.
    var map = new SITNA.Map("mapa", {
      crs: "EPSG:4326",
      initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      maxExtent: [
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      baselayerExtent: [
        -2.84820556640625,
        41.78912492257675,
        -0.32135009765625,
        43.55789822064767
      ],
      baseLayers: [
        SITNA.Consts.layer.IDENA_DYNBASEMAP
      ],
      defaultBaseLayer: SITNA.Consts.layer.IDENA_DYNBASEMAP,
      // Establecemos el mapa de situación con una capa compatible con WGS 84
      controls: {
        overviewMap: {
          layer: SITNA.Consts.layer.IDENA_DYNBASEMAP
        }
      }
    });
  </script>
```
  #### Ejemplo 3:
```javascript
  <div id="mapa"></div>
  <script>
    // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartográficas del WMS de IDENA.
    var map = new SITNA.Map("mapa", {
      workLayers: [
        {
          id: "topo_mallas",
          title: "Toponimia y mallas cartográficas",
          type: SITNA.Consts.layerType.WMS,
          url: "//idena.navarra.es/ogc/wms",
          layerNames: "IDENA:toponimia,IDENA:mallas"
        }
      ]
    });
  </script>
```

@class SITNA.Map
@constructor
@async
@param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.
@param {object} [options] Objeto de opciones de configuración del mapa. Sus propiedades sobreescriben el objeto de configuración global {{#crossLink "SITNA.Cfg"}}{{/crossLink}}.
@param {string} [options.crs="EPSG:25830"] Código EPSG del sistema de referencia espacial del mapa. Por defecto es `"EPSG:25830"`.
@param {array} [options.initialExtent] Extensión inicial del mapa definida por x mínima, y mínima, x máxima, y máxima. 
Esta opción es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver SITNA.Cfg.{{#crossLink "SITNA.Cfg/crs:property"}}{{/crossLink}}).

Para más información consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/initialExtent:property"}}{{/crossLink}}.
@param {array} [options.maxExtent] Extensión máxima del mapa definida por x mínima, y mínima, x máxima, y máxima. Para más información consultar SITNA.Cfg.{{#crossLink "SITNA.Cfg/maxExtent:property"}}{{/crossLink}}.
@param {string} [options.layout] URL de una carpeta de maquetación. Consultar la sección {{#crossLinkModule "2.2. Maquetación"}}{{/crossLinkModule}} para ver instrucciones de uso de maquetaciones.
@param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. 
@param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. 
@param {string|number} [options.defaultBaseLayer] Identificador o índice en `baseLayers` de la capa base por defecto. 
@param {SITNA.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.
@param {SITNA.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geográficas.
@param {string} [options.locale="es-ES"] Código de idioma de la interfaz de usuario. Este código debe obedecer la sintaxis definida por la <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF</a>.
Los valores posibles son `"es-ES"`, `"eu-ES"` y `"en-US"`. Por defecto es `"es-ES"`.
@param {string} [options.crossOrigin] Valor del atributo `crossorigin` de las imágenes del mapa para  <a href="https://developer.mozilla.org/es/docs/Web/HTML/Imagen_con_CORS_habilitado">habilitar CORS</a>
Es necesario establecer esta opción para poder utilizar el método SITNA.Map.{{#crossLink "SITNA.Map/exportImage:method"}}{{/crossLink}}. 

Los valores soportados son `"anonymous"` y `"use-credentials"`.
@param {boolean} [options.mouseWheelZoom] Si se establece a `true`, la rueda del ratón se puede utilizar para hacer zoom en el mapa.
@param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver SITNA.Cfg.{{#crossLink "SITNA.Cfg/proxy:property"}}{{/crossLink}}).
 */

/*
  Búsqueda actual de consulta de entidad geográfica aplicado al mapa.
  property search
  type SITNA.Search|null
 */

SITNA.Map = function (div, options) {
    var map = this;

    // Por defecto en SITNA todas las búsquedas están habilitadas
    TC.Cfg.controls.search.allowedSearchTypes = $.extend(TC.Cfg.controls.search.allowedSearchTypes, {
        urban: {},
        street: {},
        number: {},
        cadastral: {}
    });

    if (options && options.controls && options.controls.search) {
        var keys = Object.keys(options.controls.search);

        var searchCfg = $.extend(options.controls.search, { allowedSearchTypes: {} });

        keys.forEach(function (key) {
            if (typeof (options.controls.search[key]) === "boolean" || $.isPlainObject(options.controls.search[key])) {
                if (options.controls.search[key]) {

                    switch (true) {
                        case (key === "postalAddress"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.NUMBER] = $.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "cadastralParcel"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.CADASTRAL] = $.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        case (key === "town"):
                            searchCfg.allowedSearchTypes[TC.Consts.searchType.URBAN] = $.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                            break;
                        default:
                            searchCfg.allowedSearchTypes[key] = $.isPlainObject(options.controls.search[key]) ? options.controls.search[key] : {};
                    }
                }

                delete searchCfg[key];
            }
        });

        options.controls.search = searchCfg;
    }

    var tcMap = new TC.Map(div, options);
    var tcSearch;
    var tcSearchLayer;

    /**
    Añade una capa al mapa. Si se le pasa una instancia de la clase {{#crossLink "SITNA.cfg.LayerOptions"}}{{/crossLink}} como parámetro `layer`
    y tiene definida la propiedad SITNA.cfg.LayerOptions.{{#crossLink "SITNA.cfg.LayerOptions/url:property"}}{{/crossLink}}, establece por defecto
    el tipo de capa a {{#crossLink "SITNA.consts.LayerType/KML:property"}}{{/crossLink}} si la URL acaba en ".kml".
    
El tipo de la capa no puede ser {{#crossLink "SITNA.consts.LayerType/WFS:property"}}{{/crossLink}}.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.addLayer.1.html) y el [ejemplo 2](../../examples/Map.addLayer.2.html). 
  #### Ejemplo 1:
```javascript
      <div id="mapa"></div>
      <script>
        // Crear un mapa con las opciones por defecto.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
          // Añadir al mapa la capa de cartografía topográfica de IDENA
          map.addLayer(SITNA.Consts.layer.IDENA_CARTO);
        });
      </script>
```
  #### Ejemplo 2:
    ```javascript
      <div id="mapa"></div>
      <script>
        // Crear un mapa con las opciones por defecto.
        var map = new SITNA.Map("mapa");
  
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
          // Añadir al mapa un documento KML
          map.addLayer({
            id: "capa_kml",
            title: "Museos en Navarra",
            type: SITNA.Consts.layerType.KML,
            url: "data/MUSEOSNAVARRA.kml"
          });
        });
      </script>
```

    @method addLayer
    @async
    @param {string|SITNA.cfg.LayerOptions} layer Identificador de capa u objeto de opciones de capa.
    @param {function} [callback] Función a la que se llama tras ser añadida la capa.     
     */
    map.addLayer = function (layer, callback) {
        tcMap.addLayer(layer, callback);
    };

    /**
    Hace visible una capa como mapa de fondo. Esta capa debe existir previamente en la lista de mapas de fondo del mapa.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.setBaseLayer.1.html) y el [ejemplo 2](../../examples/Map.setBaseLayer.2.html).
#### Ejemplo 1:

```javascript
      <div id="mapa"></div>
      <script>
        // Crear mapa con opciones por defecto. Esto incluye la capa del catastro de Navarra entre los mapas de fondo.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado establecer como mapa de fondo visible el catastro de Navarra.
        map.loaded(function () {
          map.setBaseLayer(SITNA.Consts.layer.IDENA_CADASTER);
        });
      </script>
```
#### Ejemplo 2:
    ```javascript
      <div id="mapa"></div>
      <script>
        // Crear mapa con opciones por defecto.
        var map = new SITNA.Map("mapa");
        // Cuando el mapa esté cargado, añadir la ortofoto de 1956/1957 como mapa de fondo y establecerla como mapa de fondo visible.
        map.loaded(function () {
          map.addLayer({
            id: "orto_56_57",
            title: "Ortofoto de 1956/1957",
            url: "http://idena.navarra.es/ogc/wms",
            layerNames: "ortofoto_10000_1957",
            isBase: true
          }, function () {
            map.setBaseLayer("orto_56_57");
          });
        });
      </script>
```

    @method setBaseLayer
    @async
    @param {string|SITNA.cfg.LayerOptions} layer Identificador de capa u objeto de opciones de capa. 
    @param {function} [callback] Función al que se llama tras ser establecida la capa como mapa de fondo.    
     */
    map.setBaseLayer = function (layer, callback) {
        tcMap.setBaseLayer(layer, callback);
    };

    /**
    Añade un marcador (un punto asociado a un icono) al mapa.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.addMarker.1.html), el [ejemplo 2](../../examples/Map.addMarker.2.html),
    el [ejemplo 3](../../examples/Map.addMarker.3.html) y el [ejemplo 4](../../examples/Map.addMarker.4.html).

    #### Ejemplo 1:
    ```
    <div id="mapa"></div>
    <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador.
            map.addMarker([610749, 4741648]);
            // Centrar el mapa en el marcador.
            map.zoomToMarkers();
        });
    </script>
    ```
    #### Ejemplo 2:
    ```
    <div id="mapa"></div>
    <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");

        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir marcadores al grupo "Marcadores colgantes"
            // cuyo icono se ancle al punto en el centro hacia abajo.
            // Establecer un icono adecuado.
            var markerOptions = {
                group: "Marcadores colgantes",
                url: "data/colgante.png",
                anchor: [0.5, 0]
            };
            map.addMarker([610887, 4741244], markerOptions);
            map.addMarker([615364, 4657556], markerOptions);
            // Centrar el mapa en los marcadores.
            map.zoomToMarkers();
        });
    </script>
    ```
    #### Ejemplo 3:
    ```
    <div id="mapa"></div>
    <script>
        // Crear un mapa con una capa vectorial, centrado en la Ciudadela de Pamplona.
        var map = new SITNA.Map("mapa", {
            initialExtent: [
                609627,
                4740225,
                611191,
                4741395
            ],
            workLayers: [{
                id: "markers",
                title: "Marcadores geográficos",
                type: SITNA.Consts.layerType.VECTOR
            }]
        });
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador en la capa "markers",
            // asignarle un grupo para que salga en tabla de contenidos y leyenda.
            map.addMarker([610431, 4740837], {
                layer: "markers",
                group: "Ciudadela"
            });
        });
    </script>
    ```
    #### Ejemplo 4:
    ```
    <div id="mapa"></div>
    <script>
        // Añadir información emergente al mapa.
        SITNA.Cfg.controls.popup = true;

        // Crear un mapa.
        var map = new SITNA.Map("mapa");
        // Cuando esté todo cargado proceder a trabajar con el mapa.
        map.loaded(function () {
            // Añadir un marcador con un icono de 40x40 píxeles definido por la clase CSS kiosko.
            // Asignarle unos datos asociados que se muestren por defecto.
            map.addMarker([615366, 4657426], {
                cssClass: "kiosko",
                width: 40,
                height: 40,
                data: {
                    "Nombre": "Plaza de la Constitución, Tudela",
                    "Sitio web": "http://www.tudela.es/"
                },
                showPopup: true
            });
            // Centrar el mapa en el marcador.
            map.zoomToMarkers();
        });
    </script>
    ```
    @method addMarker
    @async
    @param {array} coords Coordenadas x e y del punto en las unidades del sistema de referencia del mapa.
    @param {object} [options] Objeto de opciones de marcador.
    @param {string} [options.group] Nombre de grupo en el que incluir el marcador. Estos grupos se muestran en la tabla de contenidos y en la leyenda.
  
    Todos los marcadores pertenecientes al mismo grupo tienen el mismo icono. Los iconos se asignan automáticamente, rotando por la lista disponible en
    SITNA.cfg.MarkerStyleOptions.{{#crossLink "SITNA.cfg.MarkerStyleOptions/classes:property"}}{{/crossLink}}.
    @param {string} [options.cssClass] Nombre de clase CSS. El marcador adoptará como icono el valor del atributo `background-image` de dicha clase.
    @param {string} [options.url] URL de archivo de imagen que será el icono del marcador.
    @param {number} [options.width] Anchura en píxeles del icono del marcador.
    @param {number} [options.height] Altura en píxeles del icono del marcador.
    @param {array} [options.anchor] Coordenadas proporcionales (entre 0 y 1) del punto de anclaje del icono al punto del mapa. La coordenada (0, 0) es la esquina superior izquierda del icono.
    @param {object} [options.data] Objeto de datos en pares clave/valor para mostrar cuando se pulsa sobre el marcador. Si un valor es una URL, se mostrará como un enlace.
    @param {boolean} [options.showPopup] Si se establece a `true`, al añadirse el marcador al mapa se muestra con el bocadillo de información asociada visible por defecto.
    @param {string} [options.layer] Identificador de capa de tipo SITNA.consts.LayerType.{{#crossLink "SITNA.consts.LayerType/VECTOR:property"}}{{/crossLink}} en la que se añadirá el marcador. Si no se especifica se creará una capa específica para marcadores.
    
     */
    map.addMarker = function (coords, options) {
        tcMap.addMarker(coords, options);
    };

    /**
     Centra y escala el mapa a la extensión que ocupan todos sus marcadores.
  
     Puede consultar también el ejemplo [online](../../examples/Map.zoomToMarkers.html).
#### Ejemplo:
```javascript
       <div class="controls">
         <div><button id="addMarkerBtn">Añadir marcador aleatorio</button></div>
         <div><input type="number" step="1" id="pbrVal" value="30" /> <label for="pbrVal">pointBoundsRadius</label></div>
         <div><input type="number" step="0.1" id="emVal" value="0.2" /> <label for="emVal">extentMargin</label></div>
         <div><button id="zoomBtn">Hacer zoom a los marcadores</button></div>
       </div>
       <div id="mapa"></div>
       <script>
         // Crear mapa.
         var map = new SITNA.Map("mapa");
  
         // Añadir un marcador en un punto aleatorio
         var addRandomMarker = function () {
           var xmin = SITNA.Cfg.initialExtent[0];
           var ymin = SITNA.Cfg.initialExtent[1];
           var width = SITNA.Cfg.initialExtent[2] - SITNA.Cfg.initialExtent[0];
           var height = SITNA.Cfg.initialExtent[3] - SITNA.Cfg.initialExtent[1];
           map.addMarker([xmin + Math.random() width, ymin + Math.random() height]);
         };
  
         // Hacer zoom a los marcadores con las opciones elegidas
         var zoomToMarkers = function () {
           map.zoomToMarkers({
             pointBoundsRadius: parseInt(document.getElementById("pbrVal").value),
             extentMargin: parseFloat(document.getElementById("emVal").value)
           });
         };
  
         document.getElementById("addMarkerBtn").addEventListener("click", addRandomMarker);
         document.getElementById("zoomBtn").addEventListener("click", zoomToMarkers);
       </script>
```

     @method zoomToMarkers
     @param {object} [options] Objeto de opciones de zoom.
     @param {number} [options.pointBoundsRadius=30] Radio en metros del área alrededor del marcador que se respetará al hacer zoom. Por defecto es 30.
     @param {number} [options.extentMargin=0.2] Tamaño del margen que se aplicará a la extensión total de todas los marcadores.
     El valor es la relación de crecimiento en ancho y alto entre la extensión resultante y la original. Por ejemplo, el valor por defecto 0,2 indica un crecimiento del 20% de la extensión, 10% por cada lado.
     @async
     
     */
    map.zoomToMarkers = function (options) {
        tcMap.zoomToMarkers(options);
    };

    /**
    Añade una función de callback que se ejecutará cuando el mapa, sus controles y todas sus capas se hayan cargado.
#### Ejemplo:
```javascript
       // Notificar cuando se haya cargado el mapa.
       map.loaded(function () { 
         console.log("Código del mapa y de sus controles cargado, cargando datos...");
       });
```
    @method loaded
    @async
    @param {function} callback Función a la que se llama tras la carga del mapa.
    
    */
    map.loaded = function (callback) {
        tcMap.loaded(callback);
    };

    // Si existe el control featureInfo lo activamos.
    tcMap.loaded(function () {

        TC.loadJS(
          !TC.control.Search,
          TC.apiLocation + 'TC/control/Search',
          function () {
              tcSearch = new TC.control.Search();
              tcSearch.register(tcMap);

              tcSearch.getLayer().then(function (layer) {
                  tcSearchLayer = layer;
              });
          }
        );

        if (!tcMap.activeControl) {
            var fi = tcMap.getControlsByClass('TC.control.FeatureInfo')[0];
            if (fi) {
                fi.activate();
            }
        }
    });

    /*
      Obtiene los valores (id y label) de las entidades geográficas disponibles en la capa de IDENA que corresponda según el parámetro searchType. 
      Puede consultar también online el [ejemplo 1](../../examples/Map.getQueryableData.html). 
    
     method getQueryableData
     async
     param {string|SITNA.consts.MapSearchType} searchType Fuente de datos del cual obtendremos los valores disponibles para buscar posteriormente.
     param {function} [callback] Función a la que se llama tras obtener los datos.  
     example
       <div id="mapa"></div>
       <script>
         // Crear un mapa con las opciones por defecto.
         var map = new SITNA.Map("mapa");
       
         // Cuando esté todo cargado proceder a trabajar con el mapa.
         map.loaded(function () {  
           // Retorna un array de objetos (id, label) con todos los municipios de Navarra
           map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, function (data) {
             $.each(data, function (key, value) {
               $('#municipality')  // Completamos el combo '#municipality' con los datos recibidos
                .append($("<option></option>")
                .attr("value", value.id)
                .text(value.label));
             });
           });
   
           // Retorna un array de objetos (id, label) con todas las mancomunidades de residuos de Navarra
           map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, function (data) {
             $.each(data, function (key, value) {
               $('#commonwealth')  // Completamos el combo '#community' con los datos recibidos
                .append($("<option></option>")
                .attr("value", value.id)
                .text(value.label));
             });
           });
         });
       </script>
    */
    map.getQueryableData = function (searchType, callback) {
        var queryable = tcSearch.availableSearchTypes[searchType];

        if (queryable.queryableData) {
            if (callback)
                callback(queryable.queryableData);
        } else {
            var params = {
                request: 'GetFeature',
                service: 'WFS',
                typename: queryable.featurePrefix + ':' + queryable.featureType,
                version: queryable.version,
                propertyname: (!(queryable.dataIdProperty instanceof Array) ? [queryable.dataIdProperty] : queryable.dataIdProperty)
                        .concat((!(queryable.outputProperties instanceof Array) ? [queryable.outputProperties] : queryable.outputProperties)).join(','),
                outputformat: TC.Consts.format.JSON
            };

            var url = queryable.url + '?' + $.param(params);
            TC.ajax({
                url: url,
                responseType: TC.Consts.mimeType.JSON
            }).then(function (data) {
                queryable.queryableData = [];

                if (data.features) {
                    var features = data.features;

                    for (var i = 0; i < features.length; i++) {
                        var f = features[i];
                        var data = {};

                        data.id = [];
                        if (!(queryable.dataIdProperty instanceof Array))
                            queryable.dataIdProperty = [queryable.dataIdProperty];

                        for (var ip = 0; ip < queryable.dataIdProperty.length; ip++) {
                            if (f.properties.hasOwnProperty(queryable.dataIdProperty[ip])) {
                                data.id.push(f.properties[queryable.dataIdProperty[ip]]);
                            }
                        }

                        data.id = queryable.idPropertiesIdentifier ? data.id.join(queryable.idPropertiesIdentifier) : data.id.join('');

                        data.label = [];
                        if (!(queryable.outputProperties instanceof Array))
                            queryable.outputProperties = [queryable.outputProperties];

                        for (var lbl = 0; lbl < queryable.outputProperties.length; lbl++) {
                            if (f.properties.hasOwnProperty(queryable.outputProperties[lbl])) {
                                data.label.push(f.properties[queryable.outputProperties[lbl]]);
                            }
                        }

                        var add = (data.label instanceof Array && data.label.join('').trim().length > 0) || (!(data.label instanceof Array) && data.label.trim().length > 0);
                        data.label = queryable.outputFormatLabel ? queryable.outputFormatLabel.tcFormat(data.label) : data.label.join('-');

                        if (add)
                            queryable.queryableData.push(data);
                    }
                }

                queryable.queryableData = queryable.queryableData.sort(function (a, b) {
                    if (queryable.idPropertiesIdentifier ? a.id.indexOf(queryable.idPropertiesIdentifier) == -1 : false) {
                        if (tcSearch.removePunctuation(a.label) < tcSearch.removePunctuation(b.label))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label) > tcSearch.removePunctuation(b.label))
                            return 1;
                        else
                            return 0;
                    } else {
                        if (tcSearch.removePunctuation(a.label.split(' ')[0]) < tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return -1;
                        else if (tcSearch.removePunctuation(a.label.split(' ')[0]) > tcSearch.removePunctuation(b.label.split(' ')[0]))
                            return 1;
                        else
                            return 0;
                    }
                });
                queryable.queryableData = queryable.queryableData.filter(function (value, index, arr) {
                    if (index < 1)
                        return true;
                    else
                        return value.id !== arr[index - 1].id && value.label !== arr[index - 1].label;
                });

                if (callback)
                    callback(queryable.queryableData);
            });
        }
    };
    /**
    Obtiene los valores (id y label) de los municipios disponibles en la capa de IDENA.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.getMunicipalities.html).
#### Ejemplo:  
```javascript
      <div class="instructions divSelect">
        <div>
          Municipios
          <select id="municipality" onchange="applyFilter()">
            <option value="-1">Seleccione...</option>
          </select>
        </div>
      </div>
      <div id="mapa"></div>
      <script>
        // Crear mapa.
        var map = new SITNA.Map("mapa");
        map.loaded(function () {
          // completamos el desplegable
          map.getMunicipalities(function (data) {
            $.each(data, function (key, value) {
              $('#municipality').append($("<option></option>")
                .attr("value", value.id)
                .text(value.label));
              });
            });
          });
        // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
        function applyFilter() {
          var id = $('#municipality').find('option:selected').val();
          if (id == -1)
            map.removeSearch();
          else {
            map.searchMunicipality(id, function (idQuery) {
              if (idQuery == null)
                alert('No se han encontrado resultados');
            });
          }
        };
     </script>
```

    @method getMunicipalities
    @async  
    @param {function} [callback] Función a la que se llama tras obtener los datos.
    
    */
    map.getMunicipalities = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.MUNICIPALITY, callback);
    };
    /**
    Obtiene los valores (id y label) de los cascos urbanos disponibles en la capa de IDENA.
  
    Puede consultar también online el [ejemplo 1](../../examples/Map.getUrbanAreas.html).
#### Ejemplo:
```javascript
      <div class="instructions divSelect">
       <div>
         Cascos urbanos
         <select id="urban" onchange="applyFilter()">
           <option value="-1">Seleccione...</option>
         </select>
       </div>
      </div>
      <div id="mapa"></div>
      <script>
       // Crear mapa.
       var map = new SITNA.Map("mapa");
       map.loaded(function () {
         // completamos el desplegable
         map.getUrbanAreas(function (data) {
           $.each(data, function (key, value) {
             $('#urban').append($("<option></option>")
                .attr("value", value.id)
                .text(value.label));
             });
           });
         });
       // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
       function applyFilter() {
         var id = $('#urban').find('option:selected').val();
         if (id == -1)
           map.removeSearch();
         else {
           map.searchUrbanArea(id, function (idQuery) {
             if (idQuery == null)
               alert('No se han encontrado resultados');
           });
         }
       };
      </script>
```  

    @method getUrbanAreas
    @async  
    @param {function} [callback] Función a la que se llama tras obtener los datos.  
    
    */
    map.getUrbanAreas = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.URBAN, callback);
    };
    /**
      Obtiene los valores (id y label) de las mancomunidades de residuos disponibles en la capa de IDENA. 
      
Puede consultar también online el [ejemplo 1](../../examples/Map.getCommonwealths.html). 
#### Ejemplo:
```javascript
       <div class="instructions divSelect">
         <div>
           Mancomunidades de residuos
           <select id="commonwealths" onchange="applyFilter()">
             <option value="-1">Seleccione...</option>
           </select>
         </div>
       </div>
       <div id="mapa"></div>
       <script>
         // Crear mapa.
         var map = new SITNA.Map("mapa");
         map.loaded(function () {
           // completamos el desplegable
           map.getCommonwealths(function (data) {
             $.each(data, function (key, value) {
               $('#commonwealths').append($("<option></option>")
                 .attr("value", value.id)
                 .text(value.label));
               });
             });
           });
         // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
         function applyFilter() {
           var id = $('#commonwealths').find('option:selected').val();
           if (id == -1)
             map.removeSearch();
           else {
             map.searchCommonwealth(id, function (idQuery) {
               if (idQuery == null)
                 alert('No se han encontrado resultados');
             });
           }
         };
      </script>
```    

     @method getCommonwealths
     @async  
     @param {function} [callback] Función a la que se llama tras obtener los datos.  
     
    */
    map.getCommonwealths = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COMMONWEALTH, callback);
    };
    /**
       Obtiene los valores (id y label) de los concejos disponibles en la capa de IDENA. 
       
Puede consultar también online el [ejemplo 1](../../examples/Map.getCouncils.html). 
 #### Ejemplo:    
 ```javascript
        <div class="instructions divSelect">
          <div>
            Concejos
            <select id="council" onchange="applyFilter()">
              <option value="-1">Seleccione...</option>
            </select>
          </div>
        </div>
        <div id="mapa"></div>
        <script>
          // Crear mapa.
          var map = new SITNA.Map("mapa");
          map.loaded(function () {
            // completamos el desplegable
            map.getCouncils(function (data) {
              $.each(data, function (key, value) {
                $('#council').append($("<option></option>")
                  .attr("value", value.id)
                  .text(value.label));
                });
              });
            });
          // Establecer como filtro del mapa el valor seleccionado del desplegable que lance el evento change
          function applyFilter() {
            var id = $('#council').find('option:selected').val();
            if (id == -1)
              map.removeSearch();
            else {
              map.searchCouncil(id, function (idQuery) {
                if (idQuery == null)
                  alert('No se han encontrado resultados');
              });
            }
          };
       </script>
```

      @method getCouncils
      @async  
      @param {function} [callback] Función a la que se llama tras obtener los datos.  
     
     */
    map.getCouncils = function (callback) {
        map.getQueryableData(SITNA.Consts.mapSearchType.COUNCIL, callback);
    };
    /**
        Busca la mancomunidad de residuos y pinta en el mapa la entidad geográfica encontrada que corresponda al identificador indicado.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchCommonwealth.html). 
#### Ejemplo:
```javascript
            <div class="instructions searchCommonwealth">    
              <div><button id="searchPamplonaBtn">Buscar Mancomunidad de la Comarca de Pamplona</button></div>    
            </div>
            <div id="mapa"></div>
            <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchPamplonaBtn").addEventListener("click", search);
              });
      
              var search = function () {
                map.removeSearch();
                map.searchCommonwealth("8", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado la mancomunidad con código 8.");
                  }
                });
              };
            </script>
```      

       @method searchCommonwealth
       @async
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      */

    map.searchCommonwealth = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COMMONWEALTH, id, callback);
    };
    /**
        Busca el concejo que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchCouncil.html). 
#### Ejemplo:     
```javascript
             <div class="instructions search">    
              <div><button id="searchBtn">Buscar concejo Esquíroz (Galar)</button></div>    
             </div>
             <div id="mapa"></div>
             <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
     
              var search = function () {
                map.removeSearch();
                map.searchCouncil("109#5", function (idQuery) {
                  if (idQuery == null) {
                      alert("No se ha encontrado el concejo con código 109#5.");
                  }
                });
              };    
             </script>    
```

       @method searchCouncil
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchCouncil = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.COUNCIL, id, callback);
    };
    /**
        Busca el casco urbano que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchUrbanArea.html). 
#### Ejemplo:
```javascript
            <div class="instructions search">
            <div><button id="searchBtn">Buscar casco urbano de Arbizu</button></div>
            </div>
            <div id="mapa"></div>
            <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
              var search = function () {
                map.removeSearch();
                map.searchUrbanArea("27", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado el casco urbano con código 27.");
                  }
                });
              };
            </script>
```     

       @method searchUrbanArea
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchUrbanArea = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.URBAN, id, callback);
    };
    /**
        Busca el municipio que corresponda con el identificador pasado como parámetro y pinta la entidad geográfica encontrada en el mapa.
        
Puede consultar también online el [ejemplo 1](../../examples/Map.searchMunicipality.html). 
#### Ejemplo:     
```javascript
             <div class="instructions search">
              <div><button id="searchBtn">Buscar Arbizu</button></div>
             </div>
             <div id="mapa"></div>
             <script>
              // Crear mapa.
              var map = new SITNA.Map("mapa");
              map.loaded(function () {
                document.getElementById("searchBtn").addEventListener("click", search);
              });
     
              var search = function () {
                 map.removeSearch();
                 map.searchMunicipality("27", function (idQuery) {
                  if (idQuery == null) {
                    alert("No se ha encontrado el municipio con código 27.");
                  }
                 });
              };
             </script>
```

       @method searchMunicipality
       @async    
       @param {string} id Identificador de la entidad geográfica a pintar.
       @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
       
      **/
    map.searchMunicipality = function (id, callback) {
        map.searchTyped(SITNA.Consts.mapSearchType.MUNICIPALITY, id, callback);
    };
    // Busca en la configuración que corresponda según el parámetro searchType el identificador pasado como parámetro
    map.searchTyped = function (searchType, id, callback) {
        var idQuery = TC.getUID();
        var query = tcSearch.availableSearchTypes[searchType];

        if (id instanceof Array && query.goToIdFormat)
            id = query.goToIdFormat.tcFormat(id);

        tcSearch._search.data = tcSearch._search.data || [];
        tcSearch._search.data.push({
            dataLayer: query.featureType,
            dataRole: searchType,
            id: id,
            label: "",
            text: ""
        });

        map.removeSearch();

        if (tcSearch.availableSearchTypes[searchType] && !tcSearch.getSearchTypeByRole(searchType)) {

            if (!tcSearch.availableSearchTypes[searchType].goTo) {
                tcSearch.availableSearchTypes[searchType].goTo = function (id) {
                    var getProperties = function (id) {

                        if (!TC.filter) {
                            TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                        }

                        var filter = [];
                        if (query.idPropertiesIdentifier) id = id.split(query.idPropertiesIdentifier);
                        if (!(id instanceof Array)) id = [id];
                        for (var i = 0; i < query.dataIdProperty.length; i++) {
                            filter.push(
                              new TC.filter.equalTo(query.dataIdProperty[i], $.trim(id[i]))
                            );
                        }

                        if (filter.length > 1) {
                            filter = new TC.filter.and(filter);
                        } else {
                            filter = filter[0];
                        }

                        return filter;
                    };
                    var properties = getProperties(id);

                    return {
                        params: {
                            type: TC.Consts.layerType.WFS,
                            url: this.url,
                            version: this.version,
                            geometryName: this.geometryName,
                            featurePrefix: this.featurePrefix,
                            featureType: this.featureType,
                            properties: properties,
                            outputFormat: this.outputFormat,
                            styles: this.styles
                        }
                    };
                }.bind(query);
            }

            tcSearch.addAllowedSearchType(searchType, tcSearch.availableSearchTypes[searchType], tcSearch);
        }

        tcMap.one(TC.Consts.event.SEARCHQUERYEMPTY, function (e) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        });

        tcMap.one(TC.Consts.event.FEATURESADD, function (e) {
            if (e.layer == tcSearchLayer && e.layer.features && e.layer.features.length > 0)
                tcMap.zoomToFeatures(e.layer.features);

            map.search = {
                layer: e.layer, type: searchType
            };

            if (callback)
                callback(e.layer.id !== idQuery ? e.layer.id : idQuery);
        });

        tcSearch.goToResult(id, searchType);
    };
    /**
          Busca y pinta en el mapa la entidad geográfica encontrada correspondiente al identificador establecido.
          
Puede consultar también online el [ejemplo 1](../../examples/Map.searchFeature.html). 
#### Ejemplo:       
```javascript
              <div class="instructions query">
                 <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
                 <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
                 <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
                 <div><button id="searchBtn">Buscar</button></div>
                 <div><button id="removeBtn">Eliminar filtro</button></div>
               </div>
               <div id="mapa"></div>
               <script>
                 // Crear mapa.
                  var map = new SITNA.Map("mapa");
                 
                  map.loaded(function () {
                    document.getElementById("searchBtn").addEventListener("click", search);
                    document.getElementById("removeBtn").addEventListener("click", remove);
                  });
                  
                  var search = function () {
                    var capa = document.getElementById("capa").value;
                    capa = capa.trim();
                 
                    var campo = document.getElementById("campo").value;
                    campo = campo.trim();
                 
                    var valor = document.getElementById("valor").value;
                    valor = valor.trim();
                 
                    map.searchFeature(capa, campo, valor, function (idQuery) {
                      if (idQuery == null) {
                        alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
                      }
                    });
                  };
                 
                  // Limpiar el mapa 
                  var remove = function () {
                    map.removeSearch();
                  };
               </script>
```

         @method searchFeature
         @async
         @param {string} layer Capa de IDENA en la cual buscar.
         @param {string} field Campo de la capa de IDENA en el cual buscar.
         @param {string} id Identificador de la entidad geográfica por el cual filtrar.
         @param {function} [callback] Función a la que se llama tras aplicar el filtro.  
         
     */
    map.searchFeature = function (layer, field, id, callback) {
        var idQuery = TC.getUID();
        var prefix = tcSearch.featurePrefix;

        map.removeSearch();

        layer = (layer || '').trim(); field = (field || '').trim(); id = (id || '').trim();
        if (layer.length == 0 || field.length == 0 || id.length == 0) {
            tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                type: TC.Consts.msgType.INFO, duration: 5000
            });

            if (callback)
                callback(null);
        } else {

            if (layer.indexOf(':') > -1) {
                prefix = layer.split(':')[0];
                layer = layer.split(':')[1];
            }

            var transformFilter = function (properties) {
                var self = this;

                if (!TC.filter) {
                    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');
                }

                if (properties && properties instanceof Array) {
                    var filters = properties.map(function (elm) {
                        if (elm.hasOwnProperty("type")) {
                            switch (true) {
                                case elm.type == TC.Consts.comparison.EQUAL_TO: {
                                    return new TC.filter.equalTo(elm.name, elm.value);
                                }
                            }
                        } else {
                            return new TC.filter.equalTo(elm.name, elm.value);
                        }
                    });

                    if (filters.length > 1) {
                        return TC.filter.and.apply(null, filters);
                    } else {
                        return filters[0];
                    }
                }
            }

            var layerOptions = {
                id: idQuery,
                type: SITNA.Consts.layerType.WFS,
                url: tcSearch.url,
                version: tcSearch.version,
                stealth: true,
                geometryName: 'the_geom',
                featurePrefix: prefix,
                featureType: layer,
                maxFeatures: 1,
                properties: transformFilter([{
                    name: field, value: id, type: TC.Consts.comparison.EQUAL_TO
                }]),
                outputFormat: TC.Consts.format.JSON
            };

            var tcSrchGenericLayer;
            tcMap.addLayer(layerOptions).then(function (layer) {
                tcSrchGenericLayer = layer;

                map.search = {
                    layer: layer, type: SITNA.Consts.mapSearchType.GENERIC
                };
            });

            tcMap.on(TC.Consts.event.FEATURESADD, function (e) {
                const layer = e.layer;
                if (layer == tcSrchGenericLayer && layer.features && layer.features.length > 0) {

                    for (var i = 0; i < layer.features.length; i++) {
                        if (layer.features[i].showsPopup != tcSearch.queryableFeatures)
                            layer.features[i].showsPopup = tcSearch.queryableFeatures;
                    }

                    tcMap.zoomToFeatures(layer.features);
                }
            });

            tcMap.on(TC.Consts.event.LAYERUPDATE, function (e) {
                const layer = e.layer;
                const newData = e.newData;
                if (layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0)
                    tcMap.toast(tcSearch.EMPTY_RESULTS_LABEL, {
                        type: TC.Consts.msgType.INFO, duration: 5000
                    });

                if (callback)
                    callback(layer == tcSrchGenericLayer && newData && newData.features && newData.features.length == 0 ? null : idQuery);
            });
        }
    };
    /**
       Elimina del mapa la entidad geográfica encontrada. 
       
Puede consultar también online el [ejemplo 1](../../examples/Map.removeSearch.html). 
#### Ejemplo:    
```javascript
        <div class="instructions query">
           <div><label>Capa</label><input type="text" id="capa" placeholder="Nombre capa de IDENA" /> </div>
           <div><label>Campo</label><input type="text" id="campo" placeholder="Nombre campo" /> </div>
           <div><label>Valor</label><input type="text" id="valor" placeholder="Valor a encontrar" /> </div>
           <div><button id="searchBtn">Buscar</button></div>
           <div><button id="removeBtn">Eliminar filtro</button></div>
         </div>
         <div id="mapa"></div>
         <script>
           // Crear mapa.
           var map = new SITNA.Map("mapa");
    
           map.loaded(function () {
             document.getElementById("addFilterBtn").addEventListener("click", addFilter);
             document.getElementById("removeFilterBtn").addEventListener("click", removeFilter);
           });
    
           // Establecer como filtro del mapa el municipio Valle de Egüés
           var addFilter = function () {
             var capa = document.getElementById("capa").value;
             capa = capa.trim();
    
            var campo = document.getElementById("campo").value;
             campo = campo.trim();
    
             var valor = document.getElementById("valor").value;
             valor = valor.trim();
        
             map.searchFeature(capa, campo, valor, function (idQuery) {
               if (idQuery == null) {
                 alert("No se han encontrado resultados en la capa: " + capa + " en el campo: " + campo + " el valor: " + valor + ".");
               }
             });
           };
          
           // Limpiar el mapa del filtro
           var remove = function () {
             map.removeSearch();
           };
         </script>
```

      @method removeSearch
      @async   
      @param {function} [callback] Función a la que se llama tras eliminar la entidad geográfica.  
      
     */
    map.removeSearch = function (callback) {
        if (map.search) {
            if (!tcSearch.availableSearchTypes[map.search.type] || !tcSearch.availableSearchTypes[map.search.type].hasOwnProperty('goTo')) {
                tcMap.removeLayer(map.search.layer).then(function () {
                    map.search = null;
                });
            } else {
                for (var i = 0; i < map.search.layer.features.length; i++) {
                    map.search.layer.removeFeature(map.search.layer.features[i]);
                }
                map.search = null;
            }
        }

        if (callback)
            callback();
    };

    /**
      Exporta el mapa a una imagen PNG. Para poder utilizar este método hay que establecer la opción `crossOrigin` al instanciar {{#crossLink "SITNA.Map"}}{{/crossLink}}. 
      
Puede consultar también el ejemplo [online](../../examples/Map.exportImage.html).
#### Ejemplo:    
```javascript
                <div id="controls" class="controls">
                   <button id="imageBtn">Exportar imagen</button>
                </div>
                 <div id="mapa"></div>
                 <script>
                   // Crear un mapa con la opción de imágenes CORS habilitada.
                   var map = new SITNA.Map("mapa", { crossOrigin: "anonymous" });
    
                   var exportImage = function () {
                     var dataUrl = map.exportImage();
                     var image = document.createElement("img");
                     image.setAttribute("src", dataUrl);
                     image.style.width = '25vw';
                     var div = document.createElement("div");
                     div.appendChild(image);
                     document.getElementById("controls").appendChild(div);
                   };
          
                   document.getElementById("imageBtn").addEventListener("click", exportImage);
                 </script>
```
      @method exportImage
      @return {String} Imagen en un [data URI](https://developer.mozilla.org/es/docs/Web/HTTP/Basics_of_HTTP/Datos_URIs).
     */
    map.exportImage = function () {
        return tcMap.exportImage();
    };

    map.search = null;
};

/**
Cuando se instancia un mapa, se carga una maquetación que establece qué datos se cargan, qué controles y en que distribución se muestran, y qué estilo
va a tener el visor. La API SITNA tiene una maquetación definida por defecto, pero esto se puede cambiar utilizando la opción
{{#crossLink "SITNA.Cfg/layout:property"}}{{/crossLink}}:
#### Ejemplo:
```javascript
var map = new SITNA.Map("mapa", {
  layout: "layouts/mylayout"
});
```

El valor de esa opción es una ruta a una carpeta, donde se encontrarán todos o alguno de los siguientes archivos:

- `markup.html`, con la plantilla HTML que se inyectará en el elemento del DOM del mapa.
- `config.json`, con un objeto JSON que sobreescribirá propiedades de {{#crossLink "SITNA.Cfg"}}{{/crossLink}}.
- `style.css`, para personalizar el estilo del visor y sus controles.
- `script.js`, para añadir lógica nueva. Este es el lugar idóneo para la lógica de la nueva interfaz definida por el marcado inyectado con `markup.html`.
- `ie8.css`, para adaptar el estilo a Internet Explorer 8, dado que este navegador tiene soporte CSS3 deficiente.
- `resources/*.json`, donde `*` es el código IETF del idioma que tendrá la interfaz de usuario, por ejemplo `resources/es-ES.json`.
 Si se van a soportar varios idiomas hay que preparar un archivo por idioma. Para saber cómo establecer un idioma de interfaz de usuario, consultar
 la opción `locale` del constructor de {{#crossLink "SITNA.Map"}}{{/crossLink}}.

La maquetación por defecto añade los siguientes controles al conjunto por defecto: {{#crossLink "SITNA.cfg.MapControlOptions/navBar:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/basemapSelector:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/TOC:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/legend:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/scaleBar:property"}}{{/crossLink}},
{{#crossLink "SITNA.cfg.MapControlOptions/search:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/streetView:property"}}{{/crossLink}}
, {{#crossLink "SITNA.cfg.MapControlOptions/measure:property"}}{{/crossLink}}, {{#crossLink "SITNA.cfg.MapControlOptions/overviewMap:property"}}{{/crossLink}} y {{#crossLink "SITNA.cfg.MapControlOptions/popup:property"}}{{/crossLink}}.
Puede [descargar la maquetación por defecto](../../tc/layout/responsive/responsive.zip).

### Soporte multiidioma

La API soporta actualmente tres idiomas: castellano, euskera e inglés. Para saber cómo establecer un idioma de interfaz de usuario, consultar la opción
`locale` del constructor de {{#crossLink "SITNA.Map"}}{{/crossLink}}. Los textos específicos para cada idioma se guardan en archivos `*.json`,
donde `*` es el código IETF del idioma de la interfaz de usuario, dentro de la subcarpeta resources en la dirección donde se aloja la API SITNA.
Por ejemplo, los textos en castellano se guardan en `resources/es-ES.json`. Estos archivos contienen un diccionario en formato JSON de pares clave/valor,
siendo la clave un identificador único de cadena y el valor el texto en el idioma elegido.

Para añadir soporte multiidioma a la maquetación, hay que crear un archivo de recursos de texto para cada idioma soportado y colocarlo en la subcarpeta
`resources` dentro de la carpeta de maquetación. Este diccionario se combinará con el diccionario de textos propio de la API.

Por otro lado, la plantilla contenida en `markup.html` puede tener identificadores de cadena de texto entre dobles llaves. La API
sustituirá estos textos por los valores del diccionario correspondiente al idioma de la interfaz de usuario.

Finalmente, hay que activar el soporte multiidioma añadiendo a config.json una clave `"i18n": true`.

@module 2. Configuración
@submodule 2.2. Maquetación
 */

/**
Al instanciar {{#crossLink "SITNA.Map"}}{{/crossLink}} se le puede pasar como parámetro un objeto de opciones con la estructura de la clase [SITNA.Cfg](../classes/SITNA.Cfg.html):
#### Ejemplo:
```javascript
var map = new SITNA.Map("mapa", {
  crs: "EPSG:4326",
  initialExtent: [
    -2.84820556640625,
    41.78912492257675,
    -0.32135009765625,
    43.55789822064767
  ]
});
```
@module 2. Configuración
@submodule 2.1. Parámetros del constructor
 */

